{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseMLSxDate = exports.transformList = exports.parseLine = exports.testLine = void 0;\nconst FileInfo_1 = require(\"./FileInfo\");\nfunction parseSize(value, info) {\n  info.size = parseInt(value, 10);\n}\n/**\n * Parsers for MLSD facts.\n */\nconst factHandlersByName = {\n  \"size\": parseSize,\n  \"sizd\": parseSize,\n  \"unique\": (value, info) => {\n    info.uniqueID = value;\n  },\n  \"modify\": (value, info) => {\n    info.modifiedAt = parseMLSxDate(value);\n    info.rawModifiedAt = info.modifiedAt.toISOString();\n  },\n  \"type\": (value, info) => {\n    // There seems to be confusion on how to handle symbolic links for Unix. RFC 3659 doesn't describe\n    // this but mentions some examples using the syntax `type=OS.unix=slink:<target>`. But according to\n    // an entry in the Errata (https://www.rfc-editor.org/errata/eid1500) this syntax can't be valid.\n    // Instead it proposes to use `type=OS.unix=symlink` and to then list the actual target of the\n    // symbolic link as another entry in the directory listing. The unique identifiers can then be used\n    // to derive the connection between link(s) and target. We'll have to handle both cases as there\n    // are differing opinions on how to deal with this. Here are some links on this topic:\n    // - ProFTPD source: https://github.com/proftpd/proftpd/blob/56e6dfa598cbd4ef5c6cba439bcbcd53a63e3b21/modules/mod_facts.c#L531\n    // - ProFTPD bug: http://bugs.proftpd.org/show_bug.cgi?id=3318\n    // - ProFTPD statement: http://www.proftpd.org/docs/modules/mod_facts.html\n    // – FileZilla bug: https://trac.filezilla-project.org/ticket/9310\n    if (value.startsWith(\"OS.unix=slink\")) {\n      info.type = FileInfo_1.FileType.SymbolicLink;\n      info.link = value.substr(value.indexOf(\":\") + 1);\n      return 1 /* FactHandlerResult.Continue */;\n    }\n\n    switch (value) {\n      case \"file\":\n        info.type = FileInfo_1.FileType.File;\n        break;\n      case \"dir\":\n        info.type = FileInfo_1.FileType.Directory;\n        break;\n      case \"OS.unix=symlink\":\n        info.type = FileInfo_1.FileType.SymbolicLink;\n        // The target of the symbolic link might be defined in another line in the directory listing.\n        // We'll handle this in `transformList()` below.\n        break;\n      case \"cdir\": // Current directory being listed\n      case \"pdir\":\n        // Parent directory\n        return 2 /* FactHandlerResult.IgnoreFile */;\n      // Don't include these entries in the listing\n      default:\n        info.type = FileInfo_1.FileType.Unknown;\n    }\n    return 1 /* FactHandlerResult.Continue */;\n  },\n\n  \"unix.mode\": (value, info) => {\n    const digits = value.substr(-3);\n    info.permissions = {\n      user: parseInt(digits[0], 10),\n      group: parseInt(digits[1], 10),\n      world: parseInt(digits[2], 10)\n    };\n  },\n  \"unix.ownername\": (value, info) => {\n    info.user = value;\n  },\n  \"unix.owner\": (value, info) => {\n    if (info.user === undefined) info.user = value;\n  },\n  get \"unix.uid\"() {\n    return this[\"unix.owner\"];\n  },\n  \"unix.groupname\": (value, info) => {\n    info.group = value;\n  },\n  \"unix.group\": (value, info) => {\n    if (info.group === undefined) info.group = value;\n  },\n  get \"unix.gid\"() {\n    return this[\"unix.group\"];\n  }\n  // Regarding the fact \"perm\":\n  // We don't handle permission information stored in \"perm\" because its information is conceptually\n  // different from what users of FTP clients usually associate with \"permissions\". Those that have\n  // some expectations (and probably want to edit them with a SITE command) often unknowingly expect\n  // the Unix permission system. The information passed by \"perm\" describes what FTP commands can be\n  // executed with a file/directory. But even this can be either incomplete or just meant as a \"guide\"\n  // as the spec mentions. From https://tools.ietf.org/html/rfc3659#section-7.5.5: \"The permissions are\n  // described here as they apply to FTP commands. They may not map easily into particular permissions\n  // available on the server's operating system.\" The parser by Apache Commons tries to translate these\n  // to Unix permissions – this is misleading users and might not even be correct.\n};\n/**\n * Split a string once at the first position of a delimiter. For example\n * `splitStringOnce(\"a b c d\", \" \")` returns `[\"a\", \"b c d\"]`.\n */\nfunction splitStringOnce(str, delimiter) {\n  const pos = str.indexOf(delimiter);\n  const a = str.substr(0, pos);\n  const b = str.substr(pos + delimiter.length);\n  return [a, b];\n}\n/**\n * Returns true if a given line might be part of an MLSD listing.\n *\n * - Example 1: `size=15227;type=dir;perm=el;modify=20190419065730; test one`\n * - Example 2: ` file name` (leading space)\n */\nfunction testLine(line) {\n  return /^\\S+=\\S+;/.test(line) || line.startsWith(\" \");\n}\nexports.testLine = testLine;\n/**\n * Parse single line as MLSD listing, see specification at https://tools.ietf.org/html/rfc3659#section-7.\n */\nfunction parseLine(line) {\n  const [packedFacts, name] = splitStringOnce(line, \" \");\n  if (name === \"\" || name === \".\" || name === \"..\") {\n    return undefined;\n  }\n  const info = new FileInfo_1.FileInfo(name);\n  const facts = packedFacts.split(\";\");\n  for (const fact of facts) {\n    const [factName, factValue] = splitStringOnce(fact, \"=\");\n    if (!factValue) {\n      continue;\n    }\n    const factHandler = factHandlersByName[factName.toLowerCase()];\n    if (!factHandler) {\n      continue;\n    }\n    const result = factHandler(factValue, info);\n    if (result === 2 /* FactHandlerResult.IgnoreFile */) {\n      return undefined;\n    }\n  }\n  return info;\n}\nexports.parseLine = parseLine;\nfunction transformList(files) {\n  // Create a map of all files that are not symbolic links by their unique ID\n  const nonLinksByID = new Map();\n  for (const file of files) {\n    if (!file.isSymbolicLink && file.uniqueID !== undefined) {\n      nonLinksByID.set(file.uniqueID, file);\n    }\n  }\n  const resolvedFiles = [];\n  for (const file of files) {\n    // Try to associate unresolved symbolic links with a target file/directory.\n    if (file.isSymbolicLink && file.uniqueID !== undefined && file.link === undefined) {\n      const target = nonLinksByID.get(file.uniqueID);\n      if (target !== undefined) {\n        file.link = target.name;\n      }\n    }\n    // The target of a symbolic link is listed as an entry in the directory listing but might\n    // have a path pointing outside of this directory. In that case we don't want this entry\n    // to be part of the listing. We generally don't want these kind of entries at all.\n    const isPartOfDirectory = !file.name.includes(\"/\");\n    if (isPartOfDirectory) {\n      resolvedFiles.push(file);\n    }\n  }\n  return resolvedFiles;\n}\nexports.transformList = transformList;\n/**\n * Parse date as specified in https://tools.ietf.org/html/rfc3659#section-2.3.\n *\n * Message contains response code and modified time in the format: YYYYMMDDHHMMSS[.sss]\n * For example `19991005213102` or `19980615100045.014`.\n */\nfunction parseMLSxDate(fact) {\n  return new Date(Date.UTC(+fact.slice(0, 4),\n  // Year\n  +fact.slice(4, 6) - 1,\n  // Month\n  +fact.slice(6, 8),\n  // Date\n  +fact.slice(8, 10),\n  // Hours\n  +fact.slice(10, 12),\n  // Minutes\n  +fact.slice(12, 14),\n  // Seconds\n  +fact.slice(15, 18) // Milliseconds\n  ));\n}\n\nexports.parseMLSxDate = parseMLSxDate;","map":{"version":3,"names":["Object","defineProperty","exports","value","parseMLSxDate","transformList","parseLine","testLine","FileInfo_1","require","parseSize","info","size","parseInt","factHandlersByName","uniqueID","modifiedAt","rawModifiedAt","toISOString","startsWith","type","FileType","SymbolicLink","link","substr","indexOf","File","Directory","Unknown","digits","permissions","user","group","world","undefined","splitStringOnce","str","delimiter","pos","a","b","length","line","test","packedFacts","name","FileInfo","facts","split","fact","factName","factValue","factHandler","toLowerCase","result","files","nonLinksByID","Map","file","isSymbolicLink","set","resolvedFiles","target","get","isPartOfDirectory","includes","push","Date","UTC","slice"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/parseListMLSD.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseMLSxDate = exports.transformList = exports.parseLine = exports.testLine = void 0;\nconst FileInfo_1 = require(\"./FileInfo\");\nfunction parseSize(value, info) {\n    info.size = parseInt(value, 10);\n}\n/**\n * Parsers for MLSD facts.\n */\nconst factHandlersByName = {\n    \"size\": parseSize,\n    \"sizd\": parseSize,\n    \"unique\": (value, info) => {\n        info.uniqueID = value;\n    },\n    \"modify\": (value, info) => {\n        info.modifiedAt = parseMLSxDate(value);\n        info.rawModifiedAt = info.modifiedAt.toISOString();\n    },\n    \"type\": (value, info) => {\n        // There seems to be confusion on how to handle symbolic links for Unix. RFC 3659 doesn't describe\n        // this but mentions some examples using the syntax `type=OS.unix=slink:<target>`. But according to\n        // an entry in the Errata (https://www.rfc-editor.org/errata/eid1500) this syntax can't be valid.\n        // Instead it proposes to use `type=OS.unix=symlink` and to then list the actual target of the\n        // symbolic link as another entry in the directory listing. The unique identifiers can then be used\n        // to derive the connection between link(s) and target. We'll have to handle both cases as there\n        // are differing opinions on how to deal with this. Here are some links on this topic:\n        // - ProFTPD source: https://github.com/proftpd/proftpd/blob/56e6dfa598cbd4ef5c6cba439bcbcd53a63e3b21/modules/mod_facts.c#L531\n        // - ProFTPD bug: http://bugs.proftpd.org/show_bug.cgi?id=3318\n        // - ProFTPD statement: http://www.proftpd.org/docs/modules/mod_facts.html\n        // – FileZilla bug: https://trac.filezilla-project.org/ticket/9310\n        if (value.startsWith(\"OS.unix=slink\")) {\n            info.type = FileInfo_1.FileType.SymbolicLink;\n            info.link = value.substr(value.indexOf(\":\") + 1);\n            return 1 /* FactHandlerResult.Continue */;\n        }\n        switch (value) {\n            case \"file\":\n                info.type = FileInfo_1.FileType.File;\n                break;\n            case \"dir\":\n                info.type = FileInfo_1.FileType.Directory;\n                break;\n            case \"OS.unix=symlink\":\n                info.type = FileInfo_1.FileType.SymbolicLink;\n                // The target of the symbolic link might be defined in another line in the directory listing.\n                // We'll handle this in `transformList()` below.\n                break;\n            case \"cdir\": // Current directory being listed\n            case \"pdir\": // Parent directory\n                return 2 /* FactHandlerResult.IgnoreFile */; // Don't include these entries in the listing\n            default:\n                info.type = FileInfo_1.FileType.Unknown;\n        }\n        return 1 /* FactHandlerResult.Continue */;\n    },\n    \"unix.mode\": (value, info) => {\n        const digits = value.substr(-3);\n        info.permissions = {\n            user: parseInt(digits[0], 10),\n            group: parseInt(digits[1], 10),\n            world: parseInt(digits[2], 10)\n        };\n    },\n    \"unix.ownername\": (value, info) => {\n        info.user = value;\n    },\n    \"unix.owner\": (value, info) => {\n        if (info.user === undefined)\n            info.user = value;\n    },\n    get \"unix.uid\"() {\n        return this[\"unix.owner\"];\n    },\n    \"unix.groupname\": (value, info) => {\n        info.group = value;\n    },\n    \"unix.group\": (value, info) => {\n        if (info.group === undefined)\n            info.group = value;\n    },\n    get \"unix.gid\"() {\n        return this[\"unix.group\"];\n    }\n    // Regarding the fact \"perm\":\n    // We don't handle permission information stored in \"perm\" because its information is conceptually\n    // different from what users of FTP clients usually associate with \"permissions\". Those that have\n    // some expectations (and probably want to edit them with a SITE command) often unknowingly expect\n    // the Unix permission system. The information passed by \"perm\" describes what FTP commands can be\n    // executed with a file/directory. But even this can be either incomplete or just meant as a \"guide\"\n    // as the spec mentions. From https://tools.ietf.org/html/rfc3659#section-7.5.5: \"The permissions are\n    // described here as they apply to FTP commands. They may not map easily into particular permissions\n    // available on the server's operating system.\" The parser by Apache Commons tries to translate these\n    // to Unix permissions – this is misleading users and might not even be correct.\n};\n/**\n * Split a string once at the first position of a delimiter. For example\n * `splitStringOnce(\"a b c d\", \" \")` returns `[\"a\", \"b c d\"]`.\n */\nfunction splitStringOnce(str, delimiter) {\n    const pos = str.indexOf(delimiter);\n    const a = str.substr(0, pos);\n    const b = str.substr(pos + delimiter.length);\n    return [a, b];\n}\n/**\n * Returns true if a given line might be part of an MLSD listing.\n *\n * - Example 1: `size=15227;type=dir;perm=el;modify=20190419065730; test one`\n * - Example 2: ` file name` (leading space)\n */\nfunction testLine(line) {\n    return /^\\S+=\\S+;/.test(line) || line.startsWith(\" \");\n}\nexports.testLine = testLine;\n/**\n * Parse single line as MLSD listing, see specification at https://tools.ietf.org/html/rfc3659#section-7.\n */\nfunction parseLine(line) {\n    const [packedFacts, name] = splitStringOnce(line, \" \");\n    if (name === \"\" || name === \".\" || name === \"..\") {\n        return undefined;\n    }\n    const info = new FileInfo_1.FileInfo(name);\n    const facts = packedFacts.split(\";\");\n    for (const fact of facts) {\n        const [factName, factValue] = splitStringOnce(fact, \"=\");\n        if (!factValue) {\n            continue;\n        }\n        const factHandler = factHandlersByName[factName.toLowerCase()];\n        if (!factHandler) {\n            continue;\n        }\n        const result = factHandler(factValue, info);\n        if (result === 2 /* FactHandlerResult.IgnoreFile */) {\n            return undefined;\n        }\n    }\n    return info;\n}\nexports.parseLine = parseLine;\nfunction transformList(files) {\n    // Create a map of all files that are not symbolic links by their unique ID\n    const nonLinksByID = new Map();\n    for (const file of files) {\n        if (!file.isSymbolicLink && file.uniqueID !== undefined) {\n            nonLinksByID.set(file.uniqueID, file);\n        }\n    }\n    const resolvedFiles = [];\n    for (const file of files) {\n        // Try to associate unresolved symbolic links with a target file/directory.\n        if (file.isSymbolicLink && file.uniqueID !== undefined && file.link === undefined) {\n            const target = nonLinksByID.get(file.uniqueID);\n            if (target !== undefined) {\n                file.link = target.name;\n            }\n        }\n        // The target of a symbolic link is listed as an entry in the directory listing but might\n        // have a path pointing outside of this directory. In that case we don't want this entry\n        // to be part of the listing. We generally don't want these kind of entries at all.\n        const isPartOfDirectory = !file.name.includes(\"/\");\n        if (isPartOfDirectory) {\n            resolvedFiles.push(file);\n        }\n    }\n    return resolvedFiles;\n}\nexports.transformList = transformList;\n/**\n * Parse date as specified in https://tools.ietf.org/html/rfc3659#section-2.3.\n *\n * Message contains response code and modified time in the format: YYYYMMDDHHMMSS[.sss]\n * For example `19991005213102` or `19980615100045.014`.\n */\nfunction parseMLSxDate(fact) {\n    return new Date(Date.UTC(+fact.slice(0, 4), // Year\n    +fact.slice(4, 6) - 1, // Month\n    +fact.slice(6, 8), // Date\n    +fact.slice(8, 10), // Hours\n    +fact.slice(10, 12), // Minutes\n    +fact.slice(12, 14), // Seconds\n    +fact.slice(15, 18) // Milliseconds\n    ));\n}\nexports.parseMLSxDate = parseMLSxDate;\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,aAAa,GAAGF,OAAO,CAACG,aAAa,GAAGH,OAAO,CAACI,SAAS,GAAGJ,OAAO,CAACK,QAAQ,GAAG,KAAK,CAAC;AAC7F,MAAMC,UAAU,GAAGC,OAAO,CAAC,YAAY,CAAC;AACxC,SAASC,SAAS,CAACP,KAAK,EAAEQ,IAAI,EAAE;EAC5BA,IAAI,CAACC,IAAI,GAAGC,QAAQ,CAACV,KAAK,EAAE,EAAE,CAAC;AACnC;AACA;AACA;AACA;AACA,MAAMW,kBAAkB,GAAG;EACvB,MAAM,EAAEJ,SAAS;EACjB,MAAM,EAAEA,SAAS;EACjB,QAAQ,EAAE,CAACP,KAAK,EAAEQ,IAAI,KAAK;IACvBA,IAAI,CAACI,QAAQ,GAAGZ,KAAK;EACzB,CAAC;EACD,QAAQ,EAAE,CAACA,KAAK,EAAEQ,IAAI,KAAK;IACvBA,IAAI,CAACK,UAAU,GAAGZ,aAAa,CAACD,KAAK,CAAC;IACtCQ,IAAI,CAACM,aAAa,GAAGN,IAAI,CAACK,UAAU,CAACE,WAAW,EAAE;EACtD,CAAC;EACD,MAAM,EAAE,CAACf,KAAK,EAAEQ,IAAI,KAAK;IACrB;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAIR,KAAK,CAACgB,UAAU,CAAC,eAAe,CAAC,EAAE;MACnCR,IAAI,CAACS,IAAI,GAAGZ,UAAU,CAACa,QAAQ,CAACC,YAAY;MAC5CX,IAAI,CAACY,IAAI,GAAGpB,KAAK,CAACqB,MAAM,CAACrB,KAAK,CAACsB,OAAO,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;MAChD,OAAO,CAAC,CAAC;IACb;;IACA,QAAQtB,KAAK;MACT,KAAK,MAAM;QACPQ,IAAI,CAACS,IAAI,GAAGZ,UAAU,CAACa,QAAQ,CAACK,IAAI;QACpC;MACJ,KAAK,KAAK;QACNf,IAAI,CAACS,IAAI,GAAGZ,UAAU,CAACa,QAAQ,CAACM,SAAS;QACzC;MACJ,KAAK,iBAAiB;QAClBhB,IAAI,CAACS,IAAI,GAAGZ,UAAU,CAACa,QAAQ,CAACC,YAAY;QAC5C;QACA;QACA;MACJ,KAAK,MAAM,CAAC,CAAC;MACb,KAAK,MAAM;QAAE;QACT,OAAO,CAAC,CAAC;MAAoC;MACjD;QACIX,IAAI,CAACS,IAAI,GAAGZ,UAAU,CAACa,QAAQ,CAACO,OAAO;IAAC;IAEhD,OAAO,CAAC,CAAC;EACb,CAAC;;EACD,WAAW,EAAE,CAACzB,KAAK,EAAEQ,IAAI,KAAK;IAC1B,MAAMkB,MAAM,GAAG1B,KAAK,CAACqB,MAAM,CAAC,CAAC,CAAC,CAAC;IAC/Bb,IAAI,CAACmB,WAAW,GAAG;MACfC,IAAI,EAAElB,QAAQ,CAACgB,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MAC7BG,KAAK,EAAEnB,QAAQ,CAACgB,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;MAC9BI,KAAK,EAAEpB,QAAQ,CAACgB,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE;IACjC,CAAC;EACL,CAAC;EACD,gBAAgB,EAAE,CAAC1B,KAAK,EAAEQ,IAAI,KAAK;IAC/BA,IAAI,CAACoB,IAAI,GAAG5B,KAAK;EACrB,CAAC;EACD,YAAY,EAAE,CAACA,KAAK,EAAEQ,IAAI,KAAK;IAC3B,IAAIA,IAAI,CAACoB,IAAI,KAAKG,SAAS,EACvBvB,IAAI,CAACoB,IAAI,GAAG5B,KAAK;EACzB,CAAC;EACD,IAAI,UAAU,GAAG;IACb,OAAO,IAAI,CAAC,YAAY,CAAC;EAC7B,CAAC;EACD,gBAAgB,EAAE,CAACA,KAAK,EAAEQ,IAAI,KAAK;IAC/BA,IAAI,CAACqB,KAAK,GAAG7B,KAAK;EACtB,CAAC;EACD,YAAY,EAAE,CAACA,KAAK,EAAEQ,IAAI,KAAK;IAC3B,IAAIA,IAAI,CAACqB,KAAK,KAAKE,SAAS,EACxBvB,IAAI,CAACqB,KAAK,GAAG7B,KAAK;EAC1B,CAAC;EACD,IAAI,UAAU,GAAG;IACb,OAAO,IAAI,CAAC,YAAY,CAAC;EAC7B;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,SAASgC,eAAe,CAACC,GAAG,EAAEC,SAAS,EAAE;EACrC,MAAMC,GAAG,GAAGF,GAAG,CAACX,OAAO,CAACY,SAAS,CAAC;EAClC,MAAME,CAAC,GAAGH,GAAG,CAACZ,MAAM,CAAC,CAAC,EAAEc,GAAG,CAAC;EAC5B,MAAME,CAAC,GAAGJ,GAAG,CAACZ,MAAM,CAACc,GAAG,GAAGD,SAAS,CAACI,MAAM,CAAC;EAC5C,OAAO,CAACF,CAAC,EAAEC,CAAC,CAAC;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASjC,QAAQ,CAACmC,IAAI,EAAE;EACpB,OAAO,WAAW,CAACC,IAAI,CAACD,IAAI,CAAC,IAAIA,IAAI,CAACvB,UAAU,CAAC,GAAG,CAAC;AACzD;AACAjB,OAAO,CAACK,QAAQ,GAAGA,QAAQ;AAC3B;AACA;AACA;AACA,SAASD,SAAS,CAACoC,IAAI,EAAE;EACrB,MAAM,CAACE,WAAW,EAAEC,IAAI,CAAC,GAAGV,eAAe,CAACO,IAAI,EAAE,GAAG,CAAC;EACtD,IAAIG,IAAI,KAAK,EAAE,IAAIA,IAAI,KAAK,GAAG,IAAIA,IAAI,KAAK,IAAI,EAAE;IAC9C,OAAOX,SAAS;EACpB;EACA,MAAMvB,IAAI,GAAG,IAAIH,UAAU,CAACsC,QAAQ,CAACD,IAAI,CAAC;EAC1C,MAAME,KAAK,GAAGH,WAAW,CAACI,KAAK,CAAC,GAAG,CAAC;EACpC,KAAK,MAAMC,IAAI,IAAIF,KAAK,EAAE;IACtB,MAAM,CAACG,QAAQ,EAAEC,SAAS,CAAC,GAAGhB,eAAe,CAACc,IAAI,EAAE,GAAG,CAAC;IACxD,IAAI,CAACE,SAAS,EAAE;MACZ;IACJ;IACA,MAAMC,WAAW,GAAGtC,kBAAkB,CAACoC,QAAQ,CAACG,WAAW,EAAE,CAAC;IAC9D,IAAI,CAACD,WAAW,EAAE;MACd;IACJ;IACA,MAAME,MAAM,GAAGF,WAAW,CAACD,SAAS,EAAExC,IAAI,CAAC;IAC3C,IAAI2C,MAAM,KAAK,CAAC,CAAC,oCAAoC;MACjD,OAAOpB,SAAS;IACpB;EACJ;EACA,OAAOvB,IAAI;AACf;AACAT,OAAO,CAACI,SAAS,GAAGA,SAAS;AAC7B,SAASD,aAAa,CAACkD,KAAK,EAAE;EAC1B;EACA,MAAMC,YAAY,GAAG,IAAIC,GAAG,EAAE;EAC9B,KAAK,MAAMC,IAAI,IAAIH,KAAK,EAAE;IACtB,IAAI,CAACG,IAAI,CAACC,cAAc,IAAID,IAAI,CAAC3C,QAAQ,KAAKmB,SAAS,EAAE;MACrDsB,YAAY,CAACI,GAAG,CAACF,IAAI,CAAC3C,QAAQ,EAAE2C,IAAI,CAAC;IACzC;EACJ;EACA,MAAMG,aAAa,GAAG,EAAE;EACxB,KAAK,MAAMH,IAAI,IAAIH,KAAK,EAAE;IACtB;IACA,IAAIG,IAAI,CAACC,cAAc,IAAID,IAAI,CAAC3C,QAAQ,KAAKmB,SAAS,IAAIwB,IAAI,CAACnC,IAAI,KAAKW,SAAS,EAAE;MAC/E,MAAM4B,MAAM,GAAGN,YAAY,CAACO,GAAG,CAACL,IAAI,CAAC3C,QAAQ,CAAC;MAC9C,IAAI+C,MAAM,KAAK5B,SAAS,EAAE;QACtBwB,IAAI,CAACnC,IAAI,GAAGuC,MAAM,CAACjB,IAAI;MAC3B;IACJ;IACA;IACA;IACA;IACA,MAAMmB,iBAAiB,GAAG,CAACN,IAAI,CAACb,IAAI,CAACoB,QAAQ,CAAC,GAAG,CAAC;IAClD,IAAID,iBAAiB,EAAE;MACnBH,aAAa,CAACK,IAAI,CAACR,IAAI,CAAC;IAC5B;EACJ;EACA,OAAOG,aAAa;AACxB;AACA3D,OAAO,CAACG,aAAa,GAAGA,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,aAAa,CAAC6C,IAAI,EAAE;EACzB,OAAO,IAAIkB,IAAI,CAACA,IAAI,CAACC,GAAG,CAAC,CAACnB,IAAI,CAACoB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EAAE;EAC5C,CAACpB,IAAI,CAACoB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,GAAG,CAAC;EAAE;EACvB,CAACpB,IAAI,CAACoB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;EAAE;EACnB,CAACpB,IAAI,CAACoB,KAAK,CAAC,CAAC,EAAE,EAAE,CAAC;EAAE;EACpB,CAACpB,IAAI,CAACoB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EAAE;EACrB,CAACpB,IAAI,CAACoB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC;EAAE;EACrB,CAACpB,IAAI,CAACoB,KAAK,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;EAAA,CACnB,CAAC;AACN;;AACAnE,OAAO,CAACE,aAAa,GAAGA,aAAa"},"metadata":{},"sourceType":"script"}