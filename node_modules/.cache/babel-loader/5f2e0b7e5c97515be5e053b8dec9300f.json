{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Client = void 0;\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst tls_1 = require(\"tls\");\nconst util_1 = require(\"util\");\nconst FtpContext_1 = require(\"./FtpContext\");\nconst parseList_1 = require(\"./parseList\");\nconst ProgressTracker_1 = require(\"./ProgressTracker\");\nconst StringWriter_1 = require(\"./StringWriter\");\nconst parseListMLSD_1 = require(\"./parseListMLSD\");\nconst netUtils_1 = require(\"./netUtils\");\nconst transfer_1 = require(\"./transfer\");\nconst parseControlResponse_1 = require(\"./parseControlResponse\");\n// Use promisify to keep the library compatible with Node 8.\nconst fsReadDir = (0, util_1.promisify)(fs_1.readdir);\nconst fsMkDir = (0, util_1.promisify)(fs_1.mkdir);\nconst fsStat = (0, util_1.promisify)(fs_1.stat);\nconst fsOpen = (0, util_1.promisify)(fs_1.open);\nconst fsClose = (0, util_1.promisify)(fs_1.close);\nconst fsUnlink = (0, util_1.promisify)(fs_1.unlink);\nconst LIST_COMMANDS_DEFAULT = [\"LIST -a\", \"LIST\"];\nconst LIST_COMMANDS_MLSD = [\"MLSD\", \"LIST -a\", \"LIST\"];\n/**\n * High-level API to interact with an FTP server.\n */\nclass Client {\n  /**\n   * Instantiate an FTP client.\n   *\n   * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.\n   */\n  constructor() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 30000;\n    this.availableListCommands = LIST_COMMANDS_DEFAULT;\n    this.ftp = new FtpContext_1.FTPContext(timeout);\n    this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);\n    this.parseList = parseList_1.parseList;\n    this._progressTracker = new ProgressTracker_1.ProgressTracker();\n  }\n  /**\n   * Close the client and all open socket connections.\n   *\n   * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,\n   * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.\n   * A client is also closed automatically if any timeout or connection error occurs.\n   */\n  close() {\n    this.ftp.close();\n    this._progressTracker.stop();\n  }\n  /**\n   * Returns true if the client is closed and can't be used anymore.\n   */\n  get closed() {\n    return this.ftp.closed;\n  }\n  /**\n   * Connect (or reconnect) to an FTP server.\n   *\n   * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n   * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n   * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n   * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n   *\n   * @param host  Host the client should connect to. Optional, default is \"localhost\".\n   * @param port  Port the client should connect to. Optional, default is 21.\n   */\n  connect() {\n    let host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"localhost\";\n    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 21;\n    this.ftp.reset();\n    this.ftp.socket.connect({\n      host,\n      port,\n      family: this.ftp.ipFamily\n    }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n    return this._handleConnectResponse();\n  }\n  /**\n   * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by\n   * explicit TLS. There are still FTP servers that support only implicit TLS, though.\n   */\n  connectImplicitTLS() {\n    let host = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"localhost\";\n    let port = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 21;\n    let tlsOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.ftp.reset();\n    this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n    this.ftp.tlsOptions = tlsOptions;\n    return this._handleConnectResponse();\n  }\n  /**\n   * Handles the first reponse by an FTP server after the socket connection has been established.\n   */\n  _handleConnectResponse() {\n    return this.ftp.handle(undefined, (res, task) => {\n      if (res instanceof Error) {\n        // The connection has been destroyed by the FTPContext at this point.\n        task.reject(res);\n      } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n        task.resolve(res);\n      }\n      // Reject all other codes, including 120 \"Service ready in nnn minutes\".\n      else {\n        // Don't stay connected but don't replace the socket yet by using reset()\n        // so the user can inspect properties of this instance.\n        task.reject(new FtpContext_1.FTPError(res));\n      }\n    });\n  }\n  /**\n   * Send an FTP command and handle the first response.\n   */\n  send(command) {\n    let ignoreErrorCodesDEPRECATED = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (ignoreErrorCodesDEPRECATED) {\n      // Deprecated starting from 3.9.0\n      this.ftp.log(\"Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).\");\n      return this.sendIgnoringError(command);\n    }\n    return this.ftp.request(command);\n  }\n  /**\n   * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.\n   *\n   * @param command\n   */\n  sendIgnoringError(command) {\n    return this.ftp.handle(command, (res, task) => {\n      if (res instanceof FtpContext_1.FTPError) {\n        task.resolve({\n          code: res.code,\n          message: res.message\n        });\n      } else if (res instanceof Error) {\n        task.reject(res);\n      } else {\n        task.resolve(res);\n      }\n    });\n  }\n  /**\n   * Upgrade the current socket connection to TLS.\n   *\n   * @param options  TLS options as in `tls.connect(options)`, optional.\n   * @param command  Set the authentication command. Optional, default is \"AUTH TLS\".\n   */\n  async useTLS() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let command = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"AUTH TLS\";\n    const ret = await this.send(command);\n    this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);\n    this.ftp.tlsOptions = options; // Keep the TLS options for later data connections that should use the same options.\n    this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n    return ret;\n  }\n  /**\n   * Login a user with a password.\n   *\n   * @param user  Username to use for login. Optional, default is \"anonymous\".\n   * @param password  Password to use for login. Optional, default is \"guest\".\n   */\n  login() {\n    let user = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"anonymous\";\n    let password = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"guest\";\n    this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n    return this.ftp.handle(\"USER \" + user, (res, task) => {\n      if (res instanceof Error) {\n        task.reject(res);\n      } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n        // User logged in proceed OR Command superfluous\n        task.resolve(res);\n      } else if (res.code === 331) {\n        // User name okay, need password\n        this.ftp.send(\"PASS \" + password);\n      } else {\n        // Also report error on 332 (Need account)\n        task.reject(new FtpContext_1.FTPError(res));\n      }\n    });\n  }\n  /**\n   * Set the usual default settings.\n   *\n   * Settings used:\n   * * Binary mode (TYPE I)\n   * * File structure (STRU F)\n   * * Additional settings for FTPS (PBSZ 0, PROT P)\n   */\n  async useDefaultSettings() {\n    const features = await this.features();\n    // Use MLSD directory listing if possible. See https://tools.ietf.org/html/rfc3659#section-7.8:\n    // \"The presence of the MLST feature indicates that both MLST and MLSD are supported.\"\n    const supportsMLSD = features.has(\"MLST\");\n    this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD : LIST_COMMANDS_DEFAULT;\n    await this.send(\"TYPE I\"); // Binary mode\n    await this.sendIgnoringError(\"STRU F\"); // Use file structure\n    await this.sendIgnoringError(\"OPTS UTF8 ON\"); // Some servers expect UTF-8 to be enabled explicitly and setting before login might not have worked.\n    if (supportsMLSD) {\n      await this.sendIgnoringError(\"OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;\"); // Make sure MLSD listings include all we can parse\n    }\n\n    if (this.ftp.hasTLS) {\n      await this.sendIgnoringError(\"PBSZ 0\"); // Set to 0 for TLS\n      await this.sendIgnoringError(\"PROT P\"); // Protect channel (also for data connections)\n    }\n  }\n  /**\n   * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.\n   *\n   * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n   * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n   * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n   * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n   */\n  async access() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _a, _b;\n    const useExplicitTLS = options.secure === true;\n    const useImplicitTLS = options.secure === \"implicit\";\n    let welcome;\n    if (useImplicitTLS) {\n      welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);\n    } else {\n      welcome = await this.connect(options.host, options.port);\n    }\n    if (useExplicitTLS) {\n      // Fixes https://github.com/patrickjuchli/basic-ftp/issues/166 by making sure\n      // host is set for any future data connection as well.\n      const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};\n      secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;\n      await this.useTLS(secureOptions);\n    }\n    // Set UTF-8 on before login in case there are non-ascii characters in user or password.\n    // Note that this might not work before login depending on server.\n    await this.sendIgnoringError(\"OPTS UTF8 ON\");\n    await this.login(options.user, options.password);\n    await this.useDefaultSettings();\n    return welcome;\n  }\n  /**\n   * Get the current working directory.\n   */\n  async pwd() {\n    const res = await this.send(\"PWD\");\n    // The directory is part of the return message, for example:\n    // 257 \"/this/that\" is current directory.\n    const parsed = res.message.match(/\"(.+)\"/);\n    if (parsed === null || parsed[1] === undefined) {\n      throw new Error(`Can't parse response to command 'PWD': ${res.message}`);\n    }\n    return parsed[1];\n  }\n  /**\n   * Get a description of supported features.\n   *\n   * This sends the FEAT command and parses the result into a Map where keys correspond to available commands\n   * and values hold further information. Be aware that your FTP servers might not support this\n   * command in which case this method will not throw an exception but just return an empty Map.\n   */\n  async features() {\n    const res = await this.sendIgnoringError(\"FEAT\");\n    const features = new Map();\n    // Not supporting any special features will be reported with a single line.\n    if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {\n      // The first and last line wrap the multiline response, ignore them.\n      res.message.split(\"\\n\").slice(1, -1).forEach(line => {\n        // A typical lines looks like: \" REST STREAM\" or \" MDTM\".\n        // Servers might not use an indentation though.\n        const entry = line.trim().split(\" \");\n        features.set(entry[0], entry[1] || \"\");\n      });\n    }\n    return features;\n  }\n  /**\n   * Set the working directory.\n   */\n  async cd(path) {\n    const validPath = await this.protectWhitespace(path);\n    return this.send(\"CWD \" + validPath);\n  }\n  /**\n   * Switch to the parent directory of the working directory.\n   */\n  async cdup() {\n    return this.send(\"CDUP\");\n  }\n  /**\n   * Get the last modified time of a file. This is not supported by every FTP server, in which case\n   * calling this method will throw an exception.\n   */\n  async lastMod(path) {\n    const validPath = await this.protectWhitespace(path);\n    const res = await this.send(`MDTM ${validPath}`);\n    const date = res.message.slice(4);\n    return (0, parseListMLSD_1.parseMLSxDate)(date);\n  }\n  /**\n   * Get the size of a file.\n   */\n  async size(path) {\n    const validPath = await this.protectWhitespace(path);\n    const command = `SIZE ${validPath}`;\n    const res = await this.send(command);\n    // The size is part of the response message, for example: \"213 555555\". It's\n    // possible that there is a commmentary appended like \"213 5555, some commentary\".\n    const size = parseInt(res.message.slice(4), 10);\n    if (Number.isNaN(size)) {\n      throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);\n    }\n    return size;\n  }\n  /**\n   * Rename a file.\n   *\n   * Depending on the FTP server this might also be used to move a file from one\n   * directory to another by providing full paths.\n   */\n  async rename(srcPath, destPath) {\n    const validSrc = await this.protectWhitespace(srcPath);\n    const validDest = await this.protectWhitespace(destPath);\n    await this.send(\"RNFR \" + validSrc);\n    return this.send(\"RNTO \" + validDest);\n  }\n  /**\n   * Remove a file from the current working directory.\n   *\n   * You can ignore FTP error return codes which won't throw an exception if e.g.\n   * the file doesn't exist.\n   */\n  async remove(path) {\n    let ignoreErrorCodes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validPath = await this.protectWhitespace(path);\n    if (ignoreErrorCodes) {\n      return this.sendIgnoringError(`DELE ${validPath}`);\n    }\n    return this.send(`DELE ${validPath}`);\n  }\n  /**\n   * Report transfer progress for any upload or download to a given handler.\n   *\n   * This will also reset the overall transfer counter that can be used for multiple transfers. You can\n   * also call the function without a handler to stop reporting to an earlier one.\n   *\n   * @param handler  Handler function to call on transfer progress.\n   */\n  trackProgress(handler) {\n    this._progressTracker.bytesOverall = 0;\n    this._progressTracker.reportTo(handler);\n  }\n  /**\n   * Upload data from a readable stream or a local file to a remote file.\n   *\n   * @param source  Readable stream or path to a local file.\n   * @param toRemotePath  Path to a remote file to write to.\n   */\n  async uploadFrom(source, toRemotePath) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._uploadWithCommand(source, toRemotePath, \"STOR\", options);\n  }\n  /**\n   * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't\n   * exist the FTP server should create it.\n   *\n   * @param source  Readable stream or path to a local file.\n   * @param toRemotePath  Path to a remote file to write to.\n   */\n  async appendFrom(source, toRemotePath) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this._uploadWithCommand(source, toRemotePath, \"APPE\", options);\n  }\n  /**\n   * @protected\n   */\n  async _uploadWithCommand(source, remotePath, command, options) {\n    if (typeof source === \"string\") {\n      return this._uploadLocalFile(source, remotePath, command, options);\n    }\n    return this._uploadFromStream(source, remotePath, command);\n  }\n  /**\n   * @protected\n   */\n  async _uploadLocalFile(localPath, remotePath, command, options) {\n    const fd = await fsOpen(localPath, \"r\");\n    const source = (0, fs_1.createReadStream)(\"\", {\n      fd,\n      start: options.localStart,\n      end: options.localEndInclusive,\n      autoClose: false\n    });\n    try {\n      return await this._uploadFromStream(source, remotePath, command);\n    } finally {\n      await ignoreError(() => fsClose(fd));\n    }\n  }\n  /**\n   * @protected\n   */\n  async _uploadFromStream(source, remotePath, command) {\n    const onError = err => this.ftp.closeWithError(err);\n    source.once(\"error\", onError);\n    try {\n      const validPath = await this.protectWhitespace(remotePath);\n      await this.prepareTransfer(this.ftp);\n      // Keep the keyword `await` or the `finally` clause below runs too early\n      // and removes the event listener for the source stream too early.\n      return await (0, transfer_1.uploadFrom)(source, {\n        ftp: this.ftp,\n        tracker: this._progressTracker,\n        command,\n        remotePath: validPath,\n        type: \"upload\"\n      });\n    } finally {\n      source.removeListener(\"error\", onError);\n    }\n  }\n  /**\n   * Download a remote file and pipe its data to a writable stream or to a local file.\n   *\n   * You can optionally define at which position of the remote file you'd like to start\n   * downloading. If the destination you provide is a file, the offset will be applied\n   * to it as well. For example: To resume a failed download, you'd request the size of\n   * the local, partially downloaded file and use that as the offset. Assuming the size\n   * is 23, you'd download the rest using `downloadTo(\"local.txt\", \"remote.txt\", 23)`.\n   *\n   * @param destination  Stream or path for a local file to write to.\n   * @param fromRemotePath  Path of the remote file to read from.\n   * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.\n   */\n  async downloadTo(destination, fromRemotePath) {\n    let startAt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    if (typeof destination === \"string\") {\n      return this._downloadToFile(destination, fromRemotePath, startAt);\n    }\n    return this._downloadToStream(destination, fromRemotePath, startAt);\n  }\n  /**\n   * @protected\n   */\n  async _downloadToFile(localPath, remotePath, startAt) {\n    const appendingToLocalFile = startAt > 0;\n    const fileSystemFlags = appendingToLocalFile ? \"r+\" : \"w\";\n    const fd = await fsOpen(localPath, fileSystemFlags);\n    const destination = (0, fs_1.createWriteStream)(\"\", {\n      fd,\n      start: startAt,\n      autoClose: false\n    });\n    try {\n      return await this._downloadToStream(destination, remotePath, startAt);\n    } catch (err) {\n      const localFileStats = await ignoreError(() => fsStat(localPath));\n      const hasDownloadedData = localFileStats && localFileStats.size > 0;\n      const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;\n      if (shouldRemoveLocalFile) {\n        await ignoreError(() => fsUnlink(localPath));\n      }\n      throw err;\n    } finally {\n      await ignoreError(() => fsClose(fd));\n    }\n  }\n  /**\n   * @protected\n   */\n  async _downloadToStream(destination, remotePath, startAt) {\n    const onError = err => this.ftp.closeWithError(err);\n    destination.once(\"error\", onError);\n    try {\n      const validPath = await this.protectWhitespace(remotePath);\n      await this.prepareTransfer(this.ftp);\n      // Keep the keyword `await` or the `finally` clause below runs too early\n      // and removes the event listener for the source stream too early.\n      return await (0, transfer_1.downloadTo)(destination, {\n        ftp: this.ftp,\n        tracker: this._progressTracker,\n        command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,\n        remotePath: validPath,\n        type: \"download\"\n      });\n    } finally {\n      destination.removeListener(\"error\", onError);\n      destination.end();\n    }\n  }\n  /**\n   * List files and directories in the current working directory, or from `path` if specified.\n   *\n   * @param [path]  Path to remote file or directory.\n   */\n  async list() {\n    let path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    const validPath = await this.protectWhitespace(path);\n    let lastError;\n    for (const candidate of this.availableListCommands) {\n      const command = validPath === \"\" ? candidate : `${candidate} ${validPath}`;\n      await this.prepareTransfer(this.ftp);\n      try {\n        const parsedList = await this._requestListWithCommand(command);\n        // Use successful candidate for all subsequent requests.\n        this.availableListCommands = [candidate];\n        return parsedList;\n      } catch (err) {\n        const shouldTryNext = err instanceof FtpContext_1.FTPError;\n        if (!shouldTryNext) {\n          throw err;\n        }\n        lastError = err;\n      }\n    }\n    throw lastError;\n  }\n  /**\n   * @protected\n   */\n  async _requestListWithCommand(command) {\n    const buffer = new StringWriter_1.StringWriter();\n    await (0, transfer_1.downloadTo)(buffer, {\n      ftp: this.ftp,\n      tracker: this._progressTracker,\n      command,\n      remotePath: \"\",\n      type: \"list\"\n    });\n    const text = buffer.getText(this.ftp.encoding);\n    this.ftp.log(text);\n    return this.parseList(text);\n  }\n  /**\n   * Remove a directory and all of its content.\n   *\n   * @param remoteDirPath  The path of the remote directory to delete.\n   * @example client.removeDir(\"foo\") // Remove directory 'foo' using a relative path.\n   * @example client.removeDir(\"foo/bar\") // Remove directory 'bar' using a relative path.\n   * @example client.removeDir(\"/foo/bar\") // Remove directory 'bar' using an absolute path.\n   * @example client.removeDir(\"/\") // Remove everything.\n   */\n  async removeDir(remoteDirPath) {\n    return this._exitAtCurrentDirectory(async () => {\n      await this.cd(remoteDirPath);\n      await this.clearWorkingDir();\n      if (remoteDirPath !== \"/\") {\n        await this.cdup();\n        await this.removeEmptyDir(remoteDirPath);\n      }\n    });\n  }\n  /**\n   * Remove all files and directories in the working directory without removing\n   * the working directory itself.\n   */\n  async clearWorkingDir() {\n    for (const file of await this.list()) {\n      if (file.isDirectory) {\n        await this.cd(file.name);\n        await this.clearWorkingDir();\n        await this.cdup();\n        await this.removeEmptyDir(file.name);\n      } else {\n        await this.remove(file.name);\n      }\n    }\n  }\n  /**\n   * Upload the contents of a local directory to the remote working directory.\n   *\n   * This will overwrite existing files with the same names and reuse existing directories.\n   * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`\n   * to put the contents inside a directory which will be created if necessary including all\n   * intermediate directories. If you did provide a remoteDirPath the working directory will stay\n   * the same as before calling this method.\n   *\n   * @param localDirPath  Local path, e.g. \"foo/bar\" or \"../test\"\n   * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.\n   */\n  async uploadFromDir(localDirPath, remoteDirPath) {\n    return this._exitAtCurrentDirectory(async () => {\n      if (remoteDirPath) {\n        await this.ensureDir(remoteDirPath);\n      }\n      return await this._uploadToWorkingDir(localDirPath);\n    });\n  }\n  /**\n   * @protected\n   */\n  async _uploadToWorkingDir(localDirPath) {\n    const files = await fsReadDir(localDirPath);\n    for (const file of files) {\n      const fullPath = (0, path_1.join)(localDirPath, file);\n      const stats = await fsStat(fullPath);\n      if (stats.isFile()) {\n        await this.uploadFrom(fullPath, file);\n      } else if (stats.isDirectory()) {\n        await this._openDir(file);\n        await this._uploadToWorkingDir(fullPath);\n        await this.cdup();\n      }\n    }\n  }\n  /**\n   * Download all files and directories of the working directory to a local directory.\n   *\n   * @param localDirPath  The local directory to download to.\n   * @param remoteDirPath  Remote directory to download. Current working directory if not specified.\n   */\n  async downloadToDir(localDirPath, remoteDirPath) {\n    return this._exitAtCurrentDirectory(async () => {\n      if (remoteDirPath) {\n        await this.cd(remoteDirPath);\n      }\n      return await this._downloadFromWorkingDir(localDirPath);\n    });\n  }\n  /**\n   * @protected\n   */\n  async _downloadFromWorkingDir(localDirPath) {\n    await ensureLocalDirectory(localDirPath);\n    for (const file of await this.list()) {\n      const localPath = (0, path_1.join)(localDirPath, file.name);\n      if (file.isDirectory) {\n        await this.cd(file.name);\n        await this._downloadFromWorkingDir(localPath);\n        await this.cdup();\n      } else if (file.isFile) {\n        await this.downloadTo(localPath, file.name);\n      }\n    }\n  }\n  /**\n   * Make sure a given remote path exists, creating all directories as necessary.\n   * This function also changes the current working directory to the given path.\n   */\n  async ensureDir(remoteDirPath) {\n    // If the remoteDirPath was absolute go to root directory.\n    if (remoteDirPath.startsWith(\"/\")) {\n      await this.cd(\"/\");\n    }\n    const names = remoteDirPath.split(\"/\").filter(name => name !== \"\");\n    for (const name of names) {\n      await this._openDir(name);\n    }\n  }\n  /**\n   * Try to create a directory and enter it. This will not raise an exception if the directory\n   * couldn't be created if for example it already exists.\n   * @protected\n   */\n  async _openDir(dirName) {\n    await this.sendIgnoringError(\"MKD \" + dirName);\n    await this.cd(dirName);\n  }\n  /**\n   * Remove an empty directory, will fail if not empty.\n   */\n  async removeEmptyDir(path) {\n    const validPath = await this.protectWhitespace(path);\n    return this.send(`RMD ${validPath}`);\n  }\n  /**\n   * FTP servers can't handle filenames that have leading whitespace. This method transforms\n   * a given path to fix that issue for most cases.\n   */\n  async protectWhitespace(path) {\n    if (!path.startsWith(\" \")) {\n      return path;\n    }\n    // Handle leading whitespace by prepending the absolute path:\n    // \" test.txt\" while being in the root directory becomes \"/ test.txt\".\n    const pwd = await this.pwd();\n    const absolutePathPrefix = pwd.endsWith(\"/\") ? pwd : pwd + \"/\";\n    return absolutePathPrefix + path;\n  }\n  async _exitAtCurrentDirectory(func) {\n    const userDir = await this.pwd();\n    try {\n      return await func();\n    } finally {\n      if (!this.closed) {\n        await ignoreError(() => this.cd(userDir));\n      }\n    }\n  }\n  /**\n   * Try all available transfer strategies and pick the first one that works. Update `client` to\n   * use the working strategy for all successive transfer requests.\n   *\n   * @returns a function that will try the provided strategies.\n   */\n  _enterFirstCompatibleMode(strategies) {\n    return async ftp => {\n      ftp.log(\"Trying to find optimal transfer strategy...\");\n      let lastError = undefined;\n      for (const strategy of strategies) {\n        try {\n          const res = await strategy(ftp);\n          ftp.log(\"Optimal transfer strategy found.\");\n          this.prepareTransfer = strategy; // eslint-disable-line require-atomic-updates\n          return res;\n        } catch (err) {\n          // Try the next candidate no matter the exact error. It's possible that a server\n          // answered incorrectly to a strategy, for example a PASV answer to an EPSV.\n          lastError = err;\n        }\n      }\n      throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);\n    };\n  }\n  /**\n   * DEPRECATED, use `uploadFrom`.\n   * @deprecated\n   */\n  async upload(source, toRemotePath) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.ftp.log(\"Warning: upload() has been deprecated, use uploadFrom().\");\n    return this.uploadFrom(source, toRemotePath, options);\n  }\n  /**\n   * DEPRECATED, use `appendFrom`.\n   * @deprecated\n   */\n  async append(source, toRemotePath) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.ftp.log(\"Warning: append() has been deprecated, use appendFrom().\");\n    return this.appendFrom(source, toRemotePath, options);\n  }\n  /**\n   * DEPRECATED, use `downloadTo`.\n   * @deprecated\n   */\n  async download(destination, fromRemotePath) {\n    let startAt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    this.ftp.log(\"Warning: download() has been deprecated, use downloadTo().\");\n    return this.downloadTo(destination, fromRemotePath, startAt);\n  }\n  /**\n   * DEPRECATED, use `uploadFromDir`.\n   * @deprecated\n   */\n  async uploadDir(localDirPath, remoteDirPath) {\n    this.ftp.log(\"Warning: uploadDir() has been deprecated, use uploadFromDir().\");\n    return this.uploadFromDir(localDirPath, remoteDirPath);\n  }\n  /**\n   * DEPRECATED, use `downloadToDir`.\n   * @deprecated\n   */\n  async downloadDir(localDirPath) {\n    this.ftp.log(\"Warning: downloadDir() has been deprecated, use downloadToDir().\");\n    return this.downloadToDir(localDirPath);\n  }\n}\nexports.Client = Client;\nasync function ensureLocalDirectory(path) {\n  try {\n    await fsStat(path);\n  } catch (err) {\n    await fsMkDir(path, {\n      recursive: true\n    });\n  }\n}\nasync function ignoreError(func) {\n  try {\n    return await func();\n  } catch (err) {\n    // Ignore\n    return undefined;\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","Client","fs_1","require","path_1","tls_1","util_1","FtpContext_1","parseList_1","ProgressTracker_1","StringWriter_1","parseListMLSD_1","netUtils_1","transfer_1","parseControlResponse_1","fsReadDir","promisify","readdir","fsMkDir","mkdir","fsStat","stat","fsOpen","open","fsClose","close","fsUnlink","unlink","LIST_COMMANDS_DEFAULT","LIST_COMMANDS_MLSD","constructor","timeout","availableListCommands","ftp","FTPContext","prepareTransfer","_enterFirstCompatibleMode","enterPassiveModeIPv6","enterPassiveModeIPv4","parseList","_progressTracker","ProgressTracker","stop","closed","connect","host","port","reset","socket","family","ipFamily","log","describeAddress","describeTLS","_handleConnectResponse","connectImplicitTLS","tlsOptions","handle","undefined","res","task","Error","reject","positiveCompletion","code","resolve","FTPError","send","command","ignoreErrorCodesDEPRECATED","sendIgnoringError","request","message","useTLS","options","ret","upgradeSocket","login","user","password","useDefaultSettings","features","supportsMLSD","has","hasTLS","access","_a","_b","useExplicitTLS","secure","useImplicitTLS","welcome","secureOptions","pwd","parsed","match","Map","isMultiline","split","slice","forEach","line","entry","trim","set","cd","path","validPath","protectWhitespace","cdup","lastMod","date","parseMLSxDate","size","parseInt","Number","isNaN","rename","srcPath","destPath","validSrc","validDest","remove","ignoreErrorCodes","trackProgress","handler","bytesOverall","reportTo","uploadFrom","source","toRemotePath","_uploadWithCommand","appendFrom","remotePath","_uploadLocalFile","_uploadFromStream","localPath","fd","createReadStream","start","localStart","end","localEndInclusive","autoClose","ignoreError","onError","err","closeWithError","once","tracker","type","removeListener","downloadTo","destination","fromRemotePath","startAt","_downloadToFile","_downloadToStream","appendingToLocalFile","fileSystemFlags","createWriteStream","localFileStats","hasDownloadedData","shouldRemoveLocalFile","list","lastError","candidate","parsedList","_requestListWithCommand","shouldTryNext","buffer","StringWriter","text","getText","encoding","removeDir","remoteDirPath","_exitAtCurrentDirectory","clearWorkingDir","removeEmptyDir","file","isDirectory","name","uploadFromDir","localDirPath","ensureDir","_uploadToWorkingDir","files","fullPath","join","stats","isFile","_openDir","downloadToDir","_downloadFromWorkingDir","ensureLocalDirectory","startsWith","names","filter","dirName","absolutePathPrefix","endsWith","func","userDir","strategies","strategy","upload","append","download","uploadDir","downloadDir","recursive"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/Client.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Client = void 0;\nconst fs_1 = require(\"fs\");\nconst path_1 = require(\"path\");\nconst tls_1 = require(\"tls\");\nconst util_1 = require(\"util\");\nconst FtpContext_1 = require(\"./FtpContext\");\nconst parseList_1 = require(\"./parseList\");\nconst ProgressTracker_1 = require(\"./ProgressTracker\");\nconst StringWriter_1 = require(\"./StringWriter\");\nconst parseListMLSD_1 = require(\"./parseListMLSD\");\nconst netUtils_1 = require(\"./netUtils\");\nconst transfer_1 = require(\"./transfer\");\nconst parseControlResponse_1 = require(\"./parseControlResponse\");\n// Use promisify to keep the library compatible with Node 8.\nconst fsReadDir = (0, util_1.promisify)(fs_1.readdir);\nconst fsMkDir = (0, util_1.promisify)(fs_1.mkdir);\nconst fsStat = (0, util_1.promisify)(fs_1.stat);\nconst fsOpen = (0, util_1.promisify)(fs_1.open);\nconst fsClose = (0, util_1.promisify)(fs_1.close);\nconst fsUnlink = (0, util_1.promisify)(fs_1.unlink);\nconst LIST_COMMANDS_DEFAULT = [\"LIST -a\", \"LIST\"];\nconst LIST_COMMANDS_MLSD = [\"MLSD\", \"LIST -a\", \"LIST\"];\n/**\n * High-level API to interact with an FTP server.\n */\nclass Client {\n    /**\n     * Instantiate an FTP client.\n     *\n     * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.\n     */\n    constructor(timeout = 30000) {\n        this.availableListCommands = LIST_COMMANDS_DEFAULT;\n        this.ftp = new FtpContext_1.FTPContext(timeout);\n        this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);\n        this.parseList = parseList_1.parseList;\n        this._progressTracker = new ProgressTracker_1.ProgressTracker();\n    }\n    /**\n     * Close the client and all open socket connections.\n     *\n     * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,\n     * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.\n     * A client is also closed automatically if any timeout or connection error occurs.\n     */\n    close() {\n        this.ftp.close();\n        this._progressTracker.stop();\n    }\n    /**\n     * Returns true if the client is closed and can't be used anymore.\n     */\n    get closed() {\n        return this.ftp.closed;\n    }\n    /**\n     * Connect (or reconnect) to an FTP server.\n     *\n     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n     * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n     * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n     *\n     * @param host  Host the client should connect to. Optional, default is \"localhost\".\n     * @param port  Port the client should connect to. Optional, default is 21.\n     */\n    connect(host = \"localhost\", port = 21) {\n        this.ftp.reset();\n        this.ftp.socket.connect({\n            host,\n            port,\n            family: this.ftp.ipFamily\n        }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n        return this._handleConnectResponse();\n    }\n    /**\n     * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by\n     * explicit TLS. There are still FTP servers that support only implicit TLS, though.\n     */\n    connectImplicitTLS(host = \"localhost\", port = 21, tlsOptions = {}) {\n        this.ftp.reset();\n        this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n        this.ftp.tlsOptions = tlsOptions;\n        return this._handleConnectResponse();\n    }\n    /**\n     * Handles the first reponse by an FTP server after the socket connection has been established.\n     */\n    _handleConnectResponse() {\n        return this.ftp.handle(undefined, (res, task) => {\n            if (res instanceof Error) {\n                // The connection has been destroyed by the FTPContext at this point.\n                task.reject(res);\n            }\n            else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n                task.resolve(res);\n            }\n            // Reject all other codes, including 120 \"Service ready in nnn minutes\".\n            else {\n                // Don't stay connected but don't replace the socket yet by using reset()\n                // so the user can inspect properties of this instance.\n                task.reject(new FtpContext_1.FTPError(res));\n            }\n        });\n    }\n    /**\n     * Send an FTP command and handle the first response.\n     */\n    send(command, ignoreErrorCodesDEPRECATED = false) {\n        if (ignoreErrorCodesDEPRECATED) { // Deprecated starting from 3.9.0\n            this.ftp.log(\"Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).\");\n            return this.sendIgnoringError(command);\n        }\n        return this.ftp.request(command);\n    }\n    /**\n     * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.\n     *\n     * @param command\n     */\n    sendIgnoringError(command) {\n        return this.ftp.handle(command, (res, task) => {\n            if (res instanceof FtpContext_1.FTPError) {\n                task.resolve({ code: res.code, message: res.message });\n            }\n            else if (res instanceof Error) {\n                task.reject(res);\n            }\n            else {\n                task.resolve(res);\n            }\n        });\n    }\n    /**\n     * Upgrade the current socket connection to TLS.\n     *\n     * @param options  TLS options as in `tls.connect(options)`, optional.\n     * @param command  Set the authentication command. Optional, default is \"AUTH TLS\".\n     */\n    async useTLS(options = {}, command = \"AUTH TLS\") {\n        const ret = await this.send(command);\n        this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);\n        this.ftp.tlsOptions = options; // Keep the TLS options for later data connections that should use the same options.\n        this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n        return ret;\n    }\n    /**\n     * Login a user with a password.\n     *\n     * @param user  Username to use for login. Optional, default is \"anonymous\".\n     * @param password  Password to use for login. Optional, default is \"guest\".\n     */\n    login(user = \"anonymous\", password = \"guest\") {\n        this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n        return this.ftp.handle(\"USER \" + user, (res, task) => {\n            if (res instanceof Error) {\n                task.reject(res);\n            }\n            else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) { // User logged in proceed OR Command superfluous\n                task.resolve(res);\n            }\n            else if (res.code === 331) { // User name okay, need password\n                this.ftp.send(\"PASS \" + password);\n            }\n            else { // Also report error on 332 (Need account)\n                task.reject(new FtpContext_1.FTPError(res));\n            }\n        });\n    }\n    /**\n     * Set the usual default settings.\n     *\n     * Settings used:\n     * * Binary mode (TYPE I)\n     * * File structure (STRU F)\n     * * Additional settings for FTPS (PBSZ 0, PROT P)\n     */\n    async useDefaultSettings() {\n        const features = await this.features();\n        // Use MLSD directory listing if possible. See https://tools.ietf.org/html/rfc3659#section-7.8:\n        // \"The presence of the MLST feature indicates that both MLST and MLSD are supported.\"\n        const supportsMLSD = features.has(\"MLST\");\n        this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD : LIST_COMMANDS_DEFAULT;\n        await this.send(\"TYPE I\"); // Binary mode\n        await this.sendIgnoringError(\"STRU F\"); // Use file structure\n        await this.sendIgnoringError(\"OPTS UTF8 ON\"); // Some servers expect UTF-8 to be enabled explicitly and setting before login might not have worked.\n        if (supportsMLSD) {\n            await this.sendIgnoringError(\"OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;\"); // Make sure MLSD listings include all we can parse\n        }\n        if (this.ftp.hasTLS) {\n            await this.sendIgnoringError(\"PBSZ 0\"); // Set to 0 for TLS\n            await this.sendIgnoringError(\"PROT P\"); // Protect channel (also for data connections)\n        }\n    }\n    /**\n     * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.\n     *\n     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n     * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n     * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n     */\n    async access(options = {}) {\n        var _a, _b;\n        const useExplicitTLS = options.secure === true;\n        const useImplicitTLS = options.secure === \"implicit\";\n        let welcome;\n        if (useImplicitTLS) {\n            welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);\n        }\n        else {\n            welcome = await this.connect(options.host, options.port);\n        }\n        if (useExplicitTLS) {\n            // Fixes https://github.com/patrickjuchli/basic-ftp/issues/166 by making sure\n            // host is set for any future data connection as well.\n            const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};\n            secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;\n            await this.useTLS(secureOptions);\n        }\n        // Set UTF-8 on before login in case there are non-ascii characters in user or password.\n        // Note that this might not work before login depending on server.\n        await this.sendIgnoringError(\"OPTS UTF8 ON\");\n        await this.login(options.user, options.password);\n        await this.useDefaultSettings();\n        return welcome;\n    }\n    /**\n     * Get the current working directory.\n     */\n    async pwd() {\n        const res = await this.send(\"PWD\");\n        // The directory is part of the return message, for example:\n        // 257 \"/this/that\" is current directory.\n        const parsed = res.message.match(/\"(.+)\"/);\n        if (parsed === null || parsed[1] === undefined) {\n            throw new Error(`Can't parse response to command 'PWD': ${res.message}`);\n        }\n        return parsed[1];\n    }\n    /**\n     * Get a description of supported features.\n     *\n     * This sends the FEAT command and parses the result into a Map where keys correspond to available commands\n     * and values hold further information. Be aware that your FTP servers might not support this\n     * command in which case this method will not throw an exception but just return an empty Map.\n     */\n    async features() {\n        const res = await this.sendIgnoringError(\"FEAT\");\n        const features = new Map();\n        // Not supporting any special features will be reported with a single line.\n        if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {\n            // The first and last line wrap the multiline response, ignore them.\n            res.message.split(\"\\n\").slice(1, -1).forEach(line => {\n                // A typical lines looks like: \" REST STREAM\" or \" MDTM\".\n                // Servers might not use an indentation though.\n                const entry = line.trim().split(\" \");\n                features.set(entry[0], entry[1] || \"\");\n            });\n        }\n        return features;\n    }\n    /**\n     * Set the working directory.\n     */\n    async cd(path) {\n        const validPath = await this.protectWhitespace(path);\n        return this.send(\"CWD \" + validPath);\n    }\n    /**\n     * Switch to the parent directory of the working directory.\n     */\n    async cdup() {\n        return this.send(\"CDUP\");\n    }\n    /**\n     * Get the last modified time of a file. This is not supported by every FTP server, in which case\n     * calling this method will throw an exception.\n     */\n    async lastMod(path) {\n        const validPath = await this.protectWhitespace(path);\n        const res = await this.send(`MDTM ${validPath}`);\n        const date = res.message.slice(4);\n        return (0, parseListMLSD_1.parseMLSxDate)(date);\n    }\n    /**\n     * Get the size of a file.\n     */\n    async size(path) {\n        const validPath = await this.protectWhitespace(path);\n        const command = `SIZE ${validPath}`;\n        const res = await this.send(command);\n        // The size is part of the response message, for example: \"213 555555\". It's\n        // possible that there is a commmentary appended like \"213 5555, some commentary\".\n        const size = parseInt(res.message.slice(4), 10);\n        if (Number.isNaN(size)) {\n            throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);\n        }\n        return size;\n    }\n    /**\n     * Rename a file.\n     *\n     * Depending on the FTP server this might also be used to move a file from one\n     * directory to another by providing full paths.\n     */\n    async rename(srcPath, destPath) {\n        const validSrc = await this.protectWhitespace(srcPath);\n        const validDest = await this.protectWhitespace(destPath);\n        await this.send(\"RNFR \" + validSrc);\n        return this.send(\"RNTO \" + validDest);\n    }\n    /**\n     * Remove a file from the current working directory.\n     *\n     * You can ignore FTP error return codes which won't throw an exception if e.g.\n     * the file doesn't exist.\n     */\n    async remove(path, ignoreErrorCodes = false) {\n        const validPath = await this.protectWhitespace(path);\n        if (ignoreErrorCodes) {\n            return this.sendIgnoringError(`DELE ${validPath}`);\n        }\n        return this.send(`DELE ${validPath}`);\n    }\n    /**\n     * Report transfer progress for any upload or download to a given handler.\n     *\n     * This will also reset the overall transfer counter that can be used for multiple transfers. You can\n     * also call the function without a handler to stop reporting to an earlier one.\n     *\n     * @param handler  Handler function to call on transfer progress.\n     */\n    trackProgress(handler) {\n        this._progressTracker.bytesOverall = 0;\n        this._progressTracker.reportTo(handler);\n    }\n    /**\n     * Upload data from a readable stream or a local file to a remote file.\n     *\n     * @param source  Readable stream or path to a local file.\n     * @param toRemotePath  Path to a remote file to write to.\n     */\n    async uploadFrom(source, toRemotePath, options = {}) {\n        return this._uploadWithCommand(source, toRemotePath, \"STOR\", options);\n    }\n    /**\n     * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't\n     * exist the FTP server should create it.\n     *\n     * @param source  Readable stream or path to a local file.\n     * @param toRemotePath  Path to a remote file to write to.\n     */\n    async appendFrom(source, toRemotePath, options = {}) {\n        return this._uploadWithCommand(source, toRemotePath, \"APPE\", options);\n    }\n    /**\n     * @protected\n     */\n    async _uploadWithCommand(source, remotePath, command, options) {\n        if (typeof source === \"string\") {\n            return this._uploadLocalFile(source, remotePath, command, options);\n        }\n        return this._uploadFromStream(source, remotePath, command);\n    }\n    /**\n     * @protected\n     */\n    async _uploadLocalFile(localPath, remotePath, command, options) {\n        const fd = await fsOpen(localPath, \"r\");\n        const source = (0, fs_1.createReadStream)(\"\", {\n            fd,\n            start: options.localStart,\n            end: options.localEndInclusive,\n            autoClose: false\n        });\n        try {\n            return await this._uploadFromStream(source, remotePath, command);\n        }\n        finally {\n            await ignoreError(() => fsClose(fd));\n        }\n    }\n    /**\n     * @protected\n     */\n    async _uploadFromStream(source, remotePath, command) {\n        const onError = (err) => this.ftp.closeWithError(err);\n        source.once(\"error\", onError);\n        try {\n            const validPath = await this.protectWhitespace(remotePath);\n            await this.prepareTransfer(this.ftp);\n            // Keep the keyword `await` or the `finally` clause below runs too early\n            // and removes the event listener for the source stream too early.\n            return await (0, transfer_1.uploadFrom)(source, {\n                ftp: this.ftp,\n                tracker: this._progressTracker,\n                command,\n                remotePath: validPath,\n                type: \"upload\"\n            });\n        }\n        finally {\n            source.removeListener(\"error\", onError);\n        }\n    }\n    /**\n     * Download a remote file and pipe its data to a writable stream or to a local file.\n     *\n     * You can optionally define at which position of the remote file you'd like to start\n     * downloading. If the destination you provide is a file, the offset will be applied\n     * to it as well. For example: To resume a failed download, you'd request the size of\n     * the local, partially downloaded file and use that as the offset. Assuming the size\n     * is 23, you'd download the rest using `downloadTo(\"local.txt\", \"remote.txt\", 23)`.\n     *\n     * @param destination  Stream or path for a local file to write to.\n     * @param fromRemotePath  Path of the remote file to read from.\n     * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.\n     */\n    async downloadTo(destination, fromRemotePath, startAt = 0) {\n        if (typeof destination === \"string\") {\n            return this._downloadToFile(destination, fromRemotePath, startAt);\n        }\n        return this._downloadToStream(destination, fromRemotePath, startAt);\n    }\n    /**\n     * @protected\n     */\n    async _downloadToFile(localPath, remotePath, startAt) {\n        const appendingToLocalFile = startAt > 0;\n        const fileSystemFlags = appendingToLocalFile ? \"r+\" : \"w\";\n        const fd = await fsOpen(localPath, fileSystemFlags);\n        const destination = (0, fs_1.createWriteStream)(\"\", {\n            fd,\n            start: startAt,\n            autoClose: false\n        });\n        try {\n            return await this._downloadToStream(destination, remotePath, startAt);\n        }\n        catch (err) {\n            const localFileStats = await ignoreError(() => fsStat(localPath));\n            const hasDownloadedData = localFileStats && localFileStats.size > 0;\n            const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;\n            if (shouldRemoveLocalFile) {\n                await ignoreError(() => fsUnlink(localPath));\n            }\n            throw err;\n        }\n        finally {\n            await ignoreError(() => fsClose(fd));\n        }\n    }\n    /**\n     * @protected\n     */\n    async _downloadToStream(destination, remotePath, startAt) {\n        const onError = (err) => this.ftp.closeWithError(err);\n        destination.once(\"error\", onError);\n        try {\n            const validPath = await this.protectWhitespace(remotePath);\n            await this.prepareTransfer(this.ftp);\n            // Keep the keyword `await` or the `finally` clause below runs too early\n            // and removes the event listener for the source stream too early.\n            return await (0, transfer_1.downloadTo)(destination, {\n                ftp: this.ftp,\n                tracker: this._progressTracker,\n                command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,\n                remotePath: validPath,\n                type: \"download\"\n            });\n        }\n        finally {\n            destination.removeListener(\"error\", onError);\n            destination.end();\n        }\n    }\n    /**\n     * List files and directories in the current working directory, or from `path` if specified.\n     *\n     * @param [path]  Path to remote file or directory.\n     */\n    async list(path = \"\") {\n        const validPath = await this.protectWhitespace(path);\n        let lastError;\n        for (const candidate of this.availableListCommands) {\n            const command = validPath === \"\" ? candidate : `${candidate} ${validPath}`;\n            await this.prepareTransfer(this.ftp);\n            try {\n                const parsedList = await this._requestListWithCommand(command);\n                // Use successful candidate for all subsequent requests.\n                this.availableListCommands = [candidate];\n                return parsedList;\n            }\n            catch (err) {\n                const shouldTryNext = err instanceof FtpContext_1.FTPError;\n                if (!shouldTryNext) {\n                    throw err;\n                }\n                lastError = err;\n            }\n        }\n        throw lastError;\n    }\n    /**\n     * @protected\n     */\n    async _requestListWithCommand(command) {\n        const buffer = new StringWriter_1.StringWriter();\n        await (0, transfer_1.downloadTo)(buffer, {\n            ftp: this.ftp,\n            tracker: this._progressTracker,\n            command,\n            remotePath: \"\",\n            type: \"list\"\n        });\n        const text = buffer.getText(this.ftp.encoding);\n        this.ftp.log(text);\n        return this.parseList(text);\n    }\n    /**\n     * Remove a directory and all of its content.\n     *\n     * @param remoteDirPath  The path of the remote directory to delete.\n     * @example client.removeDir(\"foo\") // Remove directory 'foo' using a relative path.\n     * @example client.removeDir(\"foo/bar\") // Remove directory 'bar' using a relative path.\n     * @example client.removeDir(\"/foo/bar\") // Remove directory 'bar' using an absolute path.\n     * @example client.removeDir(\"/\") // Remove everything.\n     */\n    async removeDir(remoteDirPath) {\n        return this._exitAtCurrentDirectory(async () => {\n            await this.cd(remoteDirPath);\n            await this.clearWorkingDir();\n            if (remoteDirPath !== \"/\") {\n                await this.cdup();\n                await this.removeEmptyDir(remoteDirPath);\n            }\n        });\n    }\n    /**\n     * Remove all files and directories in the working directory without removing\n     * the working directory itself.\n     */\n    async clearWorkingDir() {\n        for (const file of await this.list()) {\n            if (file.isDirectory) {\n                await this.cd(file.name);\n                await this.clearWorkingDir();\n                await this.cdup();\n                await this.removeEmptyDir(file.name);\n            }\n            else {\n                await this.remove(file.name);\n            }\n        }\n    }\n    /**\n     * Upload the contents of a local directory to the remote working directory.\n     *\n     * This will overwrite existing files with the same names and reuse existing directories.\n     * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`\n     * to put the contents inside a directory which will be created if necessary including all\n     * intermediate directories. If you did provide a remoteDirPath the working directory will stay\n     * the same as before calling this method.\n     *\n     * @param localDirPath  Local path, e.g. \"foo/bar\" or \"../test\"\n     * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.\n     */\n    async uploadFromDir(localDirPath, remoteDirPath) {\n        return this._exitAtCurrentDirectory(async () => {\n            if (remoteDirPath) {\n                await this.ensureDir(remoteDirPath);\n            }\n            return await this._uploadToWorkingDir(localDirPath);\n        });\n    }\n    /**\n     * @protected\n     */\n    async _uploadToWorkingDir(localDirPath) {\n        const files = await fsReadDir(localDirPath);\n        for (const file of files) {\n            const fullPath = (0, path_1.join)(localDirPath, file);\n            const stats = await fsStat(fullPath);\n            if (stats.isFile()) {\n                await this.uploadFrom(fullPath, file);\n            }\n            else if (stats.isDirectory()) {\n                await this._openDir(file);\n                await this._uploadToWorkingDir(fullPath);\n                await this.cdup();\n            }\n        }\n    }\n    /**\n     * Download all files and directories of the working directory to a local directory.\n     *\n     * @param localDirPath  The local directory to download to.\n     * @param remoteDirPath  Remote directory to download. Current working directory if not specified.\n     */\n    async downloadToDir(localDirPath, remoteDirPath) {\n        return this._exitAtCurrentDirectory(async () => {\n            if (remoteDirPath) {\n                await this.cd(remoteDirPath);\n            }\n            return await this._downloadFromWorkingDir(localDirPath);\n        });\n    }\n    /**\n     * @protected\n     */\n    async _downloadFromWorkingDir(localDirPath) {\n        await ensureLocalDirectory(localDirPath);\n        for (const file of await this.list()) {\n            const localPath = (0, path_1.join)(localDirPath, file.name);\n            if (file.isDirectory) {\n                await this.cd(file.name);\n                await this._downloadFromWorkingDir(localPath);\n                await this.cdup();\n            }\n            else if (file.isFile) {\n                await this.downloadTo(localPath, file.name);\n            }\n        }\n    }\n    /**\n     * Make sure a given remote path exists, creating all directories as necessary.\n     * This function also changes the current working directory to the given path.\n     */\n    async ensureDir(remoteDirPath) {\n        // If the remoteDirPath was absolute go to root directory.\n        if (remoteDirPath.startsWith(\"/\")) {\n            await this.cd(\"/\");\n        }\n        const names = remoteDirPath.split(\"/\").filter(name => name !== \"\");\n        for (const name of names) {\n            await this._openDir(name);\n        }\n    }\n    /**\n     * Try to create a directory and enter it. This will not raise an exception if the directory\n     * couldn't be created if for example it already exists.\n     * @protected\n     */\n    async _openDir(dirName) {\n        await this.sendIgnoringError(\"MKD \" + dirName);\n        await this.cd(dirName);\n    }\n    /**\n     * Remove an empty directory, will fail if not empty.\n     */\n    async removeEmptyDir(path) {\n        const validPath = await this.protectWhitespace(path);\n        return this.send(`RMD ${validPath}`);\n    }\n    /**\n     * FTP servers can't handle filenames that have leading whitespace. This method transforms\n     * a given path to fix that issue for most cases.\n     */\n    async protectWhitespace(path) {\n        if (!path.startsWith(\" \")) {\n            return path;\n        }\n        // Handle leading whitespace by prepending the absolute path:\n        // \" test.txt\" while being in the root directory becomes \"/ test.txt\".\n        const pwd = await this.pwd();\n        const absolutePathPrefix = pwd.endsWith(\"/\") ? pwd : pwd + \"/\";\n        return absolutePathPrefix + path;\n    }\n    async _exitAtCurrentDirectory(func) {\n        const userDir = await this.pwd();\n        try {\n            return await func();\n        }\n        finally {\n            if (!this.closed) {\n                await ignoreError(() => this.cd(userDir));\n            }\n        }\n    }\n    /**\n     * Try all available transfer strategies and pick the first one that works. Update `client` to\n     * use the working strategy for all successive transfer requests.\n     *\n     * @returns a function that will try the provided strategies.\n     */\n    _enterFirstCompatibleMode(strategies) {\n        return async (ftp) => {\n            ftp.log(\"Trying to find optimal transfer strategy...\");\n            let lastError = undefined;\n            for (const strategy of strategies) {\n                try {\n                    const res = await strategy(ftp);\n                    ftp.log(\"Optimal transfer strategy found.\");\n                    this.prepareTransfer = strategy; // eslint-disable-line require-atomic-updates\n                    return res;\n                }\n                catch (err) {\n                    // Try the next candidate no matter the exact error. It's possible that a server\n                    // answered incorrectly to a strategy, for example a PASV answer to an EPSV.\n                    lastError = err;\n                }\n            }\n            throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);\n        };\n    }\n    /**\n     * DEPRECATED, use `uploadFrom`.\n     * @deprecated\n     */\n    async upload(source, toRemotePath, options = {}) {\n        this.ftp.log(\"Warning: upload() has been deprecated, use uploadFrom().\");\n        return this.uploadFrom(source, toRemotePath, options);\n    }\n    /**\n     * DEPRECATED, use `appendFrom`.\n     * @deprecated\n     */\n    async append(source, toRemotePath, options = {}) {\n        this.ftp.log(\"Warning: append() has been deprecated, use appendFrom().\");\n        return this.appendFrom(source, toRemotePath, options);\n    }\n    /**\n     * DEPRECATED, use `downloadTo`.\n     * @deprecated\n     */\n    async download(destination, fromRemotePath, startAt = 0) {\n        this.ftp.log(\"Warning: download() has been deprecated, use downloadTo().\");\n        return this.downloadTo(destination, fromRemotePath, startAt);\n    }\n    /**\n     * DEPRECATED, use `uploadFromDir`.\n     * @deprecated\n     */\n    async uploadDir(localDirPath, remoteDirPath) {\n        this.ftp.log(\"Warning: uploadDir() has been deprecated, use uploadFromDir().\");\n        return this.uploadFromDir(localDirPath, remoteDirPath);\n    }\n    /**\n     * DEPRECATED, use `downloadToDir`.\n     * @deprecated\n     */\n    async downloadDir(localDirPath) {\n        this.ftp.log(\"Warning: downloadDir() has been deprecated, use downloadToDir().\");\n        return this.downloadToDir(localDirPath);\n    }\n}\nexports.Client = Client;\nasync function ensureLocalDirectory(path) {\n    try {\n        await fsStat(path);\n    }\n    catch (err) {\n        await fsMkDir(path, { recursive: true });\n    }\n}\nasync function ignoreError(func) {\n    try {\n        return await func();\n    }\n    catch (err) {\n        // Ignore\n        return undefined;\n    }\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,MAAM,GAAG,KAAK,CAAC;AACvB,MAAMC,IAAI,GAAGC,OAAO,CAAC,IAAI,CAAC;AAC1B,MAAMC,MAAM,GAAGD,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAME,KAAK,GAAGF,OAAO,CAAC,KAAK,CAAC;AAC5B,MAAMG,MAAM,GAAGH,OAAO,CAAC,MAAM,CAAC;AAC9B,MAAMI,YAAY,GAAGJ,OAAO,CAAC,cAAc,CAAC;AAC5C,MAAMK,WAAW,GAAGL,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAMM,iBAAiB,GAAGN,OAAO,CAAC,mBAAmB,CAAC;AACtD,MAAMO,cAAc,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AAChD,MAAMQ,eAAe,GAAGR,OAAO,CAAC,iBAAiB,CAAC;AAClD,MAAMS,UAAU,GAAGT,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMU,UAAU,GAAGV,OAAO,CAAC,YAAY,CAAC;AACxC,MAAMW,sBAAsB,GAAGX,OAAO,CAAC,wBAAwB,CAAC;AAChE;AACA,MAAMY,SAAS,GAAG,CAAC,CAAC,EAAET,MAAM,CAACU,SAAS,EAAEd,IAAI,CAACe,OAAO,CAAC;AACrD,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAEZ,MAAM,CAACU,SAAS,EAAEd,IAAI,CAACiB,KAAK,CAAC;AACjD,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAEd,MAAM,CAACU,SAAS,EAAEd,IAAI,CAACmB,IAAI,CAAC;AAC/C,MAAMC,MAAM,GAAG,CAAC,CAAC,EAAEhB,MAAM,CAACU,SAAS,EAAEd,IAAI,CAACqB,IAAI,CAAC;AAC/C,MAAMC,OAAO,GAAG,CAAC,CAAC,EAAElB,MAAM,CAACU,SAAS,EAAEd,IAAI,CAACuB,KAAK,CAAC;AACjD,MAAMC,QAAQ,GAAG,CAAC,CAAC,EAAEpB,MAAM,CAACU,SAAS,EAAEd,IAAI,CAACyB,MAAM,CAAC;AACnD,MAAMC,qBAAqB,GAAG,CAAC,SAAS,EAAE,MAAM,CAAC;AACjD,MAAMC,kBAAkB,GAAG,CAAC,MAAM,EAAE,SAAS,EAAE,MAAM,CAAC;AACtD;AACA;AACA;AACA,MAAM5B,MAAM,CAAC;EACT;AACJ;AACA;AACA;AACA;EACI6B,WAAW,GAAkB;IAAA,IAAjBC,OAAO,uEAAG,KAAK;IACvB,IAAI,CAACC,qBAAqB,GAAGJ,qBAAqB;IAClD,IAAI,CAACK,GAAG,GAAG,IAAI1B,YAAY,CAAC2B,UAAU,CAACH,OAAO,CAAC;IAC/C,IAAI,CAACI,eAAe,GAAG,IAAI,CAACC,yBAAyB,CAAC,CAACvB,UAAU,CAACwB,oBAAoB,EAAExB,UAAU,CAACyB,oBAAoB,CAAC,CAAC;IACzH,IAAI,CAACC,SAAS,GAAG/B,WAAW,CAAC+B,SAAS;IACtC,IAAI,CAACC,gBAAgB,GAAG,IAAI/B,iBAAiB,CAACgC,eAAe,EAAE;EACnE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIhB,KAAK,GAAG;IACJ,IAAI,CAACQ,GAAG,CAACR,KAAK,EAAE;IAChB,IAAI,CAACe,gBAAgB,CAACE,IAAI,EAAE;EAChC;EACA;AACJ;AACA;EACI,IAAIC,MAAM,GAAG;IACT,OAAO,IAAI,CAACV,GAAG,CAACU,MAAM;EAC1B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,OAAO,GAAgC;IAAA,IAA/BC,IAAI,uEAAG,WAAW;IAAA,IAAEC,IAAI,uEAAG,EAAE;IACjC,IAAI,CAACb,GAAG,CAACc,KAAK,EAAE;IAChB,IAAI,CAACd,GAAG,CAACe,MAAM,CAACJ,OAAO,CAAC;MACpBC,IAAI;MACJC,IAAI;MACJG,MAAM,EAAE,IAAI,CAAChB,GAAG,CAACiB;IACrB,CAAC,EAAE,MAAM,IAAI,CAACjB,GAAG,CAACkB,GAAG,CAAE,gBAAe,CAAC,CAAC,EAAEvC,UAAU,CAACwC,eAAe,EAAE,IAAI,CAACnB,GAAG,CAACe,MAAM,CAAE,KAAI,CAAC,CAAC,EAAEpC,UAAU,CAACyC,WAAW,EAAE,IAAI,CAACpB,GAAG,CAACe,MAAM,CAAE,GAAE,CAAC,CAAC;IAC5I,OAAO,IAAI,CAACM,sBAAsB,EAAE;EACxC;EACA;AACJ;AACA;AACA;EACIC,kBAAkB,GAAiD;IAAA,IAAhDV,IAAI,uEAAG,WAAW;IAAA,IAAEC,IAAI,uEAAG,EAAE;IAAA,IAAEU,UAAU,uEAAG,CAAC,CAAC;IAC7D,IAAI,CAACvB,GAAG,CAACc,KAAK,EAAE;IAChB,IAAI,CAACd,GAAG,CAACe,MAAM,GAAG,CAAC,CAAC,EAAE3C,KAAK,CAACuC,OAAO,EAAEE,IAAI,EAAED,IAAI,EAAEW,UAAU,EAAE,MAAM,IAAI,CAACvB,GAAG,CAACkB,GAAG,CAAE,gBAAe,CAAC,CAAC,EAAEvC,UAAU,CAACwC,eAAe,EAAE,IAAI,CAACnB,GAAG,CAACe,MAAM,CAAE,KAAI,CAAC,CAAC,EAAEpC,UAAU,CAACyC,WAAW,EAAE,IAAI,CAACpB,GAAG,CAACe,MAAM,CAAE,GAAE,CAAC,CAAC;IACtM,IAAI,CAACf,GAAG,CAACuB,UAAU,GAAGA,UAAU;IAChC,OAAO,IAAI,CAACF,sBAAsB,EAAE;EACxC;EACA;AACJ;AACA;EACIA,sBAAsB,GAAG;IACrB,OAAO,IAAI,CAACrB,GAAG,CAACwB,MAAM,CAACC,SAAS,EAAE,CAACC,GAAG,EAAEC,IAAI,KAAK;MAC7C,IAAID,GAAG,YAAYE,KAAK,EAAE;QACtB;QACAD,IAAI,CAACE,MAAM,CAACH,GAAG,CAAC;MACpB,CAAC,MACI,IAAI,CAAC,CAAC,EAAE7C,sBAAsB,CAACiD,kBAAkB,EAAEJ,GAAG,CAACK,IAAI,CAAC,EAAE;QAC/DJ,IAAI,CAACK,OAAO,CAACN,GAAG,CAAC;MACrB;MACA;MAAA,KACK;QACD;QACA;QACAC,IAAI,CAACE,MAAM,CAAC,IAAIvD,YAAY,CAAC2D,QAAQ,CAACP,GAAG,CAAC,CAAC;MAC/C;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIQ,IAAI,CAACC,OAAO,EAAsC;IAAA,IAApCC,0BAA0B,uEAAG,KAAK;IAC5C,IAAIA,0BAA0B,EAAE;MAAE;MAC9B,IAAI,CAACpC,GAAG,CAACkB,GAAG,CAAC,+GAA+G,CAAC;MAC7H,OAAO,IAAI,CAACmB,iBAAiB,CAACF,OAAO,CAAC;IAC1C;IACA,OAAO,IAAI,CAACnC,GAAG,CAACsC,OAAO,CAACH,OAAO,CAAC;EACpC;EACA;AACJ;AACA;AACA;AACA;EACIE,iBAAiB,CAACF,OAAO,EAAE;IACvB,OAAO,IAAI,CAACnC,GAAG,CAACwB,MAAM,CAACW,OAAO,EAAE,CAACT,GAAG,EAAEC,IAAI,KAAK;MAC3C,IAAID,GAAG,YAAYpD,YAAY,CAAC2D,QAAQ,EAAE;QACtCN,IAAI,CAACK,OAAO,CAAC;UAAED,IAAI,EAAEL,GAAG,CAACK,IAAI;UAAEQ,OAAO,EAAEb,GAAG,CAACa;QAAQ,CAAC,CAAC;MAC1D,CAAC,MACI,IAAIb,GAAG,YAAYE,KAAK,EAAE;QAC3BD,IAAI,CAACE,MAAM,CAACH,GAAG,CAAC;MACpB,CAAC,MACI;QACDC,IAAI,CAACK,OAAO,CAACN,GAAG,CAAC;MACrB;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMc,MAAM,GAAqC;IAAA,IAApCC,OAAO,uEAAG,CAAC,CAAC;IAAA,IAAEN,OAAO,uEAAG,UAAU;IAC3C,MAAMO,GAAG,GAAG,MAAM,IAAI,CAACR,IAAI,CAACC,OAAO,CAAC;IACpC,IAAI,CAACnC,GAAG,CAACe,MAAM,GAAG,MAAM,CAAC,CAAC,EAAEpC,UAAU,CAACgE,aAAa,EAAE,IAAI,CAAC3C,GAAG,CAACe,MAAM,EAAE0B,OAAO,CAAC;IAC/E,IAAI,CAACzC,GAAG,CAACuB,UAAU,GAAGkB,OAAO,CAAC,CAAC;IAC/B,IAAI,CAACzC,GAAG,CAACkB,GAAG,CAAE,4BAA2B,CAAC,CAAC,EAAEvC,UAAU,CAACyC,WAAW,EAAE,IAAI,CAACpB,GAAG,CAACe,MAAM,CAAE,EAAC,CAAC;IACxF,OAAO2B,GAAG;EACd;EACA;AACJ;AACA;AACA;AACA;AACA;EACIE,KAAK,GAAyC;IAAA,IAAxCC,IAAI,uEAAG,WAAW;IAAA,IAAEC,QAAQ,uEAAG,OAAO;IACxC,IAAI,CAAC9C,GAAG,CAACkB,GAAG,CAAE,mBAAkB,CAAC,CAAC,EAAEvC,UAAU,CAACyC,WAAW,EAAE,IAAI,CAACpB,GAAG,CAACe,MAAM,CAAE,EAAC,CAAC;IAC/E,OAAO,IAAI,CAACf,GAAG,CAACwB,MAAM,CAAC,OAAO,GAAGqB,IAAI,EAAE,CAACnB,GAAG,EAAEC,IAAI,KAAK;MAClD,IAAID,GAAG,YAAYE,KAAK,EAAE;QACtBD,IAAI,CAACE,MAAM,CAACH,GAAG,CAAC;MACpB,CAAC,MACI,IAAI,CAAC,CAAC,EAAE7C,sBAAsB,CAACiD,kBAAkB,EAAEJ,GAAG,CAACK,IAAI,CAAC,EAAE;QAAE;QACjEJ,IAAI,CAACK,OAAO,CAACN,GAAG,CAAC;MACrB,CAAC,MACI,IAAIA,GAAG,CAACK,IAAI,KAAK,GAAG,EAAE;QAAE;QACzB,IAAI,CAAC/B,GAAG,CAACkC,IAAI,CAAC,OAAO,GAAGY,QAAQ,CAAC;MACrC,CAAC,MACI;QAAE;QACHnB,IAAI,CAACE,MAAM,CAAC,IAAIvD,YAAY,CAAC2D,QAAQ,CAACP,GAAG,CAAC,CAAC;MAC/C;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMqB,kBAAkB,GAAG;IACvB,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACA,QAAQ,EAAE;IACtC;IACA;IACA,MAAMC,YAAY,GAAGD,QAAQ,CAACE,GAAG,CAAC,MAAM,CAAC;IACzC,IAAI,CAACnD,qBAAqB,GAAGkD,YAAY,GAAGrD,kBAAkB,GAAGD,qBAAqB;IACtF,MAAM,IAAI,CAACuC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC3B,MAAM,IAAI,CAACG,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC;IACxC,MAAM,IAAI,CAACA,iBAAiB,CAAC,cAAc,CAAC,CAAC,CAAC;IAC9C,IAAIY,YAAY,EAAE;MACd,MAAM,IAAI,CAACZ,iBAAiB,CAAC,kGAAkG,CAAC,CAAC,CAAC;IACtI;;IACA,IAAI,IAAI,CAACrC,GAAG,CAACmD,MAAM,EAAE;MACjB,MAAM,IAAI,CAACd,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC;MACxC,MAAM,IAAI,CAACA,iBAAiB,CAAC,QAAQ,CAAC,CAAC,CAAC;IAC5C;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMe,MAAM,GAAe;IAAA,IAAdX,OAAO,uEAAG,CAAC,CAAC;IACrB,IAAIY,EAAE,EAAEC,EAAE;IACV,MAAMC,cAAc,GAAGd,OAAO,CAACe,MAAM,KAAK,IAAI;IAC9C,MAAMC,cAAc,GAAGhB,OAAO,CAACe,MAAM,KAAK,UAAU;IACpD,IAAIE,OAAO;IACX,IAAID,cAAc,EAAE;MAChBC,OAAO,GAAG,MAAM,IAAI,CAACpC,kBAAkB,CAACmB,OAAO,CAAC7B,IAAI,EAAE6B,OAAO,CAAC5B,IAAI,EAAE4B,OAAO,CAACkB,aAAa,CAAC;IAC9F,CAAC,MACI;MACDD,OAAO,GAAG,MAAM,IAAI,CAAC/C,OAAO,CAAC8B,OAAO,CAAC7B,IAAI,EAAE6B,OAAO,CAAC5B,IAAI,CAAC;IAC5D;IACA,IAAI0C,cAAc,EAAE;MAChB;MACA;MACA,MAAMI,aAAa,GAAG,CAACN,EAAE,GAAGZ,OAAO,CAACkB,aAAa,MAAM,IAAI,IAAIN,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAG,CAAC,CAAC;MACtFM,aAAa,CAAC/C,IAAI,GAAG,CAAC0C,EAAE,GAAGK,aAAa,CAAC/C,IAAI,MAAM,IAAI,IAAI0C,EAAE,KAAK,KAAK,CAAC,GAAGA,EAAE,GAAGb,OAAO,CAAC7B,IAAI;MAC5F,MAAM,IAAI,CAAC4B,MAAM,CAACmB,aAAa,CAAC;IACpC;IACA;IACA;IACA,MAAM,IAAI,CAACtB,iBAAiB,CAAC,cAAc,CAAC;IAC5C,MAAM,IAAI,CAACO,KAAK,CAACH,OAAO,CAACI,IAAI,EAAEJ,OAAO,CAACK,QAAQ,CAAC;IAChD,MAAM,IAAI,CAACC,kBAAkB,EAAE;IAC/B,OAAOW,OAAO;EAClB;EACA;AACJ;AACA;EACI,MAAME,GAAG,GAAG;IACR,MAAMlC,GAAG,GAAG,MAAM,IAAI,CAACQ,IAAI,CAAC,KAAK,CAAC;IAClC;IACA;IACA,MAAM2B,MAAM,GAAGnC,GAAG,CAACa,OAAO,CAACuB,KAAK,CAAC,QAAQ,CAAC;IAC1C,IAAID,MAAM,KAAK,IAAI,IAAIA,MAAM,CAAC,CAAC,CAAC,KAAKpC,SAAS,EAAE;MAC5C,MAAM,IAAIG,KAAK,CAAE,0CAAyCF,GAAG,CAACa,OAAQ,EAAC,CAAC;IAC5E;IACA,OAAOsB,MAAM,CAAC,CAAC,CAAC;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAMb,QAAQ,GAAG;IACb,MAAMtB,GAAG,GAAG,MAAM,IAAI,CAACW,iBAAiB,CAAC,MAAM,CAAC;IAChD,MAAMW,QAAQ,GAAG,IAAIe,GAAG,EAAE;IAC1B;IACA,IAAIrC,GAAG,CAACK,IAAI,GAAG,GAAG,IAAI,CAAC,CAAC,EAAElD,sBAAsB,CAACmF,WAAW,EAAEtC,GAAG,CAACa,OAAO,CAAC,EAAE;MACxE;MACAb,GAAG,CAACa,OAAO,CAAC0B,KAAK,CAAC,IAAI,CAAC,CAACC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,OAAO,CAACC,IAAI,IAAI;QACjD;QACA;QACA,MAAMC,KAAK,GAAGD,IAAI,CAACE,IAAI,EAAE,CAACL,KAAK,CAAC,GAAG,CAAC;QACpCjB,QAAQ,CAACuB,GAAG,CAACF,KAAK,CAAC,CAAC,CAAC,EAAEA,KAAK,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;MAC1C,CAAC,CAAC;IACN;IACA,OAAOrB,QAAQ;EACnB;EACA;AACJ;AACA;EACI,MAAMwB,EAAE,CAACC,IAAI,EAAE;IACX,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC;IACpD,OAAO,IAAI,CAACvC,IAAI,CAAC,MAAM,GAAGwC,SAAS,CAAC;EACxC;EACA;AACJ;AACA;EACI,MAAME,IAAI,GAAG;IACT,OAAO,IAAI,CAAC1C,IAAI,CAAC,MAAM,CAAC;EAC5B;EACA;AACJ;AACA;AACA;EACI,MAAM2C,OAAO,CAACJ,IAAI,EAAE;IAChB,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC;IACpD,MAAM/C,GAAG,GAAG,MAAM,IAAI,CAACQ,IAAI,CAAE,QAAOwC,SAAU,EAAC,CAAC;IAChD,MAAMI,IAAI,GAAGpD,GAAG,CAACa,OAAO,CAAC2B,KAAK,CAAC,CAAC,CAAC;IACjC,OAAO,CAAC,CAAC,EAAExF,eAAe,CAACqG,aAAa,EAAED,IAAI,CAAC;EACnD;EACA;AACJ;AACA;EACI,MAAME,IAAI,CAACP,IAAI,EAAE;IACb,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC;IACpD,MAAMtC,OAAO,GAAI,QAAOuC,SAAU,EAAC;IACnC,MAAMhD,GAAG,GAAG,MAAM,IAAI,CAACQ,IAAI,CAACC,OAAO,CAAC;IACpC;IACA;IACA,MAAM6C,IAAI,GAAGC,QAAQ,CAACvD,GAAG,CAACa,OAAO,CAAC2B,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC;IAC/C,IAAIgB,MAAM,CAACC,KAAK,CAACH,IAAI,CAAC,EAAE;MACpB,MAAM,IAAIpD,KAAK,CAAE,oCAAmCO,OAAQ,2BAA0BT,GAAG,CAACa,OAAQ,EAAC,CAAC;IACxG;IACA,OAAOyC,IAAI;EACf;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMI,MAAM,CAACC,OAAO,EAAEC,QAAQ,EAAE;IAC5B,MAAMC,QAAQ,GAAG,MAAM,IAAI,CAACZ,iBAAiB,CAACU,OAAO,CAAC;IACtD,MAAMG,SAAS,GAAG,MAAM,IAAI,CAACb,iBAAiB,CAACW,QAAQ,CAAC;IACxD,MAAM,IAAI,CAACpD,IAAI,CAAC,OAAO,GAAGqD,QAAQ,CAAC;IACnC,OAAO,IAAI,CAACrD,IAAI,CAAC,OAAO,GAAGsD,SAAS,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMC,MAAM,CAAChB,IAAI,EAA4B;IAAA,IAA1BiB,gBAAgB,uEAAG,KAAK;IACvC,MAAMhB,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC;IACpD,IAAIiB,gBAAgB,EAAE;MAClB,OAAO,IAAI,CAACrD,iBAAiB,CAAE,QAAOqC,SAAU,EAAC,CAAC;IACtD;IACA,OAAO,IAAI,CAACxC,IAAI,CAAE,QAAOwC,SAAU,EAAC,CAAC;EACzC;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACIiB,aAAa,CAACC,OAAO,EAAE;IACnB,IAAI,CAACrF,gBAAgB,CAACsF,YAAY,GAAG,CAAC;IACtC,IAAI,CAACtF,gBAAgB,CAACuF,QAAQ,CAACF,OAAO,CAAC;EAC3C;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMG,UAAU,CAACC,MAAM,EAAEC,YAAY,EAAgB;IAAA,IAAdxD,OAAO,uEAAG,CAAC,CAAC;IAC/C,OAAO,IAAI,CAACyD,kBAAkB,CAACF,MAAM,EAAEC,YAAY,EAAE,MAAM,EAAExD,OAAO,CAAC;EACzE;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,MAAM0D,UAAU,CAACH,MAAM,EAAEC,YAAY,EAAgB;IAAA,IAAdxD,OAAO,uEAAG,CAAC,CAAC;IAC/C,OAAO,IAAI,CAACyD,kBAAkB,CAACF,MAAM,EAAEC,YAAY,EAAE,MAAM,EAAExD,OAAO,CAAC;EACzE;EACA;AACJ;AACA;EACI,MAAMyD,kBAAkB,CAACF,MAAM,EAAEI,UAAU,EAAEjE,OAAO,EAAEM,OAAO,EAAE;IAC3D,IAAI,OAAOuD,MAAM,KAAK,QAAQ,EAAE;MAC5B,OAAO,IAAI,CAACK,gBAAgB,CAACL,MAAM,EAAEI,UAAU,EAAEjE,OAAO,EAAEM,OAAO,CAAC;IACtE;IACA,OAAO,IAAI,CAAC6D,iBAAiB,CAACN,MAAM,EAAEI,UAAU,EAAEjE,OAAO,CAAC;EAC9D;EACA;AACJ;AACA;EACI,MAAMkE,gBAAgB,CAACE,SAAS,EAAEH,UAAU,EAAEjE,OAAO,EAAEM,OAAO,EAAE;IAC5D,MAAM+D,EAAE,GAAG,MAAMnH,MAAM,CAACkH,SAAS,EAAE,GAAG,CAAC;IACvC,MAAMP,MAAM,GAAG,CAAC,CAAC,EAAE/H,IAAI,CAACwI,gBAAgB,EAAE,EAAE,EAAE;MAC1CD,EAAE;MACFE,KAAK,EAAEjE,OAAO,CAACkE,UAAU;MACzBC,GAAG,EAAEnE,OAAO,CAACoE,iBAAiB;MAC9BC,SAAS,EAAE;IACf,CAAC,CAAC;IACF,IAAI;MACA,OAAO,MAAM,IAAI,CAACR,iBAAiB,CAACN,MAAM,EAAEI,UAAU,EAAEjE,OAAO,CAAC;IACpE,CAAC,SACO;MACJ,MAAM4E,WAAW,CAAC,MAAMxH,OAAO,CAACiH,EAAE,CAAC,CAAC;IACxC;EACJ;EACA;AACJ;AACA;EACI,MAAMF,iBAAiB,CAACN,MAAM,EAAEI,UAAU,EAAEjE,OAAO,EAAE;IACjD,MAAM6E,OAAO,GAAIC,GAAG,IAAK,IAAI,CAACjH,GAAG,CAACkH,cAAc,CAACD,GAAG,CAAC;IACrDjB,MAAM,CAACmB,IAAI,CAAC,OAAO,EAAEH,OAAO,CAAC;IAC7B,IAAI;MACA,MAAMtC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACyB,UAAU,CAAC;MAC1D,MAAM,IAAI,CAAClG,eAAe,CAAC,IAAI,CAACF,GAAG,CAAC;MACpC;MACA;MACA,OAAO,MAAM,CAAC,CAAC,EAAEpB,UAAU,CAACmH,UAAU,EAAEC,MAAM,EAAE;QAC5ChG,GAAG,EAAE,IAAI,CAACA,GAAG;QACboH,OAAO,EAAE,IAAI,CAAC7G,gBAAgB;QAC9B4B,OAAO;QACPiE,UAAU,EAAE1B,SAAS;QACrB2C,IAAI,EAAE;MACV,CAAC,CAAC;IACN,CAAC,SACO;MACJrB,MAAM,CAACsB,cAAc,CAAC,OAAO,EAAEN,OAAO,CAAC;IAC3C;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMO,UAAU,CAACC,WAAW,EAAEC,cAAc,EAAe;IAAA,IAAbC,OAAO,uEAAG,CAAC;IACrD,IAAI,OAAOF,WAAW,KAAK,QAAQ,EAAE;MACjC,OAAO,IAAI,CAACG,eAAe,CAACH,WAAW,EAAEC,cAAc,EAAEC,OAAO,CAAC;IACrE;IACA,OAAO,IAAI,CAACE,iBAAiB,CAACJ,WAAW,EAAEC,cAAc,EAAEC,OAAO,CAAC;EACvE;EACA;AACJ;AACA;EACI,MAAMC,eAAe,CAACpB,SAAS,EAAEH,UAAU,EAAEsB,OAAO,EAAE;IAClD,MAAMG,oBAAoB,GAAGH,OAAO,GAAG,CAAC;IACxC,MAAMI,eAAe,GAAGD,oBAAoB,GAAG,IAAI,GAAG,GAAG;IACzD,MAAMrB,EAAE,GAAG,MAAMnH,MAAM,CAACkH,SAAS,EAAEuB,eAAe,CAAC;IACnD,MAAMN,WAAW,GAAG,CAAC,CAAC,EAAEvJ,IAAI,CAAC8J,iBAAiB,EAAE,EAAE,EAAE;MAChDvB,EAAE;MACFE,KAAK,EAAEgB,OAAO;MACdZ,SAAS,EAAE;IACf,CAAC,CAAC;IACF,IAAI;MACA,OAAO,MAAM,IAAI,CAACc,iBAAiB,CAACJ,WAAW,EAAEpB,UAAU,EAAEsB,OAAO,CAAC;IACzE,CAAC,CACD,OAAOT,GAAG,EAAE;MACR,MAAMe,cAAc,GAAG,MAAMjB,WAAW,CAAC,MAAM5H,MAAM,CAACoH,SAAS,CAAC,CAAC;MACjE,MAAM0B,iBAAiB,GAAGD,cAAc,IAAIA,cAAc,CAAChD,IAAI,GAAG,CAAC;MACnE,MAAMkD,qBAAqB,GAAG,CAACL,oBAAoB,IAAI,CAACI,iBAAiB;MACzE,IAAIC,qBAAqB,EAAE;QACvB,MAAMnB,WAAW,CAAC,MAAMtH,QAAQ,CAAC8G,SAAS,CAAC,CAAC;MAChD;MACA,MAAMU,GAAG;IACb,CAAC,SACO;MACJ,MAAMF,WAAW,CAAC,MAAMxH,OAAO,CAACiH,EAAE,CAAC,CAAC;IACxC;EACJ;EACA;AACJ;AACA;EACI,MAAMoB,iBAAiB,CAACJ,WAAW,EAAEpB,UAAU,EAAEsB,OAAO,EAAE;IACtD,MAAMV,OAAO,GAAIC,GAAG,IAAK,IAAI,CAACjH,GAAG,CAACkH,cAAc,CAACD,GAAG,CAAC;IACrDO,WAAW,CAACL,IAAI,CAAC,OAAO,EAAEH,OAAO,CAAC;IAClC,IAAI;MACA,MAAMtC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACyB,UAAU,CAAC;MAC1D,MAAM,IAAI,CAAClG,eAAe,CAAC,IAAI,CAACF,GAAG,CAAC;MACpC;MACA;MACA,OAAO,MAAM,CAAC,CAAC,EAAEpB,UAAU,CAAC2I,UAAU,EAAEC,WAAW,EAAE;QACjDxH,GAAG,EAAE,IAAI,CAACA,GAAG;QACboH,OAAO,EAAE,IAAI,CAAC7G,gBAAgB;QAC9B4B,OAAO,EAAEuF,OAAO,GAAG,CAAC,GAAI,QAAOA,OAAQ,EAAC,GAAI,QAAOhD,SAAU,EAAC;QAC9D0B,UAAU,EAAE1B,SAAS;QACrB2C,IAAI,EAAE;MACV,CAAC,CAAC;IACN,CAAC,SACO;MACJG,WAAW,CAACF,cAAc,CAAC,OAAO,EAAEN,OAAO,CAAC;MAC5CQ,WAAW,CAACZ,GAAG,EAAE;IACrB;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMuB,IAAI,GAAY;IAAA,IAAX1D,IAAI,uEAAG,EAAE;IAChB,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC;IACpD,IAAI2D,SAAS;IACb,KAAK,MAAMC,SAAS,IAAI,IAAI,CAACtI,qBAAqB,EAAE;MAChD,MAAMoC,OAAO,GAAGuC,SAAS,KAAK,EAAE,GAAG2D,SAAS,GAAI,GAAEA,SAAU,IAAG3D,SAAU,EAAC;MAC1E,MAAM,IAAI,CAACxE,eAAe,CAAC,IAAI,CAACF,GAAG,CAAC;MACpC,IAAI;QACA,MAAMsI,UAAU,GAAG,MAAM,IAAI,CAACC,uBAAuB,CAACpG,OAAO,CAAC;QAC9D;QACA,IAAI,CAACpC,qBAAqB,GAAG,CAACsI,SAAS,CAAC;QACxC,OAAOC,UAAU;MACrB,CAAC,CACD,OAAOrB,GAAG,EAAE;QACR,MAAMuB,aAAa,GAAGvB,GAAG,YAAY3I,YAAY,CAAC2D,QAAQ;QAC1D,IAAI,CAACuG,aAAa,EAAE;UAChB,MAAMvB,GAAG;QACb;QACAmB,SAAS,GAAGnB,GAAG;MACnB;IACJ;IACA,MAAMmB,SAAS;EACnB;EACA;AACJ;AACA;EACI,MAAMG,uBAAuB,CAACpG,OAAO,EAAE;IACnC,MAAMsG,MAAM,GAAG,IAAIhK,cAAc,CAACiK,YAAY,EAAE;IAChD,MAAM,CAAC,CAAC,EAAE9J,UAAU,CAAC2I,UAAU,EAAEkB,MAAM,EAAE;MACrCzI,GAAG,EAAE,IAAI,CAACA,GAAG;MACboH,OAAO,EAAE,IAAI,CAAC7G,gBAAgB;MAC9B4B,OAAO;MACPiE,UAAU,EAAE,EAAE;MACdiB,IAAI,EAAE;IACV,CAAC,CAAC;IACF,MAAMsB,IAAI,GAAGF,MAAM,CAACG,OAAO,CAAC,IAAI,CAAC5I,GAAG,CAAC6I,QAAQ,CAAC;IAC9C,IAAI,CAAC7I,GAAG,CAACkB,GAAG,CAACyH,IAAI,CAAC;IAClB,OAAO,IAAI,CAACrI,SAAS,CAACqI,IAAI,CAAC;EAC/B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMG,SAAS,CAACC,aAAa,EAAE;IAC3B,OAAO,IAAI,CAACC,uBAAuB,CAAC,YAAY;MAC5C,MAAM,IAAI,CAACxE,EAAE,CAACuE,aAAa,CAAC;MAC5B,MAAM,IAAI,CAACE,eAAe,EAAE;MAC5B,IAAIF,aAAa,KAAK,GAAG,EAAE;QACvB,MAAM,IAAI,CAACnE,IAAI,EAAE;QACjB,MAAM,IAAI,CAACsE,cAAc,CAACH,aAAa,CAAC;MAC5C;IACJ,CAAC,CAAC;EACN;EACA;AACJ;AACA;AACA;EACI,MAAME,eAAe,GAAG;IACpB,KAAK,MAAME,IAAI,IAAI,MAAM,IAAI,CAAChB,IAAI,EAAE,EAAE;MAClC,IAAIgB,IAAI,CAACC,WAAW,EAAE;QAClB,MAAM,IAAI,CAAC5E,EAAE,CAAC2E,IAAI,CAACE,IAAI,CAAC;QACxB,MAAM,IAAI,CAACJ,eAAe,EAAE;QAC5B,MAAM,IAAI,CAACrE,IAAI,EAAE;QACjB,MAAM,IAAI,CAACsE,cAAc,CAACC,IAAI,CAACE,IAAI,CAAC;MACxC,CAAC,MACI;QACD,MAAM,IAAI,CAAC5D,MAAM,CAAC0D,IAAI,CAACE,IAAI,CAAC;MAChC;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,aAAa,CAACC,YAAY,EAAER,aAAa,EAAE;IAC7C,OAAO,IAAI,CAACC,uBAAuB,CAAC,YAAY;MAC5C,IAAID,aAAa,EAAE;QACf,MAAM,IAAI,CAACS,SAAS,CAACT,aAAa,CAAC;MACvC;MACA,OAAO,MAAM,IAAI,CAACU,mBAAmB,CAACF,YAAY,CAAC;IACvD,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACI,MAAME,mBAAmB,CAACF,YAAY,EAAE;IACpC,MAAMG,KAAK,GAAG,MAAM5K,SAAS,CAACyK,YAAY,CAAC;IAC3C,KAAK,MAAMJ,IAAI,IAAIO,KAAK,EAAE;MACtB,MAAMC,QAAQ,GAAG,CAAC,CAAC,EAAExL,MAAM,CAACyL,IAAI,EAAEL,YAAY,EAAEJ,IAAI,CAAC;MACrD,MAAMU,KAAK,GAAG,MAAM1K,MAAM,CAACwK,QAAQ,CAAC;MACpC,IAAIE,KAAK,CAACC,MAAM,EAAE,EAAE;QAChB,MAAM,IAAI,CAAC/D,UAAU,CAAC4D,QAAQ,EAAER,IAAI,CAAC;MACzC,CAAC,MACI,IAAIU,KAAK,CAACT,WAAW,EAAE,EAAE;QAC1B,MAAM,IAAI,CAACW,QAAQ,CAACZ,IAAI,CAAC;QACzB,MAAM,IAAI,CAACM,mBAAmB,CAACE,QAAQ,CAAC;QACxC,MAAM,IAAI,CAAC/E,IAAI,EAAE;MACrB;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,MAAMoF,aAAa,CAACT,YAAY,EAAER,aAAa,EAAE;IAC7C,OAAO,IAAI,CAACC,uBAAuB,CAAC,YAAY;MAC5C,IAAID,aAAa,EAAE;QACf,MAAM,IAAI,CAACvE,EAAE,CAACuE,aAAa,CAAC;MAChC;MACA,OAAO,MAAM,IAAI,CAACkB,uBAAuB,CAACV,YAAY,CAAC;IAC3D,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACI,MAAMU,uBAAuB,CAACV,YAAY,EAAE;IACxC,MAAMW,oBAAoB,CAACX,YAAY,CAAC;IACxC,KAAK,MAAMJ,IAAI,IAAI,MAAM,IAAI,CAAChB,IAAI,EAAE,EAAE;MAClC,MAAM5B,SAAS,GAAG,CAAC,CAAC,EAAEpI,MAAM,CAACyL,IAAI,EAAEL,YAAY,EAAEJ,IAAI,CAACE,IAAI,CAAC;MAC3D,IAAIF,IAAI,CAACC,WAAW,EAAE;QAClB,MAAM,IAAI,CAAC5E,EAAE,CAAC2E,IAAI,CAACE,IAAI,CAAC;QACxB,MAAM,IAAI,CAACY,uBAAuB,CAAC1D,SAAS,CAAC;QAC7C,MAAM,IAAI,CAAC3B,IAAI,EAAE;MACrB,CAAC,MACI,IAAIuE,IAAI,CAACW,MAAM,EAAE;QAClB,MAAM,IAAI,CAACvC,UAAU,CAAChB,SAAS,EAAE4C,IAAI,CAACE,IAAI,CAAC;MAC/C;IACJ;EACJ;EACA;AACJ;AACA;AACA;EACI,MAAMG,SAAS,CAACT,aAAa,EAAE;IAC3B;IACA,IAAIA,aAAa,CAACoB,UAAU,CAAC,GAAG,CAAC,EAAE;MAC/B,MAAM,IAAI,CAAC3F,EAAE,CAAC,GAAG,CAAC;IACtB;IACA,MAAM4F,KAAK,GAAGrB,aAAa,CAAC9E,KAAK,CAAC,GAAG,CAAC,CAACoG,MAAM,CAAChB,IAAI,IAAIA,IAAI,KAAK,EAAE,CAAC;IAClE,KAAK,MAAMA,IAAI,IAAIe,KAAK,EAAE;MACtB,MAAM,IAAI,CAACL,QAAQ,CAACV,IAAI,CAAC;IAC7B;EACJ;EACA;AACJ;AACA;AACA;AACA;EACI,MAAMU,QAAQ,CAACO,OAAO,EAAE;IACpB,MAAM,IAAI,CAACjI,iBAAiB,CAAC,MAAM,GAAGiI,OAAO,CAAC;IAC9C,MAAM,IAAI,CAAC9F,EAAE,CAAC8F,OAAO,CAAC;EAC1B;EACA;AACJ;AACA;EACI,MAAMpB,cAAc,CAACzE,IAAI,EAAE;IACvB,MAAMC,SAAS,GAAG,MAAM,IAAI,CAACC,iBAAiB,CAACF,IAAI,CAAC;IACpD,OAAO,IAAI,CAACvC,IAAI,CAAE,OAAMwC,SAAU,EAAC,CAAC;EACxC;EACA;AACJ;AACA;AACA;EACI,MAAMC,iBAAiB,CAACF,IAAI,EAAE;IAC1B,IAAI,CAACA,IAAI,CAAC0F,UAAU,CAAC,GAAG,CAAC,EAAE;MACvB,OAAO1F,IAAI;IACf;IACA;IACA;IACA,MAAMb,GAAG,GAAG,MAAM,IAAI,CAACA,GAAG,EAAE;IAC5B,MAAM2G,kBAAkB,GAAG3G,GAAG,CAAC4G,QAAQ,CAAC,GAAG,CAAC,GAAG5G,GAAG,GAAGA,GAAG,GAAG,GAAG;IAC9D,OAAO2G,kBAAkB,GAAG9F,IAAI;EACpC;EACA,MAAMuE,uBAAuB,CAACyB,IAAI,EAAE;IAChC,MAAMC,OAAO,GAAG,MAAM,IAAI,CAAC9G,GAAG,EAAE;IAChC,IAAI;MACA,OAAO,MAAM6G,IAAI,EAAE;IACvB,CAAC,SACO;MACJ,IAAI,CAAC,IAAI,CAAC/J,MAAM,EAAE;QACd,MAAMqG,WAAW,CAAC,MAAM,IAAI,CAACvC,EAAE,CAACkG,OAAO,CAAC,CAAC;MAC7C;IACJ;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIvK,yBAAyB,CAACwK,UAAU,EAAE;IAClC,OAAO,MAAO3K,GAAG,IAAK;MAClBA,GAAG,CAACkB,GAAG,CAAC,6CAA6C,CAAC;MACtD,IAAIkH,SAAS,GAAG3G,SAAS;MACzB,KAAK,MAAMmJ,QAAQ,IAAID,UAAU,EAAE;QAC/B,IAAI;UACA,MAAMjJ,GAAG,GAAG,MAAMkJ,QAAQ,CAAC5K,GAAG,CAAC;UAC/BA,GAAG,CAACkB,GAAG,CAAC,kCAAkC,CAAC;UAC3C,IAAI,CAAChB,eAAe,GAAG0K,QAAQ,CAAC,CAAC;UACjC,OAAOlJ,GAAG;QACd,CAAC,CACD,OAAOuF,GAAG,EAAE;UACR;UACA;UACAmB,SAAS,GAAGnB,GAAG;QACnB;MACJ;MACA,MAAM,IAAIrF,KAAK,CAAE,4EAA2EwG,SAAU,IAAG,CAAC;IAC9G,CAAC;EACL;EACA;AACJ;AACA;AACA;EACI,MAAMyC,MAAM,CAAC7E,MAAM,EAAEC,YAAY,EAAgB;IAAA,IAAdxD,OAAO,uEAAG,CAAC,CAAC;IAC3C,IAAI,CAACzC,GAAG,CAACkB,GAAG,CAAC,0DAA0D,CAAC;IACxE,OAAO,IAAI,CAAC6E,UAAU,CAACC,MAAM,EAAEC,YAAY,EAAExD,OAAO,CAAC;EACzD;EACA;AACJ;AACA;AACA;EACI,MAAMqI,MAAM,CAAC9E,MAAM,EAAEC,YAAY,EAAgB;IAAA,IAAdxD,OAAO,uEAAG,CAAC,CAAC;IAC3C,IAAI,CAACzC,GAAG,CAACkB,GAAG,CAAC,0DAA0D,CAAC;IACxE,OAAO,IAAI,CAACiF,UAAU,CAACH,MAAM,EAAEC,YAAY,EAAExD,OAAO,CAAC;EACzD;EACA;AACJ;AACA;AACA;EACI,MAAMsI,QAAQ,CAACvD,WAAW,EAAEC,cAAc,EAAe;IAAA,IAAbC,OAAO,uEAAG,CAAC;IACnD,IAAI,CAAC1H,GAAG,CAACkB,GAAG,CAAC,4DAA4D,CAAC;IAC1E,OAAO,IAAI,CAACqG,UAAU,CAACC,WAAW,EAAEC,cAAc,EAAEC,OAAO,CAAC;EAChE;EACA;AACJ;AACA;AACA;EACI,MAAMsD,SAAS,CAACzB,YAAY,EAAER,aAAa,EAAE;IACzC,IAAI,CAAC/I,GAAG,CAACkB,GAAG,CAAC,gEAAgE,CAAC;IAC9E,OAAO,IAAI,CAACoI,aAAa,CAACC,YAAY,EAAER,aAAa,CAAC;EAC1D;EACA;AACJ;AACA;AACA;EACI,MAAMkC,WAAW,CAAC1B,YAAY,EAAE;IAC5B,IAAI,CAACvJ,GAAG,CAACkB,GAAG,CAAC,kEAAkE,CAAC;IAChF,OAAO,IAAI,CAAC8I,aAAa,CAACT,YAAY,CAAC;EAC3C;AACJ;AACAzL,OAAO,CAACE,MAAM,GAAGA,MAAM;AACvB,eAAekM,oBAAoB,CAACzF,IAAI,EAAE;EACtC,IAAI;IACA,MAAMtF,MAAM,CAACsF,IAAI,CAAC;EACtB,CAAC,CACD,OAAOwC,GAAG,EAAE;IACR,MAAMhI,OAAO,CAACwF,IAAI,EAAE;MAAEyG,SAAS,EAAE;IAAK,CAAC,CAAC;EAC5C;AACJ;AACA,eAAenE,WAAW,CAAC0D,IAAI,EAAE;EAC7B,IAAI;IACA,OAAO,MAAMA,IAAI,EAAE;EACvB,CAAC,CACD,OAAOxD,GAAG,EAAE;IACR;IACA,OAAOxF,SAAS;EACpB;AACJ"},"metadata":{},"sourceType":"script"}