{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/**\n * Helper class to track network events by request ID\n *\n * @internal\n */\nexport class NetworkEventManager {\n  /**\n   * There are four possible orders of events:\n   * A. `_onRequestWillBeSent`\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`\n   * C. `_onRequestPaused`, `_onRequestWillBeSent`\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n   * (see crbug.com/1196004)\n   *\n   * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n   * optionally the `interceptionId` from `_onRequestPaused`.\n   *\n   * If request interception is disabled, call `_onRequest` once per call to\n   * `_onRequestWillBeSent`.\n   * If request interception is enabled, call `_onRequest` once per call to\n   * `_onRequestPaused` (once per `interceptionId`).\n   *\n   * Events are stored to allow for subsequent events to call `_onRequest`.\n   *\n   * Note that (chains of) redirect requests have the same `requestId` (!) as\n   * the original request. We have to anticipate series of events like these:\n   * A. `_onRequestWillBeSent`,\n   * `_onRequestWillBeSent`, ...\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, ...\n   * C. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, ...\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n   * (see crbug.com/1196004)\n   */\n  #requestWillBeSentMap = new Map();\n  #requestPausedMap = new Map();\n  #httpRequestsMap = new Map();\n  /*\n   * The below maps are used to reconcile Network.responseReceivedExtraInfo\n   * events with their corresponding request. Each response and redirect\n   * response gets an ExtraInfo event, and we don't know which will come first.\n   * This means that we have to store a Response or an ExtraInfo for each\n   * response, and emit the event when we get both of them. In addition, to\n   * handle redirects, we have to make them Arrays to represent the chain of\n   * events.\n   */\n  #responseReceivedExtraInfoMap = new Map();\n  #queuedRedirectInfoMap = new Map();\n  #queuedEventGroupMap = new Map();\n  forget(networkRequestId) {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n    this.#requestPausedMap.delete(networkRequestId);\n    this.#queuedEventGroupMap.delete(networkRequestId);\n    this.#queuedRedirectInfoMap.delete(networkRequestId);\n    this.#responseReceivedExtraInfoMap.delete(networkRequestId);\n  }\n  responseExtraInfo(networkRequestId) {\n    if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {\n      this.#responseReceivedExtraInfoMap.set(networkRequestId, []);\n    }\n    return this.#responseReceivedExtraInfoMap.get(networkRequestId);\n  }\n  queuedRedirectInfo(fetchRequestId) {\n    if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {\n      this.#queuedRedirectInfoMap.set(fetchRequestId, []);\n    }\n    return this.#queuedRedirectInfoMap.get(fetchRequestId);\n  }\n  queueRedirectInfo(fetchRequestId, redirectInfo) {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n  takeQueuedRedirectInfo(fetchRequestId) {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n  inFlightRequestsCount() {\n    let inFlightRequestCounter = 0;\n    for (const request of this.#httpRequestsMap.values()) {\n      if (!request.response()) {\n        inFlightRequestCounter++;\n      }\n    }\n    return inFlightRequestCounter;\n  }\n  storeRequestWillBeSent(networkRequestId, event) {\n    this.#requestWillBeSentMap.set(networkRequestId, event);\n  }\n  getRequestWillBeSent(networkRequestId) {\n    return this.#requestWillBeSentMap.get(networkRequestId);\n  }\n  forgetRequestWillBeSent(networkRequestId) {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n  }\n  getRequestPaused(networkRequestId) {\n    return this.#requestPausedMap.get(networkRequestId);\n  }\n  forgetRequestPaused(networkRequestId) {\n    this.#requestPausedMap.delete(networkRequestId);\n  }\n  storeRequestPaused(networkRequestId, event) {\n    this.#requestPausedMap.set(networkRequestId, event);\n  }\n  getRequest(networkRequestId) {\n    return this.#httpRequestsMap.get(networkRequestId);\n  }\n  storeRequest(networkRequestId, request) {\n    this.#httpRequestsMap.set(networkRequestId, request);\n  }\n  forgetRequest(networkRequestId) {\n    this.#httpRequestsMap.delete(networkRequestId);\n  }\n  getQueuedEventGroup(networkRequestId) {\n    return this.#queuedEventGroupMap.get(networkRequestId);\n  }\n  queueEventGroup(networkRequestId, event) {\n    this.#queuedEventGroupMap.set(networkRequestId, event);\n  }\n  forgetQueuedEventGroup(networkRequestId) {\n    this.#queuedEventGroupMap.delete(networkRequestId);\n  }\n}","map":{"version":3,"mappings":"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","names":["NetworkEventManager","Map","forget","networkRequestId","delete","responseExtraInfo","has","set","get","queuedRedirectInfo","fetchRequestId","queueRedirectInfo","redirectInfo","push","takeQueuedRedirectInfo","shift","inFlightRequestsCount","inFlightRequestCounter","request","values","response","storeRequestWillBeSent","event","getRequestWillBeSent","forgetRequestWillBeSent","getRequestPaused","forgetRequestPaused","storeRequestPaused","getRequest","storeRequest","forgetRequest","getQueuedEventGroup","queueEventGroup","forgetQueuedEventGroup"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\NetworkEventManager.ts"],"sourcesContent":["/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CdpHTTPRequest} from './HTTPRequest.js';\n\n/**\n * @internal\n */\nexport interface QueuedEventGroup {\n  responseReceivedEvent: Protocol.Network.ResponseReceivedEvent;\n  loadingFinishedEvent?: Protocol.Network.LoadingFinishedEvent;\n  loadingFailedEvent?: Protocol.Network.LoadingFailedEvent;\n}\n\n/**\n * @internal\n */\nexport type FetchRequestId = string;\n\n/**\n * @internal\n */\nexport interface RedirectInfo {\n  event: Protocol.Network.RequestWillBeSentEvent;\n  fetchRequestId?: FetchRequestId;\n}\ntype RedirectInfoList = RedirectInfo[];\n\n/**\n * @internal\n */\nexport type NetworkRequestId = string;\n\n/**\n * Helper class to track network events by request ID\n *\n * @internal\n */\nexport class NetworkEventManager {\n  /**\n   * There are four possible orders of events:\n   * A. `_onRequestWillBeSent`\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`\n   * C. `_onRequestPaused`, `_onRequestWillBeSent`\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`\n   * (see crbug.com/1196004)\n   *\n   * For `_onRequest` we need the event from `_onRequestWillBeSent` and\n   * optionally the `interceptionId` from `_onRequestPaused`.\n   *\n   * If request interception is disabled, call `_onRequest` once per call to\n   * `_onRequestWillBeSent`.\n   * If request interception is enabled, call `_onRequest` once per call to\n   * `_onRequestPaused` (once per `interceptionId`).\n   *\n   * Events are stored to allow for subsequent events to call `_onRequest`.\n   *\n   * Note that (chains of) redirect requests have the same `requestId` (!) as\n   * the original request. We have to anticipate series of events like these:\n   * A. `_onRequestWillBeSent`,\n   * `_onRequestWillBeSent`, ...\n   * B. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, ...\n   * C. `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, ...\n   * D. `_onRequestPaused`, `_onRequestWillBeSent`,\n   * `_onRequestPaused`, `_onRequestWillBeSent`, `_onRequestPaused`,\n   * `_onRequestWillBeSent`, `_onRequestPaused`, `_onRequestPaused`, ...\n   * (see crbug.com/1196004)\n   */\n  #requestWillBeSentMap = new Map<\n    NetworkRequestId,\n    Protocol.Network.RequestWillBeSentEvent\n  >();\n  #requestPausedMap = new Map<\n    NetworkRequestId,\n    Protocol.Fetch.RequestPausedEvent\n  >();\n  #httpRequestsMap = new Map<NetworkRequestId, CdpHTTPRequest>();\n\n  /*\n   * The below maps are used to reconcile Network.responseReceivedExtraInfo\n   * events with their corresponding request. Each response and redirect\n   * response gets an ExtraInfo event, and we don't know which will come first.\n   * This means that we have to store a Response or an ExtraInfo for each\n   * response, and emit the event when we get both of them. In addition, to\n   * handle redirects, we have to make them Arrays to represent the chain of\n   * events.\n   */\n  #responseReceivedExtraInfoMap = new Map<\n    NetworkRequestId,\n    Protocol.Network.ResponseReceivedExtraInfoEvent[]\n  >();\n  #queuedRedirectInfoMap = new Map<NetworkRequestId, RedirectInfoList>();\n  #queuedEventGroupMap = new Map<NetworkRequestId, QueuedEventGroup>();\n\n  forget(networkRequestId: NetworkRequestId): void {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n    this.#requestPausedMap.delete(networkRequestId);\n    this.#queuedEventGroupMap.delete(networkRequestId);\n    this.#queuedRedirectInfoMap.delete(networkRequestId);\n    this.#responseReceivedExtraInfoMap.delete(networkRequestId);\n  }\n\n  responseExtraInfo(\n    networkRequestId: NetworkRequestId\n  ): Protocol.Network.ResponseReceivedExtraInfoEvent[] {\n    if (!this.#responseReceivedExtraInfoMap.has(networkRequestId)) {\n      this.#responseReceivedExtraInfoMap.set(networkRequestId, []);\n    }\n    return this.#responseReceivedExtraInfoMap.get(\n      networkRequestId\n    ) as Protocol.Network.ResponseReceivedExtraInfoEvent[];\n  }\n\n  private queuedRedirectInfo(fetchRequestId: FetchRequestId): RedirectInfoList {\n    if (!this.#queuedRedirectInfoMap.has(fetchRequestId)) {\n      this.#queuedRedirectInfoMap.set(fetchRequestId, []);\n    }\n    return this.#queuedRedirectInfoMap.get(fetchRequestId) as RedirectInfoList;\n  }\n\n  queueRedirectInfo(\n    fetchRequestId: FetchRequestId,\n    redirectInfo: RedirectInfo\n  ): void {\n    this.queuedRedirectInfo(fetchRequestId).push(redirectInfo);\n  }\n\n  takeQueuedRedirectInfo(\n    fetchRequestId: FetchRequestId\n  ): RedirectInfo | undefined {\n    return this.queuedRedirectInfo(fetchRequestId).shift();\n  }\n\n  inFlightRequestsCount(): number {\n    let inFlightRequestCounter = 0;\n    for (const request of this.#httpRequestsMap.values()) {\n      if (!request.response()) {\n        inFlightRequestCounter++;\n      }\n    }\n    return inFlightRequestCounter;\n  }\n\n  storeRequestWillBeSent(\n    networkRequestId: NetworkRequestId,\n    event: Protocol.Network.RequestWillBeSentEvent\n  ): void {\n    this.#requestWillBeSentMap.set(networkRequestId, event);\n  }\n\n  getRequestWillBeSent(\n    networkRequestId: NetworkRequestId\n  ): Protocol.Network.RequestWillBeSentEvent | undefined {\n    return this.#requestWillBeSentMap.get(networkRequestId);\n  }\n\n  forgetRequestWillBeSent(networkRequestId: NetworkRequestId): void {\n    this.#requestWillBeSentMap.delete(networkRequestId);\n  }\n\n  getRequestPaused(\n    networkRequestId: NetworkRequestId\n  ): Protocol.Fetch.RequestPausedEvent | undefined {\n    return this.#requestPausedMap.get(networkRequestId);\n  }\n\n  forgetRequestPaused(networkRequestId: NetworkRequestId): void {\n    this.#requestPausedMap.delete(networkRequestId);\n  }\n\n  storeRequestPaused(\n    networkRequestId: NetworkRequestId,\n    event: Protocol.Fetch.RequestPausedEvent\n  ): void {\n    this.#requestPausedMap.set(networkRequestId, event);\n  }\n\n  getRequest(networkRequestId: NetworkRequestId): CdpHTTPRequest | undefined {\n    return this.#httpRequestsMap.get(networkRequestId);\n  }\n\n  storeRequest(\n    networkRequestId: NetworkRequestId,\n    request: CdpHTTPRequest\n  ): void {\n    this.#httpRequestsMap.set(networkRequestId, request);\n  }\n\n  forgetRequest(networkRequestId: NetworkRequestId): void {\n    this.#httpRequestsMap.delete(networkRequestId);\n  }\n\n  getQueuedEventGroup(\n    networkRequestId: NetworkRequestId\n  ): QueuedEventGroup | undefined {\n    return this.#queuedEventGroupMap.get(networkRequestId);\n  }\n\n  queueEventGroup(\n    networkRequestId: NetworkRequestId,\n    event: QueuedEventGroup\n  ): void {\n    this.#queuedEventGroupMap.set(networkRequestId, event);\n  }\n\n  forgetQueuedEventGroup(networkRequestId: NetworkRequestId): void {\n    this.#queuedEventGroupMap.delete(networkRequestId);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}