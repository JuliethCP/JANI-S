{"ast":null,"code":"import { EventSubscription } from '../common/EventEmitter.js';\nimport { debugError } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { DisposableStack } from '../util/disposable.js';\n/**\n * @internal\n */\nexport class PipeTransport {\n  #pipeWrite;\n  #subscriptions = new DisposableStack();\n  #isClosed = false;\n  #pendingMessage = '';\n  onclose;\n  onmessage;\n  constructor(pipeWrite, pipeRead) {\n    this.#pipeWrite = pipeWrite;\n    this.#subscriptions.use(new EventSubscription(pipeRead, 'data', buffer => {\n      return this.#dispatch(buffer);\n    }));\n    this.#subscriptions.use(new EventSubscription(pipeRead, 'close', () => {\n      if (this.onclose) {\n        this.onclose.call(null);\n      }\n    }));\n    this.#subscriptions.use(new EventSubscription(pipeRead, 'error', debugError));\n    this.#subscriptions.use(new EventSubscription(pipeWrite, 'error', debugError));\n  }\n  send(message) {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n    this.#pipeWrite.write(message);\n    this.#pipeWrite.write('\\0');\n  }\n  #dispatch(buffer) {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this.#pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this.#pendingMessage + buffer.toString(undefined, 0, end);\n    if (this.onmessage) {\n      this.onmessage.call(null, message);\n    }\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      if (this.onmessage) {\n        this.onmessage.call(null, buffer.toString(undefined, start, end));\n      }\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this.#pendingMessage = buffer.toString(undefined, start);\n  }\n  close() {\n    this.#isClosed = true;\n    this.#subscriptions.dispose();\n  }\n}","map":{"version":3,"mappings":"AAgBA,SAAQA,iBAAiB,QAAO,2BAA2B;AAC3D,SAAQC,UAAU,QAAO,mBAAmB;AAC5C,SAAQC,MAAM,QAAO,mBAAmB;AACxC,SAAQC,eAAe,QAAO,uBAAuB;AAErD;;;AAGA,OAAM,MAAOC,aAAa;EACxB,UAAU;EACV,cAAc,GAAG,IAAID,eAAe,EAAE;EAEtC,SAAS,GAAG,KAAK;EACjB,eAAe,GAAG,EAAE;EAEpBE,OAAO;EACPC,SAAS;EAETC,YACEC,SAAgC,EAChCC,QAA+B;IAE/B,IAAI,CAAC,UAAU,GAAGD,SAAS;IAC3B,IAAI,CAAC,cAAc,CAACE,GAAG,CACrB,IAAIV,iBAAiB,CAACS,QAAQ,EAAE,MAAM,EAAGE,MAAc,IAAI;MACzD,OAAO,IAAI,CAAC,SAAS,CAACA,MAAM,CAAC;IAC/B,CAAC,CAAC,CACH;IACD,IAAI,CAAC,cAAc,CAACD,GAAG,CACrB,IAAIV,iBAAiB,CAACS,QAAQ,EAAE,OAAO,EAAE,MAAK;MAC5C,IAAI,IAAI,CAACJ,OAAO,EAAE;QAChB,IAAI,CAACA,OAAO,CAACO,IAAI,CAAC,IAAI,CAAC;;IAE3B,CAAC,CAAC,CACH;IACD,IAAI,CAAC,cAAc,CAACF,GAAG,CACrB,IAAIV,iBAAiB,CAACS,QAAQ,EAAE,OAAO,EAAER,UAAU,CAAC,CACrD;IACD,IAAI,CAAC,cAAc,CAACS,GAAG,CACrB,IAAIV,iBAAiB,CAACQ,SAAS,EAAE,OAAO,EAAEP,UAAU,CAAC,CACtD;EACH;EAEAY,IAAI,CAACC,OAAe;IAClBZ,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,4BAA4B,CAAC;IAErD,IAAI,CAAC,UAAU,CAACa,KAAK,CAACD,OAAO,CAAC;IAC9B,IAAI,CAAC,UAAU,CAACC,KAAK,CAAC,IAAI,CAAC;EAC7B;EAEA,SAAS,CAACJ,MAAc;IACtBT,MAAM,CAAC,CAAC,IAAI,CAAC,SAAS,EAAE,4BAA4B,CAAC;IAErD,IAAIc,GAAG,GAAGL,MAAM,CAACM,OAAO,CAAC,IAAI,CAAC;IAC9B,IAAID,GAAG,KAAK,CAAC,CAAC,EAAE;MACd,IAAI,CAAC,eAAe,IAAIL,MAAM,CAACO,QAAQ,EAAE;MACzC;;IAEF,MAAMJ,OAAO,GAAG,IAAI,CAAC,eAAe,GAAGH,MAAM,CAACO,QAAQ,CAACC,SAAS,EAAE,CAAC,EAAEH,GAAG,CAAC;IACzE,IAAI,IAAI,CAACV,SAAS,EAAE;MAClB,IAAI,CAACA,SAAS,CAACM,IAAI,CAAC,IAAI,EAAEE,OAAO,CAAC;;IAGpC,IAAIM,KAAK,GAAGJ,GAAG,GAAG,CAAC;IACnBA,GAAG,GAAGL,MAAM,CAACM,OAAO,CAAC,IAAI,EAAEG,KAAK,CAAC;IACjC,OAAOJ,GAAG,KAAK,CAAC,CAAC,EAAE;MACjB,IAAI,IAAI,CAACV,SAAS,EAAE;QAClB,IAAI,CAACA,SAAS,CAACM,IAAI,CAAC,IAAI,EAAED,MAAM,CAACO,QAAQ,CAACC,SAAS,EAAEC,KAAK,EAAEJ,GAAG,CAAC,CAAC;;MAEnEI,KAAK,GAAGJ,GAAG,GAAG,CAAC;MACfA,GAAG,GAAGL,MAAM,CAACM,OAAO,CAAC,IAAI,EAAEG,KAAK,CAAC;;IAEnC,IAAI,CAAC,eAAe,GAAGT,MAAM,CAACO,QAAQ,CAACC,SAAS,EAAEC,KAAK,CAAC;EAC1D;EAEAC,KAAK;IACH,IAAI,CAAC,SAAS,GAAG,IAAI;IACrB,IAAI,CAAC,cAAc,CAACC,OAAO,EAAE;EAC/B","names":["EventSubscription","debugError","assert","DisposableStack","PipeTransport","onclose","onmessage","constructor","pipeWrite","pipeRead","use","buffer","call","send","message","write","end","indexOf","toString","undefined","start","close","dispose"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\node\\PipeTransport.ts"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {ConnectionTransport} from '../common/ConnectionTransport.js';\nimport {EventSubscription} from '../common/EventEmitter.js';\nimport {debugError} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {DisposableStack} from '../util/disposable.js';\n\n/**\n * @internal\n */\nexport class PipeTransport implements ConnectionTransport {\n  #pipeWrite: NodeJS.WritableStream;\n  #subscriptions = new DisposableStack();\n\n  #isClosed = false;\n  #pendingMessage = '';\n\n  onclose?: () => void;\n  onmessage?: (value: string) => void;\n\n  constructor(\n    pipeWrite: NodeJS.WritableStream,\n    pipeRead: NodeJS.ReadableStream\n  ) {\n    this.#pipeWrite = pipeWrite;\n    this.#subscriptions.use(\n      new EventSubscription(pipeRead, 'data', (buffer: Buffer) => {\n        return this.#dispatch(buffer);\n      })\n    );\n    this.#subscriptions.use(\n      new EventSubscription(pipeRead, 'close', () => {\n        if (this.onclose) {\n          this.onclose.call(null);\n        }\n      })\n    );\n    this.#subscriptions.use(\n      new EventSubscription(pipeRead, 'error', debugError)\n    );\n    this.#subscriptions.use(\n      new EventSubscription(pipeWrite, 'error', debugError)\n    );\n  }\n\n  send(message: string): void {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n\n    this.#pipeWrite.write(message);\n    this.#pipeWrite.write('\\0');\n  }\n\n  #dispatch(buffer: Buffer): void {\n    assert(!this.#isClosed, '`PipeTransport` is closed.');\n\n    let end = buffer.indexOf('\\0');\n    if (end === -1) {\n      this.#pendingMessage += buffer.toString();\n      return;\n    }\n    const message = this.#pendingMessage + buffer.toString(undefined, 0, end);\n    if (this.onmessage) {\n      this.onmessage.call(null, message);\n    }\n\n    let start = end + 1;\n    end = buffer.indexOf('\\0', start);\n    while (end !== -1) {\n      if (this.onmessage) {\n        this.onmessage.call(null, buffer.toString(undefined, start, end));\n      }\n      start = end + 1;\n      end = buffer.indexOf('\\0', start);\n    }\n    this.#pendingMessage = buffer.toString(undefined, start);\n  }\n\n  close(): void {\n    this.#isClosed = true;\n    this.#subscriptions.dispose();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}