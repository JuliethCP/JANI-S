{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { firstValueFrom, from, raceWith } from '../../third_party/rxjs/rxjs.js';\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { Page } from '../api/Page.js';\nimport { ConsoleMessage } from '../common/ConsoleMessage.js';\nimport { TargetCloseError } from '../common/Errors.js';\nimport { FileChooser } from '../common/FileChooser.js';\nimport { NetworkManagerEvent } from '../common/NetworkManagerEvents.js';\nimport { createClientError, debugError, evaluationString, getReadableAsBuffer, getReadableFromProtocolStream, NETWORK_IDLE_TIME, pageBindingInitString, timeout, validateDialogType, valueFromRemoteObject, waitForHTTP } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { AsyncDisposableStack } from '../util/disposable.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { Accessibility } from './Accessibility.js';\nimport { Binding } from './Binding.js';\nimport { CdpCDPSession } from './CDPSession.js';\nimport { isTargetClosedError } from './Connection.js';\nimport { Coverage } from './Coverage.js';\nimport { CdpDialog } from './Dialog.js';\nimport { EmulationManager } from './EmulationManager.js';\nimport { createCdpHandle } from './ExecutionContext.js';\nimport { FirefoxTargetManager } from './FirefoxTargetManager.js';\nimport { FrameManager } from './FrameManager.js';\nimport { FrameManagerEvent } from './FrameManagerEvents.js';\nimport { CdpKeyboard, CdpMouse, CdpTouchscreen } from './Input.js';\nimport { MAIN_WORLD } from './IsolatedWorlds.js';\nimport { releaseObject } from './JSHandle.js';\nimport { Tracing } from './Tracing.js';\nimport { WebWorker } from './WebWorker.js';\n/**\n * @internal\n */\nexport class CdpPage extends Page {\n  static async _create(client, target, ignoreHTTPSErrors, defaultViewport) {\n    const page = new CdpPage(client, target, ignoreHTTPSErrors);\n    await page.#initialize();\n    if (defaultViewport) {\n      try {\n        await page.setViewport(defaultViewport);\n      } catch (err) {\n        if (isErrorLike(err) && isTargetClosedError(err)) {\n          debugError(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return page;\n  }\n  #closed = false;\n  #targetManager;\n  #primaryTargetClient;\n  #primaryTarget;\n  #tabTargetClient;\n  #tabTarget;\n  #keyboard;\n  #mouse;\n  #touchscreen;\n  #accessibility;\n  #frameManager;\n  #emulationManager;\n  #tracing;\n  #bindings = new Map();\n  #exposedFunctions = new Map();\n  #coverage;\n  #viewport;\n  #workers = new Map();\n  #fileChooserDeferreds = new Set();\n  #sessionCloseDeferred = Deferred.create();\n  #serviceWorkerBypassed = false;\n  #userDragInterceptionEnabled = false;\n  #frameManagerHandlers = [[FrameManagerEvent.FrameAttached, frame => {\n    this.emit(\"frameattached\" /* PageEvent.FrameAttached */, frame);\n  }], [FrameManagerEvent.FrameDetached, frame => {\n    this.emit(\"framedetached\" /* PageEvent.FrameDetached */, frame);\n  }], [FrameManagerEvent.FrameNavigated, frame => {\n    this.emit(\"framenavigated\" /* PageEvent.FrameNavigated */, frame);\n  }]];\n  #networkManagerHandlers = [[NetworkManagerEvent.Request, request => {\n    this.emit(\"request\" /* PageEvent.Request */, request);\n  }], [NetworkManagerEvent.RequestServedFromCache, request => {\n    this.emit(\"requestservedfromcache\" /* PageEvent.RequestServedFromCache */, request);\n  }], [NetworkManagerEvent.Response, response => {\n    this.emit(\"response\" /* PageEvent.Response */, response);\n  }], [NetworkManagerEvent.RequestFailed, request => {\n    this.emit(\"requestfailed\" /* PageEvent.RequestFailed */, request);\n  }], [NetworkManagerEvent.RequestFinished, request => {\n    this.emit(\"requestfinished\" /* PageEvent.RequestFinished */, request);\n  }]];\n  #sessionHandlers = [[CDPSessionEvent.Disconnected, () => {\n    this.#sessionCloseDeferred.reject(new TargetCloseError('Target closed'));\n  }], ['Page.domContentEventFired', () => {\n    return this.emit(\"domcontentloaded\" /* PageEvent.DOMContentLoaded */, undefined);\n  }], ['Page.loadEventFired', () => {\n    return this.emit(\"load\" /* PageEvent.Load */, undefined);\n  }], ['Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this)], ['Runtime.bindingCalled', this.#onBindingCalled.bind(this)], ['Page.javascriptDialogOpening', this.#onDialog.bind(this)], ['Runtime.exceptionThrown', this.#handleException.bind(this)], ['Inspector.targetCrashed', this.#onTargetCrashed.bind(this)], ['Performance.metrics', this.#emitMetrics.bind(this)], ['Log.entryAdded', this.#onLogEntryAdded.bind(this)], ['Page.fileChooserOpened', this.#onFileChooser.bind(this)]];\n  constructor(client, target, ignoreHTTPSErrors) {\n    super();\n    this.#primaryTargetClient = client;\n    this.#tabTargetClient = client.parentSession();\n    assert(this.#tabTargetClient, 'Tab target session is not defined.');\n    this.#tabTarget = this.#tabTargetClient._target();\n    assert(this.#tabTarget, 'Tab target is not defined.');\n    this.#primaryTarget = target;\n    this.#targetManager = target._targetManager();\n    this.#keyboard = new CdpKeyboard(client);\n    this.#mouse = new CdpMouse(client, this.#keyboard);\n    this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);\n    this.#accessibility = new Accessibility(client);\n    this.#frameManager = new FrameManager(client, this, ignoreHTTPSErrors, this._timeoutSettings);\n    this.#emulationManager = new EmulationManager(client);\n    this.#tracing = new Tracing(client);\n    this.#coverage = new Coverage(client);\n    this.#viewport = null;\n    for (const [eventName, handler] of this.#frameManagerHandlers) {\n      this.#frameManager.on(eventName, handler);\n    }\n    for (const [eventName, handler] of this.#networkManagerHandlers) {\n      // TODO: Remove any.\n      this.#frameManager.networkManager.on(eventName, handler);\n    }\n    this.#tabTargetClient.on(CDPSessionEvent.Swapped, this.#onActivation.bind(this));\n    this.#tabTargetClient.on(CDPSessionEvent.Ready, this.#onSecondaryTarget.bind(this));\n    this.#targetManager.on(\"targetGone\" /* TargetManagerEvent.TargetGone */, this.#onDetachedFromTarget);\n    this.#tabTarget._isClosedDeferred.valueOrThrow().then(() => {\n      this.#targetManager.off(\"targetGone\" /* TargetManagerEvent.TargetGone */, this.#onDetachedFromTarget);\n      this.emit(\"close\" /* PageEvent.Close */, undefined);\n      this.#closed = true;\n    }).catch(debugError);\n    this.#setupPrimaryTargetListeners();\n  }\n  async #onActivation(newSession) {\n    this.#primaryTargetClient = newSession;\n    assert(this.#primaryTargetClient instanceof CdpCDPSession, 'CDPSession is not instance of CDPSessionImpl');\n    this.#primaryTarget = this.#primaryTargetClient._target();\n    assert(this.#primaryTarget, 'Missing target on swap');\n    this.#keyboard.updateClient(newSession);\n    this.#mouse.updateClient(newSession);\n    this.#touchscreen.updateClient(newSession);\n    this.#accessibility.updateClient(newSession);\n    this.#emulationManager.updateClient(newSession);\n    this.#tracing.updateClient(newSession);\n    this.#coverage.updateClient(newSession);\n    await this.#frameManager.swapFrameTree(newSession);\n    this.#setupPrimaryTargetListeners();\n  }\n  async #onSecondaryTarget(session) {\n    assert(session instanceof CdpCDPSession);\n    if (session._target()._subtype() !== 'prerender') {\n      return;\n    }\n    this.#frameManager.registerSpeculativeSession(session).catch(debugError);\n    this.#emulationManager.registerSpeculativeSession(session).catch(debugError);\n  }\n  /**\n   * Sets up listeners for the primary target. The primary target can change\n   * during a navigation to a prerended page.\n   */\n  #setupPrimaryTargetListeners() {\n    this.#primaryTargetClient.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);\n    for (const [eventName, handler] of this.#sessionHandlers) {\n      // TODO: Remove any.\n      this.#primaryTargetClient.on(eventName, handler);\n    }\n  }\n  #onDetachedFromTarget = target => {\n    const sessionId = target._session()?.id();\n    const worker = this.#workers.get(sessionId);\n    if (!worker) {\n      return;\n    }\n    this.#workers.delete(sessionId);\n    this.emit(\"workerdestroyed\" /* PageEvent.WorkerDestroyed */, worker);\n  };\n  #onAttachedToTarget = session => {\n    assert(session instanceof CdpCDPSession);\n    this.#frameManager.onAttachedToTarget(session._target());\n    if (session._target()._getTargetInfo().type === 'worker') {\n      const worker = new WebWorker(session, session._target().url(), this.#addConsoleMessage.bind(this), this.#handleException.bind(this));\n      this.#workers.set(session.id(), worker);\n      this.emit(\"workercreated\" /* PageEvent.WorkerCreated */, worker);\n    }\n    session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);\n  };\n  async #initialize() {\n    try {\n      await Promise.all([this.#frameManager.initialize(this.#primaryTargetClient), this.#primaryTargetClient.send('Performance.enable'), this.#primaryTargetClient.send('Log.enable')]);\n    } catch (err) {\n      if (isErrorLike(err) && isTargetClosedError(err)) {\n        debugError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n  async #onFileChooser(event) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      if (!this.#fileChooserDeferreds.size) {\n        return;\n      }\n      const frame = this.#frameManager.frame(event.frameId);\n      assert(frame, 'This should never happen.');\n      // This is guaranteed to be an HTMLInputElement handle by the event.\n      const handle = __addDisposableResource(env_1, await frame.worlds[MAIN_WORLD].adoptBackendNode(event.backendNodeId), false);\n      const fileChooser = new FileChooser(handle.move(), event);\n      for (const promise of this.#fileChooserDeferreds) {\n        promise.resolve(fileChooser);\n      }\n      this.#fileChooserDeferreds.clear();\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  _client() {\n    return this.#primaryTargetClient;\n  }\n  isServiceWorkerBypassed() {\n    return this.#serviceWorkerBypassed;\n  }\n  isDragInterceptionEnabled() {\n    return this.#userDragInterceptionEnabled;\n  }\n  isJavaScriptEnabled() {\n    return this.#emulationManager.javascriptEnabled;\n  }\n  async waitForFileChooser() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const needsEnable = this.#fileChooserDeferreds.size === 0;\n    const {\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    const deferred = Deferred.create({\n      message: `Waiting for \\`FileChooser\\` failed: ${timeout}ms exceeded`,\n      timeout\n    });\n    this.#fileChooserDeferreds.add(deferred);\n    let enablePromise;\n    if (needsEnable) {\n      enablePromise = this.#primaryTargetClient.send('Page.setInterceptFileChooserDialog', {\n        enabled: true\n      });\n    }\n    try {\n      const [result] = await Promise.all([deferred.valueOrThrow(), enablePromise]);\n      return result;\n    } catch (error) {\n      this.#fileChooserDeferreds.delete(deferred);\n      throw error;\n    }\n  }\n  async setGeolocation(options) {\n    return await this.#emulationManager.setGeolocation(options);\n  }\n  target() {\n    return this.#primaryTarget;\n  }\n  browser() {\n    return this.#primaryTarget.browser();\n  }\n  browserContext() {\n    return this.#primaryTarget.browserContext();\n  }\n  #onTargetCrashed() {\n    this.emit(\"error\" /* PageEvent.Error */, new Error('Page crashed!'));\n  }\n  #onLogEntryAdded(event) {\n    const {\n      level,\n      text,\n      args,\n      source,\n      url,\n      lineNumber\n    } = event.entry;\n    if (args) {\n      args.map(arg => {\n        return releaseObject(this.#primaryTargetClient, arg);\n      });\n    }\n    if (source !== 'worker') {\n      this.emit(\"console\" /* PageEvent.Console */, new ConsoleMessage(level, text, [], [{\n        url,\n        lineNumber\n      }]));\n    }\n  }\n  mainFrame() {\n    return this.#frameManager.mainFrame();\n  }\n  get keyboard() {\n    return this.#keyboard;\n  }\n  get touchscreen() {\n    return this.#touchscreen;\n  }\n  get coverage() {\n    return this.#coverage;\n  }\n  get tracing() {\n    return this.#tracing;\n  }\n  get accessibility() {\n    return this.#accessibility;\n  }\n  frames() {\n    return this.#frameManager.frames();\n  }\n  workers() {\n    return Array.from(this.#workers.values());\n  }\n  async setRequestInterception(value) {\n    return await this.#frameManager.networkManager.setRequestInterception(value);\n  }\n  async setBypassServiceWorker(bypass) {\n    this.#serviceWorkerBypassed = bypass;\n    return await this.#primaryTargetClient.send('Network.setBypassServiceWorker', {\n      bypass\n    });\n  }\n  async setDragInterception(enabled) {\n    this.#userDragInterceptionEnabled = enabled;\n    return await this.#primaryTargetClient.send('Input.setInterceptDrags', {\n      enabled\n    });\n  }\n  async setOfflineMode(enabled) {\n    return await this.#frameManager.networkManager.setOfflineMode(enabled);\n  }\n  async emulateNetworkConditions(networkConditions) {\n    return await this.#frameManager.networkManager.emulateNetworkConditions(networkConditions);\n  }\n  setDefaultNavigationTimeout(timeout) {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n  setDefaultTimeout(timeout) {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n  getDefaultTimeout() {\n    return this._timeoutSettings.timeout();\n  }\n  async queryObjects(prototypeHandle) {\n    assert(!prototypeHandle.disposed, 'Prototype JSHandle is disposed!');\n    assert(prototypeHandle.id, 'Prototype JSHandle must not be referencing primitive value');\n    const response = await this.mainFrame().client.send('Runtime.queryObjects', {\n      prototypeObjectId: prototypeHandle.id\n    });\n    return createCdpHandle(this.mainFrame().mainRealm(), response.objects);\n  }\n  async cookies() {\n    for (var _len = arguments.length, urls = new Array(_len), _key = 0; _key < _len; _key++) {\n      urls[_key] = arguments[_key];\n    }\n    const originalCookies = (await this.#primaryTargetClient.send('Network.getCookies', {\n      urls: urls.length ? urls : [this.url()]\n    })).cookies;\n    const unsupportedCookieAttributes = ['priority'];\n    const filterUnsupportedAttributes = cookie => {\n      for (const attr of unsupportedCookieAttributes) {\n        delete cookie[attr];\n      }\n      return cookie;\n    };\n    return originalCookies.map(filterUnsupportedAttributes);\n  }\n  async deleteCookie() {\n    const pageURL = this.url();\n    for (var _len2 = arguments.length, cookies = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      cookies[_key2] = arguments[_key2];\n    }\n    for (const cookie of cookies) {\n      const item = Object.assign({}, cookie);\n      if (!cookie.url && pageURL.startsWith('http')) {\n        item.url = pageURL;\n      }\n      await this.#primaryTargetClient.send('Network.deleteCookies', item);\n    }\n  }\n  async setCookie() {\n    const pageURL = this.url();\n    const startsWithHTTP = pageURL.startsWith('http');\n    for (var _len3 = arguments.length, cookies = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      cookies[_key3] = arguments[_key3];\n    }\n    const items = cookies.map(cookie => {\n      const item = Object.assign({}, cookie);\n      if (!item.url && startsWithHTTP) {\n        item.url = pageURL;\n      }\n      assert(item.url !== 'about:blank', `Blank page can not have cookie \"${item.name}\"`);\n      assert(!String.prototype.startsWith.call(item.url || '', 'data:'), `Data URL page can not have cookie \"${item.name}\"`);\n      return item;\n    });\n    await this.deleteCookie(...items);\n    if (items.length) {\n      await this.#primaryTargetClient.send('Network.setCookies', {\n        cookies: items\n      });\n    }\n  }\n  async exposeFunction(name, pptrFunction) {\n    if (this.#bindings.has(name)) {\n      throw new Error(`Failed to add page binding with name ${name}: window['${name}'] already exists!`);\n    }\n    let binding;\n    switch (typeof pptrFunction) {\n      case 'function':\n        binding = new Binding(name, pptrFunction);\n        break;\n      default:\n        binding = new Binding(name, pptrFunction.default);\n        break;\n    }\n    this.#bindings.set(name, binding);\n    const expression = pageBindingInitString('exposedFun', name);\n    await this.#primaryTargetClient.send('Runtime.addBinding', {\n      name\n    });\n    const {\n      identifier\n    } = await this.#primaryTargetClient.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: expression\n    });\n    this.#exposedFunctions.set(name, identifier);\n    await Promise.all(this.frames().map(frame => {\n      return frame.evaluate(expression).catch(debugError);\n    }));\n  }\n  async removeExposedFunction(name) {\n    const exposedFun = this.#exposedFunctions.get(name);\n    if (!exposedFun) {\n      throw new Error(`Failed to remove page binding with name ${name}: window['${name}'] does not exists!`);\n    }\n    await this.#primaryTargetClient.send('Runtime.removeBinding', {\n      name\n    });\n    await this.removeScriptToEvaluateOnNewDocument(exposedFun);\n    await Promise.all(this.frames().map(frame => {\n      return frame.evaluate(name => {\n        // Removes the dangling Puppeteer binding wrapper.\n        // @ts-expect-error: In a different context.\n        globalThis[name] = undefined;\n      }, name).catch(debugError);\n    }));\n    this.#exposedFunctions.delete(name);\n    this.#bindings.delete(name);\n  }\n  async authenticate(credentials) {\n    return await this.#frameManager.networkManager.authenticate(credentials);\n  }\n  async setExtraHTTPHeaders(headers) {\n    return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);\n  }\n  async setUserAgent(userAgent, userAgentMetadata) {\n    return await this.#frameManager.networkManager.setUserAgent(userAgent, userAgentMetadata);\n  }\n  async metrics() {\n    const response = await this.#primaryTargetClient.send('Performance.getMetrics');\n    return this.#buildMetricsObject(response.metrics);\n  }\n  #emitMetrics(event) {\n    this.emit(\"metrics\" /* PageEvent.Metrics */, {\n      title: event.title,\n      metrics: this.#buildMetricsObject(event.metrics)\n    });\n  }\n  #buildMetricsObject(metrics) {\n    const result = {};\n    for (const metric of metrics || []) {\n      if (supportedMetrics.has(metric.name)) {\n        result[metric.name] = metric.value;\n      }\n    }\n    return result;\n  }\n  #handleException(exception) {\n    this.emit(\"pageerror\" /* PageEvent.PageError */, createClientError(exception.exceptionDetails));\n  }\n  async #onConsoleAPI(event) {\n    if (event.executionContextId === 0) {\n      // DevTools protocol stores the last 1000 console messages. These\n      // messages are always reported even for removed execution contexts. In\n      // this case, they are marked with executionContextId = 0 and are\n      // reported upon enabling Runtime agent.\n      //\n      // Ignore these messages since:\n      // - there's no execution context we can use to operate with message\n      //   arguments\n      // - these messages are reported before Puppeteer clients can subscribe\n      //   to the 'console'\n      //   page event.\n      //\n      // @see https://github.com/puppeteer/puppeteer/issues/3865\n      return;\n    }\n    const context = this.#frameManager.getExecutionContextById(event.executionContextId, this.#primaryTargetClient);\n    if (!context) {\n      debugError(new Error(`ExecutionContext not found for a console message: ${JSON.stringify(event)}`));\n      return;\n    }\n    const values = event.args.map(arg => {\n      return createCdpHandle(context._world, arg);\n    });\n    this.#addConsoleMessage(event.type, values, event.stackTrace);\n  }\n  async #onBindingCalled(event) {\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'exposedFun') {\n      return;\n    }\n    const context = this.#frameManager.executionContextById(event.executionContextId, this.#primaryTargetClient);\n    if (!context) {\n      return;\n    }\n    const binding = this.#bindings.get(name);\n    await binding?.run(context, seq, args, isTrivial);\n  }\n  #addConsoleMessage(eventType, args, stackTrace) {\n    if (!this.listenerCount(\"console\" /* PageEvent.Console */)) {\n      args.forEach(arg => {\n        return arg.dispose();\n      });\n      return;\n    }\n    const textTokens = [];\n    // eslint-disable-next-line max-len -- The comment is long.\n    // eslint-disable-next-line rulesdir/use-using -- These are not owned by this function.\n    for (const arg of args) {\n      const remoteObject = arg.remoteObject();\n      if (remoteObject.objectId) {\n        textTokens.push(arg.toString());\n      } else {\n        textTokens.push(valueFromRemoteObject(remoteObject));\n      }\n    }\n    const stackTraceLocations = [];\n    if (stackTrace) {\n      for (const callFrame of stackTrace.callFrames) {\n        stackTraceLocations.push({\n          url: callFrame.url,\n          lineNumber: callFrame.lineNumber,\n          columnNumber: callFrame.columnNumber\n        });\n      }\n    }\n    const message = new ConsoleMessage(eventType, textTokens.join(' '), args, stackTraceLocations);\n    this.emit(\"console\" /* PageEvent.Console */, message);\n  }\n  #onDialog(event) {\n    const type = validateDialogType(event.type);\n    const dialog = new CdpDialog(this.#primaryTargetClient, type, event.message, event.defaultPrompt);\n    this.emit(\"dialog\" /* PageEvent.Dialog */, dialog);\n  }\n  async reload(options) {\n    const [result] = await Promise.all([this.waitForNavigation(options), this.#primaryTargetClient.send('Page.reload')]);\n    return result;\n  }\n  async createCDPSession() {\n    return await this.target().createCDPSession();\n  }\n  async waitForRequest(urlOrPredicate) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    return await waitForHTTP(this.#frameManager.networkManager, NetworkManagerEvent.Request, urlOrPredicate, timeout, this.#sessionCloseDeferred);\n  }\n  async waitForResponse(urlOrPredicate) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      timeout = this._timeoutSettings.timeout()\n    } = options;\n    return await waitForHTTP(this.#frameManager.networkManager, NetworkManagerEvent.Response, urlOrPredicate, timeout, this.#sessionCloseDeferred);\n  }\n  async waitForNetworkIdle() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      idleTime = NETWORK_IDLE_TIME,\n      timeout: ms = this._timeoutSettings.timeout()\n    } = options;\n    await firstValueFrom(this._waitForNetworkIdle(this.#frameManager.networkManager, idleTime).pipe(raceWith(timeout(ms), from(this.#sessionCloseDeferred.valueOrThrow()))));\n  }\n  async goBack() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.#go(-1, options);\n  }\n  async goForward() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.#go(+1, options);\n  }\n  async #go(delta, options) {\n    const history = await this.#primaryTargetClient.send('Page.getNavigationHistory');\n    const entry = history.entries[history.currentIndex + delta];\n    if (!entry) {\n      return null;\n    }\n    const result = await Promise.all([this.waitForNavigation(options), this.#primaryTargetClient.send('Page.navigateToHistoryEntry', {\n      entryId: entry.id\n    })]);\n    return result[0];\n  }\n  async bringToFront() {\n    await this.#primaryTargetClient.send('Page.bringToFront');\n  }\n  async setJavaScriptEnabled(enabled) {\n    return await this.#emulationManager.setJavaScriptEnabled(enabled);\n  }\n  async setBypassCSP(enabled) {\n    await this.#primaryTargetClient.send('Page.setBypassCSP', {\n      enabled\n    });\n  }\n  async emulateMediaType(type) {\n    return await this.#emulationManager.emulateMediaType(type);\n  }\n  async emulateCPUThrottling(factor) {\n    return await this.#emulationManager.emulateCPUThrottling(factor);\n  }\n  async emulateMediaFeatures(features) {\n    return await this.#emulationManager.emulateMediaFeatures(features);\n  }\n  async emulateTimezone(timezoneId) {\n    return await this.#emulationManager.emulateTimezone(timezoneId);\n  }\n  async emulateIdleState(overrides) {\n    return await this.#emulationManager.emulateIdleState(overrides);\n  }\n  async emulateVisionDeficiency(type) {\n    return await this.#emulationManager.emulateVisionDeficiency(type);\n  }\n  async setViewport(viewport) {\n    const needsReload = await this.#emulationManager.emulateViewport(viewport);\n    this.#viewport = viewport;\n    if (needsReload) {\n      await this.reload();\n    }\n  }\n  viewport() {\n    return this.#viewport;\n  }\n  async evaluateOnNewDocument(pageFunction) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n    const source = evaluationString(pageFunction, ...args);\n    const {\n      identifier\n    } = await this.#primaryTargetClient.send('Page.addScriptToEvaluateOnNewDocument', {\n      source\n    });\n    return {\n      identifier\n    };\n  }\n  async removeScriptToEvaluateOnNewDocument(identifier) {\n    await this.#primaryTargetClient.send('Page.removeScriptToEvaluateOnNewDocument', {\n      identifier\n    });\n  }\n  async setCacheEnabled() {\n    let enabled = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    await this.#frameManager.networkManager.setCacheEnabled(enabled);\n  }\n  async _screenshot(options) {\n    const env_2 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      const {\n        fromSurface,\n        omitBackground,\n        optimizeForSpeed,\n        quality,\n        clip: userClip,\n        type,\n        captureBeyondViewport\n      } = options;\n      const isFirefox = this.target()._targetManager() instanceof FirefoxTargetManager;\n      const stack = __addDisposableResource(env_2, new AsyncDisposableStack(), true);\n      // Firefox omits background by default; it's not configurable.\n      if (!isFirefox && omitBackground && (type === 'png' || type === 'webp')) {\n        await this.#emulationManager.setTransparentBackgroundColor();\n        stack.defer(async () => {\n          await this.#emulationManager.resetDefaultBackgroundColor().catch(debugError);\n        });\n      }\n      let clip = userClip;\n      if (clip && !captureBeyondViewport) {\n        const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {\n          const {\n            height,\n            pageLeft: x,\n            pageTop: y,\n            width\n          } = window.visualViewport;\n          return {\n            x,\n            y,\n            height,\n            width\n          };\n        });\n        clip = getIntersectionRect(clip, viewport);\n      }\n      // We need to do these spreads because Firefox doesn't allow unknown options.\n      const {\n        data\n      } = await this.#primaryTargetClient.send('Page.captureScreenshot', {\n        format: type,\n        ...(optimizeForSpeed ? {\n          optimizeForSpeed\n        } : {}),\n        ...(quality !== undefined ? {\n          quality: Math.round(quality)\n        } : {}),\n        clip: clip && {\n          ...clip,\n          scale: clip.scale ?? 1\n        },\n        ...(!fromSurface ? {\n          fromSurface\n        } : {}),\n        captureBeyondViewport\n      });\n      return data;\n    } catch (e_2) {\n      env_2.error = e_2;\n      env_2.hasError = true;\n    } finally {\n      const result_1 = __disposeResources(env_2);\n      if (result_1) await result_1;\n    }\n  }\n  async createPDFStream() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      landscape,\n      displayHeaderFooter,\n      headerTemplate,\n      footerTemplate,\n      printBackground,\n      scale,\n      width: paperWidth,\n      height: paperHeight,\n      margin,\n      pageRanges,\n      preferCSSPageSize,\n      omitBackground,\n      timeout: ms,\n      tagged: generateTaggedPDF\n    } = this._getPDFOptions(options);\n    if (omitBackground) {\n      await this.#emulationManager.setTransparentBackgroundColor();\n    }\n    const printCommandPromise = this.#primaryTargetClient.send('Page.printToPDF', {\n      transferMode: 'ReturnAsStream',\n      landscape,\n      displayHeaderFooter,\n      headerTemplate,\n      footerTemplate,\n      printBackground,\n      scale,\n      paperWidth,\n      paperHeight,\n      marginTop: margin.top,\n      marginBottom: margin.bottom,\n      marginLeft: margin.left,\n      marginRight: margin.right,\n      pageRanges,\n      preferCSSPageSize,\n      generateTaggedPDF\n    });\n    const result = await firstValueFrom(from(printCommandPromise).pipe(raceWith(timeout(ms))));\n    if (omitBackground) {\n      await this.#emulationManager.resetDefaultBackgroundColor();\n    }\n    assert(result.stream, '`stream` is missing from `Page.printToPDF');\n    return await getReadableFromProtocolStream(this.#primaryTargetClient, result.stream);\n  }\n  async pdf() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      path = undefined\n    } = options;\n    const readable = await this.createPDFStream(options);\n    const buffer = await getReadableAsBuffer(readable, path);\n    assert(buffer, 'Could not create buffer');\n    return buffer;\n  }\n  async close() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      runBeforeUnload: undefined\n    };\n    const connection = this.#primaryTargetClient.connection();\n    assert(connection, 'Protocol error: Connection closed. Most likely the page has been closed.');\n    const runBeforeUnload = !!options.runBeforeUnload;\n    if (runBeforeUnload) {\n      await this.#primaryTargetClient.send('Page.close');\n    } else {\n      await connection.send('Target.closeTarget', {\n        targetId: this.#primaryTarget._targetId\n      });\n      await this.#tabTarget._isClosedDeferred.valueOrThrow();\n    }\n  }\n  isClosed() {\n    return this.#closed;\n  }\n  get mouse() {\n    return this.#mouse;\n  }\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  async waitForDevicePrompt() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return await this.mainFrame().waitForDevicePrompt(options);\n  }\n}\nconst supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\n/** @see https://w3c.github.io/webdriver-bidi/#rectangle-intersection */\nfunction getIntersectionRect(clip, viewport) {\n  // Note these will already be normalized.\n  const x = Math.max(clip.x, viewport.x);\n  const y = Math.max(clip.y, viewport.y);\n  return {\n    x,\n    y,\n    width: Math.max(Math.min(clip.x + clip.width, viewport.x + viewport.width) - x, 0),\n    height: Math.max(Math.min(clip.y + clip.height, viewport.y + viewport.height) - y, 0)\n  };\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,SAAQA,cAAc,EAAEC,IAAI,EAAEC,QAAQ,QAAO,gCAAgC;AAG7E,SAAQC,eAAe,QAAwB,sBAAsB;AAMrE,SACEC,IAAI,QASC,gBAAgB;AACvB,SACEC,cAAc,QAET,6BAA6B;AACpC,SAAQC,gBAAgB,QAAO,qBAAqB;AACpD,SAAQC,WAAW,QAAO,0BAA0B;AACpD,SAAQC,mBAAmB,QAAO,mCAAmC;AAGrE,SACEC,iBAAiB,EACjBC,UAAU,EACVC,gBAAgB,EAChBC,mBAAmB,EACnBC,6BAA6B,EAC7BC,iBAAiB,EACjBC,qBAAqB,EACrBC,OAAO,EACPC,kBAAkB,EAClBC,qBAAqB,EACrBC,WAAW,QACN,mBAAmB;AAE1B,SAAQC,MAAM,QAAO,mBAAmB;AACxC,SAAQC,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,oBAAoB,QAAO,uBAAuB;AAC1D,SAAQC,WAAW,QAAO,sBAAsB;AAEhD,SAAQC,aAAa,QAAO,oBAAoB;AAChD,SAAQC,OAAO,QAAO,cAAc;AACpC,SAAQC,aAAa,QAAO,iBAAiB;AAC7C,SAAQC,mBAAmB,QAAO,iBAAiB;AACnD,SAAQC,QAAQ,QAAO,eAAe;AAEtC,SAAQC,SAAS,QAAO,aAAa;AACrC,SAAQC,gBAAgB,QAAO,uBAAuB;AACtD,SAAQC,eAAe,QAAO,uBAAuB;AACrD,SAAQC,oBAAoB,QAAO,2BAA2B;AAE9D,SAAQC,YAAY,QAAO,mBAAmB;AAC9C,SAAQC,iBAAiB,QAAO,yBAAyB;AACzD,SAAQC,WAAW,EAAEC,QAAQ,EAAEC,cAAc,QAAO,YAAY;AAChE,SAAQC,UAAU,QAAO,qBAAqB;AAC9C,SAAQC,aAAa,QAAO,eAAe;AAK3C,SAAQC,OAAO,QAAO,cAAc;AACpC,SAAQC,SAAS,QAAO,gBAAgB;AAExC;;;AAGA,OAAM,MAAOC,OAAQ,SAAQtC,IAAI;EAC/B,aAAauC,OAAO,CAClBC,MAAkB,EAClBC,MAAiB,EACjBC,iBAA0B,EAC1BC,eAAgC;IAEhC,MAAMC,IAAI,GAAG,IAAIN,OAAO,CAACE,MAAM,EAAEC,MAAM,EAAEC,iBAAiB,CAAC;IAC3D,MAAME,IAAI,CAAC,WAAW,EAAE;IACxB,IAAID,eAAe,EAAE;MACnB,IAAI;QACF,MAAMC,IAAI,CAACC,WAAW,CAACF,eAAe,CAAC;OACxC,CAAC,OAAOG,GAAG,EAAE;QACZ,IAAI3B,WAAW,CAAC2B,GAAG,CAAC,IAAIvB,mBAAmB,CAACuB,GAAG,CAAC,EAAE;UAChDxC,UAAU,CAACwC,GAAG,CAAC;SAChB,MAAM;UACL,MAAMA,GAAG;;;;IAIf,OAAOF,IAAI;EACb;EAEA,OAAO,GAAG,KAAK;EACN,cAAc;EAEvB,oBAAoB;EACpB,cAAc;EACd,gBAAgB;EAChB,UAAU;EACV,SAAS;EACT,MAAM;EACN,YAAY;EACZ,cAAc;EACd,aAAa;EACb,iBAAiB;EACjB,QAAQ;EACR,SAAS,GAAG,IAAIG,GAAG,EAAmB;EACtC,iBAAiB,GAAG,IAAIA,GAAG,EAAkB;EAC7C,SAAS;EACT,SAAS;EACT,QAAQ,GAAG,IAAIA,GAAG,EAAqB;EACvC,qBAAqB,GAAG,IAAIC,GAAG,EAAyB;EACxD,qBAAqB,GAAG/B,QAAQ,CAACgC,MAAM,EAA2B;EAClE,sBAAsB,GAAG,KAAK;EAC9B,4BAA4B,GAAG,KAAK;EAE3B,qBAAqB,GAAG,CAC/B,CACEnB,iBAAiB,CAACoB,aAAa,EAC9BC,KAAe,IAAI;IAClB,IAAI,CAACC,IAAI,gDAA0BD,KAAK,CAAC;EAC3C,CAAC,CACF,EACD,CACErB,iBAAiB,CAACuB,aAAa,EAC9BF,KAAe,IAAI;IAClB,IAAI,CAACC,IAAI,gDAA0BD,KAAK,CAAC;EAC3C,CAAC,CACF,EACD,CACErB,iBAAiB,CAACwB,cAAc,EAC/BH,KAAe,IAAI;IAClB,IAAI,CAACC,IAAI,kDAA2BD,KAAK,CAAC;EAC5C,CAAC,CACF,CACO;EAED,uBAAuB,GAAG,CACjC,CACE/C,mBAAmB,CAACmD,OAAO,EAC1BC,OAAoB,IAAI;IACvB,IAAI,CAACJ,IAAI,oCAAoBI,OAAO,CAAC;EACvC,CAAC,CACF,EACD,CACEpD,mBAAmB,CAACqD,sBAAsB,EACzCD,OAAoB,IAAI;IACvB,IAAI,CAACJ,IAAI,kEAAmCI,OAAO,CAAC;EACtD,CAAC,CACF,EACD,CACEpD,mBAAmB,CAACsD,QAAQ,EAC3BC,QAAsB,IAAI;IACzB,IAAI,CAACP,IAAI,sCAAqBO,QAAQ,CAAC;EACzC,CAAC,CACF,EACD,CACEvD,mBAAmB,CAACwD,aAAa,EAChCJ,OAAoB,IAAI;IACvB,IAAI,CAACJ,IAAI,gDAA0BI,OAAO,CAAC;EAC7C,CAAC,CACF,EACD,CACEpD,mBAAmB,CAACyD,eAAe,EAClCL,OAAoB,IAAI;IACvB,IAAI,CAACJ,IAAI,oDAA4BI,OAAO,CAAC;EAC/C,CAAC,CACF,CACO;EAED,gBAAgB,GAAG,CAC1B,CACEzD,eAAe,CAAC+D,YAAY,EAC5B,MAAK;IACH,IAAI,CAAC,qBAAqB,CAACC,MAAM,CAC/B,IAAI7D,gBAAgB,CAAC,eAAe,CAAC,CACtC;EACH,CAAC,CACF,EACD,CACE,2BAA2B,EAC3B,MAAK;IACH,OAAO,IAAI,CAACkD,IAAI,sDAA6BY,SAAS,CAAC;EACzD,CAAC,CACF,EACD,CACE,qBAAqB,EACrB,MAAK;IACH,OAAO,IAAI,CAACZ,IAAI,8BAAiBY,SAAS,CAAC;EAC7C,CAAC,CACF,EACD,CAAC,0BAA0B,EAAE,IAAI,CAAC,aAAa,CAACC,IAAI,CAAC,IAAI,CAAC,CAAC,EAC3D,CAAC,uBAAuB,EAAE,IAAI,CAAC,gBAAgB,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,EAC3D,CAAC,8BAA8B,EAAE,IAAI,CAAC,SAAS,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,EAC3D,CAAC,yBAAyB,EAAE,IAAI,CAAC,gBAAgB,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,EAC7D,CAAC,yBAAyB,EAAE,IAAI,CAAC,gBAAgB,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,EAC7D,CAAC,qBAAqB,EAAE,IAAI,CAAC,YAAY,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,EACrD,CAAC,gBAAgB,EAAE,IAAI,CAAC,gBAAgB,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,EACpD,CAAC,wBAAwB,EAAE,IAAI,CAAC,cAAc,CAACA,IAAI,CAAC,IAAI,CAAC,CAAC,CAClD;EAEVC,YACE1B,MAAkB,EAClBC,MAAiB,EACjBC,iBAA0B;IAE1B,KAAK,EAAE;IACP,IAAI,CAAC,oBAAoB,GAAGF,MAAM;IAClC,IAAI,CAAC,gBAAgB,GAAGA,MAAM,CAAC2B,aAAa,EAAG;IAC/CnD,MAAM,CAAC,IAAI,CAAC,gBAAgB,EAAE,oCAAoC,CAAC;IACnE,IAAI,CAAC,UAAU,GAAI,IAAI,CAAC,gBAAkC,CAACoD,OAAO,EAAE;IACpEpD,MAAM,CAAC,IAAI,CAAC,UAAU,EAAE,4BAA4B,CAAC;IACrD,IAAI,CAAC,cAAc,GAAGyB,MAAM;IAC5B,IAAI,CAAC,cAAc,GAAGA,MAAM,CAAC4B,cAAc,EAAE;IAC7C,IAAI,CAAC,SAAS,GAAG,IAAItC,WAAW,CAACS,MAAM,CAAC;IACxC,IAAI,CAAC,MAAM,GAAG,IAAIR,QAAQ,CAACQ,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC;IAClD,IAAI,CAAC,YAAY,GAAG,IAAIP,cAAc,CAACO,MAAM,EAAE,IAAI,CAAC,SAAS,CAAC;IAC9D,IAAI,CAAC,cAAc,GAAG,IAAIpB,aAAa,CAACoB,MAAM,CAAC;IAC/C,IAAI,CAAC,aAAa,GAAG,IAAIX,YAAY,CACnCW,MAAM,EACN,IAAI,EACJE,iBAAiB,EACjB,IAAI,CAAC4B,gBAAgB,CACtB;IACD,IAAI,CAAC,iBAAiB,GAAG,IAAI5C,gBAAgB,CAACc,MAAM,CAAC;IACrD,IAAI,CAAC,QAAQ,GAAG,IAAIJ,OAAO,CAACI,MAAM,CAAC;IACnC,IAAI,CAAC,SAAS,GAAG,IAAIhB,QAAQ,CAACgB,MAAM,CAAC;IACrC,IAAI,CAAC,SAAS,GAAG,IAAI;IAErB,KAAK,MAAM,CAAC+B,SAAS,EAAEC,OAAO,CAAC,IAAI,IAAI,CAAC,qBAAqB,EAAE;MAC7D,IAAI,CAAC,aAAa,CAACC,EAAE,CAACF,SAAS,EAAEC,OAAO,CAAC;;IAG3C,KAAK,MAAM,CAACD,SAAS,EAAEC,OAAO,CAAC,IAAI,IAAI,CAAC,uBAAuB,EAAE;MAC/D;MACA,IAAI,CAAC,aAAa,CAACE,cAAc,CAACD,EAAE,CAACF,SAAS,EAAEC,OAAc,CAAC;;IAGjE,IAAI,CAAC,gBAAgB,CAACC,EAAE,CACtB1E,eAAe,CAAC4E,OAAO,EACvB,IAAI,CAAC,aAAa,CAACV,IAAI,CAAC,IAAI,CAAC,CAC9B;IAED,IAAI,CAAC,gBAAgB,CAACQ,EAAE,CACtB1E,eAAe,CAAC6E,KAAK,EACrB,IAAI,CAAC,kBAAkB,CAACX,IAAI,CAAC,IAAI,CAAC,CACnC;IAED,IAAI,CAAC,cAAc,CAACQ,EAAE,mDAEpB,IAAI,CAAC,qBAAqB,CAC3B;IAED,IAAI,CAAC,UAAU,CAACI,iBAAiB,CAC9BC,YAAY,EAAE,CACdC,IAAI,CAAC,MAAK;MACT,IAAI,CAAC,cAAc,CAACC,GAAG,mDAErB,IAAI,CAAC,qBAAqB,CAC3B;MAED,IAAI,CAAC5B,IAAI,gCAAkBY,SAAS,CAAC;MACrC,IAAI,CAAC,OAAO,GAAG,IAAI;IACrB,CAAC,CAAC,CACDiB,KAAK,CAAC3E,UAAU,CAAC;IAEpB,IAAI,CAAC,4BAA4B,EAAE;EACrC;EAEA,MAAM,aAAa,CAAC4E,UAAsB;IACxC,IAAI,CAAC,oBAAoB,GAAGA,UAAU;IACtClE,MAAM,CACJ,IAAI,CAAC,oBAAoB,YAAYM,aAAa,EAClD,8CAA8C,CAC/C;IACD,IAAI,CAAC,cAAc,GAAG,IAAI,CAAC,oBAAoB,CAAC8C,OAAO,EAAE;IACzDpD,MAAM,CAAC,IAAI,CAAC,cAAc,EAAE,wBAAwB,CAAC;IACrD,IAAI,CAAC,SAAS,CAACmE,YAAY,CAACD,UAAU,CAAC;IACvC,IAAI,CAAC,MAAM,CAACC,YAAY,CAACD,UAAU,CAAC;IACpC,IAAI,CAAC,YAAY,CAACC,YAAY,CAACD,UAAU,CAAC;IAC1C,IAAI,CAAC,cAAc,CAACC,YAAY,CAACD,UAAU,CAAC;IAC5C,IAAI,CAAC,iBAAiB,CAACC,YAAY,CAACD,UAAU,CAAC;IAC/C,IAAI,CAAC,QAAQ,CAACC,YAAY,CAACD,UAAU,CAAC;IACtC,IAAI,CAAC,SAAS,CAACC,YAAY,CAACD,UAAU,CAAC;IACvC,MAAM,IAAI,CAAC,aAAa,CAACE,aAAa,CAACF,UAAU,CAAC;IAClD,IAAI,CAAC,4BAA4B,EAAE;EACrC;EAEA,MAAM,kBAAkB,CAACG,OAAmB;IAC1CrE,MAAM,CAACqE,OAAO,YAAY/D,aAAa,CAAC;IACxC,IAAI+D,OAAO,CAACjB,OAAO,EAAE,CAACkB,QAAQ,EAAE,KAAK,WAAW,EAAE;MAChD;;IAEF,IAAI,CAAC,aAAa,CAACC,0BAA0B,CAACF,OAAO,CAAC,CAACJ,KAAK,CAAC3E,UAAU,CAAC;IACxE,IAAI,CAAC,iBAAiB,CACnBiF,0BAA0B,CAACF,OAAO,CAAC,CACnCJ,KAAK,CAAC3E,UAAU,CAAC;EACtB;EAEA;;;;EAIA,4BAA4B;IAC1B,IAAI,CAAC,oBAAoB,CAACmE,EAAE,CAC1B1E,eAAe,CAAC6E,KAAK,EACrB,IAAI,CAAC,mBAAmB,CACzB;IAED,KAAK,MAAM,CAACL,SAAS,EAAEC,OAAO,CAAC,IAAI,IAAI,CAAC,gBAAgB,EAAE;MACxD;MACA,IAAI,CAAC,oBAAoB,CAACC,EAAE,CAACF,SAAS,EAAEC,OAAc,CAAC;;EAE3D;EAEA,qBAAqB,GAAI/B,MAAiB,IAAI;IAC5C,MAAM+C,SAAS,GAAG/C,MAAM,CAACgD,QAAQ,EAAE,EAAEC,EAAE,EAAE;IACzC,MAAMC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAACC,GAAG,CAACJ,SAAU,CAAC;IAC5C,IAAI,CAACG,MAAM,EAAE;MACX;;IAEF,IAAI,CAAC,QAAQ,CAACE,MAAM,CAACL,SAAU,CAAC;IAChC,IAAI,CAACpC,IAAI,oDAA4BuC,MAAM,CAAC;EAC9C,CAAC;EAED,mBAAmB,GAAIN,OAAmB,IAAI;IAC5CrE,MAAM,CAACqE,OAAO,YAAY/D,aAAa,CAAC;IACxC,IAAI,CAAC,aAAa,CAACwE,kBAAkB,CAACT,OAAO,CAACjB,OAAO,EAAE,CAAC;IACxD,IAAIiB,OAAO,CAACjB,OAAO,EAAE,CAAC2B,cAAc,EAAE,CAACC,IAAI,KAAK,QAAQ,EAAE;MACxD,MAAML,MAAM,GAAG,IAAItD,SAAS,CAC1BgD,OAAO,EACPA,OAAO,CAACjB,OAAO,EAAE,CAAC6B,GAAG,EAAE,EACvB,IAAI,CAAC,kBAAkB,CAAChC,IAAI,CAAC,IAAI,CAAC,EAClC,IAAI,CAAC,gBAAgB,CAACA,IAAI,CAAC,IAAI,CAAC,CACjC;MACD,IAAI,CAAC,QAAQ,CAACiC,GAAG,CAACb,OAAO,CAACK,EAAE,EAAE,EAAEC,MAAM,CAAC;MACvC,IAAI,CAACvC,IAAI,gDAA0BuC,MAAM,CAAC;;IAE5CN,OAAO,CAACZ,EAAE,CAAC1E,eAAe,CAAC6E,KAAK,EAAE,IAAI,CAAC,mBAAmB,CAAC;EAC7D,CAAC;EAED,MAAM,WAAW;IACf,IAAI;MACF,MAAMuB,OAAO,CAACC,GAAG,CAAC,CAChB,IAAI,CAAC,aAAa,CAACC,UAAU,CAAC,IAAI,CAAC,oBAAoB,CAAC,EACxD,IAAI,CAAC,oBAAoB,CAACC,IAAI,CAAC,oBAAoB,CAAC,EACpD,IAAI,CAAC,oBAAoB,CAACA,IAAI,CAAC,YAAY,CAAC,CAC7C,CAAC;KACH,CAAC,OAAOxD,GAAG,EAAE;MACZ,IAAI3B,WAAW,CAAC2B,GAAG,CAAC,IAAIvB,mBAAmB,CAACuB,GAAG,CAAC,EAAE;QAChDxC,UAAU,CAACwC,GAAG,CAAC;OAChB,MAAM;QACL,MAAMA,GAAG;;;EAGf;EAEA,MAAM,cAAc,CAClByD,KAA2C;;;;;;;MAE3C,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAACC,IAAI,EAAE;QACpC;;MAGF,MAAMrD,KAAK,GAAG,IAAI,CAAC,aAAa,CAACA,KAAK,CAACoD,KAAK,CAACE,OAAO,CAAC;MACrDzF,MAAM,CAACmC,KAAK,EAAE,2BAA2B,CAAC;MAE1C;MACA,MAAMuD,MAAM,kCAAI,MAAMvD,KAAK,CAACwD,MAAM,CAACzE,UAAU,CAAC,CAAC0E,gBAAgB,CAC7DL,KAAK,CAACM,aAAa,CACpB,EAAoC;MAErC,MAAMC,WAAW,GAAG,IAAI3G,WAAW,CAACuG,MAAM,CAACK,IAAI,EAAE,EAAER,KAAK,CAAC;MACzD,KAAK,MAAMS,OAAO,IAAI,IAAI,CAAC,qBAAqB,EAAE;QAChDA,OAAO,CAACC,OAAO,CAACH,WAAW,CAAC;;MAE9B,IAAI,CAAC,qBAAqB,CAACI,KAAK,EAAE;;;;;;;;EAGpCC,OAAO;IACL,OAAO,IAAI,CAAC,oBAAoB;EAClC;EAESC,uBAAuB;IAC9B,OAAO,IAAI,CAAC,sBAAsB;EACpC;EAESC,yBAAyB;IAChC,OAAO,IAAI,CAAC,4BAA4B;EAC1C;EAESC,mBAAmB;IAC1B,OAAO,IAAI,CAAC,iBAAiB,CAACC,iBAAiB;EACjD;EAES,MAAMC,kBAAkB,GACC;IAAA,IAAhCC,8EAA8B,EAAE;IAEhC,MAAMC,WAAW,GAAG,IAAI,CAAC,qBAAqB,CAAClB,IAAI,KAAK,CAAC;IACzD,MAAM;MAAC5F,OAAO,GAAG,IAAI,CAAC0D,gBAAgB,CAAC1D,OAAO;IAAE,CAAC,GAAG6G,OAAO;IAC3D,MAAME,QAAQ,GAAG1G,QAAQ,CAACgC,MAAM,CAAc;MAC5C2E,OAAO,EAAE,uCAAuChH,OAAO,aAAa;MACpEA;KACD,CAAC;IACF,IAAI,CAAC,qBAAqB,CAACiH,GAAG,CAACF,QAAQ,CAAC;IACxC,IAAIG,aAAwC;IAC5C,IAAIJ,WAAW,EAAE;MACfI,aAAa,GAAG,IAAI,CAAC,oBAAoB,CAACxB,IAAI,CAC5C,oCAAoC,EACpC;QACEyB,OAAO,EAAE;OACV,CACF;;IAEH,IAAI;MACF,MAAM,CAACC,MAAM,CAAC,GAAG,MAAM7B,OAAO,CAACC,GAAG,CAAC,CACjCuB,QAAQ,CAAC7C,YAAY,EAAE,EACvBgD,aAAa,CACd,CAAC;MACF,OAAOE,MAAM;KACd,CAAC,OAAOC,KAAK,EAAE;MACd,IAAI,CAAC,qBAAqB,CAACpC,MAAM,CAAC8B,QAAQ,CAAC;MAC3C,MAAMM,KAAK;;EAEf;EAES,MAAMC,cAAc,CAACT,OAA2B;IACvD,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACS,cAAc,CAACT,OAAO,CAAC;EAC7D;EAEShF,MAAM;IACb,OAAO,IAAI,CAAC,cAAc;EAC5B;EAES0F,OAAO;IACd,OAAO,IAAI,CAAC,cAAc,CAACA,OAAO,EAAE;EACtC;EAESC,cAAc;IACrB,OAAO,IAAI,CAAC,cAAc,CAACA,cAAc,EAAE;EAC7C;EAEA,gBAAgB;IACd,IAAI,CAAChF,IAAI,gCAAkB,IAAIiF,KAAK,CAAC,eAAe,CAAC,CAAC;EACxD;EAEA,gBAAgB,CAAC9B,KAAmC;IAClD,MAAM;MAAC+B,KAAK;MAAEC,IAAI;MAAEC,IAAI;MAAEC,MAAM;MAAExC,GAAG;MAAEyC;IAAU,CAAC,GAAGnC,KAAK,CAACoC,KAAK;IAChE,IAAIH,IAAI,EAAE;MACRA,IAAI,CAACI,GAAG,CAACC,GAAG,IAAG;QACb,OAAO1G,aAAa,CAAC,IAAI,CAAC,oBAAoB,EAAE0G,GAAG,CAAC;MACtD,CAAC,CAAC;;IAEJ,IAAIJ,MAAM,KAAK,QAAQ,EAAE;MACvB,IAAI,CAACrF,IAAI,oCAEP,IAAInD,cAAc,CAACqI,KAAK,EAAEC,IAAI,EAAE,EAAE,EAAE,CAAC;QAACtC,GAAG;QAAEyC;MAAU,CAAC,CAAC,CAAC,CACzD;;EAEL;EAESI,SAAS;IAChB,OAAO,IAAI,CAAC,aAAa,CAACA,SAAS,EAAE;EACvC;EAEA,IAAaC,QAAQ;IACnB,OAAO,IAAI,CAAC,SAAS;EACvB;EAEA,IAAaC,WAAW;IACtB,OAAO,IAAI,CAAC,YAAY;EAC1B;EAEA,IAAaC,QAAQ;IACnB,OAAO,IAAI,CAAC,SAAS;EACvB;EAEA,IAAaC,OAAO;IAClB,OAAO,IAAI,CAAC,QAAQ;EACtB;EAEA,IAAaC,aAAa;IACxB,OAAO,IAAI,CAAC,cAAc;EAC5B;EAESC,MAAM;IACb,OAAO,IAAI,CAAC,aAAa,CAACA,MAAM,EAAE;EACpC;EAESC,OAAO;IACd,OAAOC,KAAK,CAACzJ,IAAI,CAAC,IAAI,CAAC,QAAQ,CAAC0J,MAAM,EAAE,CAAC;EAC3C;EAES,MAAMC,sBAAsB,CAACC,KAAc;IAClD,OAAO,MAAM,IAAI,CAAC,aAAa,CAAC/E,cAAc,CAAC8E,sBAAsB,CACnEC,KAAK,CACN;EACH;EAES,MAAMC,sBAAsB,CAACC,MAAe;IACnD,IAAI,CAAC,sBAAsB,GAAGA,MAAM;IACpC,OAAO,MAAM,IAAI,CAAC,oBAAoB,CAACrD,IAAI,CACzC,gCAAgC,EAChC;MAACqD;IAAM,CAAC,CACT;EACH;EAES,MAAMC,mBAAmB,CAAC7B,OAAgB;IACjD,IAAI,CAAC,4BAA4B,GAAGA,OAAO;IAC3C,OAAO,MAAM,IAAI,CAAC,oBAAoB,CAACzB,IAAI,CAAC,yBAAyB,EAAE;MACrEyB;KACD,CAAC;EACJ;EAES,MAAM8B,cAAc,CAAC9B,OAAgB;IAC5C,OAAO,MAAM,IAAI,CAAC,aAAa,CAACrD,cAAc,CAACmF,cAAc,CAAC9B,OAAO,CAAC;EACxE;EAES,MAAM+B,wBAAwB,CACrCC,iBAA2C;IAE3C,OAAO,MAAM,IAAI,CAAC,aAAa,CAACrF,cAAc,CAACoF,wBAAwB,CACrEC,iBAAiB,CAClB;EACH;EAESC,2BAA2B,CAACpJ,OAAe;IAClD,IAAI,CAAC0D,gBAAgB,CAAC0F,2BAA2B,CAACpJ,OAAO,CAAC;EAC5D;EAESqJ,iBAAiB,CAACrJ,OAAe;IACxC,IAAI,CAAC0D,gBAAgB,CAAC2F,iBAAiB,CAACrJ,OAAO,CAAC;EAClD;EAESsJ,iBAAiB;IACxB,OAAO,IAAI,CAAC5F,gBAAgB,CAAC1D,OAAO,EAAE;EACxC;EAES,MAAMuJ,YAAY,CACzBC,eAAoC;IAEpCpJ,MAAM,CAAC,CAACoJ,eAAe,CAACC,QAAQ,EAAE,iCAAiC,CAAC;IACpErJ,MAAM,CACJoJ,eAAe,CAAC1E,EAAE,EAClB,4DAA4D,CAC7D;IACD,MAAM/B,QAAQ,GAAG,MAAM,IAAI,CAACmF,SAAS,EAAE,CAACtG,MAAM,CAAC8D,IAAI,CACjD,sBAAsB,EACtB;MACEgE,iBAAiB,EAAEF,eAAe,CAAC1E;KACpC,CACF;IACD,OAAO/D,eAAe,CACpB,IAAI,CAACmH,SAAS,EAAE,CAACyB,SAAS,EAAE,EAC5B5G,QAAQ,CAAC6G,OAAO,CACS;EAC7B;EAES,MAAMC,OAAO,GACH;IAAA,kCAAdC,IAAc;MAAdA,IAAc;IAAA;IAEjB,MAAMC,eAAe,GAAG,CACtB,MAAM,IAAI,CAAC,oBAAoB,CAACrE,IAAI,CAAC,oBAAoB,EAAE;MACzDoE,IAAI,EAAEA,IAAI,CAACE,MAAM,GAAGF,IAAI,GAAG,CAAC,IAAI,CAACzE,GAAG,EAAE;KACvC,CAAC,EACFwE,OAAO;IAET,MAAMI,2BAA2B,GAAG,CAAC,UAAU,CAAC;IAChD,MAAMC,2BAA2B,GAC/BC,MAA+B,IACJ;MAC3B,KAAK,MAAMC,IAAI,IAAIH,2BAA2B,EAAE;QAC9C,OAAQE,MAA6C,CAACC,IAAI,CAAC;;MAE7D,OAAOD,MAAM;IACf,CAAC;IACD,OAAOJ,eAAe,CAAC/B,GAAG,CAACkC,2BAA2B,CAAC;EACzD;EAES,MAAMG,YAAY,GAC0B;IAEnD,MAAMC,OAAO,GAAG,IAAI,CAACjF,GAAG,EAAE;IAAC,mCAFxBwE,OAAgD;MAAhDA,OAAgD;IAAA;IAGnD,KAAK,MAAMM,MAAM,IAAIN,OAAO,EAAE;MAC5B,MAAMU,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEN,MAAM,CAAC;MACtC,IAAI,CAACA,MAAM,CAAC9E,GAAG,IAAIiF,OAAO,CAACI,UAAU,CAAC,MAAM,CAAC,EAAE;QAC7CH,IAAI,CAAClF,GAAG,GAAGiF,OAAO;;MAEpB,MAAM,IAAI,CAAC,oBAAoB,CAAC5E,IAAI,CAAC,uBAAuB,EAAE6E,IAAI,CAAC;;EAEvE;EAES,MAAMI,SAAS,GACoB;IAE1C,MAAML,OAAO,GAAG,IAAI,CAACjF,GAAG,EAAE;IAC1B,MAAMuF,cAAc,GAAGN,OAAO,CAACI,UAAU,CAAC,MAAM,CAAC;IAAC,mCAH/Cb,OAAuC;MAAvCA,OAAuC;IAAA;IAI1C,MAAMgB,KAAK,GAAGhB,OAAO,CAAC7B,GAAG,CAACmC,MAAM,IAAG;MACjC,MAAMI,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEN,MAAM,CAAC;MACtC,IAAI,CAACI,IAAI,CAAClF,GAAG,IAAIuF,cAAc,EAAE;QAC/BL,IAAI,CAAClF,GAAG,GAAGiF,OAAO;;MAEpBlK,MAAM,CACJmK,IAAI,CAAClF,GAAG,KAAK,aAAa,EAC1B,mCAAmCkF,IAAI,CAACO,IAAI,GAAG,CAChD;MACD1K,MAAM,CACJ,CAAC2K,MAAM,CAACC,SAAS,CAACN,UAAU,CAACO,IAAI,CAACV,IAAI,CAAClF,GAAG,IAAI,EAAE,EAAE,OAAO,CAAC,EAC1D,sCAAsCkF,IAAI,CAACO,IAAI,GAAG,CACnD;MACD,OAAOP,IAAI;IACb,CAAC,CAAC;IACF,MAAM,IAAI,CAACF,YAAY,CAAC,GAAGQ,KAAK,CAAC;IACjC,IAAIA,KAAK,CAACb,MAAM,EAAE;MAChB,MAAM,IAAI,CAAC,oBAAoB,CAACtE,IAAI,CAAC,oBAAoB,EAAE;QACzDmE,OAAO,EAAEgB;OACV,CAAC;;EAEN;EAES,MAAMK,cAAc,CAC3BJ,IAAY,EACZK,YAA4C;IAE5C,IAAI,IAAI,CAAC,SAAS,CAACC,GAAG,CAACN,IAAI,CAAC,EAAE;MAC5B,MAAM,IAAIrD,KAAK,CACb,wCAAwCqD,IAAI,aAAaA,IAAI,oBAAoB,CAClF;;IAGH,IAAIO,OAAgB;IACpB,QAAQ,OAAOF,YAAY;MACzB,KAAK,UAAU;QACbE,OAAO,GAAG,IAAI5K,OAAO,CACnBqK,IAAI,EACJK,YAA+C,CAChD;QACD;MACF;QACEE,OAAO,GAAG,IAAI5K,OAAO,CACnBqK,IAAI,EACJK,YAAY,CAACG,OAA0C,CACxD;QACD;IAAM;IAGV,IAAI,CAAC,SAAS,CAAChG,GAAG,CAACwF,IAAI,EAAEO,OAAO,CAAC;IAEjC,MAAME,UAAU,GAAGxL,qBAAqB,CAAC,YAAY,EAAE+K,IAAI,CAAC;IAC5D,MAAM,IAAI,CAAC,oBAAoB,CAACpF,IAAI,CAAC,oBAAoB,EAAE;MAACoF;IAAI,CAAC,CAAC;IAClE,MAAM;MAACU;IAAU,CAAC,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC9F,IAAI,CACvD,uCAAuC,EACvC;MACEmC,MAAM,EAAE0D;KACT,CACF;IAED,IAAI,CAAC,iBAAiB,CAACjG,GAAG,CAACwF,IAAI,EAAEU,UAAU,CAAC;IAE5C,MAAMjG,OAAO,CAACC,GAAG,CACf,IAAI,CAACgD,MAAM,EAAE,CAACR,GAAG,CAACzF,KAAK,IAAG;MACxB,OAAOA,KAAK,CAACkJ,QAAQ,CAACF,UAAU,CAAC,CAAClH,KAAK,CAAC3E,UAAU,CAAC;IACrD,CAAC,CAAC,CACH;EACH;EAES,MAAMgM,qBAAqB,CAACZ,IAAY;IAC/C,MAAMa,UAAU,GAAG,IAAI,CAAC,iBAAiB,CAAC3G,GAAG,CAAC8F,IAAI,CAAC;IACnD,IAAI,CAACa,UAAU,EAAE;MACf,MAAM,IAAIlE,KAAK,CACb,2CAA2CqD,IAAI,aAAaA,IAAI,qBAAqB,CACtF;;IAGH,MAAM,IAAI,CAAC,oBAAoB,CAACpF,IAAI,CAAC,uBAAuB,EAAE;MAACoF;IAAI,CAAC,CAAC;IACrE,MAAM,IAAI,CAACc,mCAAmC,CAACD,UAAU,CAAC;IAE1D,MAAMpG,OAAO,CAACC,GAAG,CACf,IAAI,CAACgD,MAAM,EAAE,CAACR,GAAG,CAACzF,KAAK,IAAG;MACxB,OAAOA,KAAK,CACTkJ,QAAQ,CAACX,IAAI,IAAG;QACf;QACA;QACAe,UAAU,CAACf,IAAI,CAAC,GAAG1H,SAAS;MAC9B,CAAC,EAAE0H,IAAI,CAAC,CACPzG,KAAK,CAAC3E,UAAU,CAAC;IACtB,CAAC,CAAC,CACH;IAED,IAAI,CAAC,iBAAiB,CAACuF,MAAM,CAAC6F,IAAI,CAAC;IACnC,IAAI,CAAC,SAAS,CAAC7F,MAAM,CAAC6F,IAAI,CAAC;EAC7B;EAES,MAAMgB,YAAY,CAACC,WAAwB;IAClD,OAAO,MAAM,IAAI,CAAC,aAAa,CAACjI,cAAc,CAACgI,YAAY,CAACC,WAAW,CAAC;EAC1E;EAES,MAAMC,mBAAmB,CAChCC,OAA+B;IAE/B,OAAO,MAAM,IAAI,CAAC,aAAa,CAACnI,cAAc,CAACkI,mBAAmB,CAACC,OAAO,CAAC;EAC7E;EAES,MAAMC,YAAY,CACzBC,SAAiB,EACjBC,iBAAwD;IAExD,OAAO,MAAM,IAAI,CAAC,aAAa,CAACtI,cAAc,CAACoI,YAAY,CACzDC,SAAS,EACTC,iBAAiB,CAClB;EACH;EAES,MAAMC,OAAO;IACpB,MAAMtJ,QAAQ,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC2C,IAAI,CACnD,wBAAwB,CACzB;IACD,OAAO,IAAI,CAAC,mBAAmB,CAAC3C,QAAQ,CAACsJ,OAAO,CAAC;EACnD;EAEA,YAAY,CAAC1G,KAAwC;IACnD,IAAI,CAACnD,IAAI,oCAAoB;MAC3B8J,KAAK,EAAE3G,KAAK,CAAC2G,KAAK;MAClBD,OAAO,EAAE,IAAI,CAAC,mBAAmB,CAAC1G,KAAK,CAAC0G,OAAO;KAChD,CAAC;EACJ;EAEA,mBAAmB,CAACA,OAAuC;IACzD,MAAMjF,MAAM,GAGR,EAAE;IACN,KAAK,MAAMmF,MAAM,IAAIF,OAAO,IAAI,EAAE,EAAE;MAClC,IAAIG,gBAAgB,CAACpB,GAAG,CAACmB,MAAM,CAACzB,IAAI,CAAC,EAAE;QACrC1D,MAAM,CAACmF,MAAM,CAACzB,IAAI,CAAC,GAAGyB,MAAM,CAAC1D,KAAK;;;IAGtC,OAAOzB,MAAM;EACf;EAEA,gBAAgB,CAACqF,SAAgD;IAC/D,IAAI,CAACjK,IAAI,wCAEP/C,iBAAiB,CAACgN,SAAS,CAACC,gBAAgB,CAAC,CAC9C;EACH;EAEA,MAAM,aAAa,CACjB/G,KAA6C;IAE7C,IAAIA,KAAK,CAACgH,kBAAkB,KAAK,CAAC,EAAE;MAClC;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;;IAEF,MAAMC,OAAO,GAAG,IAAI,CAAC,aAAa,CAACC,uBAAuB,CACxDlH,KAAK,CAACgH,kBAAkB,EACxB,IAAI,CAAC,oBAAoB,CAC1B;IACD,IAAI,CAACC,OAAO,EAAE;MACZlN,UAAU,CACR,IAAI+H,KAAK,CACP,qDAAqDqF,IAAI,CAACC,SAAS,CACjEpH,KAAK,CACN,EAAE,CACJ,CACF;MACD;;IAEF,MAAMgD,MAAM,GAAGhD,KAAK,CAACiC,IAAI,CAACI,GAAG,CAACC,GAAG,IAAG;MAClC,OAAOlH,eAAe,CAAC6L,OAAO,CAACI,MAAM,EAAE/E,GAAG,CAAC;IAC7C,CAAC,CAAC;IACF,IAAI,CAAC,kBAAkB,CAACtC,KAAK,CAACP,IAAI,EAAEuD,MAAM,EAAEhD,KAAK,CAACsH,UAAU,CAAC;EAC/D;EAEA,MAAM,gBAAgB,CACpBtH,KAA0C;IAE1C,IAAIuH,OAAuB;IAC3B,IAAI;MACFA,OAAO,GAAGJ,IAAI,CAACK,KAAK,CAACxH,KAAK,CAACuH,OAAO,CAAC;KACpC,CAAC,MAAM;MACN;MACA;MACA;;IAEF,MAAM;MAAC9H,IAAI;MAAE0F,IAAI;MAAEsC,GAAG;MAAExF,IAAI;MAAEyF;IAAS,CAAC,GAAGH,OAAO;IAClD,IAAI9H,IAAI,KAAK,YAAY,EAAE;MACzB;;IAGF,MAAMwH,OAAO,GAAG,IAAI,CAAC,aAAa,CAACU,oBAAoB,CACrD3H,KAAK,CAACgH,kBAAkB,EACxB,IAAI,CAAC,oBAAoB,CAC1B;IACD,IAAI,CAACC,OAAO,EAAE;MACZ;;IAGF,MAAMvB,OAAO,GAAG,IAAI,CAAC,SAAS,CAACrG,GAAG,CAAC8F,IAAI,CAAC;IACxC,MAAMO,OAAO,EAAEkC,GAAG,CAACX,OAAO,EAAEQ,GAAG,EAAExF,IAAI,EAAEyF,SAAS,CAAC;EACnD;EAEA,kBAAkB,CAChBG,SAA6B,EAC7B5F,IAAgB,EAChBqF,UAAwC;IAExC,IAAI,CAAC,IAAI,CAACQ,aAAa,mCAAmB,EAAE;MAC1C7F,IAAI,CAAC8F,OAAO,CAACzF,GAAG,IAAG;QACjB,OAAOA,GAAG,CAAC0F,OAAO,EAAE;MACtB,CAAC,CAAC;MACF;;IAEF,MAAMC,UAAU,GAAG,EAAE;IACrB;IACA;IACA,KAAK,MAAM3F,GAAG,IAAIL,IAAI,EAAE;MACtB,MAAMiG,YAAY,GAAG5F,GAAG,CAAC4F,YAAY,EAAE;MACvC,IAAIA,YAAY,CAACC,QAAQ,EAAE;QACzBF,UAAU,CAACG,IAAI,CAAC9F,GAAG,CAAC+F,QAAQ,EAAE,CAAC;OAChC,MAAM;QACLJ,UAAU,CAACG,IAAI,CAAC7N,qBAAqB,CAAC2N,YAAY,CAAC,CAAC;;;IAGxD,MAAMI,mBAAmB,GAAG,EAAE;IAC9B,IAAIhB,UAAU,EAAE;MACd,KAAK,MAAMiB,SAAS,IAAIjB,UAAU,CAACkB,UAAU,EAAE;QAC7CF,mBAAmB,CAACF,IAAI,CAAC;UACvB1I,GAAG,EAAE6I,SAAS,CAAC7I,GAAG;UAClByC,UAAU,EAAEoG,SAAS,CAACpG,UAAU;UAChCsG,YAAY,EAAEF,SAAS,CAACE;SACzB,CAAC;;;IAGN,MAAMpH,OAAO,GAAG,IAAI3H,cAAc,CAChCmO,SAAS,EACTI,UAAU,CAACS,IAAI,CAAC,GAAG,CAAC,EACpBzG,IAAI,EACJqG,mBAAmB,CACpB;IACD,IAAI,CAACzL,IAAI,oCAAoBwE,OAAO,CAAC;EACvC;EAEA,SAAS,CAACrB,KAAiD;IACzD,MAAMP,IAAI,GAAGnF,kBAAkB,CAAC0F,KAAK,CAACP,IAAI,CAAC;IAC3C,MAAMkJ,MAAM,GAAG,IAAIzN,SAAS,CAC1B,IAAI,CAAC,oBAAoB,EACzBuE,IAAI,EACJO,KAAK,CAACqB,OAAO,EACbrB,KAAK,CAAC4I,aAAa,CACpB;IACD,IAAI,CAAC/L,IAAI,kCAAmB8L,MAAM,CAAC;EACrC;EAES,MAAME,MAAM,CACnB3H,OAAwB;IAExB,MAAM,CAACO,MAAM,CAAC,GAAG,MAAM7B,OAAO,CAACC,GAAG,CAAC,CACjC,IAAI,CAACiJ,iBAAiB,CAAC5H,OAAO,CAAC,EAC/B,IAAI,CAAC,oBAAoB,CAACnB,IAAI,CAAC,aAAa,CAAC,CAC9C,CAAC;IAEF,OAAO0B,MAAM;EACf;EAES,MAAMsH,gBAAgB;IAC7B,OAAO,MAAM,IAAI,CAAC7M,MAAM,EAAE,CAAC6M,gBAAgB,EAAE;EAC/C;EAES,MAAMC,cAAc,CAC3BC,cAA2E,EAC3C;IAAA,IAAhC/H,8EAA8B,EAAE;IAEhC,MAAM;MAAC7G,OAAO,GAAG,IAAI,CAAC0D,gBAAgB,CAAC1D,OAAO;IAAE,CAAC,GAAG6G,OAAO;IAC3D,OAAO,MAAM1G,WAAW,CACtB,IAAI,CAAC,aAAa,CAAC2D,cAAc,EACjCtE,mBAAmB,CAACmD,OAAO,EAC3BiM,cAAc,EACd5O,OAAO,EACP,IAAI,CAAC,qBAAqB,CAC3B;EACH;EAES,MAAM6O,eAAe,CAC5BD,cAEuD,EACvB;IAAA,IAAhC/H,8EAA8B,EAAE;IAEhC,MAAM;MAAC7G,OAAO,GAAG,IAAI,CAAC0D,gBAAgB,CAAC1D,OAAO;IAAE,CAAC,GAAG6G,OAAO;IAC3D,OAAO,MAAM1G,WAAW,CACtB,IAAI,CAAC,aAAa,CAAC2D,cAAc,EACjCtE,mBAAmB,CAACsD,QAAQ,EAC5B8L,cAAc,EACd5O,OAAO,EACP,IAAI,CAAC,qBAAqB,CAC3B;EACH;EAES,MAAM8O,kBAAkB,GACoB;IAAA,IAAnDjI,8EAAiD,EAAE;IAEnD,MAAM;MACJkI,QAAQ,GAAGjP,iBAAiB;MAC5BE,OAAO,EAAEgP,EAAE,GAAG,IAAI,CAACtL,gBAAgB,CAAC1D,OAAO;IAAE,CAC9C,GAAG6G,OAAO;IAEX,MAAM7H,cAAc,CAClB,IAAI,CAACiQ,mBAAmB,CACtB,IAAI,CAAC,aAAa,CAACnL,cAAc,EACjCiL,QAAQ,CACT,CAACG,IAAI,CACJhQ,QAAQ,CAACc,OAAO,CAACgP,EAAE,CAAC,EAAE/P,IAAI,CAAC,IAAI,CAAC,qBAAqB,CAACiF,YAAY,EAAE,CAAC,CAAC,CACvE,CACF;EACH;EAES,MAAMiL,MAAM,GACS;IAAA,IAA5BtI,8EAA0B,EAAE;IAE5B,OAAO,MAAM,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC;EACpC;EAES,MAAMuI,SAAS,GACM;IAAA,IAA5BvI,8EAA0B,EAAE;IAE5B,OAAO,MAAM,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,EAAEA,OAAO,CAAC;EACpC;EAEA,MAAM,GAAG,CACPwI,KAAa,EACbxI,OAAuB;IAEvB,MAAMyI,OAAO,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC5J,IAAI,CAClD,2BAA2B,CAC5B;IACD,MAAMqC,KAAK,GAAGuH,OAAO,CAACC,OAAO,CAACD,OAAO,CAACE,YAAY,GAAGH,KAAK,CAAC;IAC3D,IAAI,CAACtH,KAAK,EAAE;MACV,OAAO,IAAI;;IAEb,MAAMX,MAAM,GAAG,MAAM7B,OAAO,CAACC,GAAG,CAAC,CAC/B,IAAI,CAACiJ,iBAAiB,CAAC5H,OAAO,CAAC,EAC/B,IAAI,CAAC,oBAAoB,CAACnB,IAAI,CAAC,6BAA6B,EAAE;MAC5D+J,OAAO,EAAE1H,KAAK,CAACjD;KAChB,CAAC,CACH,CAAC;IACF,OAAOsC,MAAM,CAAC,CAAC,CAAC;EAClB;EAES,MAAMsI,YAAY;IACzB,MAAM,IAAI,CAAC,oBAAoB,CAAChK,IAAI,CAAC,mBAAmB,CAAC;EAC3D;EAES,MAAMiK,oBAAoB,CAACxI,OAAgB;IAClD,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACwI,oBAAoB,CAACxI,OAAO,CAAC;EACnE;EAES,MAAMyI,YAAY,CAACzI,OAAgB;IAC1C,MAAM,IAAI,CAAC,oBAAoB,CAACzB,IAAI,CAAC,mBAAmB,EAAE;MAACyB;IAAO,CAAC,CAAC;EACtE;EAES,MAAM0I,gBAAgB,CAACzK,IAAa;IAC3C,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACyK,gBAAgB,CAACzK,IAAI,CAAC;EAC5D;EAES,MAAM0K,oBAAoB,CAACC,MAAqB;IACvD,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACD,oBAAoB,CAACC,MAAM,CAAC;EAClE;EAES,MAAMC,oBAAoB,CACjCC,QAAyB;IAEzB,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACD,oBAAoB,CAACC,QAAQ,CAAC;EACpE;EAES,MAAMC,eAAe,CAACC,UAAmB;IAChD,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACD,eAAe,CAACC,UAAU,CAAC;EACjE;EAES,MAAMC,gBAAgB,CAACC,SAG/B;IACC,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACD,gBAAgB,CAACC,SAAS,CAAC;EACjE;EAES,MAAMC,uBAAuB,CACpClL,IAAoE;IAEpE,OAAO,MAAM,IAAI,CAAC,iBAAiB,CAACkL,uBAAuB,CAAClL,IAAI,CAAC;EACnE;EAES,MAAMnD,WAAW,CAACsO,QAAkB;IAC3C,MAAMC,WAAW,GAAG,MAAM,IAAI,CAAC,iBAAiB,CAACC,eAAe,CAACF,QAAQ,CAAC;IAC1E,IAAI,CAAC,SAAS,GAAGA,QAAQ;IACzB,IAAIC,WAAW,EAAE;MACf,MAAM,IAAI,CAAChC,MAAM,EAAE;;EAEvB;EAES+B,QAAQ;IACf,OAAO,IAAI,CAAC,SAAS;EACvB;EAES,MAAMG,qBAAqB,CAIlCC,YAA2B,EACZ;IAAA,mCAAZ/I,IAAY;MAAZA,IAAY;IAAA;IAEf,MAAMC,MAAM,GAAGlI,gBAAgB,CAACgR,YAAY,EAAE,GAAG/I,IAAI,CAAC;IACtD,MAAM;MAAC4D;IAAU,CAAC,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC9F,IAAI,CACvD,uCAAuC,EACvC;MACEmC;KACD,CACF;IAED,OAAO;MAAC2D;IAAU,CAAC;EACrB;EAES,MAAMI,mCAAmC,CAChDJ,UAAkB;IAElB,MAAM,IAAI,CAAC,oBAAoB,CAAC9F,IAAI,CAClC,0CAA0C,EAC1C;MACE8F;KACD,CACF;EACH;EAES,MAAMoF,eAAe,GAAe;IAAA,IAAdzJ,OAAO,uEAAG,IAAI;IAC3C,MAAM,IAAI,CAAC,aAAa,CAACrD,cAAc,CAAC8M,eAAe,CAACzJ,OAAO,CAAC;EAClE;EAES,MAAM0J,WAAW,CACxBhK,OAAoC;;;;;;;MAEpC,MAAM;QACJiK,WAAW;QACXC,cAAc;QACdC,gBAAgB;QAChBC,OAAO;QACPC,IAAI,EAAEC,QAAQ;QACd/L,IAAI;QACJgM;MAAqB,CACtB,GAAGvK,OAAO;MAEX,MAAMwK,SAAS,GACb,IAAI,CAACxP,MAAM,EAAE,CAAC4B,cAAc,EAAE,YAAYzC,oBAAoB;MAEhE,MAAYsQ,KAAK,kCAAG,IAAIhR,oBAAoB,EAAE;MAC9C;MACA,IAAI,CAAC+Q,SAAS,IAAIN,cAAc,KAAK3L,IAAI,KAAK,KAAK,IAAIA,IAAI,KAAK,MAAM,CAAC,EAAE;QACvE,MAAM,IAAI,CAAC,iBAAiB,CAACmM,6BAA6B,EAAE;QAC5DD,KAAK,CAACE,KAAK,CAAC,YAAW;UACrB,MAAM,IAAI,CAAC,iBAAiB,CACzBC,2BAA2B,EAAE,CAC7BpN,KAAK,CAAC3E,UAAU,CAAC;QACtB,CAAC,CAAC;;MAGJ,IAAIwR,IAAI,GAAGC,QAAQ;MACnB,IAAID,IAAI,IAAI,CAACE,qBAAqB,EAAE;QAClC,MAAMb,QAAQ,GAAG,MAAM,IAAI,CAACrI,SAAS,EAAE,CACpCwJ,aAAa,EAAE,CACfjG,QAAQ,CAAC,MAAK;UACb,MAAM;YACJkG,MAAM;YACNC,QAAQ,EAAEC,CAAC;YACXC,OAAO,EAAEC,CAAC;YACVC;UAAK,CACN,GAAGC,MAAM,CAACC,cAAe;UAC1B,OAAO;YAACL,CAAC;YAAEE,CAAC;YAAEJ,MAAM;YAAEK;UAAK,CAAC;QAC9B,CAAC,CAAC;QACJd,IAAI,GAAGiB,mBAAmB,CAACjB,IAAI,EAAEX,QAAQ,CAAC;;MAG5C;MACA,MAAM;QAAC6B;MAAI,CAAC,GAAG,MAAM,IAAI,CAAC,oBAAoB,CAAC1M,IAAI,CACjD,wBAAwB,EACxB;QACE2M,MAAM,EAAEjN,IAAI;QACZ,IAAI4L,gBAAgB,GAAG;UAACA;QAAgB,CAAC,GAAG,EAAE,CAAC;QAC/C,IAAIC,OAAO,KAAK7N,SAAS,GAAG;UAAC6N,OAAO,EAAEqB,IAAI,CAACC,KAAK,CAACtB,OAAO;QAAC,CAAC,GAAG,EAAE,CAAC;QAChEC,IAAI,EAAEA,IAAI,IAAI;UACZ,GAAGA,IAAI;UACPsB,KAAK,EAAEtB,IAAI,CAACsB,KAAK,IAAI;SACtB;QACD,IAAI,CAAC1B,WAAW,GAAG;UAACA;QAAW,CAAC,GAAG,EAAE,CAAC;QACtCM;OACD,CACF;MACD,OAAOgB,IAAI;;;;;;;;;EAGJ,MAAMK,eAAe,GAAyB;IAAA,IAAxB5L,8EAAsB,EAAE;IACrD,MAAM;MACJ6L,SAAS;MACTC,mBAAmB;MACnBC,cAAc;MACdC,cAAc;MACdC,eAAe;MACfN,KAAK;MACLR,KAAK,EAAEe,UAAU;MACjBpB,MAAM,EAAEqB,WAAW;MACnBC,MAAM;MACNC,UAAU;MACVC,iBAAiB;MACjBpC,cAAc;MACd/Q,OAAO,EAAEgP,EAAE;MACXoE,MAAM,EAAEC;IAAiB,CAC1B,GAAG,IAAI,CAACC,cAAc,CAACzM,OAAO,CAAC;IAEhC,IAAIkK,cAAc,EAAE;MAClB,MAAM,IAAI,CAAC,iBAAiB,CAACQ,6BAA6B,EAAE;;IAG9D,MAAMgC,mBAAmB,GAAG,IAAI,CAAC,oBAAoB,CAAC7N,IAAI,CACxD,iBAAiB,EACjB;MACE8N,YAAY,EAAE,gBAAgB;MAC9Bd,SAAS;MACTC,mBAAmB;MACnBC,cAAc;MACdC,cAAc;MACdC,eAAe;MACfN,KAAK;MACLO,UAAU;MACVC,WAAW;MACXS,SAAS,EAAER,MAAM,CAACS,GAAG;MACrBC,YAAY,EAAEV,MAAM,CAACW,MAAM;MAC3BC,UAAU,EAAEZ,MAAM,CAACa,IAAI;MACvBC,WAAW,EAAEd,MAAM,CAACe,KAAK;MACzBd,UAAU;MACVC,iBAAiB;MACjBE;KACD,CACF;IAED,MAAMjM,MAAM,GAAG,MAAMpI,cAAc,CACjCC,IAAI,CAACsU,mBAAmB,CAAC,CAACrE,IAAI,CAAChQ,QAAQ,CAACc,OAAO,CAACgP,EAAE,CAAC,CAAC,CAAC,CACtD;IAED,IAAI+B,cAAc,EAAE;MAClB,MAAM,IAAI,CAAC,iBAAiB,CAACU,2BAA2B,EAAE;;IAG5DrR,MAAM,CAACgH,MAAM,CAAC6M,MAAM,EAAE,2CAA2C,CAAC;IAClE,OAAO,MAAMpU,6BAA6B,CACxC,IAAI,CAAC,oBAAoB,EACzBuH,MAAM,CAAC6M,MAAM,CACd;EACH;EAES,MAAMC,GAAG,GAAyB;IAAA,IAAxBrN,8EAAsB,EAAE;IACzC,MAAM;MAACsN,IAAI,GAAG/Q;IAAS,CAAC,GAAGyD,OAAO;IAClC,MAAMuN,QAAQ,GAAG,MAAM,IAAI,CAAC3B,eAAe,CAAC5L,OAAO,CAAC;IACpD,MAAMwN,MAAM,GAAG,MAAMzU,mBAAmB,CAACwU,QAAQ,EAAED,IAAI,CAAC;IACxD/T,MAAM,CAACiU,MAAM,EAAE,yBAAyB,CAAC;IACzC,OAAOA,MAAM;EACf;EAES,MAAMC,KAAK,GACiD;IAAA,IAAnEzN,8EAAuC;MAAC0N,eAAe,EAAEnR;IAAS,CAAC;IAEnE,MAAMoR,UAAU,GAAG,IAAI,CAAC,oBAAoB,CAACA,UAAU,EAAE;IACzDpU,MAAM,CACJoU,UAAU,EACV,0EAA0E,CAC3E;IACD,MAAMD,eAAe,GAAG,CAAC,CAAC1N,OAAO,CAAC0N,eAAe;IACjD,IAAIA,eAAe,EAAE;MACnB,MAAM,IAAI,CAAC,oBAAoB,CAAC7O,IAAI,CAAC,YAAY,CAAC;KACnD,MAAM;MACL,MAAM8O,UAAU,CAAC9O,IAAI,CAAC,oBAAoB,EAAE;QAC1C+O,QAAQ,EAAE,IAAI,CAAC,cAAc,CAACC;OAC/B,CAAC;MACF,MAAM,IAAI,CAAC,UAAU,CAACzQ,iBAAiB,CAACC,YAAY,EAAE;;EAE1D;EAESyQ,QAAQ;IACf,OAAO,IAAI,CAAC,OAAO;EACrB;EAEA,IAAaC,KAAK;IAChB,OAAO,IAAI,CAAC,MAAM;EACpB;EAEA;;;;;;;;;;;;;;;;;;;;;;;EAuBS,MAAMC,mBAAmB,GACA;IAAA,IAAhChO,8EAA8B,EAAE;IAEhC,OAAO,MAAM,IAAI,CAACqB,SAAS,EAAE,CAAC2M,mBAAmB,CAAChO,OAAO,CAAC;EAC5D;;AAGF,MAAM2F,gBAAgB,GAAG,IAAIpK,GAAG,CAAS,CACvC,WAAW,EACX,WAAW,EACX,QAAQ,EACR,kBAAkB,EAClB,OAAO,EACP,aAAa,EACb,kBAAkB,EAClB,gBAAgB,EAChB,qBAAqB,EACrB,gBAAgB,EAChB,cAAc,EACd,gBAAgB,EAChB,iBAAiB,CAClB,CAAC;AAEF;AACA,SAAS+P,mBAAmB,CAC1BjB,IAA8B,EAC9BX,QAAqC;EAErC;EACA,MAAMsB,CAAC,GAAGS,IAAI,CAACwC,GAAG,CAAC5D,IAAI,CAACW,CAAC,EAAEtB,QAAQ,CAACsB,CAAC,CAAC;EACtC,MAAME,CAAC,GAAGO,IAAI,CAACwC,GAAG,CAAC5D,IAAI,CAACa,CAAC,EAAExB,QAAQ,CAACwB,CAAC,CAAC;EACtC,OAAO;IACLF,CAAC;IACDE,CAAC;IACDC,KAAK,EAAEM,IAAI,CAACwC,GAAG,CACbxC,IAAI,CAACyC,GAAG,CAAC7D,IAAI,CAACW,CAAC,GAAGX,IAAI,CAACc,KAAK,EAAEzB,QAAQ,CAACsB,CAAC,GAAGtB,QAAQ,CAACyB,KAAK,CAAC,GAAGH,CAAC,EAC9D,CAAC,CACF;IACDF,MAAM,EAAEW,IAAI,CAACwC,GAAG,CACdxC,IAAI,CAACyC,GAAG,CAAC7D,IAAI,CAACa,CAAC,GAAGb,IAAI,CAACS,MAAM,EAAEpB,QAAQ,CAACwB,CAAC,GAAGxB,QAAQ,CAACoB,MAAM,CAAC,GAAGI,CAAC,EAChE,CAAC;GAEJ;AACH","names":["firstValueFrom","from","raceWith","CDPSessionEvent","Page","ConsoleMessage","TargetCloseError","FileChooser","NetworkManagerEvent","createClientError","debugError","evaluationString","getReadableAsBuffer","getReadableFromProtocolStream","NETWORK_IDLE_TIME","pageBindingInitString","timeout","validateDialogType","valueFromRemoteObject","waitForHTTP","assert","Deferred","AsyncDisposableStack","isErrorLike","Accessibility","Binding","CdpCDPSession","isTargetClosedError","Coverage","CdpDialog","EmulationManager","createCdpHandle","FirefoxTargetManager","FrameManager","FrameManagerEvent","CdpKeyboard","CdpMouse","CdpTouchscreen","MAIN_WORLD","releaseObject","Tracing","WebWorker","CdpPage","_create","client","target","ignoreHTTPSErrors","defaultViewport","page","setViewport","err","Map","Set","create","FrameAttached","frame","emit","FrameDetached","FrameNavigated","Request","request","RequestServedFromCache","Response","response","RequestFailed","RequestFinished","Disconnected","reject","undefined","bind","constructor","parentSession","_target","_targetManager","_timeoutSettings","eventName","handler","on","networkManager","Swapped","Ready","_isClosedDeferred","valueOrThrow","then","off","catch","newSession","updateClient","swapFrameTree","session","_subtype","registerSpeculativeSession","sessionId","_session","id","worker","get","delete","onAttachedToTarget","_getTargetInfo","type","url","set","Promise","all","initialize","send","event","size","frameId","handle","worlds","adoptBackendNode","backendNodeId","fileChooser","move","promise","resolve","clear","_client","isServiceWorkerBypassed","isDragInterceptionEnabled","isJavaScriptEnabled","javascriptEnabled","waitForFileChooser","options","needsEnable","deferred","message","add","enablePromise","enabled","result","error","setGeolocation","browser","browserContext","Error","level","text","args","source","lineNumber","entry","map","arg","mainFrame","keyboard","touchscreen","coverage","tracing","accessibility","frames","workers","Array","values","setRequestInterception","value","setBypassServiceWorker","bypass","setDragInterception","setOfflineMode","emulateNetworkConditions","networkConditions","setDefaultNavigationTimeout","setDefaultTimeout","getDefaultTimeout","queryObjects","prototypeHandle","disposed","prototypeObjectId","mainRealm","objects","cookies","urls","originalCookies","length","unsupportedCookieAttributes","filterUnsupportedAttributes","cookie","attr","deleteCookie","pageURL","item","Object","assign","startsWith","setCookie","startsWithHTTP","items","name","String","prototype","call","exposeFunction","pptrFunction","has","binding","default","expression","identifier","evaluate","removeExposedFunction","exposedFun","removeScriptToEvaluateOnNewDocument","globalThis","authenticate","credentials","setExtraHTTPHeaders","headers","setUserAgent","userAgent","userAgentMetadata","metrics","title","metric","supportedMetrics","exception","exceptionDetails","executionContextId","context","getExecutionContextById","JSON","stringify","_world","stackTrace","payload","parse","seq","isTrivial","executionContextById","run","eventType","listenerCount","forEach","dispose","textTokens","remoteObject","objectId","push","toString","stackTraceLocations","callFrame","callFrames","columnNumber","join","dialog","defaultPrompt","reload","waitForNavigation","createCDPSession","waitForRequest","urlOrPredicate","waitForResponse","waitForNetworkIdle","idleTime","ms","_waitForNetworkIdle","pipe","goBack","goForward","delta","history","entries","currentIndex","entryId","bringToFront","setJavaScriptEnabled","setBypassCSP","emulateMediaType","emulateCPUThrottling","factor","emulateMediaFeatures","features","emulateTimezone","timezoneId","emulateIdleState","overrides","emulateVisionDeficiency","viewport","needsReload","emulateViewport","evaluateOnNewDocument","pageFunction","setCacheEnabled","_screenshot","fromSurface","omitBackground","optimizeForSpeed","quality","clip","userClip","captureBeyondViewport","isFirefox","stack","setTransparentBackgroundColor","defer","resetDefaultBackgroundColor","isolatedRealm","height","pageLeft","x","pageTop","y","width","window","visualViewport","getIntersectionRect","data","format","Math","round","scale","createPDFStream","landscape","displayHeaderFooter","headerTemplate","footerTemplate","printBackground","paperWidth","paperHeight","margin","pageRanges","preferCSSPageSize","tagged","generateTaggedPDF","_getPDFOptions","printCommandPromise","transferMode","marginTop","top","marginBottom","bottom","marginLeft","left","marginRight","right","stream","pdf","path","readable","buffer","close","runBeforeUnload","connection","targetId","_targetId","isClosed","mouse","waitForDevicePrompt","max","min"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\Page.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Readable} from 'stream';\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {firstValueFrom, from, raceWith} from '../../third_party/rxjs/rxjs.js';\nimport type {Browser} from '../api/Browser.js';\nimport type {BrowserContext} from '../api/BrowserContext.js';\nimport {CDPSessionEvent, type CDPSession} from '../api/CDPSession.js';\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {Frame, WaitForOptions} from '../api/Frame.js';\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {\n  Page,\n  PageEvent,\n  type GeolocationOptions,\n  type MediaFeature,\n  type Metrics,\n  type NewDocumentScriptEvaluation,\n  type ScreenshotClip,\n  type ScreenshotOptions,\n  type WaitTimeoutOptions,\n} from '../api/Page.js';\nimport {\n  ConsoleMessage,\n  type ConsoleMessageType,\n} from '../common/ConsoleMessage.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {FileChooser} from '../common/FileChooser.js';\nimport {NetworkManagerEvent} from '../common/NetworkManagerEvents.js';\nimport type {PDFOptions} from '../common/PDFOptions.js';\nimport type {BindingPayload, HandleFor} from '../common/types.js';\nimport {\n  createClientError,\n  debugError,\n  evaluationString,\n  getReadableAsBuffer,\n  getReadableFromProtocolStream,\n  NETWORK_IDLE_TIME,\n  pageBindingInitString,\n  timeout,\n  validateDialogType,\n  valueFromRemoteObject,\n  waitForHTTP,\n} from '../common/util.js';\nimport type {Viewport} from '../common/Viewport.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {AsyncDisposableStack} from '../util/disposable.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {Accessibility} from './Accessibility.js';\nimport {Binding} from './Binding.js';\nimport {CdpCDPSession} from './CDPSession.js';\nimport {isTargetClosedError} from './Connection.js';\nimport {Coverage} from './Coverage.js';\nimport type {DeviceRequestPrompt} from './DeviceRequestPrompt.js';\nimport {CdpDialog} from './Dialog.js';\nimport {EmulationManager} from './EmulationManager.js';\nimport {createCdpHandle} from './ExecutionContext.js';\nimport {FirefoxTargetManager} from './FirefoxTargetManager.js';\nimport type {CdpFrame} from './Frame.js';\nimport {FrameManager} from './FrameManager.js';\nimport {FrameManagerEvent} from './FrameManagerEvents.js';\nimport {CdpKeyboard, CdpMouse, CdpTouchscreen} from './Input.js';\nimport {MAIN_WORLD} from './IsolatedWorlds.js';\nimport {releaseObject} from './JSHandle.js';\nimport type {Credentials, NetworkConditions} from './NetworkManager.js';\nimport type {CdpTarget} from './Target.js';\nimport type {TargetManager} from './TargetManager.js';\nimport {TargetManagerEvent} from './TargetManager.js';\nimport {Tracing} from './Tracing.js';\nimport {WebWorker} from './WebWorker.js';\n\n/**\n * @internal\n */\nexport class CdpPage extends Page {\n  static async _create(\n    client: CDPSession,\n    target: CdpTarget,\n    ignoreHTTPSErrors: boolean,\n    defaultViewport: Viewport | null\n  ): Promise<CdpPage> {\n    const page = new CdpPage(client, target, ignoreHTTPSErrors);\n    await page.#initialize();\n    if (defaultViewport) {\n      try {\n        await page.setViewport(defaultViewport);\n      } catch (err) {\n        if (isErrorLike(err) && isTargetClosedError(err)) {\n          debugError(err);\n        } else {\n          throw err;\n        }\n      }\n    }\n    return page;\n  }\n\n  #closed = false;\n  readonly #targetManager: TargetManager;\n\n  #primaryTargetClient: CDPSession;\n  #primaryTarget: CdpTarget;\n  #tabTargetClient: CDPSession;\n  #tabTarget: CdpTarget;\n  #keyboard: CdpKeyboard;\n  #mouse: CdpMouse;\n  #touchscreen: CdpTouchscreen;\n  #accessibility: Accessibility;\n  #frameManager: FrameManager;\n  #emulationManager: EmulationManager;\n  #tracing: Tracing;\n  #bindings = new Map<string, Binding>();\n  #exposedFunctions = new Map<string, string>();\n  #coverage: Coverage;\n  #viewport: Viewport | null;\n  #workers = new Map<string, WebWorker>();\n  #fileChooserDeferreds = new Set<Deferred<FileChooser>>();\n  #sessionCloseDeferred = Deferred.create<never, TargetCloseError>();\n  #serviceWorkerBypassed = false;\n  #userDragInterceptionEnabled = false;\n\n  readonly #frameManagerHandlers = [\n    [\n      FrameManagerEvent.FrameAttached,\n      (frame: CdpFrame) => {\n        this.emit(PageEvent.FrameAttached, frame);\n      },\n    ],\n    [\n      FrameManagerEvent.FrameDetached,\n      (frame: CdpFrame) => {\n        this.emit(PageEvent.FrameDetached, frame);\n      },\n    ],\n    [\n      FrameManagerEvent.FrameNavigated,\n      (frame: CdpFrame) => {\n        this.emit(PageEvent.FrameNavigated, frame);\n      },\n    ],\n  ] as const;\n\n  readonly #networkManagerHandlers = [\n    [\n      NetworkManagerEvent.Request,\n      (request: HTTPRequest) => {\n        this.emit(PageEvent.Request, request);\n      },\n    ],\n    [\n      NetworkManagerEvent.RequestServedFromCache,\n      (request: HTTPRequest) => {\n        this.emit(PageEvent.RequestServedFromCache, request);\n      },\n    ],\n    [\n      NetworkManagerEvent.Response,\n      (response: HTTPResponse) => {\n        this.emit(PageEvent.Response, response);\n      },\n    ],\n    [\n      NetworkManagerEvent.RequestFailed,\n      (request: HTTPRequest) => {\n        this.emit(PageEvent.RequestFailed, request);\n      },\n    ],\n    [\n      NetworkManagerEvent.RequestFinished,\n      (request: HTTPRequest) => {\n        this.emit(PageEvent.RequestFinished, request);\n      },\n    ],\n  ] as const;\n\n  readonly #sessionHandlers = [\n    [\n      CDPSessionEvent.Disconnected,\n      () => {\n        this.#sessionCloseDeferred.reject(\n          new TargetCloseError('Target closed')\n        );\n      },\n    ],\n    [\n      'Page.domContentEventFired',\n      () => {\n        return this.emit(PageEvent.DOMContentLoaded, undefined);\n      },\n    ],\n    [\n      'Page.loadEventFired',\n      () => {\n        return this.emit(PageEvent.Load, undefined);\n      },\n    ],\n    ['Runtime.consoleAPICalled', this.#onConsoleAPI.bind(this)],\n    ['Runtime.bindingCalled', this.#onBindingCalled.bind(this)],\n    ['Page.javascriptDialogOpening', this.#onDialog.bind(this)],\n    ['Runtime.exceptionThrown', this.#handleException.bind(this)],\n    ['Inspector.targetCrashed', this.#onTargetCrashed.bind(this)],\n    ['Performance.metrics', this.#emitMetrics.bind(this)],\n    ['Log.entryAdded', this.#onLogEntryAdded.bind(this)],\n    ['Page.fileChooserOpened', this.#onFileChooser.bind(this)],\n  ] as const;\n\n  constructor(\n    client: CDPSession,\n    target: CdpTarget,\n    ignoreHTTPSErrors: boolean\n  ) {\n    super();\n    this.#primaryTargetClient = client;\n    this.#tabTargetClient = client.parentSession()!;\n    assert(this.#tabTargetClient, 'Tab target session is not defined.');\n    this.#tabTarget = (this.#tabTargetClient as CdpCDPSession)._target();\n    assert(this.#tabTarget, 'Tab target is not defined.');\n    this.#primaryTarget = target;\n    this.#targetManager = target._targetManager();\n    this.#keyboard = new CdpKeyboard(client);\n    this.#mouse = new CdpMouse(client, this.#keyboard);\n    this.#touchscreen = new CdpTouchscreen(client, this.#keyboard);\n    this.#accessibility = new Accessibility(client);\n    this.#frameManager = new FrameManager(\n      client,\n      this,\n      ignoreHTTPSErrors,\n      this._timeoutSettings\n    );\n    this.#emulationManager = new EmulationManager(client);\n    this.#tracing = new Tracing(client);\n    this.#coverage = new Coverage(client);\n    this.#viewport = null;\n\n    for (const [eventName, handler] of this.#frameManagerHandlers) {\n      this.#frameManager.on(eventName, handler);\n    }\n\n    for (const [eventName, handler] of this.#networkManagerHandlers) {\n      // TODO: Remove any.\n      this.#frameManager.networkManager.on(eventName, handler as any);\n    }\n\n    this.#tabTargetClient.on(\n      CDPSessionEvent.Swapped,\n      this.#onActivation.bind(this)\n    );\n\n    this.#tabTargetClient.on(\n      CDPSessionEvent.Ready,\n      this.#onSecondaryTarget.bind(this)\n    );\n\n    this.#targetManager.on(\n      TargetManagerEvent.TargetGone,\n      this.#onDetachedFromTarget\n    );\n\n    this.#tabTarget._isClosedDeferred\n      .valueOrThrow()\n      .then(() => {\n        this.#targetManager.off(\n          TargetManagerEvent.TargetGone,\n          this.#onDetachedFromTarget\n        );\n\n        this.emit(PageEvent.Close, undefined);\n        this.#closed = true;\n      })\n      .catch(debugError);\n\n    this.#setupPrimaryTargetListeners();\n  }\n\n  async #onActivation(newSession: CDPSession): Promise<void> {\n    this.#primaryTargetClient = newSession;\n    assert(\n      this.#primaryTargetClient instanceof CdpCDPSession,\n      'CDPSession is not instance of CDPSessionImpl'\n    );\n    this.#primaryTarget = this.#primaryTargetClient._target();\n    assert(this.#primaryTarget, 'Missing target on swap');\n    this.#keyboard.updateClient(newSession);\n    this.#mouse.updateClient(newSession);\n    this.#touchscreen.updateClient(newSession);\n    this.#accessibility.updateClient(newSession);\n    this.#emulationManager.updateClient(newSession);\n    this.#tracing.updateClient(newSession);\n    this.#coverage.updateClient(newSession);\n    await this.#frameManager.swapFrameTree(newSession);\n    this.#setupPrimaryTargetListeners();\n  }\n\n  async #onSecondaryTarget(session: CDPSession): Promise<void> {\n    assert(session instanceof CdpCDPSession);\n    if (session._target()._subtype() !== 'prerender') {\n      return;\n    }\n    this.#frameManager.registerSpeculativeSession(session).catch(debugError);\n    this.#emulationManager\n      .registerSpeculativeSession(session)\n      .catch(debugError);\n  }\n\n  /**\n   * Sets up listeners for the primary target. The primary target can change\n   * during a navigation to a prerended page.\n   */\n  #setupPrimaryTargetListeners() {\n    this.#primaryTargetClient.on(\n      CDPSessionEvent.Ready,\n      this.#onAttachedToTarget\n    );\n\n    for (const [eventName, handler] of this.#sessionHandlers) {\n      // TODO: Remove any.\n      this.#primaryTargetClient.on(eventName, handler as any);\n    }\n  }\n\n  #onDetachedFromTarget = (target: CdpTarget) => {\n    const sessionId = target._session()?.id();\n    const worker = this.#workers.get(sessionId!);\n    if (!worker) {\n      return;\n    }\n    this.#workers.delete(sessionId!);\n    this.emit(PageEvent.WorkerDestroyed, worker);\n  };\n\n  #onAttachedToTarget = (session: CDPSession) => {\n    assert(session instanceof CdpCDPSession);\n    this.#frameManager.onAttachedToTarget(session._target());\n    if (session._target()._getTargetInfo().type === 'worker') {\n      const worker = new WebWorker(\n        session,\n        session._target().url(),\n        this.#addConsoleMessage.bind(this),\n        this.#handleException.bind(this)\n      );\n      this.#workers.set(session.id(), worker);\n      this.emit(PageEvent.WorkerCreated, worker);\n    }\n    session.on(CDPSessionEvent.Ready, this.#onAttachedToTarget);\n  };\n\n  async #initialize(): Promise<void> {\n    try {\n      await Promise.all([\n        this.#frameManager.initialize(this.#primaryTargetClient),\n        this.#primaryTargetClient.send('Performance.enable'),\n        this.#primaryTargetClient.send('Log.enable'),\n      ]);\n    } catch (err) {\n      if (isErrorLike(err) && isTargetClosedError(err)) {\n        debugError(err);\n      } else {\n        throw err;\n      }\n    }\n  }\n\n  async #onFileChooser(\n    event: Protocol.Page.FileChooserOpenedEvent\n  ): Promise<void> {\n    if (!this.#fileChooserDeferreds.size) {\n      return;\n    }\n\n    const frame = this.#frameManager.frame(event.frameId);\n    assert(frame, 'This should never happen.');\n\n    // This is guaranteed to be an HTMLInputElement handle by the event.\n    using handle = (await frame.worlds[MAIN_WORLD].adoptBackendNode(\n      event.backendNodeId\n    )) as ElementHandle<HTMLInputElement>;\n\n    const fileChooser = new FileChooser(handle.move(), event);\n    for (const promise of this.#fileChooserDeferreds) {\n      promise.resolve(fileChooser);\n    }\n    this.#fileChooserDeferreds.clear();\n  }\n\n  _client(): CDPSession {\n    return this.#primaryTargetClient;\n  }\n\n  override isServiceWorkerBypassed(): boolean {\n    return this.#serviceWorkerBypassed;\n  }\n\n  override isDragInterceptionEnabled(): boolean {\n    return this.#userDragInterceptionEnabled;\n  }\n\n  override isJavaScriptEnabled(): boolean {\n    return this.#emulationManager.javascriptEnabled;\n  }\n\n  override async waitForFileChooser(\n    options: WaitTimeoutOptions = {}\n  ): Promise<FileChooser> {\n    const needsEnable = this.#fileChooserDeferreds.size === 0;\n    const {timeout = this._timeoutSettings.timeout()} = options;\n    const deferred = Deferred.create<FileChooser>({\n      message: `Waiting for \\`FileChooser\\` failed: ${timeout}ms exceeded`,\n      timeout,\n    });\n    this.#fileChooserDeferreds.add(deferred);\n    let enablePromise: Promise<void> | undefined;\n    if (needsEnable) {\n      enablePromise = this.#primaryTargetClient.send(\n        'Page.setInterceptFileChooserDialog',\n        {\n          enabled: true,\n        }\n      );\n    }\n    try {\n      const [result] = await Promise.all([\n        deferred.valueOrThrow(),\n        enablePromise,\n      ]);\n      return result;\n    } catch (error) {\n      this.#fileChooserDeferreds.delete(deferred);\n      throw error;\n    }\n  }\n\n  override async setGeolocation(options: GeolocationOptions): Promise<void> {\n    return await this.#emulationManager.setGeolocation(options);\n  }\n\n  override target(): CdpTarget {\n    return this.#primaryTarget;\n  }\n\n  override browser(): Browser {\n    return this.#primaryTarget.browser();\n  }\n\n  override browserContext(): BrowserContext {\n    return this.#primaryTarget.browserContext();\n  }\n\n  #onTargetCrashed(): void {\n    this.emit(PageEvent.Error, new Error('Page crashed!'));\n  }\n\n  #onLogEntryAdded(event: Protocol.Log.EntryAddedEvent): void {\n    const {level, text, args, source, url, lineNumber} = event.entry;\n    if (args) {\n      args.map(arg => {\n        return releaseObject(this.#primaryTargetClient, arg);\n      });\n    }\n    if (source !== 'worker') {\n      this.emit(\n        PageEvent.Console,\n        new ConsoleMessage(level, text, [], [{url, lineNumber}])\n      );\n    }\n  }\n\n  override mainFrame(): CdpFrame {\n    return this.#frameManager.mainFrame();\n  }\n\n  override get keyboard(): CdpKeyboard {\n    return this.#keyboard;\n  }\n\n  override get touchscreen(): CdpTouchscreen {\n    return this.#touchscreen;\n  }\n\n  override get coverage(): Coverage {\n    return this.#coverage;\n  }\n\n  override get tracing(): Tracing {\n    return this.#tracing;\n  }\n\n  override get accessibility(): Accessibility {\n    return this.#accessibility;\n  }\n\n  override frames(): Frame[] {\n    return this.#frameManager.frames();\n  }\n\n  override workers(): WebWorker[] {\n    return Array.from(this.#workers.values());\n  }\n\n  override async setRequestInterception(value: boolean): Promise<void> {\n    return await this.#frameManager.networkManager.setRequestInterception(\n      value\n    );\n  }\n\n  override async setBypassServiceWorker(bypass: boolean): Promise<void> {\n    this.#serviceWorkerBypassed = bypass;\n    return await this.#primaryTargetClient.send(\n      'Network.setBypassServiceWorker',\n      {bypass}\n    );\n  }\n\n  override async setDragInterception(enabled: boolean): Promise<void> {\n    this.#userDragInterceptionEnabled = enabled;\n    return await this.#primaryTargetClient.send('Input.setInterceptDrags', {\n      enabled,\n    });\n  }\n\n  override async setOfflineMode(enabled: boolean): Promise<void> {\n    return await this.#frameManager.networkManager.setOfflineMode(enabled);\n  }\n\n  override async emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void> {\n    return await this.#frameManager.networkManager.emulateNetworkConditions(\n      networkConditions\n    );\n  }\n\n  override setDefaultNavigationTimeout(timeout: number): void {\n    this._timeoutSettings.setDefaultNavigationTimeout(timeout);\n  }\n\n  override setDefaultTimeout(timeout: number): void {\n    this._timeoutSettings.setDefaultTimeout(timeout);\n  }\n\n  override getDefaultTimeout(): number {\n    return this._timeoutSettings.timeout();\n  }\n\n  override async queryObjects<Prototype>(\n    prototypeHandle: JSHandle<Prototype>\n  ): Promise<JSHandle<Prototype[]>> {\n    assert(!prototypeHandle.disposed, 'Prototype JSHandle is disposed!');\n    assert(\n      prototypeHandle.id,\n      'Prototype JSHandle must not be referencing primitive value'\n    );\n    const response = await this.mainFrame().client.send(\n      'Runtime.queryObjects',\n      {\n        prototypeObjectId: prototypeHandle.id,\n      }\n    );\n    return createCdpHandle(\n      this.mainFrame().mainRealm(),\n      response.objects\n    ) as HandleFor<Prototype[]>;\n  }\n\n  override async cookies(\n    ...urls: string[]\n  ): Promise<Protocol.Network.Cookie[]> {\n    const originalCookies = (\n      await this.#primaryTargetClient.send('Network.getCookies', {\n        urls: urls.length ? urls : [this.url()],\n      })\n    ).cookies;\n\n    const unsupportedCookieAttributes = ['priority'];\n    const filterUnsupportedAttributes = (\n      cookie: Protocol.Network.Cookie\n    ): Protocol.Network.Cookie => {\n      for (const attr of unsupportedCookieAttributes) {\n        delete (cookie as unknown as Record<string, unknown>)[attr];\n      }\n      return cookie;\n    };\n    return originalCookies.map(filterUnsupportedAttributes);\n  }\n\n  override async deleteCookie(\n    ...cookies: Protocol.Network.DeleteCookiesRequest[]\n  ): Promise<void> {\n    const pageURL = this.url();\n    for (const cookie of cookies) {\n      const item = Object.assign({}, cookie);\n      if (!cookie.url && pageURL.startsWith('http')) {\n        item.url = pageURL;\n      }\n      await this.#primaryTargetClient.send('Network.deleteCookies', item);\n    }\n  }\n\n  override async setCookie(\n    ...cookies: Protocol.Network.CookieParam[]\n  ): Promise<void> {\n    const pageURL = this.url();\n    const startsWithHTTP = pageURL.startsWith('http');\n    const items = cookies.map(cookie => {\n      const item = Object.assign({}, cookie);\n      if (!item.url && startsWithHTTP) {\n        item.url = pageURL;\n      }\n      assert(\n        item.url !== 'about:blank',\n        `Blank page can not have cookie \"${item.name}\"`\n      );\n      assert(\n        !String.prototype.startsWith.call(item.url || '', 'data:'),\n        `Data URL page can not have cookie \"${item.name}\"`\n      );\n      return item;\n    });\n    await this.deleteCookie(...items);\n    if (items.length) {\n      await this.#primaryTargetClient.send('Network.setCookies', {\n        cookies: items,\n      });\n    }\n  }\n\n  override async exposeFunction(\n    name: string,\n    pptrFunction: Function | {default: Function}\n  ): Promise<void> {\n    if (this.#bindings.has(name)) {\n      throw new Error(\n        `Failed to add page binding with name ${name}: window['${name}'] already exists!`\n      );\n    }\n\n    let binding: Binding;\n    switch (typeof pptrFunction) {\n      case 'function':\n        binding = new Binding(\n          name,\n          pptrFunction as (...args: unknown[]) => unknown\n        );\n        break;\n      default:\n        binding = new Binding(\n          name,\n          pptrFunction.default as (...args: unknown[]) => unknown\n        );\n        break;\n    }\n\n    this.#bindings.set(name, binding);\n\n    const expression = pageBindingInitString('exposedFun', name);\n    await this.#primaryTargetClient.send('Runtime.addBinding', {name});\n    const {identifier} = await this.#primaryTargetClient.send(\n      'Page.addScriptToEvaluateOnNewDocument',\n      {\n        source: expression,\n      }\n    );\n\n    this.#exposedFunctions.set(name, identifier);\n\n    await Promise.all(\n      this.frames().map(frame => {\n        return frame.evaluate(expression).catch(debugError);\n      })\n    );\n  }\n\n  override async removeExposedFunction(name: string): Promise<void> {\n    const exposedFun = this.#exposedFunctions.get(name);\n    if (!exposedFun) {\n      throw new Error(\n        `Failed to remove page binding with name ${name}: window['${name}'] does not exists!`\n      );\n    }\n\n    await this.#primaryTargetClient.send('Runtime.removeBinding', {name});\n    await this.removeScriptToEvaluateOnNewDocument(exposedFun);\n\n    await Promise.all(\n      this.frames().map(frame => {\n        return frame\n          .evaluate(name => {\n            // Removes the dangling Puppeteer binding wrapper.\n            // @ts-expect-error: In a different context.\n            globalThis[name] = undefined;\n          }, name)\n          .catch(debugError);\n      })\n    );\n\n    this.#exposedFunctions.delete(name);\n    this.#bindings.delete(name);\n  }\n\n  override async authenticate(credentials: Credentials): Promise<void> {\n    return await this.#frameManager.networkManager.authenticate(credentials);\n  }\n\n  override async setExtraHTTPHeaders(\n    headers: Record<string, string>\n  ): Promise<void> {\n    return await this.#frameManager.networkManager.setExtraHTTPHeaders(headers);\n  }\n\n  override async setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void> {\n    return await this.#frameManager.networkManager.setUserAgent(\n      userAgent,\n      userAgentMetadata\n    );\n  }\n\n  override async metrics(): Promise<Metrics> {\n    const response = await this.#primaryTargetClient.send(\n      'Performance.getMetrics'\n    );\n    return this.#buildMetricsObject(response.metrics);\n  }\n\n  #emitMetrics(event: Protocol.Performance.MetricsEvent): void {\n    this.emit(PageEvent.Metrics, {\n      title: event.title,\n      metrics: this.#buildMetricsObject(event.metrics),\n    });\n  }\n\n  #buildMetricsObject(metrics?: Protocol.Performance.Metric[]): Metrics {\n    const result: Record<\n      Protocol.Performance.Metric['name'],\n      Protocol.Performance.Metric['value']\n    > = {};\n    for (const metric of metrics || []) {\n      if (supportedMetrics.has(metric.name)) {\n        result[metric.name] = metric.value;\n      }\n    }\n    return result;\n  }\n\n  #handleException(exception: Protocol.Runtime.ExceptionThrownEvent): void {\n    this.emit(\n      PageEvent.PageError,\n      createClientError(exception.exceptionDetails)\n    );\n  }\n\n  async #onConsoleAPI(\n    event: Protocol.Runtime.ConsoleAPICalledEvent\n  ): Promise<void> {\n    if (event.executionContextId === 0) {\n      // DevTools protocol stores the last 1000 console messages. These\n      // messages are always reported even for removed execution contexts. In\n      // this case, they are marked with executionContextId = 0 and are\n      // reported upon enabling Runtime agent.\n      //\n      // Ignore these messages since:\n      // - there's no execution context we can use to operate with message\n      //   arguments\n      // - these messages are reported before Puppeteer clients can subscribe\n      //   to the 'console'\n      //   page event.\n      //\n      // @see https://github.com/puppeteer/puppeteer/issues/3865\n      return;\n    }\n    const context = this.#frameManager.getExecutionContextById(\n      event.executionContextId,\n      this.#primaryTargetClient\n    );\n    if (!context) {\n      debugError(\n        new Error(\n          `ExecutionContext not found for a console message: ${JSON.stringify(\n            event\n          )}`\n        )\n      );\n      return;\n    }\n    const values = event.args.map(arg => {\n      return createCdpHandle(context._world, arg);\n    });\n    this.#addConsoleMessage(event.type, values, event.stackTrace);\n  }\n\n  async #onBindingCalled(\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> {\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'exposedFun') {\n      return;\n    }\n\n    const context = this.#frameManager.executionContextById(\n      event.executionContextId,\n      this.#primaryTargetClient\n    );\n    if (!context) {\n      return;\n    }\n\n    const binding = this.#bindings.get(name);\n    await binding?.run(context, seq, args, isTrivial);\n  }\n\n  #addConsoleMessage(\n    eventType: ConsoleMessageType,\n    args: JSHandle[],\n    stackTrace?: Protocol.Runtime.StackTrace\n  ): void {\n    if (!this.listenerCount(PageEvent.Console)) {\n      args.forEach(arg => {\n        return arg.dispose();\n      });\n      return;\n    }\n    const textTokens = [];\n    // eslint-disable-next-line max-len -- The comment is long.\n    // eslint-disable-next-line rulesdir/use-using -- These are not owned by this function.\n    for (const arg of args) {\n      const remoteObject = arg.remoteObject();\n      if (remoteObject.objectId) {\n        textTokens.push(arg.toString());\n      } else {\n        textTokens.push(valueFromRemoteObject(remoteObject));\n      }\n    }\n    const stackTraceLocations = [];\n    if (stackTrace) {\n      for (const callFrame of stackTrace.callFrames) {\n        stackTraceLocations.push({\n          url: callFrame.url,\n          lineNumber: callFrame.lineNumber,\n          columnNumber: callFrame.columnNumber,\n        });\n      }\n    }\n    const message = new ConsoleMessage(\n      eventType,\n      textTokens.join(' '),\n      args,\n      stackTraceLocations\n    );\n    this.emit(PageEvent.Console, message);\n  }\n\n  #onDialog(event: Protocol.Page.JavascriptDialogOpeningEvent): void {\n    const type = validateDialogType(event.type);\n    const dialog = new CdpDialog(\n      this.#primaryTargetClient,\n      type,\n      event.message,\n      event.defaultPrompt\n    );\n    this.emit(PageEvent.Dialog, dialog);\n  }\n\n  override async reload(\n    options?: WaitForOptions\n  ): Promise<HTTPResponse | null> {\n    const [result] = await Promise.all([\n      this.waitForNavigation(options),\n      this.#primaryTargetClient.send('Page.reload'),\n    ]);\n\n    return result;\n  }\n\n  override async createCDPSession(): Promise<CDPSession> {\n    return await this.target().createCDPSession();\n  }\n\n  override async waitForRequest(\n    urlOrPredicate: string | ((req: HTTPRequest) => boolean | Promise<boolean>),\n    options: {timeout?: number} = {}\n  ): Promise<HTTPRequest> {\n    const {timeout = this._timeoutSettings.timeout()} = options;\n    return await waitForHTTP(\n      this.#frameManager.networkManager,\n      NetworkManagerEvent.Request,\n      urlOrPredicate,\n      timeout,\n      this.#sessionCloseDeferred\n    );\n  }\n\n  override async waitForResponse(\n    urlOrPredicate:\n      | string\n      | ((res: HTTPResponse) => boolean | Promise<boolean>),\n    options: {timeout?: number} = {}\n  ): Promise<HTTPResponse> {\n    const {timeout = this._timeoutSettings.timeout()} = options;\n    return await waitForHTTP(\n      this.#frameManager.networkManager,\n      NetworkManagerEvent.Response,\n      urlOrPredicate,\n      timeout,\n      this.#sessionCloseDeferred\n    );\n  }\n\n  override async waitForNetworkIdle(\n    options: {idleTime?: number; timeout?: number} = {}\n  ): Promise<void> {\n    const {\n      idleTime = NETWORK_IDLE_TIME,\n      timeout: ms = this._timeoutSettings.timeout(),\n    } = options;\n\n    await firstValueFrom(\n      this._waitForNetworkIdle(\n        this.#frameManager.networkManager,\n        idleTime\n      ).pipe(\n        raceWith(timeout(ms), from(this.#sessionCloseDeferred.valueOrThrow()))\n      )\n    );\n  }\n\n  override async goBack(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.#go(-1, options);\n  }\n\n  override async goForward(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.#go(+1, options);\n  }\n\n  async #go(\n    delta: number,\n    options: WaitForOptions\n  ): Promise<HTTPResponse | null> {\n    const history = await this.#primaryTargetClient.send(\n      'Page.getNavigationHistory'\n    );\n    const entry = history.entries[history.currentIndex + delta];\n    if (!entry) {\n      return null;\n    }\n    const result = await Promise.all([\n      this.waitForNavigation(options),\n      this.#primaryTargetClient.send('Page.navigateToHistoryEntry', {\n        entryId: entry.id,\n      }),\n    ]);\n    return result[0];\n  }\n\n  override async bringToFront(): Promise<void> {\n    await this.#primaryTargetClient.send('Page.bringToFront');\n  }\n\n  override async setJavaScriptEnabled(enabled: boolean): Promise<void> {\n    return await this.#emulationManager.setJavaScriptEnabled(enabled);\n  }\n\n  override async setBypassCSP(enabled: boolean): Promise<void> {\n    await this.#primaryTargetClient.send('Page.setBypassCSP', {enabled});\n  }\n\n  override async emulateMediaType(type?: string): Promise<void> {\n    return await this.#emulationManager.emulateMediaType(type);\n  }\n\n  override async emulateCPUThrottling(factor: number | null): Promise<void> {\n    return await this.#emulationManager.emulateCPUThrottling(factor);\n  }\n\n  override async emulateMediaFeatures(\n    features?: MediaFeature[]\n  ): Promise<void> {\n    return await this.#emulationManager.emulateMediaFeatures(features);\n  }\n\n  override async emulateTimezone(timezoneId?: string): Promise<void> {\n    return await this.#emulationManager.emulateTimezone(timezoneId);\n  }\n\n  override async emulateIdleState(overrides?: {\n    isUserActive: boolean;\n    isScreenUnlocked: boolean;\n  }): Promise<void> {\n    return await this.#emulationManager.emulateIdleState(overrides);\n  }\n\n  override async emulateVisionDeficiency(\n    type?: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest['type']\n  ): Promise<void> {\n    return await this.#emulationManager.emulateVisionDeficiency(type);\n  }\n\n  override async setViewport(viewport: Viewport): Promise<void> {\n    const needsReload = await this.#emulationManager.emulateViewport(viewport);\n    this.#viewport = viewport;\n    if (needsReload) {\n      await this.reload();\n    }\n  }\n\n  override viewport(): Viewport | null {\n    return this.#viewport;\n  }\n\n  override async evaluateOnNewDocument<\n    Params extends unknown[],\n    Func extends (...args: Params) => unknown = (...args: Params) => unknown,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<NewDocumentScriptEvaluation> {\n    const source = evaluationString(pageFunction, ...args);\n    const {identifier} = await this.#primaryTargetClient.send(\n      'Page.addScriptToEvaluateOnNewDocument',\n      {\n        source,\n      }\n    );\n\n    return {identifier};\n  }\n\n  override async removeScriptToEvaluateOnNewDocument(\n    identifier: string\n  ): Promise<void> {\n    await this.#primaryTargetClient.send(\n      'Page.removeScriptToEvaluateOnNewDocument',\n      {\n        identifier,\n      }\n    );\n  }\n\n  override async setCacheEnabled(enabled = true): Promise<void> {\n    await this.#frameManager.networkManager.setCacheEnabled(enabled);\n  }\n\n  override async _screenshot(\n    options: Readonly<ScreenshotOptions>\n  ): Promise<string> {\n    const {\n      fromSurface,\n      omitBackground,\n      optimizeForSpeed,\n      quality,\n      clip: userClip,\n      type,\n      captureBeyondViewport,\n    } = options;\n\n    const isFirefox =\n      this.target()._targetManager() instanceof FirefoxTargetManager;\n\n    await using stack = new AsyncDisposableStack();\n    // Firefox omits background by default; it's not configurable.\n    if (!isFirefox && omitBackground && (type === 'png' || type === 'webp')) {\n      await this.#emulationManager.setTransparentBackgroundColor();\n      stack.defer(async () => {\n        await this.#emulationManager\n          .resetDefaultBackgroundColor()\n          .catch(debugError);\n      });\n    }\n\n    let clip = userClip;\n    if (clip && !captureBeyondViewport) {\n      const viewport = await this.mainFrame()\n        .isolatedRealm()\n        .evaluate(() => {\n          const {\n            height,\n            pageLeft: x,\n            pageTop: y,\n            width,\n          } = window.visualViewport!;\n          return {x, y, height, width};\n        });\n      clip = getIntersectionRect(clip, viewport);\n    }\n\n    // We need to do these spreads because Firefox doesn't allow unknown options.\n    const {data} = await this.#primaryTargetClient.send(\n      'Page.captureScreenshot',\n      {\n        format: type,\n        ...(optimizeForSpeed ? {optimizeForSpeed} : {}),\n        ...(quality !== undefined ? {quality: Math.round(quality)} : {}),\n        clip: clip && {\n          ...clip,\n          scale: clip.scale ?? 1,\n        },\n        ...(!fromSurface ? {fromSurface} : {}),\n        captureBeyondViewport,\n      }\n    );\n    return data;\n  }\n\n  override async createPDFStream(options: PDFOptions = {}): Promise<Readable> {\n    const {\n      landscape,\n      displayHeaderFooter,\n      headerTemplate,\n      footerTemplate,\n      printBackground,\n      scale,\n      width: paperWidth,\n      height: paperHeight,\n      margin,\n      pageRanges,\n      preferCSSPageSize,\n      omitBackground,\n      timeout: ms,\n      tagged: generateTaggedPDF,\n    } = this._getPDFOptions(options);\n\n    if (omitBackground) {\n      await this.#emulationManager.setTransparentBackgroundColor();\n    }\n\n    const printCommandPromise = this.#primaryTargetClient.send(\n      'Page.printToPDF',\n      {\n        transferMode: 'ReturnAsStream',\n        landscape,\n        displayHeaderFooter,\n        headerTemplate,\n        footerTemplate,\n        printBackground,\n        scale,\n        paperWidth,\n        paperHeight,\n        marginTop: margin.top,\n        marginBottom: margin.bottom,\n        marginLeft: margin.left,\n        marginRight: margin.right,\n        pageRanges,\n        preferCSSPageSize,\n        generateTaggedPDF,\n      }\n    );\n\n    const result = await firstValueFrom(\n      from(printCommandPromise).pipe(raceWith(timeout(ms)))\n    );\n\n    if (omitBackground) {\n      await this.#emulationManager.resetDefaultBackgroundColor();\n    }\n\n    assert(result.stream, '`stream` is missing from `Page.printToPDF');\n    return await getReadableFromProtocolStream(\n      this.#primaryTargetClient,\n      result.stream\n    );\n  }\n\n  override async pdf(options: PDFOptions = {}): Promise<Buffer> {\n    const {path = undefined} = options;\n    const readable = await this.createPDFStream(options);\n    const buffer = await getReadableAsBuffer(readable, path);\n    assert(buffer, 'Could not create buffer');\n    return buffer;\n  }\n\n  override async close(\n    options: {runBeforeUnload?: boolean} = {runBeforeUnload: undefined}\n  ): Promise<void> {\n    const connection = this.#primaryTargetClient.connection();\n    assert(\n      connection,\n      'Protocol error: Connection closed. Most likely the page has been closed.'\n    );\n    const runBeforeUnload = !!options.runBeforeUnload;\n    if (runBeforeUnload) {\n      await this.#primaryTargetClient.send('Page.close');\n    } else {\n      await connection.send('Target.closeTarget', {\n        targetId: this.#primaryTarget._targetId,\n      });\n      await this.#tabTarget._isClosedDeferred.valueOrThrow();\n    }\n  }\n\n  override isClosed(): boolean {\n    return this.#closed;\n  }\n\n  override get mouse(): CdpMouse {\n    return this.#mouse;\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  override async waitForDevicePrompt(\n    options: WaitTimeoutOptions = {}\n  ): Promise<DeviceRequestPrompt> {\n    return await this.mainFrame().waitForDevicePrompt(options);\n  }\n}\n\nconst supportedMetrics = new Set<string>([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/** @see https://w3c.github.io/webdriver-bidi/#rectangle-intersection */\nfunction getIntersectionRect(\n  clip: Readonly<ScreenshotClip>,\n  viewport: Readonly<Protocol.DOM.Rect>\n): ScreenshotClip {\n  // Note these will already be normalized.\n  const x = Math.max(clip.x, viewport.x);\n  const y = Math.max(clip.y, viewport.y);\n  return {\n    x,\n    y,\n    width: Math.max(\n      Math.min(clip.x + clip.width, viewport.x + viewport.width) - x,\n      0\n    ),\n    height: Math.max(\n      Math.min(clip.y + clip.height, viewport.y + viewport.height) - y,\n      0\n    ),\n  };\n}\n"]},"metadata":{},"sourceType":"module"}