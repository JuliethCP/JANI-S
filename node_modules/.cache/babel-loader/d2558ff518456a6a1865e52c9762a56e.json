{"ast":null,"code":"var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\nFdSlicer.prototype.read = function (buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function (cb) {\n    fs.read(self.fd, buffer, offset, length, position, function (err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\nFdSlicer.prototype.write = function (buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function (cb) {\n    fs.write(self.fd, buffer, offset, length, position, function (err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\nFdSlicer.prototype.createReadStream = function (options) {\n  return new ReadStream(this, options);\n};\nFdSlicer.prototype.createWriteStream = function (options) {\n  return new WriteStream(this, options);\n};\nFdSlicer.prototype.ref = function () {\n  this.refCount += 1;\n};\nFdSlicer.prototype.unref = function () {\n  var self = this;\n  self.refCount -= 1;\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n  this.context = context;\n  this.context.ref();\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\nReadStream.prototype._read = function (n) {\n  var self = this;\n  if (self.destroyed) return;\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function (cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function (err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\nReadStream.prototype.destroy = function (err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n  this.context = context;\n  this.context.ref();\n  this.start = options.start || 0;\n  this.endOffset = options.end == null ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n  this.on('finish', this.destroy.bind(this));\n}\nWriteStream.prototype._write = function (buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function (cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function (err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\nWriteStream.prototype.destroy = function () {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\nBufferSlicer.prototype.read = function (buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = delta > 0 ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function () {\n    callback(null, written);\n  });\n};\nBufferSlicer.prototype.write = function (buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function () {\n    callback(null, length, buffer);\n  });\n};\nBufferSlicer.prototype.createReadStream = function (options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n  readStream.end();\n  readStream.destroy = function () {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\nBufferSlicer.prototype.createWriteStream = function (options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = options.end == null ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function (buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function () {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\nBufferSlicer.prototype.ref = function () {\n  this.refCount += 1;\n};\nBufferSlicer.prototype.unref = function () {\n  this.refCount -= 1;\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}","map":{"version":3,"names":["fs","require","util","stream","Readable","Writable","PassThrough","Pend","EventEmitter","exports","createFromBuffer","createFromFd","BufferSlicer","FdSlicer","inherits","fd","options","call","pend","max","refCount","autoClose","prototype","read","buffer","offset","length","position","callback","self","go","cb","err","bytesRead","write","written","createReadStream","ReadStream","createWriteStream","WriteStream","ref","unref","Error","close","onCloseDone","emit","context","start","endOffset","end","pos","destroyed","_read","n","toRead","Math","min","_readableState","highWaterMark","push","Buffer","destroy","slice","Infinity","bytesWritten","on","bind","_write","encoding","code","bytes","maxChunkSize","Number","MAX_SAFE_INTEGER","delta","copy","setImmediate","readStream","entireSlice","nextOffset","bufferSlicer","writeStream"],"sources":["D:/Julieth-Campos/PSO/node_modules/fd-slicer/index.js"],"sourcesContent":["var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer, options) {\n  EventEmitter.call(this);\n\n  options = options || {};\n  this.refCount = 0;\n  this.buffer = buffer;\n  this.maxChunkSize = options.maxChunkSize || Number.MAX_SAFE_INTEGER;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.destroyed = false;\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  // by the time this function returns, we'll be done.\n  readStream.pos = readStream.endOffset || this.buffer.length;\n\n  // respect the maxChunkSize option to slice up the chunk into smaller pieces.\n  var entireSlice = this.buffer.slice(readStream.start, readStream.pos);\n  var offset = 0;\n  while (true) {\n    var nextOffset = offset + this.maxChunkSize;\n    if (nextOffset >= entireSlice.length) {\n      // last chunk\n      if (offset < entireSlice.length) {\n        readStream.write(entireSlice.slice(offset, entireSlice.length));\n      }\n      break;\n    }\n    readStream.write(entireSlice.slice(offset, nextOffset));\n    offset = nextOffset;\n  }\n\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer, options) {\n  return new BufferSlicer(buffer, options);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}