{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n  var types = fork.use(types_1.default);\n  var getFieldNames = types.getFieldNames;\n  var getFieldValue = types.getFieldValue;\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isDate = types.builtInTypes.Date;\n  var isRegExp = types.builtInTypes.RegExp;\n  var hasOwn = Object.prototype.hasOwnProperty;\n  function astNodesAreEquivalent(a, b, problemPath) {\n    if (isArray.check(problemPath)) {\n      problemPath.length = 0;\n    } else {\n      problemPath = null;\n    }\n    return areEquivalent(a, b, problemPath);\n  }\n  astNodesAreEquivalent.assert = function (a, b) {\n    var problemPath = [];\n    if (!astNodesAreEquivalent(a, b, problemPath)) {\n      if (problemPath.length === 0) {\n        if (a !== b) {\n          throw new Error(\"Nodes must be equal\");\n        }\n      } else {\n        throw new Error(\"Nodes differ in the following path: \" + problemPath.map(subscriptForProperty).join(\"\"));\n      }\n    }\n  };\n  function subscriptForProperty(property) {\n    if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n      return \".\" + property;\n    }\n    return \"[\" + JSON.stringify(property) + \"]\";\n  }\n  function areEquivalent(a, b, problemPath) {\n    if (a === b) {\n      return true;\n    }\n    if (isArray.check(a)) {\n      return arraysAreEquivalent(a, b, problemPath);\n    }\n    if (isObject.check(a)) {\n      return objectsAreEquivalent(a, b, problemPath);\n    }\n    if (isDate.check(a)) {\n      return isDate.check(b) && +a === +b;\n    }\n    if (isRegExp.check(a)) {\n      return isRegExp.check(b) && a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase;\n    }\n    return a == b;\n  }\n  function arraysAreEquivalent(a, b, problemPath) {\n    isArray.assert(a);\n    var aLength = a.length;\n    if (!isArray.check(b) || b.length !== aLength) {\n      if (problemPath) {\n        problemPath.push(\"length\");\n      }\n      return false;\n    }\n    for (var i = 0; i < aLength; ++i) {\n      if (problemPath) {\n        problemPath.push(i);\n      }\n      if (i in a !== i in b) {\n        return false;\n      }\n      if (!areEquivalent(a[i], b[i], problemPath)) {\n        return false;\n      }\n      if (problemPath) {\n        var problemPathTail = problemPath.pop();\n        if (problemPathTail !== i) {\n          throw new Error(\"\" + problemPathTail);\n        }\n      }\n    }\n    return true;\n  }\n  function objectsAreEquivalent(a, b, problemPath) {\n    isObject.assert(a);\n    if (!isObject.check(b)) {\n      return false;\n    }\n    // Fast path for a common property of AST nodes.\n    if (a.type !== b.type) {\n      if (problemPath) {\n        problemPath.push(\"type\");\n      }\n      return false;\n    }\n    var aNames = getFieldNames(a);\n    var aNameCount = aNames.length;\n    var bNames = getFieldNames(b);\n    var bNameCount = bNames.length;\n    if (aNameCount === bNameCount) {\n      for (var i = 0; i < aNameCount; ++i) {\n        var name = aNames[i];\n        var aChild = getFieldValue(a, name);\n        var bChild = getFieldValue(b, name);\n        if (problemPath) {\n          problemPath.push(name);\n        }\n        if (!areEquivalent(aChild, bChild, problemPath)) {\n          return false;\n        }\n        if (problemPath) {\n          var problemPathTail = problemPath.pop();\n          if (problemPathTail !== name) {\n            throw new Error(\"\" + problemPathTail);\n          }\n        }\n      }\n      return true;\n    }\n    if (!problemPath) {\n      return false;\n    }\n    // Since aNameCount !== bNameCount, we need to find some name that's\n    // missing in aNames but present in bNames, or vice-versa.\n    var seenNames = Object.create(null);\n    for (i = 0; i < aNameCount; ++i) {\n      seenNames[aNames[i]] = true;\n    }\n    for (i = 0; i < bNameCount; ++i) {\n      name = bNames[i];\n      if (!hasOwn.call(seenNames, name)) {\n        problemPath.push(name);\n        return false;\n      }\n      delete seenNames[name];\n    }\n    for (name in seenNames) {\n      problemPath.push(name);\n      break;\n    }\n    return false;\n  }\n  return astNodesAreEquivalent;\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","default_1","fork","types","use","default","getFieldNames","getFieldValue","isArray","builtInTypes","array","isObject","object","isDate","Date","isRegExp","RegExp","hasOwn","prototype","hasOwnProperty","astNodesAreEquivalent","a","b","problemPath","check","length","areEquivalent","assert","Error","map","subscriptForProperty","join","property","test","JSON","stringify","arraysAreEquivalent","objectsAreEquivalent","source","global","multiline","ignoreCase","aLength","push","i","problemPathTail","pop","type","aNames","aNameCount","bNames","bNameCount","name","aChild","bChild","seenNames","create","call","module"],"sources":["D:/Julieth-Campos/PSO/node_modules/ast-types/lib/equiv.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nfunction default_1(fork) {\n    var types = fork.use(types_1.default);\n    var getFieldNames = types.getFieldNames;\n    var getFieldValue = types.getFieldValue;\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isDate = types.builtInTypes.Date;\n    var isRegExp = types.builtInTypes.RegExp;\n    var hasOwn = Object.prototype.hasOwnProperty;\n    function astNodesAreEquivalent(a, b, problemPath) {\n        if (isArray.check(problemPath)) {\n            problemPath.length = 0;\n        }\n        else {\n            problemPath = null;\n        }\n        return areEquivalent(a, b, problemPath);\n    }\n    astNodesAreEquivalent.assert = function (a, b) {\n        var problemPath = [];\n        if (!astNodesAreEquivalent(a, b, problemPath)) {\n            if (problemPath.length === 0) {\n                if (a !== b) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n            }\n            else {\n                throw new Error(\"Nodes differ in the following path: \" +\n                    problemPath.map(subscriptForProperty).join(\"\"));\n            }\n        }\n    };\n    function subscriptForProperty(property) {\n        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {\n            return \".\" + property;\n        }\n        return \"[\" + JSON.stringify(property) + \"]\";\n    }\n    function areEquivalent(a, b, problemPath) {\n        if (a === b) {\n            return true;\n        }\n        if (isArray.check(a)) {\n            return arraysAreEquivalent(a, b, problemPath);\n        }\n        if (isObject.check(a)) {\n            return objectsAreEquivalent(a, b, problemPath);\n        }\n        if (isDate.check(a)) {\n            return isDate.check(b) && (+a === +b);\n        }\n        if (isRegExp.check(a)) {\n            return isRegExp.check(b) && (a.source === b.source &&\n                a.global === b.global &&\n                a.multiline === b.multiline &&\n                a.ignoreCase === b.ignoreCase);\n        }\n        return a == b;\n    }\n    function arraysAreEquivalent(a, b, problemPath) {\n        isArray.assert(a);\n        var aLength = a.length;\n        if (!isArray.check(b) || b.length !== aLength) {\n            if (problemPath) {\n                problemPath.push(\"length\");\n            }\n            return false;\n        }\n        for (var i = 0; i < aLength; ++i) {\n            if (problemPath) {\n                problemPath.push(i);\n            }\n            if (i in a !== i in b) {\n                return false;\n            }\n            if (!areEquivalent(a[i], b[i], problemPath)) {\n                return false;\n            }\n            if (problemPath) {\n                var problemPathTail = problemPath.pop();\n                if (problemPathTail !== i) {\n                    throw new Error(\"\" + problemPathTail);\n                }\n            }\n        }\n        return true;\n    }\n    function objectsAreEquivalent(a, b, problemPath) {\n        isObject.assert(a);\n        if (!isObject.check(b)) {\n            return false;\n        }\n        // Fast path for a common property of AST nodes.\n        if (a.type !== b.type) {\n            if (problemPath) {\n                problemPath.push(\"type\");\n            }\n            return false;\n        }\n        var aNames = getFieldNames(a);\n        var aNameCount = aNames.length;\n        var bNames = getFieldNames(b);\n        var bNameCount = bNames.length;\n        if (aNameCount === bNameCount) {\n            for (var i = 0; i < aNameCount; ++i) {\n                var name = aNames[i];\n                var aChild = getFieldValue(a, name);\n                var bChild = getFieldValue(b, name);\n                if (problemPath) {\n                    problemPath.push(name);\n                }\n                if (!areEquivalent(aChild, bChild, problemPath)) {\n                    return false;\n                }\n                if (problemPath) {\n                    var problemPathTail = problemPath.pop();\n                    if (problemPathTail !== name) {\n                        throw new Error(\"\" + problemPathTail);\n                    }\n                }\n            }\n            return true;\n        }\n        if (!problemPath) {\n            return false;\n        }\n        // Since aNameCount !== bNameCount, we need to find some name that's\n        // missing in aNames but present in bNames, or vice-versa.\n        var seenNames = Object.create(null);\n        for (i = 0; i < aNameCount; ++i) {\n            seenNames[aNames[i]] = true;\n        }\n        for (i = 0; i < bNameCount; ++i) {\n            name = bNames[i];\n            if (!hasOwn.call(seenNames, name)) {\n                problemPath.push(name);\n                return false;\n            }\n            delete seenNames[name];\n        }\n        for (name in seenNames) {\n            problemPath.push(name);\n            break;\n        }\n        return false;\n    }\n    return astNodesAreEquivalent;\n}\nexports.default = default_1;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}