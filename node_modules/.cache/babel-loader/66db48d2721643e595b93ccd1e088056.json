{"ast":null,"code":"import { headersArray, HTTPRequest, InterceptResolutionAction, STATUS_TEXTS } from '../api/HTTPRequest.js';\nimport { debugError, isString } from '../common/util.js';\nimport { assert } from '../util/assert.js';\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  #client;\n  #isNavigationRequest;\n  #allowInterception;\n  #interceptionHandled = false;\n  #url;\n  #resourceType;\n  #method;\n  #postData;\n  #headers = {};\n  #frame;\n  #continueRequestOverrides;\n  #responseForRequest = null;\n  #abortErrorReason = null;\n  #interceptResolutionState = {\n    action: InterceptResolutionAction.None\n  };\n  #interceptHandlers;\n  #initiator;\n  get client() {\n    return this.#client;\n  }\n  constructor(client, frame, interceptionId, allowInterception, data, redirectChain) {\n    super();\n    this.#client = client;\n    this._requestId = data.requestId;\n    this.#isNavigationRequest = data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase();\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n  url() {\n    return this.#url;\n  }\n  continueRequestOverrides() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n  responseForRequest() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n  abortErrorReason() {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n  interceptResolutionState() {\n    if (!this.#allowInterception) {\n      return {\n        action: InterceptResolutionAction.Disabled\n      };\n    }\n    if (this.#interceptionHandled) {\n      return {\n        action: InterceptResolutionAction.AlreadyHandled\n      };\n    }\n    return {\n      ...this.#interceptResolutionState\n    };\n  }\n  isInterceptResolutionHandled() {\n    return this.#interceptionHandled;\n  }\n  enqueueInterceptAction(pendingHandler) {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n  async finalizeInterceptions() {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {\n      action\n    } = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this.#respond(this.#responseForRequest);\n      case 'continue':\n        return await this.#continue(this.#continueRequestOverrides);\n    }\n  }\n  resourceType() {\n    return this.#resourceType;\n  }\n  method() {\n    return this.#method;\n  }\n  postData() {\n    return this.#postData;\n  }\n  headers() {\n    return this.#headers;\n  }\n  response() {\n    return this._response;\n  }\n  frame() {\n    return this.#frame;\n  }\n  isNavigationRequest() {\n    return this.#isNavigationRequest;\n  }\n  initiator() {\n    return this.#initiator;\n  }\n  redirectChain() {\n    return this._redirectChain.slice();\n  }\n  failure() {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText\n    };\n  }\n  async continue() {\n    let overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let priority = arguments.length > 1 ? arguments[1] : undefined;\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort' || this.#interceptResolutionState.action === 'respond') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n  async #continue() {\n    let overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      url,\n      method,\n      postData,\n      headers\n    } = overrides;\n    this.#interceptionHandled = true;\n    const postDataBinaryBase64 = postData ? Buffer.from(postData).toString('base64') : undefined;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.continueRequest');\n    }\n    await this.#client.send('Fetch.continueRequest', {\n      requestId: this._interceptionId,\n      url,\n      method,\n      postData: postDataBinaryBase64,\n      headers: headers ? headersArray(headers) : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async respond(response, priority) {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (this.#interceptResolutionState.priority === undefined || priority > this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n  async #respond(response) {\n    this.#interceptionHandled = true;\n    const responseBody = response.body && isString(response.body) ? Buffer.from(response.body) : response.body || null;\n    const responseHeaders = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n        responseHeaders[header.toLowerCase()] = Array.isArray(value) ? value.map(item => {\n          return String(item);\n        }) : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(Buffer.byteLength(responseBody));\n    }\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest');\n    }\n    await this.#client.send('Fetch.fulfillRequest', {\n      requestId: this._interceptionId,\n      responseCode: status,\n      responsePhrase: STATUS_TEXTS[status],\n      responseHeaders: headersArray(responseHeaders),\n      body: responseBody ? responseBody.toString('base64') : undefined\n    }).catch(error => {\n      this.#interceptionHandled = false;\n      return handleError(error);\n    });\n  }\n  async abort() {\n    let errorCode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'failed';\n    let priority = arguments.length > 1 ? arguments[1] : undefined;\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (this.#interceptResolutionState.priority === undefined || priority >= this.#interceptResolutionState.priority) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority\n      };\n      return;\n    }\n  }\n  async #abort(errorReason) {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error('HTTPRequest is missing _interceptionId needed for Fetch.failRequest');\n    }\n    await this.#client.send('Fetch.failRequest', {\n      requestId: this._interceptionId,\n      errorReason: errorReason || 'Failed'\n    }).catch(handleError);\n  }\n}\nconst errorReasons = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed'\n};\nasync function handleError(error) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}","map":{"version":3,"mappings":"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","names":["headersArray","HTTPRequest","InterceptResolutionAction","STATUS_TEXTS","debugError","isString","assert","CdpHTTPRequest","action","None","client","constructor","frame","interceptionId","allowInterception","data","redirectChain","_requestId","requestId","loaderId","type","_interceptionId","request","url","toLowerCase","method","postData","_redirectChain","initiator","key","value","Object","entries","headers","continueRequestOverrides","responseForRequest","abortErrorReason","interceptResolutionState","Disabled","AlreadyHandled","isInterceptResolutionHandled","enqueueInterceptAction","pendingHandler","push","finalizeInterceptions","reduce","promiseChain","interceptAction","then","Promise","resolve","Error","resourceType","response","_response","isNavigationRequest","slice","failure","_failureText","errorText","continue","overrides","priority","startsWith","undefined","Continue","postDataBinaryBase64","Buffer","from","toString","send","catch","error","handleError","respond","Respond","responseBody","body","responseHeaders","header","keys","Array","isArray","map","item","String","contentType","byteLength","status","responseCode","responsePhrase","abort","errorCode","errorReason","errorReasons","Abort","aborted","accessdenied","addressunreachable","blockedbyclient","blockedbyresponse","connectionaborted","connectionclosed","connectionfailed","connectionrefused","connectionreset","internetdisconnected","namenotresolved","timedout","failed","includes","originalMessage"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\HTTPRequest.ts"],"sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Frame} from '../api/Frame.js';\nimport {\n  type ContinueRequestOverrides,\n  type ErrorCode,\n  headersArray,\n  HTTPRequest,\n  InterceptResolutionAction,\n  type InterceptResolutionState,\n  type ResourceType,\n  type ResponseForRequest,\n  STATUS_TEXTS,\n} from '../api/HTTPRequest.js';\nimport type {ProtocolError} from '../common/Errors.js';\nimport {debugError, isString} from '../common/util.js';\nimport {assert} from '../util/assert.js';\n\nimport type {CdpHTTPResponse} from './HTTPResponse.js';\n\n/**\n * @internal\n */\nexport class CdpHTTPRequest extends HTTPRequest {\n  declare _redirectChain: CdpHTTPRequest[];\n  declare _response: CdpHTTPResponse | null;\n\n  #client: CDPSession;\n  #isNavigationRequest: boolean;\n  #allowInterception: boolean;\n  #interceptionHandled = false;\n  #url: string;\n  #resourceType: ResourceType;\n\n  #method: string;\n  #postData?: string;\n  #headers: Record<string, string> = {};\n  #frame: Frame | null;\n  #continueRequestOverrides: ContinueRequestOverrides;\n  #responseForRequest: Partial<ResponseForRequest> | null = null;\n  #abortErrorReason: Protocol.Network.ErrorReason | null = null;\n  #interceptResolutionState: InterceptResolutionState = {\n    action: InterceptResolutionAction.None,\n  };\n  #interceptHandlers: Array<() => void | PromiseLike<any>>;\n  #initiator?: Protocol.Network.Initiator;\n\n  override get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    frame: Frame | null,\n    interceptionId: string | undefined,\n    allowInterception: boolean,\n    data: {\n      /**\n       * Request identifier.\n       */\n      requestId: Protocol.Network.RequestId;\n      /**\n       * Loader identifier. Empty string if the request is fetched from worker.\n       */\n      loaderId?: Protocol.Network.LoaderId;\n      /**\n       * URL of the document this request is loaded for.\n       */\n      documentURL?: string;\n      /**\n       * Request data.\n       */\n      request: Protocol.Network.Request;\n      /**\n       * Request initiator.\n       */\n      initiator?: Protocol.Network.Initiator;\n      /**\n       * Type of this resource.\n       */\n      type?: Protocol.Network.ResourceType;\n    },\n    redirectChain: CdpHTTPRequest[]\n  ) {\n    super();\n    this.#client = client;\n    this._requestId = data.requestId;\n    this.#isNavigationRequest =\n      data.requestId === data.loaderId && data.type === 'Document';\n    this._interceptionId = interceptionId;\n    this.#allowInterception = allowInterception;\n    this.#url = data.request.url;\n    this.#resourceType = (data.type || 'other').toLowerCase() as ResourceType;\n    this.#method = data.request.method;\n    this.#postData = data.request.postData;\n    this.#frame = frame;\n    this._redirectChain = redirectChain;\n    this.#continueRequestOverrides = {};\n    this.#interceptHandlers = [];\n    this.#initiator = data.initiator;\n\n    for (const [key, value] of Object.entries(data.request.headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n  }\n\n  override url(): string {\n    return this.#url;\n  }\n\n  override continueRequestOverrides(): ContinueRequestOverrides {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#continueRequestOverrides;\n  }\n\n  override responseForRequest(): Partial<ResponseForRequest> | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#responseForRequest;\n  }\n\n  override abortErrorReason(): Protocol.Network.ErrorReason | null {\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    return this.#abortErrorReason;\n  }\n\n  override interceptResolutionState(): InterceptResolutionState {\n    if (!this.#allowInterception) {\n      return {action: InterceptResolutionAction.Disabled};\n    }\n    if (this.#interceptionHandled) {\n      return {action: InterceptResolutionAction.AlreadyHandled};\n    }\n    return {...this.#interceptResolutionState};\n  }\n\n  override isInterceptResolutionHandled(): boolean {\n    return this.#interceptionHandled;\n  }\n\n  enqueueInterceptAction(\n    pendingHandler: () => void | PromiseLike<unknown>\n  ): void {\n    this.#interceptHandlers.push(pendingHandler);\n  }\n\n  override async finalizeInterceptions(): Promise<void> {\n    await this.#interceptHandlers.reduce((promiseChain, interceptAction) => {\n      return promiseChain.then(interceptAction);\n    }, Promise.resolve());\n    const {action} = this.interceptResolutionState();\n    switch (action) {\n      case 'abort':\n        return await this.#abort(this.#abortErrorReason);\n      case 'respond':\n        if (this.#responseForRequest === null) {\n          throw new Error('Response is missing for the interception');\n        }\n        return await this.#respond(this.#responseForRequest);\n      case 'continue':\n        return await this.#continue(this.#continueRequestOverrides);\n    }\n  }\n\n  override resourceType(): ResourceType {\n    return this.#resourceType;\n  }\n\n  override method(): string {\n    return this.#method;\n  }\n\n  override postData(): string | undefined {\n    return this.#postData;\n  }\n\n  override headers(): Record<string, string> {\n    return this.#headers;\n  }\n\n  override response(): CdpHTTPResponse | null {\n    return this._response;\n  }\n\n  override frame(): Frame | null {\n    return this.#frame;\n  }\n\n  override isNavigationRequest(): boolean {\n    return this.#isNavigationRequest;\n  }\n\n  override initiator(): Protocol.Network.Initiator | undefined {\n    return this.#initiator;\n  }\n\n  override redirectChain(): CdpHTTPRequest[] {\n    return this._redirectChain.slice();\n  }\n\n  override failure(): {errorText: string} | null {\n    if (!this._failureText) {\n      return null;\n    }\n    return {\n      errorText: this._failureText,\n    };\n  }\n\n  override async continue(\n    overrides: ContinueRequestOverrides = {},\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#continue(overrides);\n    }\n    this.#continueRequestOverrides = overrides;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Continue,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (\n        this.#interceptResolutionState.action === 'abort' ||\n        this.#interceptResolutionState.action === 'respond'\n      ) {\n        return;\n      }\n      this.#interceptResolutionState.action =\n        InterceptResolutionAction.Continue;\n    }\n    return;\n  }\n\n  async #continue(overrides: ContinueRequestOverrides = {}): Promise<void> {\n    const {url, method, postData, headers} = overrides;\n    this.#interceptionHandled = true;\n\n    const postDataBinaryBase64 = postData\n      ? Buffer.from(postData).toString('base64')\n      : undefined;\n\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.continueRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.continueRequest', {\n        requestId: this._interceptionId,\n        url,\n        method,\n        postData: postDataBinaryBase64,\n        headers: headers ? headersArray(headers) : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async respond(\n    response: Partial<ResponseForRequest>,\n    priority?: number\n  ): Promise<void> {\n    // Mocking responses for dataURL requests is not currently supported.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#respond(response);\n    }\n    this.#responseForRequest = response;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority > this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Respond,\n        priority,\n      };\n      return;\n    }\n    if (priority === this.#interceptResolutionState.priority) {\n      if (this.#interceptResolutionState.action === 'abort') {\n        return;\n      }\n      this.#interceptResolutionState.action = InterceptResolutionAction.Respond;\n    }\n  }\n\n  async #respond(response: Partial<ResponseForRequest>): Promise<void> {\n    this.#interceptionHandled = true;\n\n    const responseBody: Buffer | null =\n      response.body && isString(response.body)\n        ? Buffer.from(response.body)\n        : (response.body as Buffer) || null;\n\n    const responseHeaders: Record<string, string | string[]> = {};\n    if (response.headers) {\n      for (const header of Object.keys(response.headers)) {\n        const value = response.headers[header];\n\n        responseHeaders[header.toLowerCase()] = Array.isArray(value)\n          ? value.map(item => {\n              return String(item);\n            })\n          : String(value);\n      }\n    }\n    if (response.contentType) {\n      responseHeaders['content-type'] = response.contentType;\n    }\n    if (responseBody && !('content-length' in responseHeaders)) {\n      responseHeaders['content-length'] = String(\n        Buffer.byteLength(responseBody)\n      );\n    }\n\n    const status = response.status || 200;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.fulfillRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.fulfillRequest', {\n        requestId: this._interceptionId,\n        responseCode: status,\n        responsePhrase: STATUS_TEXTS[status],\n        responseHeaders: headersArray(responseHeaders),\n        body: responseBody ? responseBody.toString('base64') : undefined,\n      })\n      .catch(error => {\n        this.#interceptionHandled = false;\n        return handleError(error);\n      });\n  }\n\n  override async abort(\n    errorCode: ErrorCode = 'failed',\n    priority?: number\n  ): Promise<void> {\n    // Request interception is not supported for data: urls.\n    if (this.#url.startsWith('data:')) {\n      return;\n    }\n    const errorReason = errorReasons[errorCode];\n    assert(errorReason, 'Unknown error code: ' + errorCode);\n    assert(this.#allowInterception, 'Request Interception is not enabled!');\n    assert(!this.#interceptionHandled, 'Request is already handled!');\n    if (priority === undefined) {\n      return await this.#abort(errorReason);\n    }\n    this.#abortErrorReason = errorReason;\n    if (\n      this.#interceptResolutionState.priority === undefined ||\n      priority >= this.#interceptResolutionState.priority\n    ) {\n      this.#interceptResolutionState = {\n        action: InterceptResolutionAction.Abort,\n        priority,\n      };\n      return;\n    }\n  }\n\n  async #abort(\n    errorReason: Protocol.Network.ErrorReason | null\n  ): Promise<void> {\n    this.#interceptionHandled = true;\n    if (this._interceptionId === undefined) {\n      throw new Error(\n        'HTTPRequest is missing _interceptionId needed for Fetch.failRequest'\n      );\n    }\n    await this.#client\n      .send('Fetch.failRequest', {\n        requestId: this._interceptionId,\n        errorReason: errorReason || 'Failed',\n      })\n      .catch(handleError);\n  }\n}\n\nconst errorReasons: Record<ErrorCode, Protocol.Network.ErrorReason> = {\n  aborted: 'Aborted',\n  accessdenied: 'AccessDenied',\n  addressunreachable: 'AddressUnreachable',\n  blockedbyclient: 'BlockedByClient',\n  blockedbyresponse: 'BlockedByResponse',\n  connectionaborted: 'ConnectionAborted',\n  connectionclosed: 'ConnectionClosed',\n  connectionfailed: 'ConnectionFailed',\n  connectionrefused: 'ConnectionRefused',\n  connectionreset: 'ConnectionReset',\n  internetdisconnected: 'InternetDisconnected',\n  namenotresolved: 'NameNotResolved',\n  timedout: 'TimedOut',\n  failed: 'Failed',\n} as const;\n\nasync function handleError(error: ProtocolError) {\n  if (['Invalid header'].includes(error.originalMessage)) {\n    throw error;\n  }\n  // In certain cases, protocol will return error if the request was\n  // already canceled or the page was closed. We should tolerate these\n  // errors.\n  debugError(error);\n}\n"]},"metadata":{},"sourceType":"module"}