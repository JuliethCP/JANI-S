{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.concat = exports.evalOptionsToFlags = exports.DefaultIntrinsics = void 0;\nconst types_ffi_1 = require(\"./types-ffi\");\nconst UnstableSymbol = Symbol(\"Unstable\");\n// For informational purposes\nconst DefaultIntrinsicsList = [\"BaseObjects\", \"Date\", \"Eval\", \"StringNormalize\", \"RegExp\", \"JSON\", \"Proxy\", \"MapSet\", \"TypedArrays\", \"Promise\"];\n/**\n * Work in progress.\n */\nexports.DefaultIntrinsics = Symbol(\"DefaultIntrinsics\");\n/** Convert [[ContextEvalOptions]] to a bitfield flags */\nfunction evalOptionsToFlags(evalOptions) {\n  if (typeof evalOptions === \"number\") {\n    return evalOptions;\n  }\n  if (evalOptions === undefined) {\n    return 0;\n  }\n  const {\n    type,\n    strict,\n    strip,\n    compileOnly,\n    backtraceBarrier\n  } = evalOptions;\n  let flags = 0;\n  if (type === \"global\") flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_GLOBAL;\n  if (type === \"module\") flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_MODULE;\n  if (strict) flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRICT;\n  if (strip) flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRIP;\n  if (compileOnly) flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY;\n  if (backtraceBarrier) flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER;\n  return flags;\n}\nexports.evalOptionsToFlags = evalOptionsToFlags;\nfunction concat() {\n  let result = [];\n  for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n    values[_key] = arguments[_key];\n  }\n  for (const value of values) {\n    if (value !== undefined) {\n      result = result.concat(value);\n    }\n  }\n  return result;\n}\nexports.concat = concat;","map":{"version":3,"mappings":";;;;;;AAMA;AA+FA,MAAMA,cAAc,GAAGC,MAAM,CAAC,UAAU,CAAC;AAwDzC;AACA,MAAMC,qBAAqB,GAAG,CAC5B,aAAa,EACb,MAAM,EACN,MAAM,EACN,iBAAiB,EACjB,QAAQ,EACR,MAAM,EACN,OAAO,EACP,QAAQ,EACR,aAAa,EACb,SAAS,CACD;AAEV;;;AAGaC,yBAAiB,GAAGF,MAAM,CAAC,mBAAmB,CAAC;AAwC5D;AACA,SAAgBG,kBAAkB,CAACC,WAAoD;EACrF,IAAI,OAAOA,WAAW,KAAK,QAAQ,EAAE;IACnC,OAAOA,WAAW;;EAGpB,IAAIA,WAAW,KAAKC,SAAS,EAAE;IAC7B,OAAO,CAAC;;EAGV,MAAM;IAAEC,IAAI;IAAEC,MAAM;IAAEC,KAAK;IAAEC,WAAW;IAAEC;EAAgB,CAAE,GAAGN,WAAW;EAC1E,IAAIO,KAAK,GAAG,CAAC;EACb,IAAIL,IAAI,KAAK,QAAQ,EAAEK,KAAK,IAAIC,qBAAS,CAACC,mBAAmB;EAC7D,IAAIP,IAAI,KAAK,QAAQ,EAAEK,KAAK,IAAIC,qBAAS,CAACE,mBAAmB;EAC7D,IAAIP,MAAM,EAAEI,KAAK,IAAIC,qBAAS,CAACG,mBAAmB;EAClD,IAAIP,KAAK,EAAEG,KAAK,IAAIC,qBAAS,CAACI,kBAAkB;EAChD,IAAIP,WAAW,EAAEE,KAAK,IAAIC,qBAAS,CAACK,yBAAyB;EAC7D,IAAIP,gBAAgB,EAAEC,KAAK,IAAIC,qBAAS,CAACM,8BAA8B;EACvE,OAAOP,KAAK;AACd;AAlBAT;AAyBA,SAAgBiB,MAAM,GAAyC;EAC7D,IAAIC,MAAM,GAAQ,EAAE;EAAA,kCADOC,MAAkC;IAAlCA,MAAkC;EAAA;EAE7D,KAAK,MAAMC,KAAK,IAAID,MAAM,EAAE;IAC1B,IAAIC,KAAK,KAAKjB,SAAS,EAAE;MACvBe,MAAM,GAAGA,MAAM,CAACD,MAAM,CAACG,KAAK,CAAC;;;EAGjC,OAAOF,MAAM;AACf;AARAlB","names":["UnstableSymbol","Symbol","DefaultIntrinsicsList","exports","evalOptionsToFlags","evalOptions","undefined","type","strict","strip","compileOnly","backtraceBarrier","flags","types_ffi_1","JS_EVAL_TYPE_GLOBAL","JS_EVAL_TYPE_MODULE","JS_EVAL_FLAG_STRICT","JS_EVAL_FLAG_STRIP","JS_EVAL_FLAG_COMPILE_ONLY","JS_EVAL_FLAG_BACKTRACE_BARRIER","concat","result","values","value"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\types.ts"],"sourcesContent":["import type { QuickJSFFI, QuickJSAsyncFFI } from \"./variants\"\nimport type { QuickJSContext } from \"./context\"\nimport type { SuccessOrFail, VmFunctionImplementation } from \"./vm-interface\"\nimport type { Disposable, Lifetime } from \"./lifetime\"\nimport type { QuickJSAsyncContext } from \"./context-asyncify\"\nimport type { InterruptHandler, QuickJSRuntime } from \"./runtime\"\nimport { EvalFlags, JSContextPointer, JSValueConstPointer, JSValuePointer } from \"./types-ffi\"\n\nexport type EitherFFI = QuickJSFFI | QuickJSAsyncFFI\n\n/**\n * A QuickJSHandle to a constant that will never change, and does not need to\n * be disposed.\n */\nexport type StaticJSValue = Lifetime<JSValueConstPointer, JSValueConstPointer, QuickJSRuntime>\n\n/**\n * A QuickJSHandle to a borrowed value that does not need to be disposed.\n *\n * In QuickJS, a JSValueConst is a \"borrowed\" reference that isn't owned by the\n * current scope. That means that the current scope should not `JS_FreeValue`\n * it, or retain a reference to it after the scope exits, because it may be\n * freed by its owner.\n *\n * quickjs-emscripten takes care of disposing JSValueConst references.\n */\nexport type JSValueConst = Lifetime<JSValueConstPointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * A owned QuickJSHandle that should be disposed or returned.\n *\n * The QuickJS interpreter passes Javascript values between functions as\n * `JSValue` structs that references some internal data. Because passing\n * structs cross the Empscripten FFI interfaces is bothersome, we use pointers\n * to these structs instead.\n *\n * A JSValue reference is \"owned\" in its scope. before exiting the scope, it\n * should be freed,  by calling `JS_FreeValue(ctx, js_value)`) or returned from\n * the scope. We extend that contract - a JSValuePointer (`JSValue*`) must also\n * be `free`d.\n *\n * You can do so from Javascript by calling the .dispose() method.\n */\nexport type JSValue = Lifetime<JSValuePointer, JSValuePointer, QuickJSRuntime>\n\n/**\n * Wraps a C pointer to a QuickJS JSValue, which represents a Javascript value inside\n * a QuickJS virtual machine.\n *\n * Values must not be shared between QuickJSContext instances.\n * You must dispose of any handles you create by calling the `.dispose()` method.\n */\nexport type QuickJSHandle = StaticJSValue | JSValue | JSValueConst\n\nexport type JSModuleExport =\n  | {\n      type: \"function\"\n      name: string\n      implementation: (vm: QuickJSContext) => VmFunctionImplementation<QuickJSHandle>\n    }\n  | { type: \"value\"; name: string; value: (vm: QuickJSContext) => QuickJSHandle }\n\nexport interface JSModuleDefinition {\n  name: string\n  exports: JSModuleExport[]\n}\n\nexport type JSModuleLoadSuccess = string\nexport type JSModuleLoadFailure = Error | QuickJSHandle\nexport type JSModuleLoadResult =\n  | JSModuleLoadSuccess\n  | SuccessOrFail<JSModuleLoadSuccess, JSModuleLoadFailure>\n\nexport interface JSModuleLoaderAsync {\n  /** Load module (async) */\n  (moduleName: string, context: QuickJSAsyncContext):\n    | JSModuleLoadResult\n    | Promise<JSModuleLoadResult>\n}\nexport interface JSModuleLoader {\n  /** Load module (sync) */\n  (moduleName: string, context: QuickJSContext): JSModuleLoadResult\n}\n\nexport type JSModuleNormalizeSuccess = string\nexport type JSModuleNormalizeFailure = Error | QuickJSHandle\nexport type JSModuleNormalizeResult =\n  | JSModuleNormalizeSuccess\n  | SuccessOrFail<JSModuleNormalizeSuccess, JSModuleNormalizeFailure>\n\nexport interface JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSAsyncContext):\n    | JSModuleNormalizeResult\n    | Promise<JSModuleNormalizeResult>\n}\nexport interface JSModuleNormalizer extends JSModuleNormalizerAsync {\n  (baseModuleName: string, requestedName: string, vm: QuickJSContext): JSModuleNormalizeResult\n}\n\ntype TODO<hint extends string = \"?\", typeHint = unknown> = never\n\nconst UnstableSymbol = Symbol(\"Unstable\")\n\nexport type PartiallyImplemented<T> = never &\n  T & {\n    [UnstableSymbol]: \"This feature may unimplemented, broken, throw errors, etc.\"\n  }\n\nexport interface RuntimeOptionsBase {\n  interruptHandler?: InterruptHandler\n  maxStackSizeBytes?: number\n  memoryLimitBytes?: number\n\n  promiseRejectionHandler?: TODO<\"JSHostPromiseRejectionTracker\">\n  runtimeInfo?: TODO<\"JS_SetRuntimeInfo\", string>\n  gcThreshold?: TODO<\"JS_SetGCThreshold\", number>\n  sharedArrayBufferFunctions?: TODO<\n    \"JS_SetJSSharedArrayBufferFunctions\",\n    { sab_alloc: TODO; sab_free: TODO; sab_dup: TODO; sab_opaque: TODO }\n  >\n\n  /**\n   * Extra lifetimes the runtime should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface RuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoader\n}\n\nexport interface AsyncRuntimeOptions extends RuntimeOptionsBase {\n  moduleLoader?: JSModuleLoaderAsync | JSModuleLoader\n}\n\n/**\n * Work in progress.\n */\nexport type Intrinsic =\n  | \"BaseObjects\"\n  | \"Date\"\n  | \"Eval\"\n  | \"StringNormalize\"\n  | \"RegExp\"\n  | \"RegExpCompiler\"\n  | \"JSON\"\n  | \"Proxy\"\n  | \"MapSet\"\n  | \"TypedArrays\"\n  | \"Promise\"\n  | \"BigInt\"\n  | \"BigFloat\"\n  | \"BigDecimal\"\n  | \"OperatorOverloading\"\n  | \"BignumExt\"\n\n// For informational purposes\nconst DefaultIntrinsicsList = [\n  \"BaseObjects\",\n  \"Date\",\n  \"Eval\",\n  \"StringNormalize\",\n  \"RegExp\",\n  \"JSON\",\n  \"Proxy\",\n  \"MapSet\",\n  \"TypedArrays\",\n  \"Promise\",\n] as const\n\n/**\n * Work in progress.\n */\nexport const DefaultIntrinsics = Symbol(\"DefaultIntrinsics\")\n\nexport interface ContextOptions {\n  /**\n   * What built-in objects and language features to enable?\n   * If unset, the default intrinsics will be used.\n   * To omit all intrinsics, pass an empty array.\n   */\n  intrinsics?: PartiallyImplemented<Intrinsic[]> | typeof DefaultIntrinsics\n\n  /**\n   * Wrap the provided context instead of constructing a new one.\n   * @private\n   */\n  contextPointer?: JSContextPointer\n\n  /**\n   * Extra lifetimes the context should dispose of after it is destroyed.\n   * @private\n   */\n  ownedLifetimes?: Disposable[]\n}\n\nexport interface ContextEvalOptions {\n  /** Global code (default) */\n  type?: \"global\" | \"module\"\n  /** Force \"strict\" mode */\n  strict?: boolean\n  /** Force \"strip\" mode */\n  strip?: boolean\n  /**\n   * compile but do not run. The result is an object with a\n   * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed\n   * with JS_EvalFunction().\n   */\n  compileOnly?: boolean\n  /** don't include the stack frames before this eval in the Error() backtraces */\n  backtraceBarrier?: boolean\n}\n\n/** Convert [[ContextEvalOptions]] to a bitfield flags */\nexport function evalOptionsToFlags(evalOptions: ContextEvalOptions | number | undefined): number {\n  if (typeof evalOptions === \"number\") {\n    return evalOptions\n  }\n\n  if (evalOptions === undefined) {\n    return 0\n  }\n\n  const { type, strict, strip, compileOnly, backtraceBarrier } = evalOptions\n  let flags = 0\n  if (type === \"global\") flags |= EvalFlags.JS_EVAL_TYPE_GLOBAL\n  if (type === \"module\") flags |= EvalFlags.JS_EVAL_TYPE_MODULE\n  if (strict) flags |= EvalFlags.JS_EVAL_FLAG_STRICT\n  if (strip) flags |= EvalFlags.JS_EVAL_FLAG_STRIP\n  if (compileOnly) flags |= EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY\n  if (backtraceBarrier) flags |= EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER\n  return flags\n}\n\nexport type PromiseExecutor<ResolveT, RejectT> = (\n  resolve: (value: ResolveT | PromiseLike<ResolveT>) => void,\n  reject: (reason: RejectT) => void\n) => void\n\nexport function concat<T>(...values: Array<T[] | T | undefined>): T[] {\n  let result: T[] = []\n  for (const value of values) {\n    if (value !== undefined) {\n      result = result.concat(value)\n    }\n  }\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}