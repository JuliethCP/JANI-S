{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getUri = exports.isValidProtocol = exports.protocols = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\n// Built-in protocols\nconst data_1 = require(\"./data\");\nconst file_1 = require(\"./file\");\nconst ftp_1 = require(\"./ftp\");\nconst http_1 = require(\"./http\");\nconst https_1 = require(\"./https\");\nconst debug = (0, debug_1.default)('get-uri');\nexports.protocols = {\n  data: data_1.data,\n  file: file_1.file,\n  ftp: ftp_1.ftp,\n  http: http_1.http,\n  https: https_1.https\n};\nconst VALID_PROTOCOLS = new Set(Object.keys(exports.protocols));\nfunction isValidProtocol(p) {\n  return VALID_PROTOCOLS.has(p);\n}\nexports.isValidProtocol = isValidProtocol;\n/**\n * Async function that returns a `stream.Readable` instance that will output\n * the contents of the given URI.\n *\n * For caching purposes, you can pass in a `stream` instance from a previous\n * `getUri()` call as a `cache: stream` option, and if the destination has\n * not changed since the last time the endpoint was retreived then the callback\n * will be invoked with an Error object with `code` set to \"ENOTMODIFIED\" and\n * `null` for the \"stream\" instance argument. In this case, you can skip\n * retreiving the file again and continue to use the previous payload.\n *\n * @param {String} uri URI to retrieve\n * @param {Object} opts optional \"options\" object\n * @api public\n */\nasync function getUri(uri, opts) {\n  debug('getUri(%o)', uri);\n  if (!uri) {\n    throw new TypeError('Must pass in a URI to \"getUri()\"');\n  }\n  const url = typeof uri === 'string' ? new URL(uri) : uri;\n  // Strip trailing `:`\n  const protocol = url.protocol.replace(/:$/, '');\n  if (!isValidProtocol(protocol)) {\n    throw new TypeError(`Unsupported protocol \"${protocol}\" specified in URI: \"${uri}\"`);\n  }\n  const getter = exports.protocols[protocol];\n  return getter(url, opts);\n}\nexports.getUri = getUri;","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA,MAAMA,KAAK,GAAG,mBAAW,EAAC,SAAS,CAAC;AAOvBC,iBAAS,GAAG;EACxBC,IAAI,EAAJC,WAAI;EACJC,IAAI,EAAJC,WAAI;EACJC,GAAG,EAAHC,SAAG;EACHC,IAAI,EAAJC,WAAI;EACJC,KAAK,EAALC;CACA;AAcD,MAAMC,eAAe,GAAG,IAAIC,GAAG,CAACC,MAAM,CAACC,IAAI,CAACd,iBAAS,CAAC,CAAC;AAEvD,SAAgBe,eAAe,CAACC,CAAS;EACxC,OAAOL,eAAe,CAACM,GAAG,CAACD,CAAC,CAAC;AAC9B;AAFAhB;AAIA;;;;;;;;;;;;;;;AAeO,eAAekB,MAAM,CAC3BC,GAAc,EACdC,IAAwB;EAExBrB,KAAK,CAAC,YAAY,EAAEoB,GAAG,CAAC;EAExB,IAAI,CAACA,GAAG,EAAE;IACT,MAAM,IAAIE,SAAS,CAAC,kCAAkC,CAAC;;EAGxD,MAAMC,GAAG,GAAG,OAAOH,GAAG,KAAK,QAAQ,GAAG,IAAII,GAAG,CAACJ,GAAG,CAAC,GAAGA,GAAG;EAExD;EACA,MAAMK,QAAQ,GAAGF,GAAG,CAACE,QAAQ,CAACC,OAAO,CAAC,IAAI,EAAE,EAAE,CAAC;EAC/C,IAAI,CAACV,eAAe,CAACS,QAAQ,CAAC,EAAE;IAC/B,MAAM,IAAIH,SAAS,CAClB,yBAAyBG,QAAQ,wBAAwBL,GAAG,GAAG,CAC/D;;EAGF,MAAMO,MAAM,GAAG1B,iBAAS,CAACwB,QAAQ,CAAC;EAClC,OAAOE,MAAM,CAACJ,GAAG,EAAEF,IAAa,CAAC;AAClC;AAtBApB","names":["debug","exports","data","data_1","file","file_1","ftp","ftp_1","http","http_1","https","https_1","VALID_PROTOCOLS","Set","Object","keys","isValidProtocol","p","has","getUri","uri","opts","TypeError","url","URL","protocol","replace","getter"],"sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}