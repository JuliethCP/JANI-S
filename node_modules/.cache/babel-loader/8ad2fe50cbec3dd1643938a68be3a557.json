{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { exec as execChildProcess } from 'child_process';\nimport { createReadStream } from 'fs';\nimport { mkdir, readdir } from 'fs/promises';\nimport * as path from 'path';\nimport { promisify } from 'util';\nimport extractZip from 'extract-zip';\nimport tar from 'tar-fs';\nimport bzip from 'unbzip2-stream';\nconst exec = promisify(execChildProcess);\n/**\n * @internal\n */\nexport async function unpackArchive(archivePath, folderPath) {\n  if (archivePath.endsWith('.zip')) {\n    await extractZip(archivePath, {\n      dir: folderPath\n    });\n  } else if (archivePath.endsWith('.tar.bz2')) {\n    await extractTar(archivePath, folderPath);\n  } else if (archivePath.endsWith('.dmg')) {\n    await mkdir(folderPath);\n    await installDMG(archivePath, folderPath);\n  } else {\n    throw new Error(`Unsupported archive format: ${archivePath}`);\n  }\n}\n/**\n * @internal\n */\nfunction extractTar(tarPath, folderPath) {\n  return new Promise((fulfill, reject) => {\n    const tarStream = tar.extract(folderPath);\n    tarStream.on('error', reject);\n    tarStream.on('finish', fulfill);\n    const readStream = createReadStream(tarPath);\n    readStream.pipe(bzip()).pipe(tarStream);\n  });\n}\n/**\n * @internal\n */\nasync function installDMG(dmgPath, folderPath) {\n  const {\n    stdout\n  } = await exec(`hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`);\n  const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n  if (!volumes) {\n    throw new Error(`Could not find volume path in ${stdout}`);\n  }\n  const mountPath = volumes[0];\n  try {\n    const fileNames = await readdir(mountPath);\n    const appName = fileNames.find(item => {\n      return typeof item === 'string' && item.endsWith('.app');\n    });\n    if (!appName) {\n      throw new Error(`Cannot find app in ${mountPath}`);\n    }\n    const mountedPath = path.join(mountPath, appName);\n    await exec(`cp -R \"${mountedPath}\" \"${folderPath}\"`);\n  } finally {\n    await exec(`hdiutil detach \"${mountPath}\" -quiet`);\n  }\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,SAAQA,IAAI,IAAIC,gBAAgB,QAAO,eAAe;AACtD,SAAQC,gBAAgB,QAAO,IAAI;AACnC,SAAQC,KAAK,EAAEC,OAAO,QAAO,aAAa;AAC1C,OAAO,KAAKC,IAAI,MAAM,MAAM;AAC5B,SAAQC,SAAS,QAAO,MAAM;AAE9B,OAAOC,UAAU,MAAM,aAAa;AACpC,OAAOC,GAAG,MAAM,QAAQ;AACxB,OAAOC,IAAI,MAAM,gBAAgB;AAEjC,MAAMT,IAAI,GAAGM,SAAS,CAACL,gBAAgB,CAAC;AAExC;;;AAGA,OAAO,eAAeS,aAAa,CACjCC,WAAmB,EACnBC,UAAkB;EAElB,IAAID,WAAW,CAACE,QAAQ,CAAC,MAAM,CAAC,EAAE;IAChC,MAAMN,UAAU,CAACI,WAAW,EAAE;MAACG,GAAG,EAAEF;IAAU,CAAC,CAAC;GACjD,MAAM,IAAID,WAAW,CAACE,QAAQ,CAAC,UAAU,CAAC,EAAE;IAC3C,MAAME,UAAU,CAACJ,WAAW,EAAEC,UAAU,CAAC;GAC1C,MAAM,IAAID,WAAW,CAACE,QAAQ,CAAC,MAAM,CAAC,EAAE;IACvC,MAAMV,KAAK,CAACS,UAAU,CAAC;IACvB,MAAMI,UAAU,CAACL,WAAW,EAAEC,UAAU,CAAC;GAC1C,MAAM;IACL,MAAM,IAAIK,KAAK,CAAC,+BAA+BN,WAAW,EAAE,CAAC;;AAEjE;AAEA;;;AAGA,SAASI,UAAU,CAACG,OAAe,EAAEN,UAAkB;EACrD,OAAO,IAAIO,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAI;IACrC,MAAMC,SAAS,GAAGd,GAAG,CAACe,OAAO,CAACX,UAAU,CAAC;IACzCU,SAAS,CAACE,EAAE,CAAC,OAAO,EAAEH,MAAM,CAAC;IAC7BC,SAAS,CAACE,EAAE,CAAC,QAAQ,EAAEJ,OAAO,CAAC;IAC/B,MAAMK,UAAU,GAAGvB,gBAAgB,CAACgB,OAAO,CAAC;IAC5CO,UAAU,CAACC,IAAI,CAACjB,IAAI,EAAE,CAAC,CAACiB,IAAI,CAACJ,SAAS,CAAC;EACzC,CAAC,CAAC;AACJ;AAEA;;;AAGA,eAAeN,UAAU,CAACW,OAAe,EAAEf,UAAkB;EAC3D,MAAM;IAACgB;EAAM,CAAC,GAAG,MAAM5B,IAAI,CACzB,yCAAyC2B,OAAO,GAAG,CACpD;EAED,MAAME,OAAO,GAAGD,MAAM,CAACE,KAAK,CAAC,kBAAkB,CAAC;EAChD,IAAI,CAACD,OAAO,EAAE;IACZ,MAAM,IAAIZ,KAAK,CAAC,iCAAiCW,MAAM,EAAE,CAAC;;EAE5D,MAAMG,SAAS,GAAGF,OAAO,CAAC,CAAC,CAAE;EAE7B,IAAI;IACF,MAAMG,SAAS,GAAG,MAAM5B,OAAO,CAAC2B,SAAS,CAAC;IAC1C,MAAME,OAAO,GAAGD,SAAS,CAACE,IAAI,CAACC,IAAI,IAAG;MACpC,OAAO,OAAOA,IAAI,KAAK,QAAQ,IAAIA,IAAI,CAACtB,QAAQ,CAAC,MAAM,CAAC;IAC1D,CAAC,CAAC;IACF,IAAI,CAACoB,OAAO,EAAE;MACZ,MAAM,IAAIhB,KAAK,CAAC,sBAAsBc,SAAS,EAAE,CAAC;;IAEpD,MAAMK,WAAW,GAAG/B,IAAI,CAACgC,IAAI,CAACN,SAAU,EAAEE,OAAO,CAAC;IAElD,MAAMjC,IAAI,CAAC,UAAUoC,WAAW,MAAMxB,UAAU,GAAG,CAAC;GACrD,SAAS;IACR,MAAMZ,IAAI,CAAC,mBAAmB+B,SAAS,UAAU,CAAC;;AAEtD","names":["exec","execChildProcess","createReadStream","mkdir","readdir","path","promisify","extractZip","tar","bzip","unpackArchive","archivePath","folderPath","endsWith","dir","extractTar","installDMG","Error","tarPath","Promise","fulfill","reject","tarStream","extract","on","readStream","pipe","dmgPath","stdout","volumes","match","mountPath","fileNames","appName","find","item","mountedPath","join"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@puppeteer\\browsers\\src\\fileUtil.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {exec as execChildProcess} from 'child_process';\nimport {createReadStream} from 'fs';\nimport {mkdir, readdir} from 'fs/promises';\nimport * as path from 'path';\nimport {promisify} from 'util';\n\nimport extractZip from 'extract-zip';\nimport tar from 'tar-fs';\nimport bzip from 'unbzip2-stream';\n\nconst exec = promisify(execChildProcess);\n\n/**\n * @internal\n */\nexport async function unpackArchive(\n  archivePath: string,\n  folderPath: string\n): Promise<void> {\n  if (archivePath.endsWith('.zip')) {\n    await extractZip(archivePath, {dir: folderPath});\n  } else if (archivePath.endsWith('.tar.bz2')) {\n    await extractTar(archivePath, folderPath);\n  } else if (archivePath.endsWith('.dmg')) {\n    await mkdir(folderPath);\n    await installDMG(archivePath, folderPath);\n  } else {\n    throw new Error(`Unsupported archive format: ${archivePath}`);\n  }\n}\n\n/**\n * @internal\n */\nfunction extractTar(tarPath: string, folderPath: string): Promise<void> {\n  return new Promise((fulfill, reject) => {\n    const tarStream = tar.extract(folderPath);\n    tarStream.on('error', reject);\n    tarStream.on('finish', fulfill);\n    const readStream = createReadStream(tarPath);\n    readStream.pipe(bzip()).pipe(tarStream);\n  });\n}\n\n/**\n * @internal\n */\nasync function installDMG(dmgPath: string, folderPath: string): Promise<void> {\n  const {stdout} = await exec(\n    `hdiutil attach -nobrowse -noautoopen \"${dmgPath}\"`\n  );\n\n  const volumes = stdout.match(/\\/Volumes\\/(.*)/m);\n  if (!volumes) {\n    throw new Error(`Could not find volume path in ${stdout}`);\n  }\n  const mountPath = volumes[0]!;\n\n  try {\n    const fileNames = await readdir(mountPath);\n    const appName = fileNames.find(item => {\n      return typeof item === 'string' && item.endsWith('.app');\n    });\n    if (!appName) {\n      throw new Error(`Cannot find app in ${mountPath}`);\n    }\n    const mountedPath = path.join(mountPath!, appName);\n\n    await exec(`cp -R \"${mountedPath}\" \"${folderPath}\"`);\n  } finally {\n    await exec(`hdiutil detach \"${mountPath}\" -quiet`);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}