{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar path_1 = tslib_1.__importDefault(require(\"./path\"));\nvar scope_1 = tslib_1.__importDefault(require(\"./scope\"));\nfunction nodePathPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var n = types.namedTypes;\n  var b = types.builders;\n  var isNumber = types.builtInTypes.number;\n  var isArray = types.builtInTypes.array;\n  var Path = fork.use(path_1.default);\n  var Scope = fork.use(scope_1.default);\n  var NodePath = function NodePath(value, parentPath, name) {\n    if (!(this instanceof NodePath)) {\n      throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n    }\n    Path.call(this, value, parentPath, name);\n  };\n  var NPp = NodePath.prototype = Object.create(Path.prototype, {\n    constructor: {\n      value: NodePath,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperties(NPp, {\n    node: {\n      get: function () {\n        Object.defineProperty(this, \"node\", {\n          configurable: true,\n          value: this._computeNode()\n        });\n        return this.node;\n      }\n    },\n    parent: {\n      get: function () {\n        Object.defineProperty(this, \"parent\", {\n          configurable: true,\n          value: this._computeParent()\n        });\n        return this.parent;\n      }\n    },\n    scope: {\n      get: function () {\n        Object.defineProperty(this, \"scope\", {\n          configurable: true,\n          value: this._computeScope()\n        });\n        return this.scope;\n      }\n    }\n  });\n  NPp.replace = function () {\n    delete this.node;\n    delete this.parent;\n    delete this.scope;\n    return Path.prototype.replace.apply(this, arguments);\n  };\n  NPp.prune = function () {\n    var remainingNodePath = this.parent;\n    this.replace();\n    return cleanUpNodesAfterPrune(remainingNodePath);\n  };\n  // The value of the first ancestor Path whose value is a Node.\n  NPp._computeNode = function () {\n    var value = this.value;\n    if (n.Node.check(value)) {\n      return value;\n    }\n    var pp = this.parentPath;\n    return pp && pp.node || null;\n  };\n  // The first ancestor Path whose value is a Node distinct from this.node.\n  NPp._computeParent = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n    if (!n.Node.check(value)) {\n      while (pp && !n.Node.check(pp.value)) {\n        pp = pp.parentPath;\n      }\n      if (pp) {\n        pp = pp.parentPath;\n      }\n    }\n    while (pp && !n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n    }\n    return pp || null;\n  };\n  // The closest enclosing scope that governs this node.\n  NPp._computeScope = function () {\n    var value = this.value;\n    var pp = this.parentPath;\n    var scope = pp && pp.scope;\n    if (n.Node.check(value) && Scope.isEstablishedBy(value)) {\n      scope = new Scope(this, scope);\n    }\n    return scope || null;\n  };\n  NPp.getValueProperty = function (name) {\n    return types.getFieldValue(this.value, name);\n  };\n  /**\n   * Determine whether this.node needs to be wrapped in parentheses in order\n   * for a parser to reproduce the same local AST structure.\n   *\n   * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n   * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n   * parse differently.\n   *\n   * If assumeExpressionContext === true, we don't worry about edge cases\n   * like an anonymous FunctionExpression appearing lexically first in its\n   * enclosing statement and thus needing parentheses to avoid being parsed\n   * as a FunctionDeclaration with a missing name.\n   */\n  NPp.needsParens = function (assumeExpressionContext) {\n    var pp = this.parentPath;\n    if (!pp) {\n      return false;\n    }\n    var node = this.value;\n    // Only expressions need parentheses.\n    if (!n.Expression.check(node)) {\n      return false;\n    }\n    // Identifiers never need parentheses.\n    if (node.type === \"Identifier\") {\n      return false;\n    }\n    while (!n.Node.check(pp.value)) {\n      pp = pp.parentPath;\n      if (!pp) {\n        return false;\n      }\n    }\n    var parent = pp.value;\n    switch (node.type) {\n      case \"UnaryExpression\":\n      case \"SpreadElement\":\n      case \"SpreadProperty\":\n        return parent.type === \"MemberExpression\" && this.name === \"object\" && parent.object === node;\n      case \"BinaryExpression\":\n      case \"LogicalExpression\":\n        switch (parent.type) {\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n            return true;\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            {\n              var n_1 = node;\n              var po = parent.operator;\n              var pp_1 = PRECEDENCE[po];\n              var no = n_1.operator;\n              var np = PRECEDENCE[no];\n              if (pp_1 > np) {\n                return true;\n              }\n              if (pp_1 === np && this.name === \"right\") {\n                if (parent.right !== n_1) {\n                  throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n              }\n            }\n          default:\n            return false;\n        }\n      case \"SequenceExpression\":\n        switch (parent.type) {\n          case \"ForStatement\":\n            // Although parentheses wouldn't hurt around sequence\n            // expressions in the head of for loops, traditional style\n            // dictates that e.g. i++, j++ should not be wrapped with\n            // parentheses.\n            return false;\n          case \"ExpressionStatement\":\n            return this.name !== \"expression\";\n          default:\n            // Otherwise err on the side of overparenthesization, adding\n            // explicit exceptions above if this proves overzealous.\n            return true;\n        }\n      case \"YieldExpression\":\n        switch (parent.type) {\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"CallExpression\":\n          case \"MemberExpression\":\n          case \"NewExpression\":\n          case \"ConditionalExpression\":\n          case \"YieldExpression\":\n            return true;\n          default:\n            return false;\n        }\n      case \"Literal\":\n        return parent.type === \"MemberExpression\" && isNumber.check(node.value) && this.name === \"object\" && parent.object === node;\n      case \"AssignmentExpression\":\n      case \"ConditionalExpression\":\n        switch (parent.type) {\n          case \"UnaryExpression\":\n          case \"SpreadElement\":\n          case \"SpreadProperty\":\n          case \"BinaryExpression\":\n          case \"LogicalExpression\":\n            return true;\n          case \"CallExpression\":\n            return this.name === \"callee\" && parent.callee === node;\n          case \"ConditionalExpression\":\n            return this.name === \"test\" && parent.test === node;\n          case \"MemberExpression\":\n            return this.name === \"object\" && parent.object === node;\n          default:\n            return false;\n        }\n      default:\n        if (parent.type === \"NewExpression\" && this.name === \"callee\" && parent.callee === node) {\n          return containsCallExpression(node);\n        }\n    }\n    if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement()) return true;\n    return false;\n  };\n  function isBinary(node) {\n    return n.BinaryExpression.check(node) || n.LogicalExpression.check(node);\n  }\n  // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n  function isUnaryLike(node) {\n    return n.UnaryExpression.check(node)\n    // I considered making SpreadElement and SpreadProperty subtypes\n    // of UnaryExpression, but they're not really Expression nodes.\n    || n.SpreadElement && n.SpreadElement.check(node) || n.SpreadProperty && n.SpreadProperty.check(node);\n  }\n  var PRECEDENCE = {};\n  [[\"||\"], [\"&&\"], [\"|\"], [\"^\"], [\"&\"], [\"==\", \"===\", \"!=\", \"!==\"], [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"], [\">>\", \"<<\", \">>>\"], [\"+\", \"-\"], [\"*\", \"/\", \"%\"]].forEach(function (tier, i) {\n    tier.forEach(function (op) {\n      PRECEDENCE[op] = i;\n    });\n  });\n  function containsCallExpression(node) {\n    if (n.CallExpression.check(node)) {\n      return true;\n    }\n    if (isArray.check(node)) {\n      return node.some(containsCallExpression);\n    }\n    if (n.Node.check(node)) {\n      return types.someField(node, function (_name, child) {\n        return containsCallExpression(child);\n      });\n    }\n    return false;\n  }\n  NPp.canBeFirstInStatement = function () {\n    var node = this.node;\n    return !n.FunctionExpression.check(node) && !n.ObjectExpression.check(node);\n  };\n  NPp.firstInStatement = function () {\n    return firstInStatement(this);\n  };\n  function firstInStatement(path) {\n    for (var node, parent; path.parent; path = path.parent) {\n      node = path.node;\n      parent = path.parent.node;\n      if (n.BlockStatement.check(parent) && path.parent.name === \"body\" && path.name === 0) {\n        if (parent.body[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        return true;\n      }\n      if (n.ExpressionStatement.check(parent) && path.name === \"expression\") {\n        if (parent.expression !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        return true;\n      }\n      if (n.SequenceExpression.check(parent) && path.parent.name === \"expressions\" && path.name === 0) {\n        if (parent.expressions[0] !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.CallExpression.check(parent) && path.name === \"callee\") {\n        if (parent.callee !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.MemberExpression.check(parent) && path.name === \"object\") {\n        if (parent.object !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.ConditionalExpression.check(parent) && path.name === \"test\") {\n        if (parent.test !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (isBinary(parent) && path.name === \"left\") {\n        if (parent.left !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      if (n.UnaryExpression.check(parent) && !parent.prefix && path.name === \"argument\") {\n        if (parent.argument !== node) {\n          throw new Error(\"Nodes must be equal\");\n        }\n        continue;\n      }\n      return false;\n    }\n    return true;\n  }\n  /**\n   * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n   */\n  function cleanUpNodesAfterPrune(remainingNodePath) {\n    if (n.VariableDeclaration.check(remainingNodePath.node)) {\n      var declarations = remainingNodePath.get('declarations').value;\n      if (!declarations || declarations.length === 0) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n      if (!remainingNodePath.get('expression').value) {\n        return remainingNodePath.prune();\n      }\n    } else if (n.IfStatement.check(remainingNodePath.node)) {\n      cleanUpIfStatementAfterPrune(remainingNodePath);\n    }\n    return remainingNodePath;\n  }\n  function cleanUpIfStatementAfterPrune(ifStatement) {\n    var testExpression = ifStatement.get('test').value;\n    var alternate = ifStatement.get('alternate').value;\n    var consequent = ifStatement.get('consequent').value;\n    if (!consequent && !alternate) {\n      var testExpressionStatement = b.expressionStatement(testExpression);\n      ifStatement.replace(testExpressionStatement);\n    } else if (!consequent && alternate) {\n      var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n      if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n        negatedTestExpression = testExpression.argument;\n      }\n      ifStatement.get(\"test\").replace(negatedTestExpression);\n      ifStatement.get(\"consequent\").replace(alternate);\n      ifStatement.get(\"alternate\").replace();\n    }\n  }\n  return NodePath;\n}\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","path_1","scope_1","nodePathPlugin","fork","types","use","default","n","namedTypes","b","builders","isNumber","builtInTypes","number","isArray","array","Path","Scope","NodePath","parentPath","name","Error","call","NPp","prototype","create","constructor","enumerable","writable","configurable","defineProperties","node","get","_computeNode","parent","_computeParent","scope","_computeScope","replace","apply","arguments","prune","remainingNodePath","cleanUpNodesAfterPrune","Node","check","pp","isEstablishedBy","getValueProperty","getFieldValue","needsParens","assumeExpressionContext","Expression","type","object","callee","n_1","po","operator","pp_1","PRECEDENCE","no","np","right","test","containsCallExpression","canBeFirstInStatement","firstInStatement","isBinary","BinaryExpression","LogicalExpression","isUnaryLike","UnaryExpression","SpreadElement","SpreadProperty","forEach","tier","i","op","CallExpression","some","someField","_name","child","FunctionExpression","ObjectExpression","path","BlockStatement","body","ExpressionStatement","expression","SequenceExpression","expressions","MemberExpression","ConditionalExpression","left","prefix","argument","VariableDeclaration","declarations","length","IfStatement","cleanUpIfStatementAfterPrune","ifStatement","testExpression","alternate","consequent","testExpressionStatement","expressionStatement","negatedTestExpression","unaryExpression","module"],"sources":["D:/Julieth-Campos/PSO/node_modules/ast-types/lib/node-path.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar path_1 = tslib_1.__importDefault(require(\"./path\"));\nvar scope_1 = tslib_1.__importDefault(require(\"./scope\"));\nfunction nodePathPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var n = types.namedTypes;\n    var b = types.builders;\n    var isNumber = types.builtInTypes.number;\n    var isArray = types.builtInTypes.array;\n    var Path = fork.use(path_1.default);\n    var Scope = fork.use(scope_1.default);\n    var NodePath = function NodePath(value, parentPath, name) {\n        if (!(this instanceof NodePath)) {\n            throw new Error(\"NodePath constructor cannot be invoked without 'new'\");\n        }\n        Path.call(this, value, parentPath, name);\n    };\n    var NPp = NodePath.prototype = Object.create(Path.prototype, {\n        constructor: {\n            value: NodePath,\n            enumerable: false,\n            writable: true,\n            configurable: true\n        }\n    });\n    Object.defineProperties(NPp, {\n        node: {\n            get: function () {\n                Object.defineProperty(this, \"node\", {\n                    configurable: true,\n                    value: this._computeNode()\n                });\n                return this.node;\n            }\n        },\n        parent: {\n            get: function () {\n                Object.defineProperty(this, \"parent\", {\n                    configurable: true,\n                    value: this._computeParent()\n                });\n                return this.parent;\n            }\n        },\n        scope: {\n            get: function () {\n                Object.defineProperty(this, \"scope\", {\n                    configurable: true,\n                    value: this._computeScope()\n                });\n                return this.scope;\n            }\n        }\n    });\n    NPp.replace = function () {\n        delete this.node;\n        delete this.parent;\n        delete this.scope;\n        return Path.prototype.replace.apply(this, arguments);\n    };\n    NPp.prune = function () {\n        var remainingNodePath = this.parent;\n        this.replace();\n        return cleanUpNodesAfterPrune(remainingNodePath);\n    };\n    // The value of the first ancestor Path whose value is a Node.\n    NPp._computeNode = function () {\n        var value = this.value;\n        if (n.Node.check(value)) {\n            return value;\n        }\n        var pp = this.parentPath;\n        return pp && pp.node || null;\n    };\n    // The first ancestor Path whose value is a Node distinct from this.node.\n    NPp._computeParent = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        if (!n.Node.check(value)) {\n            while (pp && !n.Node.check(pp.value)) {\n                pp = pp.parentPath;\n            }\n            if (pp) {\n                pp = pp.parentPath;\n            }\n        }\n        while (pp && !n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n        }\n        return pp || null;\n    };\n    // The closest enclosing scope that governs this node.\n    NPp._computeScope = function () {\n        var value = this.value;\n        var pp = this.parentPath;\n        var scope = pp && pp.scope;\n        if (n.Node.check(value) &&\n            Scope.isEstablishedBy(value)) {\n            scope = new Scope(this, scope);\n        }\n        return scope || null;\n    };\n    NPp.getValueProperty = function (name) {\n        return types.getFieldValue(this.value, name);\n    };\n    /**\n     * Determine whether this.node needs to be wrapped in parentheses in order\n     * for a parser to reproduce the same local AST structure.\n     *\n     * For instance, in the expression `(1 + 2) * 3`, the BinaryExpression\n     * whose operator is \"+\" needs parentheses, because `1 + 2 * 3` would\n     * parse differently.\n     *\n     * If assumeExpressionContext === true, we don't worry about edge cases\n     * like an anonymous FunctionExpression appearing lexically first in its\n     * enclosing statement and thus needing parentheses to avoid being parsed\n     * as a FunctionDeclaration with a missing name.\n     */\n    NPp.needsParens = function (assumeExpressionContext) {\n        var pp = this.parentPath;\n        if (!pp) {\n            return false;\n        }\n        var node = this.value;\n        // Only expressions need parentheses.\n        if (!n.Expression.check(node)) {\n            return false;\n        }\n        // Identifiers never need parentheses.\n        if (node.type === \"Identifier\") {\n            return false;\n        }\n        while (!n.Node.check(pp.value)) {\n            pp = pp.parentPath;\n            if (!pp) {\n                return false;\n            }\n        }\n        var parent = pp.value;\n        switch (node.type) {\n            case \"UnaryExpression\":\n            case \"SpreadElement\":\n            case \"SpreadProperty\":\n                return parent.type === \"MemberExpression\"\n                    && this.name === \"object\"\n                    && parent.object === node;\n            case \"BinaryExpression\":\n            case \"LogicalExpression\":\n                switch (parent.type) {\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                            && parent.callee === node;\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                        return true;\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                            && parent.object === node;\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\": {\n                        var n_1 = node;\n                        var po = parent.operator;\n                        var pp_1 = PRECEDENCE[po];\n                        var no = n_1.operator;\n                        var np = PRECEDENCE[no];\n                        if (pp_1 > np) {\n                            return true;\n                        }\n                        if (pp_1 === np && this.name === \"right\") {\n                            if (parent.right !== n_1) {\n                                throw new Error(\"Nodes must be equal\");\n                            }\n                            return true;\n                        }\n                    }\n                    default:\n                        return false;\n                }\n            case \"SequenceExpression\":\n                switch (parent.type) {\n                    case \"ForStatement\":\n                        // Although parentheses wouldn't hurt around sequence\n                        // expressions in the head of for loops, traditional style\n                        // dictates that e.g. i++, j++ should not be wrapped with\n                        // parentheses.\n                        return false;\n                    case \"ExpressionStatement\":\n                        return this.name !== \"expression\";\n                    default:\n                        // Otherwise err on the side of overparenthesization, adding\n                        // explicit exceptions above if this proves overzealous.\n                        return true;\n                }\n            case \"YieldExpression\":\n                switch (parent.type) {\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"CallExpression\":\n                    case \"MemberExpression\":\n                    case \"NewExpression\":\n                    case \"ConditionalExpression\":\n                    case \"YieldExpression\":\n                        return true;\n                    default:\n                        return false;\n                }\n            case \"Literal\":\n                return parent.type === \"MemberExpression\"\n                    && isNumber.check(node.value)\n                    && this.name === \"object\"\n                    && parent.object === node;\n            case \"AssignmentExpression\":\n            case \"ConditionalExpression\":\n                switch (parent.type) {\n                    case \"UnaryExpression\":\n                    case \"SpreadElement\":\n                    case \"SpreadProperty\":\n                    case \"BinaryExpression\":\n                    case \"LogicalExpression\":\n                        return true;\n                    case \"CallExpression\":\n                        return this.name === \"callee\"\n                            && parent.callee === node;\n                    case \"ConditionalExpression\":\n                        return this.name === \"test\"\n                            && parent.test === node;\n                    case \"MemberExpression\":\n                        return this.name === \"object\"\n                            && parent.object === node;\n                    default:\n                        return false;\n                }\n            default:\n                if (parent.type === \"NewExpression\" &&\n                    this.name === \"callee\" &&\n                    parent.callee === node) {\n                    return containsCallExpression(node);\n                }\n        }\n        if (assumeExpressionContext !== true &&\n            !this.canBeFirstInStatement() &&\n            this.firstInStatement())\n            return true;\n        return false;\n    };\n    function isBinary(node) {\n        return n.BinaryExpression.check(node)\n            || n.LogicalExpression.check(node);\n    }\n    // @ts-ignore 'isUnaryLike' is declared but its value is never read. [6133]\n    function isUnaryLike(node) {\n        return n.UnaryExpression.check(node)\n            // I considered making SpreadElement and SpreadProperty subtypes\n            // of UnaryExpression, but they're not really Expression nodes.\n            || (n.SpreadElement && n.SpreadElement.check(node))\n            || (n.SpreadProperty && n.SpreadProperty.check(node));\n    }\n    var PRECEDENCE = {};\n    [[\"||\"],\n        [\"&&\"],\n        [\"|\"],\n        [\"^\"],\n        [\"&\"],\n        [\"==\", \"===\", \"!=\", \"!==\"],\n        [\"<\", \">\", \"<=\", \">=\", \"in\", \"instanceof\"],\n        [\">>\", \"<<\", \">>>\"],\n        [\"+\", \"-\"],\n        [\"*\", \"/\", \"%\"]\n    ].forEach(function (tier, i) {\n        tier.forEach(function (op) {\n            PRECEDENCE[op] = i;\n        });\n    });\n    function containsCallExpression(node) {\n        if (n.CallExpression.check(node)) {\n            return true;\n        }\n        if (isArray.check(node)) {\n            return node.some(containsCallExpression);\n        }\n        if (n.Node.check(node)) {\n            return types.someField(node, function (_name, child) {\n                return containsCallExpression(child);\n            });\n        }\n        return false;\n    }\n    NPp.canBeFirstInStatement = function () {\n        var node = this.node;\n        return !n.FunctionExpression.check(node)\n            && !n.ObjectExpression.check(node);\n    };\n    NPp.firstInStatement = function () {\n        return firstInStatement(this);\n    };\n    function firstInStatement(path) {\n        for (var node, parent; path.parent; path = path.parent) {\n            node = path.node;\n            parent = path.parent.node;\n            if (n.BlockStatement.check(parent) &&\n                path.parent.name === \"body\" &&\n                path.name === 0) {\n                if (parent.body[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n            if (n.ExpressionStatement.check(parent) &&\n                path.name === \"expression\") {\n                if (parent.expression !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                return true;\n            }\n            if (n.SequenceExpression.check(parent) &&\n                path.parent.name === \"expressions\" &&\n                path.name === 0) {\n                if (parent.expressions[0] !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.CallExpression.check(parent) &&\n                path.name === \"callee\") {\n                if (parent.callee !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.MemberExpression.check(parent) &&\n                path.name === \"object\") {\n                if (parent.object !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.ConditionalExpression.check(parent) &&\n                path.name === \"test\") {\n                if (parent.test !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (isBinary(parent) &&\n                path.name === \"left\") {\n                if (parent.left !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            if (n.UnaryExpression.check(parent) &&\n                !parent.prefix &&\n                path.name === \"argument\") {\n                if (parent.argument !== node) {\n                    throw new Error(\"Nodes must be equal\");\n                }\n                continue;\n            }\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Pruning certain nodes will result in empty or incomplete nodes, here we clean those nodes up.\n     */\n    function cleanUpNodesAfterPrune(remainingNodePath) {\n        if (n.VariableDeclaration.check(remainingNodePath.node)) {\n            var declarations = remainingNodePath.get('declarations').value;\n            if (!declarations || declarations.length === 0) {\n                return remainingNodePath.prune();\n            }\n        }\n        else if (n.ExpressionStatement.check(remainingNodePath.node)) {\n            if (!remainingNodePath.get('expression').value) {\n                return remainingNodePath.prune();\n            }\n        }\n        else if (n.IfStatement.check(remainingNodePath.node)) {\n            cleanUpIfStatementAfterPrune(remainingNodePath);\n        }\n        return remainingNodePath;\n    }\n    function cleanUpIfStatementAfterPrune(ifStatement) {\n        var testExpression = ifStatement.get('test').value;\n        var alternate = ifStatement.get('alternate').value;\n        var consequent = ifStatement.get('consequent').value;\n        if (!consequent && !alternate) {\n            var testExpressionStatement = b.expressionStatement(testExpression);\n            ifStatement.replace(testExpressionStatement);\n        }\n        else if (!consequent && alternate) {\n            var negatedTestExpression = b.unaryExpression('!', testExpression, true);\n            if (n.UnaryExpression.check(testExpression) && testExpression.operator === '!') {\n                negatedTestExpression = testExpression.argument;\n            }\n            ifStatement.get(\"test\").replace(negatedTestExpression);\n            ifStatement.get(\"consequent\").replace(alternate);\n            ifStatement.get(\"alternate\").replace();\n        }\n    }\n    return NodePath;\n}\nexports.default = nodePathPlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}