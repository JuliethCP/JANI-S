{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ipIsPrivateV4Address = exports.upgradeSocket = exports.describeAddress = exports.describeTLS = void 0;\nconst tls_1 = require(\"tls\");\n/**\n * Returns a string describing the encryption on a given socket instance.\n */\nfunction describeTLS(socket) {\n  if (socket instanceof tls_1.TLSSocket) {\n    const protocol = socket.getProtocol();\n    return protocol ? protocol : \"Server socket or disconnected client socket\";\n  }\n  return \"No encryption\";\n}\nexports.describeTLS = describeTLS;\n/**\n * Returns a string describing the remote address of a socket.\n */\nfunction describeAddress(socket) {\n  if (socket.remoteFamily === \"IPv6\") {\n    return `[${socket.remoteAddress}]:${socket.remotePort}`;\n  }\n  return `${socket.remoteAddress}:${socket.remotePort}`;\n}\nexports.describeAddress = describeAddress;\n/**\n * Upgrade a socket connection with TLS.\n */\nfunction upgradeSocket(socket, options) {\n  return new Promise((resolve, reject) => {\n    const tlsOptions = Object.assign({}, options, {\n      socket\n    });\n    const tlsSocket = (0, tls_1.connect)(tlsOptions, () => {\n      const expectCertificate = tlsOptions.rejectUnauthorized !== false;\n      if (expectCertificate && !tlsSocket.authorized) {\n        reject(tlsSocket.authorizationError);\n      } else {\n        // Remove error listener added below.\n        tlsSocket.removeAllListeners(\"error\");\n        resolve(tlsSocket);\n      }\n    }).once(\"error\", error => {\n      reject(error);\n    });\n  });\n}\nexports.upgradeSocket = upgradeSocket;\n/**\n * Returns true if an IP is a private address according to https://tools.ietf.org/html/rfc1918#section-3.\n * This will handle IPv4-mapped IPv6 addresses correctly but return false for all other IPv6 addresses.\n *\n * @param ip  The IP as a string, e.g. \"192.168.0.1\"\n */\nfunction ipIsPrivateV4Address() {\n  let ip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n  // Handle IPv4-mapped IPv6 addresses like ::ffff:192.168.0.1\n  if (ip.startsWith(\"::ffff:\")) {\n    ip = ip.substr(7); // Strip ::ffff: prefix\n  }\n\n  const octets = ip.split(\".\").map(o => parseInt(o, 10));\n  return octets[0] === 10 // 10.0.0.0 - 10.255.255.255\n  || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 // 172.16.0.0 - 172.31.255.255\n  || octets[0] === 192 && octets[1] === 168 // 192.168.0.0 - 192.168.255.255\n  || ip === \"127.0.0.1\";\n}\nexports.ipIsPrivateV4Address = ipIsPrivateV4Address;","map":{"version":3,"names":["Object","defineProperty","exports","value","ipIsPrivateV4Address","upgradeSocket","describeAddress","describeTLS","tls_1","require","socket","TLSSocket","protocol","getProtocol","remoteFamily","remoteAddress","remotePort","options","Promise","resolve","reject","tlsOptions","assign","tlsSocket","connect","expectCertificate","rejectUnauthorized","authorized","authorizationError","removeAllListeners","once","error","ip","startsWith","substr","octets","split","map","o","parseInt"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/netUtils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ipIsPrivateV4Address = exports.upgradeSocket = exports.describeAddress = exports.describeTLS = void 0;\nconst tls_1 = require(\"tls\");\n/**\n * Returns a string describing the encryption on a given socket instance.\n */\nfunction describeTLS(socket) {\n    if (socket instanceof tls_1.TLSSocket) {\n        const protocol = socket.getProtocol();\n        return protocol ? protocol : \"Server socket or disconnected client socket\";\n    }\n    return \"No encryption\";\n}\nexports.describeTLS = describeTLS;\n/**\n * Returns a string describing the remote address of a socket.\n */\nfunction describeAddress(socket) {\n    if (socket.remoteFamily === \"IPv6\") {\n        return `[${socket.remoteAddress}]:${socket.remotePort}`;\n    }\n    return `${socket.remoteAddress}:${socket.remotePort}`;\n}\nexports.describeAddress = describeAddress;\n/**\n * Upgrade a socket connection with TLS.\n */\nfunction upgradeSocket(socket, options) {\n    return new Promise((resolve, reject) => {\n        const tlsOptions = Object.assign({}, options, {\n            socket\n        });\n        const tlsSocket = (0, tls_1.connect)(tlsOptions, () => {\n            const expectCertificate = tlsOptions.rejectUnauthorized !== false;\n            if (expectCertificate && !tlsSocket.authorized) {\n                reject(tlsSocket.authorizationError);\n            }\n            else {\n                // Remove error listener added below.\n                tlsSocket.removeAllListeners(\"error\");\n                resolve(tlsSocket);\n            }\n        }).once(\"error\", error => {\n            reject(error);\n        });\n    });\n}\nexports.upgradeSocket = upgradeSocket;\n/**\n * Returns true if an IP is a private address according to https://tools.ietf.org/html/rfc1918#section-3.\n * This will handle IPv4-mapped IPv6 addresses correctly but return false for all other IPv6 addresses.\n *\n * @param ip  The IP as a string, e.g. \"192.168.0.1\"\n */\nfunction ipIsPrivateV4Address(ip = \"\") {\n    // Handle IPv4-mapped IPv6 addresses like ::ffff:192.168.0.1\n    if (ip.startsWith(\"::ffff:\")) {\n        ip = ip.substr(7); // Strip ::ffff: prefix\n    }\n    const octets = ip.split(\".\").map(o => parseInt(o, 10));\n    return octets[0] === 10 // 10.0.0.0 - 10.255.255.255\n        || (octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31) // 172.16.0.0 - 172.31.255.255\n        || (octets[0] === 192 && octets[1] === 168) // 192.168.0.0 - 192.168.255.255\n        || ip === \"127.0.0.1\";\n}\nexports.ipIsPrivateV4Address = ipIsPrivateV4Address;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}