{"ast":null,"code":"/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nimport { tokenizeArgString } from './tokenize-arg-string.js';\nimport { DefaultValuesForTypeKey } from './yargs-parser-types.js';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nlet mixin;\nexport class YargsParser {\n  constructor(_mixin) {\n    mixin = _mixin;\n  }\n  parse(argsInput, options) {\n    const opts = Object.assign({\n      alias: undefined,\n      array: undefined,\n      boolean: undefined,\n      config: undefined,\n      configObjects: undefined,\n      configuration: undefined,\n      coerce: undefined,\n      count: undefined,\n      default: undefined,\n      envPrefix: undefined,\n      narg: undefined,\n      normalize: undefined,\n      string: undefined,\n      number: undefined,\n      __: undefined,\n      key: undefined\n    }, options);\n    // allow a string argument to be passed in rather\n    // than an argv array.\n    const args = tokenizeArgString(argsInput);\n    // tokenizeArgString adds extra quotes to args if argsInput is a string\n    // only strip those extra quotes in processValue if argsInput is a string\n    const inputIsString = typeof argsInput === 'string';\n    // aliases might have transitive relationships, normalize this.\n    const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n    const configuration = Object.assign({\n      'boolean-negation': true,\n      'camel-case-expansion': true,\n      'combine-arrays': false,\n      'dot-notation': true,\n      'duplicate-arguments-array': true,\n      'flatten-duplicate-arrays': true,\n      'greedy-arrays': true,\n      'halt-at-non-option': false,\n      'nargs-eats-options': false,\n      'negation-prefix': 'no-',\n      'parse-numbers': true,\n      'parse-positional-numbers': true,\n      'populate--': false,\n      'set-placeholder-key': false,\n      'short-option-groups': true,\n      'strip-aliased': false,\n      'strip-dashed': false,\n      'unknown-options-as-args': false\n    }, opts.configuration);\n    const defaults = Object.assign(Object.create(null), opts.default);\n    const configObjects = opts.configObjects || [];\n    const envPrefix = opts.envPrefix;\n    const notFlagsOption = configuration['populate--'];\n    const notFlagsArgv = notFlagsOption ? '--' : '_';\n    const newAliases = Object.create(null);\n    const defaulted = Object.create(null);\n    // allow a i18n handler to be passed in, default to a fake one (util.format).\n    const __ = opts.__ || mixin.format;\n    const flags = {\n      aliases: Object.create(null),\n      arrays: Object.create(null),\n      bools: Object.create(null),\n      strings: Object.create(null),\n      numbers: Object.create(null),\n      counts: Object.create(null),\n      normalize: Object.create(null),\n      configs: Object.create(null),\n      nargs: Object.create(null),\n      coercions: Object.create(null),\n      keys: []\n    };\n    const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n    const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n    [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n      const key = typeof opt === 'object' ? opt.key : opt;\n      // assign to flags[bools|strings|numbers]\n      const assignment = Object.keys(opt).map(function (key) {\n        const arrayFlagKeys = {\n          boolean: 'bools',\n          string: 'strings',\n          number: 'numbers'\n        };\n        return arrayFlagKeys[key];\n      }).filter(Boolean).pop();\n      // assign key to be coerced\n      if (assignment) {\n        flags[assignment][key] = true;\n      }\n      flags.arrays[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n      flags.bools[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n      flags.strings[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n      flags.numbers[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n      flags.counts[key] = true;\n      flags.keys.push(key);\n    });\n    [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n      flags.normalize[key] = true;\n      flags.keys.push(key);\n    });\n    if (typeof opts.narg === 'object') {\n      Object.entries(opts.narg).forEach(_ref => {\n        let [key, value] = _ref;\n        if (typeof value === 'number') {\n          flags.nargs[key] = value;\n          flags.keys.push(key);\n        }\n      });\n    }\n    if (typeof opts.coerce === 'object') {\n      Object.entries(opts.coerce).forEach(_ref2 => {\n        let [key, value] = _ref2;\n        if (typeof value === 'function') {\n          flags.coercions[key] = value;\n          flags.keys.push(key);\n        }\n      });\n    }\n    if (typeof opts.config !== 'undefined') {\n      if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n        ;\n        [].concat(opts.config).filter(Boolean).forEach(function (key) {\n          flags.configs[key] = true;\n        });\n      } else if (typeof opts.config === 'object') {\n        Object.entries(opts.config).forEach(_ref3 => {\n          let [key, value] = _ref3;\n          if (typeof value === 'boolean' || typeof value === 'function') {\n            flags.configs[key] = value;\n          }\n        });\n      }\n    }\n    // create a lookup table that takes into account all\n    // combinations of aliases: {f: ['foo'], foo: ['f']}\n    extendAliases(opts.key, aliases, opts.default, flags.arrays);\n    // apply default values to all aliases.\n    Object.keys(defaults).forEach(function (key) {\n      (flags.aliases[key] || []).forEach(function (alias) {\n        defaults[alias] = defaults[key];\n      });\n    });\n    let error = null;\n    checkConfiguration();\n    let notFlags = [];\n    const argv = Object.assign(Object.create(null), {\n      _: []\n    });\n    // TODO(bcoe): for the first pass at removing object prototype  we didn't\n    // remove all prototypes from objects returned by this API, we might want\n    // to gradually move towards doing so.\n    const argvReturn = {};\n    for (let i = 0; i < args.length; i++) {\n      const arg = args[i];\n      const truncatedArg = arg.replace(/^-{3,}/, '---');\n      let broken;\n      let key;\n      let letters;\n      let m;\n      let next;\n      let value;\n      // any unknown option (except for end-of-options, \"--\")\n      if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n        pushPositional(arg);\n        // ---, ---=, ----, etc,\n      } else if (truncatedArg.match(/^---+(=|$)/)) {\n        // options without key name are invalid.\n        pushPositional(arg);\n        continue;\n        // -- separated by =\n      } else if (arg.match(/^--.+=/) || !configuration['short-option-groups'] && arg.match(/^-.+=/)) {\n        // Using [\\s\\S] instead of . because js doesn't support the\n        // 'dotall' regex modifier. See:\n        // http://stackoverflow.com/a/1068308/13216\n        m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n        // arrays format = '--f=a b c'\n        if (m !== null && Array.isArray(m) && m.length >= 3) {\n          if (checkAllAliases(m[1], flags.arrays)) {\n            i = eatArray(i, m[1], args, m[2]);\n          } else if (checkAllAliases(m[1], flags.nargs) !== false) {\n            // nargs format = '--f=monkey washing cat'\n            i = eatNargs(i, m[1], args, m[2]);\n          } else {\n            setArg(m[1], m[2], true);\n          }\n        }\n      } else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n        m = arg.match(negatedBoolean);\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n        }\n        // -- separated by space.\n      } else if (arg.match(/^--.+/) || !configuration['short-option-groups'] && arg.match(/^-[^-]+/)) {\n        m = arg.match(/^--?(.+)/);\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '--foo a b c'\n            i = eatArray(i, key, args);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '--foo a b c'\n            // should be truthy even if: flags.nargs[key] === 0\n            i = eatNargs(i, key, args);\n          } else {\n            next = args[i + 1];\n            if (next !== undefined && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else if (/^(true|false)$/.test(next)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        }\n        // dot-notation flag separated by '='.\n      } else if (arg.match(/^-.\\..+=/)) {\n        m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n        if (m !== null && Array.isArray(m) && m.length >= 3) {\n          setArg(m[1], m[2]);\n        }\n        // dot-notation flag separated by space.\n      } else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n        next = args[i + 1];\n        m = arg.match(/^-(.\\..+)/);\n        if (m !== null && Array.isArray(m) && m.length >= 2) {\n          key = m[1];\n          if (next !== undefined && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n            setArg(key, next);\n            i++;\n          } else {\n            setArg(key, defaultValue(key));\n          }\n        }\n      } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n        letters = arg.slice(1, -1).split('');\n        broken = false;\n        for (let j = 0; j < letters.length; j++) {\n          next = arg.slice(j + 2);\n          if (letters[j + 1] && letters[j + 1] === '=') {\n            value = arg.slice(j + 3);\n            key = letters[j];\n            if (checkAllAliases(key, flags.arrays)) {\n              // array format = '-f=a b c'\n              i = eatArray(i, key, args, value);\n            } else if (checkAllAliases(key, flags.nargs) !== false) {\n              // nargs format = '-f=monkey washing cat'\n              i = eatNargs(i, key, args, value);\n            } else {\n              setArg(key, value);\n            }\n            broken = true;\n            break;\n          }\n          if (next === '-') {\n            setArg(letters[j], next);\n            continue;\n          }\n          // current letter is an alphabetic character and next value is a number\n          if (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {\n            setArg(letters[j], next);\n            broken = true;\n            break;\n          }\n          if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n            setArg(letters[j], next);\n            broken = true;\n            break;\n          } else {\n            setArg(letters[j], defaultValue(letters[j]));\n          }\n        }\n        key = arg.slice(-1)[0];\n        if (!broken && key !== '-') {\n          if (checkAllAliases(key, flags.arrays)) {\n            // array format = '-f a b c'\n            i = eatArray(i, key, args);\n          } else if (checkAllAliases(key, flags.nargs) !== false) {\n            // nargs format = '-f a b c'\n            // should be truthy even if: flags.nargs[key] === 0\n            i = eatNargs(i, key, args);\n          } else {\n            next = args[i + 1];\n            if (next !== undefined && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {\n              setArg(key, next);\n              i++;\n            } else if (/^(true|false)$/.test(next)) {\n              setArg(key, next);\n              i++;\n            } else {\n              setArg(key, defaultValue(key));\n            }\n          }\n        }\n      } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {\n        // single-digit boolean alias, e.g: xargs -0\n        key = arg.slice(1);\n        setArg(key, defaultValue(key));\n      } else if (arg === '--') {\n        notFlags = args.slice(i + 1);\n        break;\n      } else if (configuration['halt-at-non-option']) {\n        notFlags = args.slice(i);\n        break;\n      } else {\n        pushPositional(arg);\n      }\n    }\n    // order of precedence:\n    // 1. command line arg\n    // 2. value from env var\n    // 3. value from config file\n    // 4. value from config objects\n    // 5. configured default value\n    applyEnvVars(argv, true); // special case: check env vars that point to config file\n    applyEnvVars(argv, false);\n    setConfig(argv);\n    setConfigObjects();\n    applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n    applyCoercions(argv);\n    if (configuration['set-placeholder-key']) setPlaceholderKeys(argv);\n    // for any counts either not in args or without an explicit default, set to 0\n    Object.keys(flags.counts).forEach(function (key) {\n      if (!hasKey(argv, key.split('.'))) setArg(key, 0);\n    });\n    // '--' defaults to undefined.\n    if (notFlagsOption && notFlags.length) argv[notFlagsArgv] = [];\n    notFlags.forEach(function (key) {\n      argv[notFlagsArgv].push(key);\n    });\n    if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n      Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n        delete argv[key];\n      });\n    }\n    if (configuration['strip-aliased']) {\n      ;\n      [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n        if (configuration['camel-case-expansion'] && alias.includes('-')) {\n          delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n        }\n        delete argv[alias];\n      });\n    }\n    // Push argument into positional array, applying numeric coercion:\n    function pushPositional(arg) {\n      const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n      if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n        argv._.push(maybeCoercedNumber);\n      }\n    }\n    // how many arguments should we consume, based\n    // on the nargs option?\n    function eatNargs(i, key, args, argAfterEqualSign) {\n      let ii;\n      let toEat = checkAllAliases(key, flags.nargs);\n      // NaN has a special meaning for the array type, indicating that one or\n      // more values are expected.\n      toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n      if (toEat === 0) {\n        if (!isUndefined(argAfterEqualSign)) {\n          error = Error(__('Argument unexpected for: %s', key));\n        }\n        setArg(key, defaultValue(key));\n        return i;\n      }\n      let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n      if (configuration['nargs-eats-options']) {\n        // classic behavior, yargs eats positional and dash arguments.\n        if (args.length - (i + 1) + available < toEat) {\n          error = Error(__('Not enough arguments following: %s', key));\n        }\n        available = toEat;\n      } else {\n        // nargs will not consume flag arguments, e.g., -abc, --foo,\n        // and terminates when one is observed.\n        for (ii = i + 1; ii < args.length; ii++) {\n          if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii])) available++;else break;\n        }\n        if (available < toEat) error = Error(__('Not enough arguments following: %s', key));\n      }\n      let consumed = Math.min(available, toEat);\n      if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n        setArg(key, argAfterEqualSign);\n        consumed--;\n      }\n      for (ii = i + 1; ii < consumed + i + 1; ii++) {\n        setArg(key, args[ii]);\n      }\n      return i + consumed;\n    }\n    // if an option is an array, eat all non-hyphenated arguments\n    // following it... YUM!\n    // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n    function eatArray(i, key, args, argAfterEqualSign) {\n      let argsToSet = [];\n      let next = argAfterEqualSign || args[i + 1];\n      // If both array and nargs are configured, enforce the nargs count:\n      const nargsCount = checkAllAliases(key, flags.nargs);\n      if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {\n        argsToSet.push(true);\n      } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {\n        // for keys without value ==> argsToSet remains an empty []\n        // set user default value, if available\n        if (defaults[key] !== undefined) {\n          const defVal = defaults[key];\n          argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n        }\n      } else {\n        // value in --option=value is eaten as is\n        if (!isUndefined(argAfterEqualSign)) {\n          argsToSet.push(processValue(key, argAfterEqualSign, true));\n        }\n        for (let ii = i + 1; ii < args.length; ii++) {\n          if (!configuration['greedy-arrays'] && argsToSet.length > 0 || nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount) break;\n          next = args[ii];\n          if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;\n          i = ii;\n          argsToSet.push(processValue(key, next, inputIsString));\n        }\n      }\n      // If both array and nargs are configured, create an error if less than\n      // nargs positionals were found. NaN has special meaning, indicating\n      // that at least one value is required (more are okay).\n      if (typeof nargsCount === 'number' && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {\n        error = Error(__('Not enough arguments following: %s', key));\n      }\n      setArg(key, argsToSet);\n      return i;\n    }\n    function setArg(key, val) {\n      let shouldStripQuotes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : inputIsString;\n      if (/-/.test(key) && configuration['camel-case-expansion']) {\n        const alias = key.split('.').map(function (prop) {\n          return camelCase(prop);\n        }).join('.');\n        addNewAlias(key, alias);\n      }\n      const value = processValue(key, val, shouldStripQuotes);\n      const splitKey = key.split('.');\n      setKey(argv, splitKey, value);\n      // handle populating aliases of the full key\n      if (flags.aliases[key]) {\n        flags.aliases[key].forEach(function (x) {\n          const keyProperties = x.split('.');\n          setKey(argv, keyProperties, value);\n        });\n      }\n      // handle populating aliases of the first element of the dot-notation key\n      if (splitKey.length > 1 && configuration['dot-notation']) {\n        ;\n        (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n          let keyProperties = x.split('.');\n          // expand alias with nested objects in key\n          const a = [].concat(splitKey);\n          a.shift(); // nuke the old key.\n          keyProperties = keyProperties.concat(a);\n          // populate alias only if is not already an alias of the full key\n          // (already populated above)\n          if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n            setKey(argv, keyProperties, value);\n          }\n        });\n      }\n      // Set normalize getter and setter when key is in 'normalize' but isn't an array\n      if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n        const keys = [key].concat(flags.aliases[key] || []);\n        keys.forEach(function (key) {\n          Object.defineProperty(argvReturn, key, {\n            enumerable: true,\n            get() {\n              return val;\n            },\n            set(value) {\n              val = typeof value === 'string' ? mixin.normalize(value) : value;\n            }\n          });\n        });\n      }\n    }\n    function addNewAlias(key, alias) {\n      if (!(flags.aliases[key] && flags.aliases[key].length)) {\n        flags.aliases[key] = [alias];\n        newAliases[alias] = true;\n      }\n      if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n        addNewAlias(alias, key);\n      }\n    }\n    function processValue(key, val, shouldStripQuotes) {\n      // strings may be quoted, clean this up as we assign values.\n      if (shouldStripQuotes) {\n        val = stripQuotes(val);\n      }\n      // handle parsing boolean arguments --foo=true --bar false.\n      if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n        if (typeof val === 'string') val = val === 'true';\n      }\n      let value = Array.isArray(val) ? val.map(function (v) {\n        return maybeCoerceNumber(key, v);\n      }) : maybeCoerceNumber(key, val);\n      // increment a count given as arg (either no value or value parsed as boolean)\n      if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n        value = increment();\n      }\n      // Set normalized value when key is in 'normalize' and in 'arrays'\n      if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n        if (Array.isArray(val)) value = val.map(val => {\n          return mixin.normalize(val);\n        });else value = mixin.normalize(val);\n      }\n      return value;\n    }\n    function maybeCoerceNumber(key, value) {\n      if (!configuration['parse-positional-numbers'] && key === '_') return value;\n      if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n        const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && Number.isSafeInteger(Math.floor(parseFloat(`${value}`)));\n        if (shouldCoerceNumber || !isUndefined(value) && checkAllAliases(key, flags.numbers)) {\n          value = Number(value);\n        }\n      }\n      return value;\n    }\n    // set args from config.json file, this should be\n    // applied last so that defaults can be applied.\n    function setConfig(argv) {\n      const configLookup = Object.create(null);\n      // expand defaults/aliases, in-case any happen to reference\n      // the config.json file.\n      applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n      Object.keys(flags.configs).forEach(function (configKey) {\n        const configPath = argv[configKey] || configLookup[configKey];\n        if (configPath) {\n          try {\n            let config = null;\n            const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n            const resolveConfig = flags.configs[configKey];\n            if (typeof resolveConfig === 'function') {\n              try {\n                config = resolveConfig(resolvedConfigPath);\n              } catch (e) {\n                config = e;\n              }\n              if (config instanceof Error) {\n                error = config;\n                return;\n              }\n            } else {\n              config = mixin.require(resolvedConfigPath);\n            }\n            setConfigObject(config);\n          } catch (ex) {\n            // Deno will receive a PermissionDenied error if an attempt is\n            // made to load config without the --allow-read flag:\n            if (ex.name === 'PermissionDenied') error = ex;else if (argv[configKey]) error = Error(__('Invalid JSON config file: %s', configPath));\n          }\n        }\n      });\n    }\n    // set args from config object.\n    // it recursively checks nested objects.\n    function setConfigObject(config, prev) {\n      Object.keys(config).forEach(function (key) {\n        const value = config[key];\n        const fullKey = prev ? prev + '.' + key : key;\n        // if the value is an inner object and we have dot-notation\n        // enabled, treat inner objects in config the same as\n        // heavily nested dot notations (foo.bar.apple).\n        if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n          // if the value is an object but not an array, check nested object\n          setConfigObject(value, fullKey);\n        } else {\n          // setting arguments via CLI takes precedence over\n          // values within the config file.\n          if (!hasKey(argv, fullKey.split('.')) || checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays']) {\n            setArg(fullKey, value);\n          }\n        }\n      });\n    }\n    // set all config objects passed in opts\n    function setConfigObjects() {\n      if (typeof configObjects !== 'undefined') {\n        configObjects.forEach(function (configObject) {\n          setConfigObject(configObject);\n        });\n      }\n    }\n    function applyEnvVars(argv, configOnly) {\n      if (typeof envPrefix === 'undefined') return;\n      const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n      const env = mixin.env();\n      Object.keys(env).forEach(function (envVar) {\n        if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n          // get array of nested keys and convert them to camel case\n          const keys = envVar.split('__').map(function (key, i) {\n            if (i === 0) {\n              key = key.substring(prefix.length);\n            }\n            return camelCase(key);\n          });\n          if ((configOnly && flags.configs[keys.join('.')] || !configOnly) && !hasKey(argv, keys)) {\n            setArg(keys.join('.'), env[envVar]);\n          }\n        }\n      });\n    }\n    function applyCoercions(argv) {\n      let coerce;\n      const applied = new Set();\n      Object.keys(argv).forEach(function (key) {\n        if (!applied.has(key)) {\n          // If we haven't already coerced this option via one of its aliases\n          coerce = checkAllAliases(key, flags.coercions);\n          if (typeof coerce === 'function') {\n            try {\n              const value = maybeCoerceNumber(key, coerce(argv[key]));\n              [].concat(flags.aliases[key] || [], key).forEach(ali => {\n                applied.add(ali);\n                argv[ali] = value;\n              });\n            } catch (err) {\n              error = err;\n            }\n          }\n        }\n      });\n    }\n    function setPlaceholderKeys(argv) {\n      flags.keys.forEach(key => {\n        // don't set placeholder keys for dot notation options 'foo.bar'.\n        if (~key.indexOf('.')) return;\n        if (typeof argv[key] === 'undefined') argv[key] = undefined;\n      });\n      return argv;\n    }\n    function applyDefaultsAndAliases(obj, aliases, defaults) {\n      let canLog = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      Object.keys(defaults).forEach(function (key) {\n        if (!hasKey(obj, key.split('.'))) {\n          setKey(obj, key.split('.'), defaults[key]);\n          if (canLog) defaulted[key] = true;\n          (aliases[key] || []).forEach(function (x) {\n            if (hasKey(obj, x.split('.'))) return;\n            setKey(obj, x.split('.'), defaults[key]);\n          });\n        }\n      });\n    }\n    function hasKey(obj, keys) {\n      let o = obj;\n      if (!configuration['dot-notation']) keys = [keys.join('.')];\n      keys.slice(0, -1).forEach(function (key) {\n        o = o[key] || {};\n      });\n      const key = keys[keys.length - 1];\n      if (typeof o !== 'object') return false;else return key in o;\n    }\n    function setKey(obj, keys, value) {\n      let o = obj;\n      if (!configuration['dot-notation']) keys = [keys.join('.')];\n      keys.slice(0, -1).forEach(function (key) {\n        // TODO(bcoe): in the next major version of yargs, switch to\n        // Object.create(null) for dot notation:\n        key = sanitizeKey(key);\n        if (typeof o === 'object' && o[key] === undefined) {\n          o[key] = {};\n        }\n        if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n          // ensure that o[key] is an array, and that the last item is an empty object.\n          if (Array.isArray(o[key])) {\n            o[key].push({});\n          } else {\n            o[key] = [o[key], {}];\n          }\n          // we want to update the empty object at the end of the o[key] array, so set o to that object\n          o = o[key][o[key].length - 1];\n        } else {\n          o = o[key];\n        }\n      });\n      // TODO(bcoe): in the next major version of yargs, switch to\n      // Object.create(null) for dot notation:\n      const key = sanitizeKey(keys[keys.length - 1]);\n      const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n      const isValueArray = Array.isArray(value);\n      let duplicate = configuration['duplicate-arguments-array'];\n      // nargs has higher priority than duplicate\n      if (!duplicate && checkAllAliases(key, flags.nargs)) {\n        duplicate = true;\n        if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {\n          o[key] = undefined;\n        }\n      }\n      if (value === increment()) {\n        o[key] = increment(o[key]);\n      } else if (Array.isArray(o[key])) {\n        if (duplicate && isTypeArray && isValueArray) {\n          o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n        } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n          o[key] = value;\n        } else {\n          o[key] = o[key].concat([value]);\n        }\n      } else if (o[key] === undefined && isTypeArray) {\n        o[key] = isValueArray ? value : [value];\n      } else if (duplicate && !(o[key] === undefined || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {\n        o[key] = [o[key], value];\n      } else {\n        o[key] = value;\n      }\n    }\n    // extend the aliases list with inferred aliases.\n    function extendAliases() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      args.forEach(function (obj) {\n        Object.keys(obj || {}).forEach(function (key) {\n          // short-circuit if we've already added a key\n          // to the aliases array, for example it might\n          // exist in both 'opts.default' and 'opts.key'.\n          if (flags.aliases[key]) return;\n          flags.aliases[key] = [].concat(aliases[key] || []);\n          // For \"--option-name\", also set argv.optionName\n          flags.aliases[key].concat(key).forEach(function (x) {\n            if (/-/.test(x) && configuration['camel-case-expansion']) {\n              const c = camelCase(x);\n              if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                flags.aliases[key].push(c);\n                newAliases[c] = true;\n              }\n            }\n          });\n          // For \"--optionName\", also set argv['option-name']\n          flags.aliases[key].concat(key).forEach(function (x) {\n            if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n              const c = decamelize(x, '-');\n              if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                flags.aliases[key].push(c);\n                newAliases[c] = true;\n              }\n            }\n          });\n          flags.aliases[key].forEach(function (x) {\n            flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n              return x !== y;\n            }));\n          });\n        });\n      });\n    }\n    function checkAllAliases(key, flag) {\n      const toCheck = [].concat(flags.aliases[key] || [], key);\n      const keys = Object.keys(flag);\n      const setAlias = toCheck.find(key => keys.includes(key));\n      return setAlias ? flag[setAlias] : false;\n    }\n    function hasAnyFlag(key) {\n      const flagsKeys = Object.keys(flags);\n      const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n      return toCheck.some(function (flag) {\n        return Array.isArray(flag) ? flag.includes(key) : flag[key];\n      });\n    }\n    function hasFlagsMatching(arg) {\n      for (var _len2 = arguments.length, patterns = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        patterns[_key2 - 1] = arguments[_key2];\n      }\n      const toCheck = [].concat(...patterns);\n      return toCheck.some(function (pattern) {\n        const match = arg.match(pattern);\n        return match && hasAnyFlag(match[1]);\n      });\n    }\n    // based on a simplified version of the short flag group parsing logic\n    function hasAllShortFlags(arg) {\n      // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n      if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n        return false;\n      }\n      let hasAllFlags = true;\n      let next;\n      const letters = arg.slice(1).split('');\n      for (let j = 0; j < letters.length; j++) {\n        next = arg.slice(j + 2);\n        if (!hasAnyFlag(letters[j])) {\n          hasAllFlags = false;\n          break;\n        }\n        if (letters[j + 1] && letters[j + 1] === '=' || next === '-' || /[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\\W/)) {\n          break;\n        }\n      }\n      return hasAllFlags;\n    }\n    function isUnknownOptionAsArg(arg) {\n      return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n    }\n    function isUnknownOption(arg) {\n      arg = arg.replace(/^-{3,}/, '--');\n      // ignore negative numbers\n      if (arg.match(negative)) {\n        return false;\n      }\n      // if this is a short option group and all of them are configured, it isn't unknown\n      if (hasAllShortFlags(arg)) {\n        return false;\n      }\n      // e.g. '--count=2'\n      const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n      // e.g. '-a' or '--arg'\n      const normalFlag = /^-+([^=]+?)$/;\n      // e.g. '-a-'\n      const flagEndingInHyphen = /^-+([^=]+?)-$/;\n      // e.g. '-abc123'\n      const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n      // e.g. '-a/usr/local'\n      const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n      // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n      return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n    }\n    // make a best effort to pick a default value\n    // for an option based on name and type.\n    function defaultValue(key) {\n      if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {\n        return defaults[key];\n      } else {\n        return defaultForType(guessType(key));\n      }\n    }\n    // return a default value, given the type of a flag.,\n    function defaultForType(type) {\n      const def = {\n        [DefaultValuesForTypeKey.BOOLEAN]: true,\n        [DefaultValuesForTypeKey.STRING]: '',\n        [DefaultValuesForTypeKey.NUMBER]: undefined,\n        [DefaultValuesForTypeKey.ARRAY]: []\n      };\n      return def[type];\n    }\n    // given a flag, enforce a default type.\n    function guessType(key) {\n      let type = DefaultValuesForTypeKey.BOOLEAN;\n      if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;\n      return type;\n    }\n    function isUndefined(num) {\n      return num === undefined;\n    }\n    // check user configuration settings for inconsistencies\n    function checkConfiguration() {\n      // count keys should not be set as array/narg\n      Object.keys(flags.counts).find(key => {\n        if (checkAllAliases(key, flags.arrays)) {\n          error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n          return true;\n        } else if (checkAllAliases(key, flags.nargs)) {\n          error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n          return true;\n        }\n        return false;\n      });\n    }\n    return {\n      aliases: Object.assign({}, flags.aliases),\n      argv: Object.assign(argvReturn, argv),\n      configuration: configuration,\n      defaulted: Object.assign({}, defaulted),\n      error: error,\n      newAliases: Object.assign({}, newAliases)\n    };\n  }\n}\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n  const aliasArrays = [];\n  const combined = Object.create(null);\n  let change = true;\n  // turn alias lookup hash {key: ['alias1', 'alias2']} into\n  // a simple array ['key', 'alias1', 'alias2']\n  Object.keys(aliases).forEach(function (key) {\n    aliasArrays.push([].concat(aliases[key], key));\n  });\n  // combine arrays until zero changes are\n  // made in an iteration.\n  while (change) {\n    change = false;\n    for (let i = 0; i < aliasArrays.length; i++) {\n      for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n        const intersect = aliasArrays[i].filter(function (v) {\n          return aliasArrays[ii].indexOf(v) !== -1;\n        });\n        if (intersect.length) {\n          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n          aliasArrays.splice(ii, 1);\n          change = true;\n          break;\n        }\n      }\n    }\n  }\n  // map arrays back to the hash-lookup (de-dupe while\n  // we're at it).\n  aliasArrays.forEach(function (aliasArray) {\n    aliasArray = aliasArray.filter(function (v, i, self) {\n      return self.indexOf(v) === i;\n    });\n    const lastAlias = aliasArray.pop();\n    if (lastAlias !== undefined && typeof lastAlias === 'string') {\n      combined[lastAlias] = aliasArray;\n    }\n  });\n  return combined;\n}\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n  return orig !== undefined ? orig + 1 : 1;\n}\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey(key) {\n  if (key === '__proto__') return '___proto___';\n  return key;\n}\nfunction stripQuotes(val) {\n  return typeof val === 'string' && (val[0] === \"'\" || val[0] === '\"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;\n}","map":{"version":3,"names":["tokenizeArgString","DefaultValuesForTypeKey","camelCase","decamelize","looksLikeNumber","mixin","YargsParser","constructor","_mixin","parse","argsInput","options","opts","Object","assign","alias","undefined","array","boolean","config","configObjects","configuration","coerce","count","default","envPrefix","narg","normalize","string","number","__","key","args","inputIsString","aliases","combineAliases","create","defaults","notFlagsOption","notFlagsArgv","newAliases","defaulted","format","flags","arrays","bools","strings","numbers","counts","configs","nargs","coercions","keys","negative","negatedBoolean","RegExp","concat","filter","Boolean","forEach","opt","assignment","map","arrayFlagKeys","pop","push","entries","value","Array","isArray","extendAliases","error","checkConfiguration","notFlags","argv","_","argvReturn","i","length","arg","truncatedArg","replace","broken","letters","m","next","test","isUnknownOptionAsArg","pushPositional","match","checkAllAliases","eatArray","eatNargs","setArg","defaultValue","slice","split","j","applyEnvVars","setConfig","setConfigObjects","applyDefaultsAndAliases","applyCoercions","setPlaceholderKeys","hasKey","includes","k","prop","join","maybeCoercedNumber","maybeCoerceNumber","argAfterEqualSign","ii","toEat","isNaN","isUndefined","Error","available","consumed","Math","min","argsToSet","nargsCount","defVal","processValue","val","shouldStripQuotes","addNewAlias","splitKey","setKey","x","keyProperties","a","shift","defineProperty","enumerable","get","set","stripQuotes","v","increment","shouldCoerceNumber","Number","isSafeInteger","floor","parseFloat","configLookup","configKey","configPath","resolvedConfigPath","resolve","cwd","resolveConfig","e","require","setConfigObject","ex","name","prev","fullKey","configObject","configOnly","prefix","env","envVar","lastIndexOf","substring","applied","Set","has","ali","add","err","indexOf","obj","canLog","o","sanitizeKey","isTypeArray","isValueArray","duplicate","c","y","flag","toCheck","setAlias","find","hasAnyFlag","flagsKeys","some","hasFlagsMatching","patterns","pattern","hasAllShortFlags","hasAllFlags","isUnknownOption","flagWithEquals","normalFlag","flagEndingInHyphen","flagEndingInDigits","flagEndingInNonWordCharacters","defaultForType","guessType","type","def","BOOLEAN","STRING","NUMBER","ARRAY","num","aliasArrays","combined","change","intersect","splice","aliasArray","self","lastAlias","orig"],"sources":["D:/Julieth-Campos/PSO/node_modules/@puppeteer/browsers/node_modules/yargs-parser/build/lib/yargs-parser.js"],"sourcesContent":["/**\n * @license\n * Copyright (c) 2016, Contributors\n * SPDX-License-Identifier: ISC\n */\nimport { tokenizeArgString } from './tokenize-arg-string.js';\nimport { DefaultValuesForTypeKey } from './yargs-parser-types.js';\nimport { camelCase, decamelize, looksLikeNumber } from './string-utils.js';\nlet mixin;\nexport class YargsParser {\n    constructor(_mixin) {\n        mixin = _mixin;\n    }\n    parse(argsInput, options) {\n        const opts = Object.assign({\n            alias: undefined,\n            array: undefined,\n            boolean: undefined,\n            config: undefined,\n            configObjects: undefined,\n            configuration: undefined,\n            coerce: undefined,\n            count: undefined,\n            default: undefined,\n            envPrefix: undefined,\n            narg: undefined,\n            normalize: undefined,\n            string: undefined,\n            number: undefined,\n            __: undefined,\n            key: undefined\n        }, options);\n        // allow a string argument to be passed in rather\n        // than an argv array.\n        const args = tokenizeArgString(argsInput);\n        // tokenizeArgString adds extra quotes to args if argsInput is a string\n        // only strip those extra quotes in processValue if argsInput is a string\n        const inputIsString = typeof argsInput === 'string';\n        // aliases might have transitive relationships, normalize this.\n        const aliases = combineAliases(Object.assign(Object.create(null), opts.alias));\n        const configuration = Object.assign({\n            'boolean-negation': true,\n            'camel-case-expansion': true,\n            'combine-arrays': false,\n            'dot-notation': true,\n            'duplicate-arguments-array': true,\n            'flatten-duplicate-arrays': true,\n            'greedy-arrays': true,\n            'halt-at-non-option': false,\n            'nargs-eats-options': false,\n            'negation-prefix': 'no-',\n            'parse-numbers': true,\n            'parse-positional-numbers': true,\n            'populate--': false,\n            'set-placeholder-key': false,\n            'short-option-groups': true,\n            'strip-aliased': false,\n            'strip-dashed': false,\n            'unknown-options-as-args': false\n        }, opts.configuration);\n        const defaults = Object.assign(Object.create(null), opts.default);\n        const configObjects = opts.configObjects || [];\n        const envPrefix = opts.envPrefix;\n        const notFlagsOption = configuration['populate--'];\n        const notFlagsArgv = notFlagsOption ? '--' : '_';\n        const newAliases = Object.create(null);\n        const defaulted = Object.create(null);\n        // allow a i18n handler to be passed in, default to a fake one (util.format).\n        const __ = opts.__ || mixin.format;\n        const flags = {\n            aliases: Object.create(null),\n            arrays: Object.create(null),\n            bools: Object.create(null),\n            strings: Object.create(null),\n            numbers: Object.create(null),\n            counts: Object.create(null),\n            normalize: Object.create(null),\n            configs: Object.create(null),\n            nargs: Object.create(null),\n            coercions: Object.create(null),\n            keys: []\n        };\n        const negative = /^-([0-9]+(\\.[0-9]+)?|\\.[0-9]+)$/;\n        const negatedBoolean = new RegExp('^--' + configuration['negation-prefix'] + '(.+)');\n        [].concat(opts.array || []).filter(Boolean).forEach(function (opt) {\n            const key = typeof opt === 'object' ? opt.key : opt;\n            // assign to flags[bools|strings|numbers]\n            const assignment = Object.keys(opt).map(function (key) {\n                const arrayFlagKeys = {\n                    boolean: 'bools',\n                    string: 'strings',\n                    number: 'numbers'\n                };\n                return arrayFlagKeys[key];\n            }).filter(Boolean).pop();\n            // assign key to be coerced\n            if (assignment) {\n                flags[assignment][key] = true;\n            }\n            flags.arrays[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.boolean || []).filter(Boolean).forEach(function (key) {\n            flags.bools[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.string || []).filter(Boolean).forEach(function (key) {\n            flags.strings[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.number || []).filter(Boolean).forEach(function (key) {\n            flags.numbers[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.count || []).filter(Boolean).forEach(function (key) {\n            flags.counts[key] = true;\n            flags.keys.push(key);\n        });\n        [].concat(opts.normalize || []).filter(Boolean).forEach(function (key) {\n            flags.normalize[key] = true;\n            flags.keys.push(key);\n        });\n        if (typeof opts.narg === 'object') {\n            Object.entries(opts.narg).forEach(([key, value]) => {\n                if (typeof value === 'number') {\n                    flags.nargs[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.coerce === 'object') {\n            Object.entries(opts.coerce).forEach(([key, value]) => {\n                if (typeof value === 'function') {\n                    flags.coercions[key] = value;\n                    flags.keys.push(key);\n                }\n            });\n        }\n        if (typeof opts.config !== 'undefined') {\n            if (Array.isArray(opts.config) || typeof opts.config === 'string') {\n                ;\n                [].concat(opts.config).filter(Boolean).forEach(function (key) {\n                    flags.configs[key] = true;\n                });\n            }\n            else if (typeof opts.config === 'object') {\n                Object.entries(opts.config).forEach(([key, value]) => {\n                    if (typeof value === 'boolean' || typeof value === 'function') {\n                        flags.configs[key] = value;\n                    }\n                });\n            }\n        }\n        // create a lookup table that takes into account all\n        // combinations of aliases: {f: ['foo'], foo: ['f']}\n        extendAliases(opts.key, aliases, opts.default, flags.arrays);\n        // apply default values to all aliases.\n        Object.keys(defaults).forEach(function (key) {\n            (flags.aliases[key] || []).forEach(function (alias) {\n                defaults[alias] = defaults[key];\n            });\n        });\n        let error = null;\n        checkConfiguration();\n        let notFlags = [];\n        const argv = Object.assign(Object.create(null), { _: [] });\n        // TODO(bcoe): for the first pass at removing object prototype  we didn't\n        // remove all prototypes from objects returned by this API, we might want\n        // to gradually move towards doing so.\n        const argvReturn = {};\n        for (let i = 0; i < args.length; i++) {\n            const arg = args[i];\n            const truncatedArg = arg.replace(/^-{3,}/, '---');\n            let broken;\n            let key;\n            let letters;\n            let m;\n            let next;\n            let value;\n            // any unknown option (except for end-of-options, \"--\")\n            if (arg !== '--' && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {\n                pushPositional(arg);\n                // ---, ---=, ----, etc,\n            }\n            else if (truncatedArg.match(/^---+(=|$)/)) {\n                // options without key name are invalid.\n                pushPositional(arg);\n                continue;\n                // -- separated by =\n            }\n            else if (arg.match(/^--.+=/) || (!configuration['short-option-groups'] && arg.match(/^-.+=/))) {\n                // Using [\\s\\S] instead of . because js doesn't support the\n                // 'dotall' regex modifier. See:\n                // http://stackoverflow.com/a/1068308/13216\n                m = arg.match(/^--?([^=]+)=([\\s\\S]*)$/);\n                // arrays format = '--f=a b c'\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    if (checkAllAliases(m[1], flags.arrays)) {\n                        i = eatArray(i, m[1], args, m[2]);\n                    }\n                    else if (checkAllAliases(m[1], flags.nargs) !== false) {\n                        // nargs format = '--f=monkey washing cat'\n                        i = eatNargs(i, m[1], args, m[2]);\n                    }\n                    else {\n                        setArg(m[1], m[2], true);\n                    }\n                }\n            }\n            else if (arg.match(negatedBoolean) && configuration['boolean-negation']) {\n                m = arg.match(negatedBoolean);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    setArg(key, checkAllAliases(key, flags.arrays) ? [false] : false);\n                }\n                // -- separated by space.\n            }\n            else if (arg.match(/^--.+/) || (!configuration['short-option-groups'] && arg.match(/^-[^-]+/))) {\n                m = arg.match(/^--?(.+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '--foo a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '--foo a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!next.match(/^-/) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n                // dot-notation flag separated by '='.\n            }\n            else if (arg.match(/^-.\\..+=/)) {\n                m = arg.match(/^-([^=]+)=([\\s\\S]*)$/);\n                if (m !== null && Array.isArray(m) && m.length >= 3) {\n                    setArg(m[1], m[2]);\n                }\n                // dot-notation flag separated by space.\n            }\n            else if (arg.match(/^-.\\..+/) && !arg.match(negative)) {\n                next = args[i + 1];\n                m = arg.match(/^-(.\\..+)/);\n                if (m !== null && Array.isArray(m) && m.length >= 2) {\n                    key = m[1];\n                    if (next !== undefined && !next.match(/^-/) &&\n                        !checkAllAliases(key, flags.bools) &&\n                        !checkAllAliases(key, flags.counts)) {\n                        setArg(key, next);\n                        i++;\n                    }\n                    else {\n                        setArg(key, defaultValue(key));\n                    }\n                }\n            }\n            else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {\n                letters = arg.slice(1, -1).split('');\n                broken = false;\n                for (let j = 0; j < letters.length; j++) {\n                    next = arg.slice(j + 2);\n                    if (letters[j + 1] && letters[j + 1] === '=') {\n                        value = arg.slice(j + 3);\n                        key = letters[j];\n                        if (checkAllAliases(key, flags.arrays)) {\n                            // array format = '-f=a b c'\n                            i = eatArray(i, key, args, value);\n                        }\n                        else if (checkAllAliases(key, flags.nargs) !== false) {\n                            // nargs format = '-f=monkey washing cat'\n                            i = eatNargs(i, key, args, value);\n                        }\n                        else {\n                            setArg(key, value);\n                        }\n                        broken = true;\n                        break;\n                    }\n                    if (next === '-') {\n                        setArg(letters[j], next);\n                        continue;\n                    }\n                    // current letter is an alphabetic character and next value is a number\n                    if (/[A-Za-z]/.test(letters[j]) &&\n                        /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next) &&\n                        checkAllAliases(next, flags.bools) === false) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    if (letters[j + 1] && letters[j + 1].match(/\\W/)) {\n                        setArg(letters[j], next);\n                        broken = true;\n                        break;\n                    }\n                    else {\n                        setArg(letters[j], defaultValue(letters[j]));\n                    }\n                }\n                key = arg.slice(-1)[0];\n                if (!broken && key !== '-') {\n                    if (checkAllAliases(key, flags.arrays)) {\n                        // array format = '-f a b c'\n                        i = eatArray(i, key, args);\n                    }\n                    else if (checkAllAliases(key, flags.nargs) !== false) {\n                        // nargs format = '-f a b c'\n                        // should be truthy even if: flags.nargs[key] === 0\n                        i = eatNargs(i, key, args);\n                    }\n                    else {\n                        next = args[i + 1];\n                        if (next !== undefined && (!/^(-|--)[^-]/.test(next) ||\n                            next.match(negative)) &&\n                            !checkAllAliases(key, flags.bools) &&\n                            !checkAllAliases(key, flags.counts)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else if (/^(true|false)$/.test(next)) {\n                            setArg(key, next);\n                            i++;\n                        }\n                        else {\n                            setArg(key, defaultValue(key));\n                        }\n                    }\n                }\n            }\n            else if (arg.match(/^-[0-9]$/) &&\n                arg.match(negative) &&\n                checkAllAliases(arg.slice(1), flags.bools)) {\n                // single-digit boolean alias, e.g: xargs -0\n                key = arg.slice(1);\n                setArg(key, defaultValue(key));\n            }\n            else if (arg === '--') {\n                notFlags = args.slice(i + 1);\n                break;\n            }\n            else if (configuration['halt-at-non-option']) {\n                notFlags = args.slice(i);\n                break;\n            }\n            else {\n                pushPositional(arg);\n            }\n        }\n        // order of precedence:\n        // 1. command line arg\n        // 2. value from env var\n        // 3. value from config file\n        // 4. value from config objects\n        // 5. configured default value\n        applyEnvVars(argv, true); // special case: check env vars that point to config file\n        applyEnvVars(argv, false);\n        setConfig(argv);\n        setConfigObjects();\n        applyDefaultsAndAliases(argv, flags.aliases, defaults, true);\n        applyCoercions(argv);\n        if (configuration['set-placeholder-key'])\n            setPlaceholderKeys(argv);\n        // for any counts either not in args or without an explicit default, set to 0\n        Object.keys(flags.counts).forEach(function (key) {\n            if (!hasKey(argv, key.split('.')))\n                setArg(key, 0);\n        });\n        // '--' defaults to undefined.\n        if (notFlagsOption && notFlags.length)\n            argv[notFlagsArgv] = [];\n        notFlags.forEach(function (key) {\n            argv[notFlagsArgv].push(key);\n        });\n        if (configuration['camel-case-expansion'] && configuration['strip-dashed']) {\n            Object.keys(argv).filter(key => key !== '--' && key.includes('-')).forEach(key => {\n                delete argv[key];\n            });\n        }\n        if (configuration['strip-aliased']) {\n            ;\n            [].concat(...Object.keys(aliases).map(k => aliases[k])).forEach(alias => {\n                if (configuration['camel-case-expansion'] && alias.includes('-')) {\n                    delete argv[alias.split('.').map(prop => camelCase(prop)).join('.')];\n                }\n                delete argv[alias];\n            });\n        }\n        // Push argument into positional array, applying numeric coercion:\n        function pushPositional(arg) {\n            const maybeCoercedNumber = maybeCoerceNumber('_', arg);\n            if (typeof maybeCoercedNumber === 'string' || typeof maybeCoercedNumber === 'number') {\n                argv._.push(maybeCoercedNumber);\n            }\n        }\n        // how many arguments should we consume, based\n        // on the nargs option?\n        function eatNargs(i, key, args, argAfterEqualSign) {\n            let ii;\n            let toEat = checkAllAliases(key, flags.nargs);\n            // NaN has a special meaning for the array type, indicating that one or\n            // more values are expected.\n            toEat = typeof toEat !== 'number' || isNaN(toEat) ? 1 : toEat;\n            if (toEat === 0) {\n                if (!isUndefined(argAfterEqualSign)) {\n                    error = Error(__('Argument unexpected for: %s', key));\n                }\n                setArg(key, defaultValue(key));\n                return i;\n            }\n            let available = isUndefined(argAfterEqualSign) ? 0 : 1;\n            if (configuration['nargs-eats-options']) {\n                // classic behavior, yargs eats positional and dash arguments.\n                if (args.length - (i + 1) + available < toEat) {\n                    error = Error(__('Not enough arguments following: %s', key));\n                }\n                available = toEat;\n            }\n            else {\n                // nargs will not consume flag arguments, e.g., -abc, --foo,\n                // and terminates when one is observed.\n                for (ii = i + 1; ii < args.length; ii++) {\n                    if (!args[ii].match(/^-[^0-9]/) || args[ii].match(negative) || isUnknownOptionAsArg(args[ii]))\n                        available++;\n                    else\n                        break;\n                }\n                if (available < toEat)\n                    error = Error(__('Not enough arguments following: %s', key));\n            }\n            let consumed = Math.min(available, toEat);\n            if (!isUndefined(argAfterEqualSign) && consumed > 0) {\n                setArg(key, argAfterEqualSign);\n                consumed--;\n            }\n            for (ii = i + 1; ii < (consumed + i + 1); ii++) {\n                setArg(key, args[ii]);\n            }\n            return (i + consumed);\n        }\n        // if an option is an array, eat all non-hyphenated arguments\n        // following it... YUM!\n        // e.g., --foo apple banana cat becomes [\"apple\", \"banana\", \"cat\"]\n        function eatArray(i, key, args, argAfterEqualSign) {\n            let argsToSet = [];\n            let next = argAfterEqualSign || args[i + 1];\n            // If both array and nargs are configured, enforce the nargs count:\n            const nargsCount = checkAllAliases(key, flags.nargs);\n            if (checkAllAliases(key, flags.bools) && !(/^(true|false)$/.test(next))) {\n                argsToSet.push(true);\n            }\n            else if (isUndefined(next) ||\n                (isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))) {\n                // for keys without value ==> argsToSet remains an empty []\n                // set user default value, if available\n                if (defaults[key] !== undefined) {\n                    const defVal = defaults[key];\n                    argsToSet = Array.isArray(defVal) ? defVal : [defVal];\n                }\n            }\n            else {\n                // value in --option=value is eaten as is\n                if (!isUndefined(argAfterEqualSign)) {\n                    argsToSet.push(processValue(key, argAfterEqualSign, true));\n                }\n                for (let ii = i + 1; ii < args.length; ii++) {\n                    if ((!configuration['greedy-arrays'] && argsToSet.length > 0) ||\n                        (nargsCount && typeof nargsCount === 'number' && argsToSet.length >= nargsCount))\n                        break;\n                    next = args[ii];\n                    if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next))\n                        break;\n                    i = ii;\n                    argsToSet.push(processValue(key, next, inputIsString));\n                }\n            }\n            // If both array and nargs are configured, create an error if less than\n            // nargs positionals were found. NaN has special meaning, indicating\n            // that at least one value is required (more are okay).\n            if (typeof nargsCount === 'number' && ((nargsCount && argsToSet.length < nargsCount) ||\n                (isNaN(nargsCount) && argsToSet.length === 0))) {\n                error = Error(__('Not enough arguments following: %s', key));\n            }\n            setArg(key, argsToSet);\n            return i;\n        }\n        function setArg(key, val, shouldStripQuotes = inputIsString) {\n            if (/-/.test(key) && configuration['camel-case-expansion']) {\n                const alias = key.split('.').map(function (prop) {\n                    return camelCase(prop);\n                }).join('.');\n                addNewAlias(key, alias);\n            }\n            const value = processValue(key, val, shouldStripQuotes);\n            const splitKey = key.split('.');\n            setKey(argv, splitKey, value);\n            // handle populating aliases of the full key\n            if (flags.aliases[key]) {\n                flags.aliases[key].forEach(function (x) {\n                    const keyProperties = x.split('.');\n                    setKey(argv, keyProperties, value);\n                });\n            }\n            // handle populating aliases of the first element of the dot-notation key\n            if (splitKey.length > 1 && configuration['dot-notation']) {\n                ;\n                (flags.aliases[splitKey[0]] || []).forEach(function (x) {\n                    let keyProperties = x.split('.');\n                    // expand alias with nested objects in key\n                    const a = [].concat(splitKey);\n                    a.shift(); // nuke the old key.\n                    keyProperties = keyProperties.concat(a);\n                    // populate alias only if is not already an alias of the full key\n                    // (already populated above)\n                    if (!(flags.aliases[key] || []).includes(keyProperties.join('.'))) {\n                        setKey(argv, keyProperties, value);\n                    }\n                });\n            }\n            // Set normalize getter and setter when key is in 'normalize' but isn't an array\n            if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {\n                const keys = [key].concat(flags.aliases[key] || []);\n                keys.forEach(function (key) {\n                    Object.defineProperty(argvReturn, key, {\n                        enumerable: true,\n                        get() {\n                            return val;\n                        },\n                        set(value) {\n                            val = typeof value === 'string' ? mixin.normalize(value) : value;\n                        }\n                    });\n                });\n            }\n        }\n        function addNewAlias(key, alias) {\n            if (!(flags.aliases[key] && flags.aliases[key].length)) {\n                flags.aliases[key] = [alias];\n                newAliases[alias] = true;\n            }\n            if (!(flags.aliases[alias] && flags.aliases[alias].length)) {\n                addNewAlias(alias, key);\n            }\n        }\n        function processValue(key, val, shouldStripQuotes) {\n            // strings may be quoted, clean this up as we assign values.\n            if (shouldStripQuotes) {\n                val = stripQuotes(val);\n            }\n            // handle parsing boolean arguments --foo=true --bar false.\n            if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {\n                if (typeof val === 'string')\n                    val = val === 'true';\n            }\n            let value = Array.isArray(val)\n                ? val.map(function (v) { return maybeCoerceNumber(key, v); })\n                : maybeCoerceNumber(key, val);\n            // increment a count given as arg (either no value or value parsed as boolean)\n            if (checkAllAliases(key, flags.counts) && (isUndefined(value) || typeof value === 'boolean')) {\n                value = increment();\n            }\n            // Set normalized value when key is in 'normalize' and in 'arrays'\n            if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {\n                if (Array.isArray(val))\n                    value = val.map((val) => { return mixin.normalize(val); });\n                else\n                    value = mixin.normalize(val);\n            }\n            return value;\n        }\n        function maybeCoerceNumber(key, value) {\n            if (!configuration['parse-positional-numbers'] && key === '_')\n                return value;\n            if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value)) {\n                const shouldCoerceNumber = looksLikeNumber(value) && configuration['parse-numbers'] && (Number.isSafeInteger(Math.floor(parseFloat(`${value}`))));\n                if (shouldCoerceNumber || (!isUndefined(value) && checkAllAliases(key, flags.numbers))) {\n                    value = Number(value);\n                }\n            }\n            return value;\n        }\n        // set args from config.json file, this should be\n        // applied last so that defaults can be applied.\n        function setConfig(argv) {\n            const configLookup = Object.create(null);\n            // expand defaults/aliases, in-case any happen to reference\n            // the config.json file.\n            applyDefaultsAndAliases(configLookup, flags.aliases, defaults);\n            Object.keys(flags.configs).forEach(function (configKey) {\n                const configPath = argv[configKey] || configLookup[configKey];\n                if (configPath) {\n                    try {\n                        let config = null;\n                        const resolvedConfigPath = mixin.resolve(mixin.cwd(), configPath);\n                        const resolveConfig = flags.configs[configKey];\n                        if (typeof resolveConfig === 'function') {\n                            try {\n                                config = resolveConfig(resolvedConfigPath);\n                            }\n                            catch (e) {\n                                config = e;\n                            }\n                            if (config instanceof Error) {\n                                error = config;\n                                return;\n                            }\n                        }\n                        else {\n                            config = mixin.require(resolvedConfigPath);\n                        }\n                        setConfigObject(config);\n                    }\n                    catch (ex) {\n                        // Deno will receive a PermissionDenied error if an attempt is\n                        // made to load config without the --allow-read flag:\n                        if (ex.name === 'PermissionDenied')\n                            error = ex;\n                        else if (argv[configKey])\n                            error = Error(__('Invalid JSON config file: %s', configPath));\n                    }\n                }\n            });\n        }\n        // set args from config object.\n        // it recursively checks nested objects.\n        function setConfigObject(config, prev) {\n            Object.keys(config).forEach(function (key) {\n                const value = config[key];\n                const fullKey = prev ? prev + '.' + key : key;\n                // if the value is an inner object and we have dot-notation\n                // enabled, treat inner objects in config the same as\n                // heavily nested dot notations (foo.bar.apple).\n                if (typeof value === 'object' && value !== null && !Array.isArray(value) && configuration['dot-notation']) {\n                    // if the value is an object but not an array, check nested object\n                    setConfigObject(value, fullKey);\n                }\n                else {\n                    // setting arguments via CLI takes precedence over\n                    // values within the config file.\n                    if (!hasKey(argv, fullKey.split('.')) || (checkAllAliases(fullKey, flags.arrays) && configuration['combine-arrays'])) {\n                        setArg(fullKey, value);\n                    }\n                }\n            });\n        }\n        // set all config objects passed in opts\n        function setConfigObjects() {\n            if (typeof configObjects !== 'undefined') {\n                configObjects.forEach(function (configObject) {\n                    setConfigObject(configObject);\n                });\n            }\n        }\n        function applyEnvVars(argv, configOnly) {\n            if (typeof envPrefix === 'undefined')\n                return;\n            const prefix = typeof envPrefix === 'string' ? envPrefix : '';\n            const env = mixin.env();\n            Object.keys(env).forEach(function (envVar) {\n                if (prefix === '' || envVar.lastIndexOf(prefix, 0) === 0) {\n                    // get array of nested keys and convert them to camel case\n                    const keys = envVar.split('__').map(function (key, i) {\n                        if (i === 0) {\n                            key = key.substring(prefix.length);\n                        }\n                        return camelCase(key);\n                    });\n                    if (((configOnly && flags.configs[keys.join('.')]) || !configOnly) && !hasKey(argv, keys)) {\n                        setArg(keys.join('.'), env[envVar]);\n                    }\n                }\n            });\n        }\n        function applyCoercions(argv) {\n            let coerce;\n            const applied = new Set();\n            Object.keys(argv).forEach(function (key) {\n                if (!applied.has(key)) { // If we haven't already coerced this option via one of its aliases\n                    coerce = checkAllAliases(key, flags.coercions);\n                    if (typeof coerce === 'function') {\n                        try {\n                            const value = maybeCoerceNumber(key, coerce(argv[key]));\n                            ([].concat(flags.aliases[key] || [], key)).forEach(ali => {\n                                applied.add(ali);\n                                argv[ali] = value;\n                            });\n                        }\n                        catch (err) {\n                            error = err;\n                        }\n                    }\n                }\n            });\n        }\n        function setPlaceholderKeys(argv) {\n            flags.keys.forEach((key) => {\n                // don't set placeholder keys for dot notation options 'foo.bar'.\n                if (~key.indexOf('.'))\n                    return;\n                if (typeof argv[key] === 'undefined')\n                    argv[key] = undefined;\n            });\n            return argv;\n        }\n        function applyDefaultsAndAliases(obj, aliases, defaults, canLog = false) {\n            Object.keys(defaults).forEach(function (key) {\n                if (!hasKey(obj, key.split('.'))) {\n                    setKey(obj, key.split('.'), defaults[key]);\n                    if (canLog)\n                        defaulted[key] = true;\n                    (aliases[key] || []).forEach(function (x) {\n                        if (hasKey(obj, x.split('.')))\n                            return;\n                        setKey(obj, x.split('.'), defaults[key]);\n                    });\n                }\n            });\n        }\n        function hasKey(obj, keys) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                o = (o[key] || {});\n            });\n            const key = keys[keys.length - 1];\n            if (typeof o !== 'object')\n                return false;\n            else\n                return key in o;\n        }\n        function setKey(obj, keys, value) {\n            let o = obj;\n            if (!configuration['dot-notation'])\n                keys = [keys.join('.')];\n            keys.slice(0, -1).forEach(function (key) {\n                // TODO(bcoe): in the next major version of yargs, switch to\n                // Object.create(null) for dot notation:\n                key = sanitizeKey(key);\n                if (typeof o === 'object' && o[key] === undefined) {\n                    o[key] = {};\n                }\n                if (typeof o[key] !== 'object' || Array.isArray(o[key])) {\n                    // ensure that o[key] is an array, and that the last item is an empty object.\n                    if (Array.isArray(o[key])) {\n                        o[key].push({});\n                    }\n                    else {\n                        o[key] = [o[key], {}];\n                    }\n                    // we want to update the empty object at the end of the o[key] array, so set o to that object\n                    o = o[key][o[key].length - 1];\n                }\n                else {\n                    o = o[key];\n                }\n            });\n            // TODO(bcoe): in the next major version of yargs, switch to\n            // Object.create(null) for dot notation:\n            const key = sanitizeKey(keys[keys.length - 1]);\n            const isTypeArray = checkAllAliases(keys.join('.'), flags.arrays);\n            const isValueArray = Array.isArray(value);\n            let duplicate = configuration['duplicate-arguments-array'];\n            // nargs has higher priority than duplicate\n            if (!duplicate && checkAllAliases(key, flags.nargs)) {\n                duplicate = true;\n                if ((!isUndefined(o[key]) && flags.nargs[key] === 1) || (Array.isArray(o[key]) && o[key].length === flags.nargs[key])) {\n                    o[key] = undefined;\n                }\n            }\n            if (value === increment()) {\n                o[key] = increment(o[key]);\n            }\n            else if (Array.isArray(o[key])) {\n                if (duplicate && isTypeArray && isValueArray) {\n                    o[key] = configuration['flatten-duplicate-arrays'] ? o[key].concat(value) : (Array.isArray(o[key][0]) ? o[key] : [o[key]]).concat([value]);\n                }\n                else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {\n                    o[key] = value;\n                }\n                else {\n                    o[key] = o[key].concat([value]);\n                }\n            }\n            else if (o[key] === undefined && isTypeArray) {\n                o[key] = isValueArray ? value : [value];\n            }\n            else if (duplicate && !(o[key] === undefined ||\n                checkAllAliases(key, flags.counts) ||\n                checkAllAliases(key, flags.bools))) {\n                o[key] = [o[key], value];\n            }\n            else {\n                o[key] = value;\n            }\n        }\n        // extend the aliases list with inferred aliases.\n        function extendAliases(...args) {\n            args.forEach(function (obj) {\n                Object.keys(obj || {}).forEach(function (key) {\n                    // short-circuit if we've already added a key\n                    // to the aliases array, for example it might\n                    // exist in both 'opts.default' and 'opts.key'.\n                    if (flags.aliases[key])\n                        return;\n                    flags.aliases[key] = [].concat(aliases[key] || []);\n                    // For \"--option-name\", also set argv.optionName\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (/-/.test(x) && configuration['camel-case-expansion']) {\n                            const c = camelCase(x);\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    // For \"--optionName\", also set argv['option-name']\n                    flags.aliases[key].concat(key).forEach(function (x) {\n                        if (x.length > 1 && /[A-Z]/.test(x) && configuration['camel-case-expansion']) {\n                            const c = decamelize(x, '-');\n                            if (c !== key && flags.aliases[key].indexOf(c) === -1) {\n                                flags.aliases[key].push(c);\n                                newAliases[c] = true;\n                            }\n                        }\n                    });\n                    flags.aliases[key].forEach(function (x) {\n                        flags.aliases[x] = [key].concat(flags.aliases[key].filter(function (y) {\n                            return x !== y;\n                        }));\n                    });\n                });\n            });\n        }\n        function checkAllAliases(key, flag) {\n            const toCheck = [].concat(flags.aliases[key] || [], key);\n            const keys = Object.keys(flag);\n            const setAlias = toCheck.find(key => keys.includes(key));\n            return setAlias ? flag[setAlias] : false;\n        }\n        function hasAnyFlag(key) {\n            const flagsKeys = Object.keys(flags);\n            const toCheck = [].concat(flagsKeys.map(k => flags[k]));\n            return toCheck.some(function (flag) {\n                return Array.isArray(flag) ? flag.includes(key) : flag[key];\n            });\n        }\n        function hasFlagsMatching(arg, ...patterns) {\n            const toCheck = [].concat(...patterns);\n            return toCheck.some(function (pattern) {\n                const match = arg.match(pattern);\n                return match && hasAnyFlag(match[1]);\n            });\n        }\n        // based on a simplified version of the short flag group parsing logic\n        function hasAllShortFlags(arg) {\n            // if this is a negative number, or doesn't start with a single hyphen, it's not a short flag group\n            if (arg.match(negative) || !arg.match(/^-[^-]+/)) {\n                return false;\n            }\n            let hasAllFlags = true;\n            let next;\n            const letters = arg.slice(1).split('');\n            for (let j = 0; j < letters.length; j++) {\n                next = arg.slice(j + 2);\n                if (!hasAnyFlag(letters[j])) {\n                    hasAllFlags = false;\n                    break;\n                }\n                if ((letters[j + 1] && letters[j + 1] === '=') ||\n                    next === '-' ||\n                    (/[A-Za-z]/.test(letters[j]) && /^-?\\d+(\\.\\d*)?(e-?\\d+)?$/.test(next)) ||\n                    (letters[j + 1] && letters[j + 1].match(/\\W/))) {\n                    break;\n                }\n            }\n            return hasAllFlags;\n        }\n        function isUnknownOptionAsArg(arg) {\n            return configuration['unknown-options-as-args'] && isUnknownOption(arg);\n        }\n        function isUnknownOption(arg) {\n            arg = arg.replace(/^-{3,}/, '--');\n            // ignore negative numbers\n            if (arg.match(negative)) {\n                return false;\n            }\n            // if this is a short option group and all of them are configured, it isn't unknown\n            if (hasAllShortFlags(arg)) {\n                return false;\n            }\n            // e.g. '--count=2'\n            const flagWithEquals = /^-+([^=]+?)=[\\s\\S]*$/;\n            // e.g. '-a' or '--arg'\n            const normalFlag = /^-+([^=]+?)$/;\n            // e.g. '-a-'\n            const flagEndingInHyphen = /^-+([^=]+?)-$/;\n            // e.g. '-abc123'\n            const flagEndingInDigits = /^-+([^=]+?\\d+)$/;\n            // e.g. '-a/usr/local'\n            const flagEndingInNonWordCharacters = /^-+([^=]+?)\\W+.*$/;\n            // check the different types of flag styles, including negatedBoolean, a pattern defined near the start of the parse method\n            return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);\n        }\n        // make a best effort to pick a default value\n        // for an option based on name and type.\n        function defaultValue(key) {\n            if (!checkAllAliases(key, flags.bools) &&\n                !checkAllAliases(key, flags.counts) &&\n                `${key}` in defaults) {\n                return defaults[key];\n            }\n            else {\n                return defaultForType(guessType(key));\n            }\n        }\n        // return a default value, given the type of a flag.,\n        function defaultForType(type) {\n            const def = {\n                [DefaultValuesForTypeKey.BOOLEAN]: true,\n                [DefaultValuesForTypeKey.STRING]: '',\n                [DefaultValuesForTypeKey.NUMBER]: undefined,\n                [DefaultValuesForTypeKey.ARRAY]: []\n            };\n            return def[type];\n        }\n        // given a flag, enforce a default type.\n        function guessType(key) {\n            let type = DefaultValuesForTypeKey.BOOLEAN;\n            if (checkAllAliases(key, flags.strings))\n                type = DefaultValuesForTypeKey.STRING;\n            else if (checkAllAliases(key, flags.numbers))\n                type = DefaultValuesForTypeKey.NUMBER;\n            else if (checkAllAliases(key, flags.bools))\n                type = DefaultValuesForTypeKey.BOOLEAN;\n            else if (checkAllAliases(key, flags.arrays))\n                type = DefaultValuesForTypeKey.ARRAY;\n            return type;\n        }\n        function isUndefined(num) {\n            return num === undefined;\n        }\n        // check user configuration settings for inconsistencies\n        function checkConfiguration() {\n            // count keys should not be set as array/narg\n            Object.keys(flags.counts).find(key => {\n                if (checkAllAliases(key, flags.arrays)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.array.', key));\n                    return true;\n                }\n                else if (checkAllAliases(key, flags.nargs)) {\n                    error = Error(__('Invalid configuration: %s, opts.count excludes opts.narg.', key));\n                    return true;\n                }\n                return false;\n            });\n        }\n        return {\n            aliases: Object.assign({}, flags.aliases),\n            argv: Object.assign(argvReturn, argv),\n            configuration: configuration,\n            defaulted: Object.assign({}, defaulted),\n            error: error,\n            newAliases: Object.assign({}, newAliases)\n        };\n    }\n}\n// if any aliases reference each other, we should\n// merge them together.\nfunction combineAliases(aliases) {\n    const aliasArrays = [];\n    const combined = Object.create(null);\n    let change = true;\n    // turn alias lookup hash {key: ['alias1', 'alias2']} into\n    // a simple array ['key', 'alias1', 'alias2']\n    Object.keys(aliases).forEach(function (key) {\n        aliasArrays.push([].concat(aliases[key], key));\n    });\n    // combine arrays until zero changes are\n    // made in an iteration.\n    while (change) {\n        change = false;\n        for (let i = 0; i < aliasArrays.length; i++) {\n            for (let ii = i + 1; ii < aliasArrays.length; ii++) {\n                const intersect = aliasArrays[i].filter(function (v) {\n                    return aliasArrays[ii].indexOf(v) !== -1;\n                });\n                if (intersect.length) {\n                    aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);\n                    aliasArrays.splice(ii, 1);\n                    change = true;\n                    break;\n                }\n            }\n        }\n    }\n    // map arrays back to the hash-lookup (de-dupe while\n    // we're at it).\n    aliasArrays.forEach(function (aliasArray) {\n        aliasArray = aliasArray.filter(function (v, i, self) {\n            return self.indexOf(v) === i;\n        });\n        const lastAlias = aliasArray.pop();\n        if (lastAlias !== undefined && typeof lastAlias === 'string') {\n            combined[lastAlias] = aliasArray;\n        }\n    });\n    return combined;\n}\n// this function should only be called when a count is given as an arg\n// it is NOT called to set a default value\n// thus we can start the count at 1 instead of 0\nfunction increment(orig) {\n    return orig !== undefined ? orig + 1 : 1;\n}\n// TODO(bcoe): in the next major version of yargs, switch to\n// Object.create(null) for dot notation:\nfunction sanitizeKey(key) {\n    if (key === '__proto__')\n        return '___proto___';\n    return key;\n}\nfunction stripQuotes(val) {\n    return (typeof val === 'string' &&\n        (val[0] === \"'\" || val[0] === '\"') &&\n        val[val.length - 1] === val[0])\n        ? val.substring(1, val.length - 1)\n        : val;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA,SAASA,iBAAiB,QAAQ,0BAA0B;AAC5D,SAASC,uBAAuB,QAAQ,yBAAyB;AACjE,SAASC,SAAS,EAAEC,UAAU,EAAEC,eAAe,QAAQ,mBAAmB;AAC1E,IAAIC,KAAK;AACT,OAAO,MAAMC,WAAW,CAAC;EACrBC,WAAW,CAACC,MAAM,EAAE;IAChBH,KAAK,GAAGG,MAAM;EAClB;EACAC,KAAK,CAACC,SAAS,EAAEC,OAAO,EAAE;IACtB,MAAMC,IAAI,GAAGC,MAAM,CAACC,MAAM,CAAC;MACvBC,KAAK,EAAEC,SAAS;MAChBC,KAAK,EAAED,SAAS;MAChBE,OAAO,EAAEF,SAAS;MAClBG,MAAM,EAAEH,SAAS;MACjBI,aAAa,EAAEJ,SAAS;MACxBK,aAAa,EAAEL,SAAS;MACxBM,MAAM,EAAEN,SAAS;MACjBO,KAAK,EAAEP,SAAS;MAChBQ,OAAO,EAAER,SAAS;MAClBS,SAAS,EAAET,SAAS;MACpBU,IAAI,EAAEV,SAAS;MACfW,SAAS,EAAEX,SAAS;MACpBY,MAAM,EAAEZ,SAAS;MACjBa,MAAM,EAAEb,SAAS;MACjBc,EAAE,EAAEd,SAAS;MACbe,GAAG,EAAEf;IACT,CAAC,EAAEL,OAAO,CAAC;IACX;IACA;IACA,MAAMqB,IAAI,GAAGhC,iBAAiB,CAACU,SAAS,CAAC;IACzC;IACA;IACA,MAAMuB,aAAa,GAAG,OAAOvB,SAAS,KAAK,QAAQ;IACnD;IACA,MAAMwB,OAAO,GAAGC,cAAc,CAACtB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC,EAAExB,IAAI,CAACG,KAAK,CAAC,CAAC;IAC9E,MAAMM,aAAa,GAAGR,MAAM,CAACC,MAAM,CAAC;MAChC,kBAAkB,EAAE,IAAI;MACxB,sBAAsB,EAAE,IAAI;MAC5B,gBAAgB,EAAE,KAAK;MACvB,cAAc,EAAE,IAAI;MACpB,2BAA2B,EAAE,IAAI;MACjC,0BAA0B,EAAE,IAAI;MAChC,eAAe,EAAE,IAAI;MACrB,oBAAoB,EAAE,KAAK;MAC3B,oBAAoB,EAAE,KAAK;MAC3B,iBAAiB,EAAE,KAAK;MACxB,eAAe,EAAE,IAAI;MACrB,0BAA0B,EAAE,IAAI;MAChC,YAAY,EAAE,KAAK;MACnB,qBAAqB,EAAE,KAAK;MAC5B,qBAAqB,EAAE,IAAI;MAC3B,eAAe,EAAE,KAAK;MACtB,cAAc,EAAE,KAAK;MACrB,yBAAyB,EAAE;IAC/B,CAAC,EAAEF,IAAI,CAACS,aAAa,CAAC;IACtB,MAAMgB,QAAQ,GAAGxB,MAAM,CAACC,MAAM,CAACD,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC,EAAExB,IAAI,CAACY,OAAO,CAAC;IACjE,MAAMJ,aAAa,GAAGR,IAAI,CAACQ,aAAa,IAAI,EAAE;IAC9C,MAAMK,SAAS,GAAGb,IAAI,CAACa,SAAS;IAChC,MAAMa,cAAc,GAAGjB,aAAa,CAAC,YAAY,CAAC;IAClD,MAAMkB,YAAY,GAAGD,cAAc,GAAG,IAAI,GAAG,GAAG;IAChD,MAAME,UAAU,GAAG3B,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;IACtC,MAAMK,SAAS,GAAG5B,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;IACrC;IACA,MAAMN,EAAE,GAAGlB,IAAI,CAACkB,EAAE,IAAIzB,KAAK,CAACqC,MAAM;IAClC,MAAMC,KAAK,GAAG;MACVT,OAAO,EAAErB,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC5BQ,MAAM,EAAE/B,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC3BS,KAAK,EAAEhC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC1BU,OAAO,EAAEjC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC5BW,OAAO,EAAElC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC5BY,MAAM,EAAEnC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC3BT,SAAS,EAAEd,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC9Ba,OAAO,EAAEpC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC5Bc,KAAK,EAAErC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC1Be,SAAS,EAAEtC,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MAC9BgB,IAAI,EAAE;IACV,CAAC;IACD,MAAMC,QAAQ,GAAG,iCAAiC;IAClD,MAAMC,cAAc,GAAG,IAAIC,MAAM,CAAC,KAAK,GAAGlC,aAAa,CAAC,iBAAiB,CAAC,GAAG,MAAM,CAAC;IACpF,EAAE,CAACmC,MAAM,CAAC5C,IAAI,CAACK,KAAK,IAAI,EAAE,CAAC,CAACwC,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAUC,GAAG,EAAE;MAC/D,MAAM7B,GAAG,GAAG,OAAO6B,GAAG,KAAK,QAAQ,GAAGA,GAAG,CAAC7B,GAAG,GAAG6B,GAAG;MACnD;MACA,MAAMC,UAAU,GAAGhD,MAAM,CAACuC,IAAI,CAACQ,GAAG,CAAC,CAACE,GAAG,CAAC,UAAU/B,GAAG,EAAE;QACnD,MAAMgC,aAAa,GAAG;UAClB7C,OAAO,EAAE,OAAO;UAChBU,MAAM,EAAE,SAAS;UACjBC,MAAM,EAAE;QACZ,CAAC;QACD,OAAOkC,aAAa,CAAChC,GAAG,CAAC;MAC7B,CAAC,CAAC,CAAC0B,MAAM,CAACC,OAAO,CAAC,CAACM,GAAG,EAAE;MACxB;MACA,IAAIH,UAAU,EAAE;QACZlB,KAAK,CAACkB,UAAU,CAAC,CAAC9B,GAAG,CAAC,GAAG,IAAI;MACjC;MACAY,KAAK,CAACC,MAAM,CAACb,GAAG,CAAC,GAAG,IAAI;MACxBY,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,EAAE,CAACyB,MAAM,CAAC5C,IAAI,CAACM,OAAO,IAAI,EAAE,CAAC,CAACuC,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAU5B,GAAG,EAAE;MACjEY,KAAK,CAACE,KAAK,CAACd,GAAG,CAAC,GAAG,IAAI;MACvBY,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,EAAE,CAACyB,MAAM,CAAC5C,IAAI,CAACgB,MAAM,IAAI,EAAE,CAAC,CAAC6B,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAU5B,GAAG,EAAE;MAChEY,KAAK,CAACG,OAAO,CAACf,GAAG,CAAC,GAAG,IAAI;MACzBY,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,EAAE,CAACyB,MAAM,CAAC5C,IAAI,CAACiB,MAAM,IAAI,EAAE,CAAC,CAAC4B,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAU5B,GAAG,EAAE;MAChEY,KAAK,CAACI,OAAO,CAAChB,GAAG,CAAC,GAAG,IAAI;MACzBY,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,EAAE,CAACyB,MAAM,CAAC5C,IAAI,CAACW,KAAK,IAAI,EAAE,CAAC,CAACkC,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAU5B,GAAG,EAAE;MAC/DY,KAAK,CAACK,MAAM,CAACjB,GAAG,CAAC,GAAG,IAAI;MACxBY,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,EAAE,CAACyB,MAAM,CAAC5C,IAAI,CAACe,SAAS,IAAI,EAAE,CAAC,CAAC8B,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAU5B,GAAG,EAAE;MACnEY,KAAK,CAAChB,SAAS,CAACI,GAAG,CAAC,GAAG,IAAI;MAC3BY,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;IACxB,CAAC,CAAC;IACF,IAAI,OAAOnB,IAAI,CAACc,IAAI,KAAK,QAAQ,EAAE;MAC/Bb,MAAM,CAACqD,OAAO,CAACtD,IAAI,CAACc,IAAI,CAAC,CAACiC,OAAO,CAAC,QAAkB;QAAA,IAAjB,CAAC5B,GAAG,EAAEoC,KAAK,CAAC;QAC3C,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;UAC3BxB,KAAK,CAACO,KAAK,CAACnB,GAAG,CAAC,GAAGoC,KAAK;UACxBxB,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;QACxB;MACJ,CAAC,CAAC;IACN;IACA,IAAI,OAAOnB,IAAI,CAACU,MAAM,KAAK,QAAQ,EAAE;MACjCT,MAAM,CAACqD,OAAO,CAACtD,IAAI,CAACU,MAAM,CAAC,CAACqC,OAAO,CAAC,SAAkB;QAAA,IAAjB,CAAC5B,GAAG,EAAEoC,KAAK,CAAC;QAC7C,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;UAC7BxB,KAAK,CAACQ,SAAS,CAACpB,GAAG,CAAC,GAAGoC,KAAK;UAC5BxB,KAAK,CAACS,IAAI,CAACa,IAAI,CAAClC,GAAG,CAAC;QACxB;MACJ,CAAC,CAAC;IACN;IACA,IAAI,OAAOnB,IAAI,CAACO,MAAM,KAAK,WAAW,EAAE;MACpC,IAAIiD,KAAK,CAACC,OAAO,CAACzD,IAAI,CAACO,MAAM,CAAC,IAAI,OAAOP,IAAI,CAACO,MAAM,KAAK,QAAQ,EAAE;QAC/D;QACA,EAAE,CAACqC,MAAM,CAAC5C,IAAI,CAACO,MAAM,CAAC,CAACsC,MAAM,CAACC,OAAO,CAAC,CAACC,OAAO,CAAC,UAAU5B,GAAG,EAAE;UAC1DY,KAAK,CAACM,OAAO,CAAClB,GAAG,CAAC,GAAG,IAAI;QAC7B,CAAC,CAAC;MACN,CAAC,MACI,IAAI,OAAOnB,IAAI,CAACO,MAAM,KAAK,QAAQ,EAAE;QACtCN,MAAM,CAACqD,OAAO,CAACtD,IAAI,CAACO,MAAM,CAAC,CAACwC,OAAO,CAAC,SAAkB;UAAA,IAAjB,CAAC5B,GAAG,EAAEoC,KAAK,CAAC;UAC7C,IAAI,OAAOA,KAAK,KAAK,SAAS,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;YAC3DxB,KAAK,CAACM,OAAO,CAAClB,GAAG,CAAC,GAAGoC,KAAK;UAC9B;QACJ,CAAC,CAAC;MACN;IACJ;IACA;IACA;IACAG,aAAa,CAAC1D,IAAI,CAACmB,GAAG,EAAEG,OAAO,EAAEtB,IAAI,CAACY,OAAO,EAAEmB,KAAK,CAACC,MAAM,CAAC;IAC5D;IACA/B,MAAM,CAACuC,IAAI,CAACf,QAAQ,CAAC,CAACsB,OAAO,CAAC,UAAU5B,GAAG,EAAE;MACzC,CAACY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,EAAE4B,OAAO,CAAC,UAAU5C,KAAK,EAAE;QAChDsB,QAAQ,CAACtB,KAAK,CAAC,GAAGsB,QAAQ,CAACN,GAAG,CAAC;MACnC,CAAC,CAAC;IACN,CAAC,CAAC;IACF,IAAIwC,KAAK,GAAG,IAAI;IAChBC,kBAAkB,EAAE;IACpB,IAAIC,QAAQ,GAAG,EAAE;IACjB,MAAMC,IAAI,GAAG7D,MAAM,CAACC,MAAM,CAACD,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC,EAAE;MAAEuC,CAAC,EAAE;IAAG,CAAC,CAAC;IAC1D;IACA;IACA;IACA,MAAMC,UAAU,GAAG,CAAC,CAAC;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG7C,IAAI,CAAC8C,MAAM,EAAED,CAAC,EAAE,EAAE;MAClC,MAAME,GAAG,GAAG/C,IAAI,CAAC6C,CAAC,CAAC;MACnB,MAAMG,YAAY,GAAGD,GAAG,CAACE,OAAO,CAAC,QAAQ,EAAE,KAAK,CAAC;MACjD,IAAIC,MAAM;MACV,IAAInD,GAAG;MACP,IAAIoD,OAAO;MACX,IAAIC,CAAC;MACL,IAAIC,IAAI;MACR,IAAIlB,KAAK;MACT;MACA,IAAIY,GAAG,KAAK,IAAI,IAAI,IAAI,CAACO,IAAI,CAACP,GAAG,CAAC,IAAIQ,oBAAoB,CAACR,GAAG,CAAC,EAAE;QAC7DS,cAAc,CAACT,GAAG,CAAC;QACnB;MACJ,CAAC,MACI,IAAIC,YAAY,CAACS,KAAK,CAAC,YAAY,CAAC,EAAE;QACvC;QACAD,cAAc,CAACT,GAAG,CAAC;QACnB;QACA;MACJ,CAAC,MACI,IAAIA,GAAG,CAACU,KAAK,CAAC,QAAQ,CAAC,IAAK,CAACpE,aAAa,CAAC,qBAAqB,CAAC,IAAI0D,GAAG,CAACU,KAAK,CAAC,OAAO,CAAE,EAAE;QAC3F;QACA;QACA;QACAL,CAAC,GAAGL,GAAG,CAACU,KAAK,CAAC,wBAAwB,CAAC;QACvC;QACA,IAAIL,CAAC,KAAK,IAAI,IAAIhB,KAAK,CAACC,OAAO,CAACe,CAAC,CAAC,IAAIA,CAAC,CAACN,MAAM,IAAI,CAAC,EAAE;UACjD,IAAIY,eAAe,CAACN,CAAC,CAAC,CAAC,CAAC,EAAEzC,KAAK,CAACC,MAAM,CAAC,EAAE;YACrCiC,CAAC,GAAGc,QAAQ,CAACd,CAAC,EAAEO,CAAC,CAAC,CAAC,CAAC,EAAEpD,IAAI,EAAEoD,CAAC,CAAC,CAAC,CAAC,CAAC;UACrC,CAAC,MACI,IAAIM,eAAe,CAACN,CAAC,CAAC,CAAC,CAAC,EAAEzC,KAAK,CAACO,KAAK,CAAC,KAAK,KAAK,EAAE;YACnD;YACA2B,CAAC,GAAGe,QAAQ,CAACf,CAAC,EAAEO,CAAC,CAAC,CAAC,CAAC,EAAEpD,IAAI,EAAEoD,CAAC,CAAC,CAAC,CAAC,CAAC;UACrC,CAAC,MACI;YACDS,MAAM,CAACT,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC;UAC5B;QACJ;MACJ,CAAC,MACI,IAAIL,GAAG,CAACU,KAAK,CAACnC,cAAc,CAAC,IAAIjC,aAAa,CAAC,kBAAkB,CAAC,EAAE;QACrE+D,CAAC,GAAGL,GAAG,CAACU,KAAK,CAACnC,cAAc,CAAC;QAC7B,IAAI8B,CAAC,KAAK,IAAI,IAAIhB,KAAK,CAACC,OAAO,CAACe,CAAC,CAAC,IAAIA,CAAC,CAACN,MAAM,IAAI,CAAC,EAAE;UACjD/C,GAAG,GAAGqD,CAAC,CAAC,CAAC,CAAC;UACVS,MAAM,CAAC9D,GAAG,EAAE2D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,GAAG,KAAK,CAAC;QACrE;QACA;MACJ,CAAC,MACI,IAAImC,GAAG,CAACU,KAAK,CAAC,OAAO,CAAC,IAAK,CAACpE,aAAa,CAAC,qBAAqB,CAAC,IAAI0D,GAAG,CAACU,KAAK,CAAC,SAAS,CAAE,EAAE;QAC5FL,CAAC,GAAGL,GAAG,CAACU,KAAK,CAAC,UAAU,CAAC;QACzB,IAAIL,CAAC,KAAK,IAAI,IAAIhB,KAAK,CAACC,OAAO,CAACe,CAAC,CAAC,IAAIA,CAAC,CAACN,MAAM,IAAI,CAAC,EAAE;UACjD/C,GAAG,GAAGqD,CAAC,CAAC,CAAC,CAAC;UACV,IAAIM,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EAAE;YACpC;YACAiC,CAAC,GAAGc,QAAQ,CAACd,CAAC,EAAE9C,GAAG,EAAEC,IAAI,CAAC;UAC9B,CAAC,MACI,IAAI0D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC,KAAK,KAAK,EAAE;YAClD;YACA;YACA2B,CAAC,GAAGe,QAAQ,CAACf,CAAC,EAAE9C,GAAG,EAAEC,IAAI,CAAC;UAC9B,CAAC,MACI;YACDqD,IAAI,GAAGrD,IAAI,CAAC6C,CAAC,GAAG,CAAC,CAAC;YAClB,IAAIQ,IAAI,KAAKrE,SAAS,KAAK,CAACqE,IAAI,CAACI,KAAK,CAAC,IAAI,CAAC,IACxCJ,IAAI,CAACI,KAAK,CAACpC,QAAQ,CAAC,CAAC,IACrB,CAACqC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAClC,CAAC6C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,EAAE;cACrC6C,MAAM,CAAC9D,GAAG,EAAEsD,IAAI,CAAC;cACjBR,CAAC,EAAE;YACP,CAAC,MACI,IAAI,gBAAgB,CAACS,IAAI,CAACD,IAAI,CAAC,EAAE;cAClCQ,MAAM,CAAC9D,GAAG,EAAEsD,IAAI,CAAC;cACjBR,CAAC,EAAE;YACP,CAAC,MACI;cACDgB,MAAM,CAAC9D,GAAG,EAAE+D,YAAY,CAAC/D,GAAG,CAAC,CAAC;YAClC;UACJ;QACJ;QACA;MACJ,CAAC,MACI,IAAIgD,GAAG,CAACU,KAAK,CAAC,UAAU,CAAC,EAAE;QAC5BL,CAAC,GAAGL,GAAG,CAACU,KAAK,CAAC,sBAAsB,CAAC;QACrC,IAAIL,CAAC,KAAK,IAAI,IAAIhB,KAAK,CAACC,OAAO,CAACe,CAAC,CAAC,IAAIA,CAAC,CAACN,MAAM,IAAI,CAAC,EAAE;UACjDe,MAAM,CAACT,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;QACtB;QACA;MACJ,CAAC,MACI,IAAIL,GAAG,CAACU,KAAK,CAAC,SAAS,CAAC,IAAI,CAACV,GAAG,CAACU,KAAK,CAACpC,QAAQ,CAAC,EAAE;QACnDgC,IAAI,GAAGrD,IAAI,CAAC6C,CAAC,GAAG,CAAC,CAAC;QAClBO,CAAC,GAAGL,GAAG,CAACU,KAAK,CAAC,WAAW,CAAC;QAC1B,IAAIL,CAAC,KAAK,IAAI,IAAIhB,KAAK,CAACC,OAAO,CAACe,CAAC,CAAC,IAAIA,CAAC,CAACN,MAAM,IAAI,CAAC,EAAE;UACjD/C,GAAG,GAAGqD,CAAC,CAAC,CAAC,CAAC;UACV,IAAIC,IAAI,KAAKrE,SAAS,IAAI,CAACqE,IAAI,CAACI,KAAK,CAAC,IAAI,CAAC,IACvC,CAACC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAClC,CAAC6C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,EAAE;YACrC6C,MAAM,CAAC9D,GAAG,EAAEsD,IAAI,CAAC;YACjBR,CAAC,EAAE;UACP,CAAC,MACI;YACDgB,MAAM,CAAC9D,GAAG,EAAE+D,YAAY,CAAC/D,GAAG,CAAC,CAAC;UAClC;QACJ;MACJ,CAAC,MACI,IAAIgD,GAAG,CAACU,KAAK,CAAC,SAAS,CAAC,IAAI,CAACV,GAAG,CAACU,KAAK,CAACpC,QAAQ,CAAC,EAAE;QACnD8B,OAAO,GAAGJ,GAAG,CAACgB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC;QACpCd,MAAM,GAAG,KAAK;QACd,KAAK,IAAIe,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,OAAO,CAACL,MAAM,EAAEmB,CAAC,EAAE,EAAE;UACrCZ,IAAI,GAAGN,GAAG,CAACgB,KAAK,CAACE,CAAC,GAAG,CAAC,CAAC;UACvB,IAAId,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,IAAId,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,EAAE;YAC1C9B,KAAK,GAAGY,GAAG,CAACgB,KAAK,CAACE,CAAC,GAAG,CAAC,CAAC;YACxBlE,GAAG,GAAGoD,OAAO,CAACc,CAAC,CAAC;YAChB,IAAIP,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EAAE;cACpC;cACAiC,CAAC,GAAGc,QAAQ,CAACd,CAAC,EAAE9C,GAAG,EAAEC,IAAI,EAAEmC,KAAK,CAAC;YACrC,CAAC,MACI,IAAIuB,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC,KAAK,KAAK,EAAE;cAClD;cACA2B,CAAC,GAAGe,QAAQ,CAACf,CAAC,EAAE9C,GAAG,EAAEC,IAAI,EAAEmC,KAAK,CAAC;YACrC,CAAC,MACI;cACD0B,MAAM,CAAC9D,GAAG,EAAEoC,KAAK,CAAC;YACtB;YACAe,MAAM,GAAG,IAAI;YACb;UACJ;UACA,IAAIG,IAAI,KAAK,GAAG,EAAE;YACdQ,MAAM,CAACV,OAAO,CAACc,CAAC,CAAC,EAAEZ,IAAI,CAAC;YACxB;UACJ;UACA;UACA,IAAI,UAAU,CAACC,IAAI,CAACH,OAAO,CAACc,CAAC,CAAC,CAAC,IAC3B,0BAA0B,CAACX,IAAI,CAACD,IAAI,CAAC,IACrCK,eAAe,CAACL,IAAI,EAAE1C,KAAK,CAACE,KAAK,CAAC,KAAK,KAAK,EAAE;YAC9CgD,MAAM,CAACV,OAAO,CAACc,CAAC,CAAC,EAAEZ,IAAI,CAAC;YACxBH,MAAM,GAAG,IAAI;YACb;UACJ;UACA,IAAIC,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,IAAId,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,CAACR,KAAK,CAAC,IAAI,CAAC,EAAE;YAC9CI,MAAM,CAACV,OAAO,CAACc,CAAC,CAAC,EAAEZ,IAAI,CAAC;YACxBH,MAAM,GAAG,IAAI;YACb;UACJ,CAAC,MACI;YACDW,MAAM,CAACV,OAAO,CAACc,CAAC,CAAC,EAAEH,YAAY,CAACX,OAAO,CAACc,CAAC,CAAC,CAAC,CAAC;UAChD;QACJ;QACAlE,GAAG,GAAGgD,GAAG,CAACgB,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,CAACb,MAAM,IAAInD,GAAG,KAAK,GAAG,EAAE;UACxB,IAAI2D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EAAE;YACpC;YACAiC,CAAC,GAAGc,QAAQ,CAACd,CAAC,EAAE9C,GAAG,EAAEC,IAAI,CAAC;UAC9B,CAAC,MACI,IAAI0D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC,KAAK,KAAK,EAAE;YAClD;YACA;YACA2B,CAAC,GAAGe,QAAQ,CAACf,CAAC,EAAE9C,GAAG,EAAEC,IAAI,CAAC;UAC9B,CAAC,MACI;YACDqD,IAAI,GAAGrD,IAAI,CAAC6C,CAAC,GAAG,CAAC,CAAC;YAClB,IAAIQ,IAAI,KAAKrE,SAAS,KAAK,CAAC,aAAa,CAACsE,IAAI,CAACD,IAAI,CAAC,IAChDA,IAAI,CAACI,KAAK,CAACpC,QAAQ,CAAC,CAAC,IACrB,CAACqC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAClC,CAAC6C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,EAAE;cACrC6C,MAAM,CAAC9D,GAAG,EAAEsD,IAAI,CAAC;cACjBR,CAAC,EAAE;YACP,CAAC,MACI,IAAI,gBAAgB,CAACS,IAAI,CAACD,IAAI,CAAC,EAAE;cAClCQ,MAAM,CAAC9D,GAAG,EAAEsD,IAAI,CAAC;cACjBR,CAAC,EAAE;YACP,CAAC,MACI;cACDgB,MAAM,CAAC9D,GAAG,EAAE+D,YAAY,CAAC/D,GAAG,CAAC,CAAC;YAClC;UACJ;QACJ;MACJ,CAAC,MACI,IAAIgD,GAAG,CAACU,KAAK,CAAC,UAAU,CAAC,IAC1BV,GAAG,CAACU,KAAK,CAACpC,QAAQ,CAAC,IACnBqC,eAAe,CAACX,GAAG,CAACgB,KAAK,CAAC,CAAC,CAAC,EAAEpD,KAAK,CAACE,KAAK,CAAC,EAAE;QAC5C;QACAd,GAAG,GAAGgD,GAAG,CAACgB,KAAK,CAAC,CAAC,CAAC;QAClBF,MAAM,CAAC9D,GAAG,EAAE+D,YAAY,CAAC/D,GAAG,CAAC,CAAC;MAClC,CAAC,MACI,IAAIgD,GAAG,KAAK,IAAI,EAAE;QACnBN,QAAQ,GAAGzC,IAAI,CAAC+D,KAAK,CAAClB,CAAC,GAAG,CAAC,CAAC;QAC5B;MACJ,CAAC,MACI,IAAIxD,aAAa,CAAC,oBAAoB,CAAC,EAAE;QAC1CoD,QAAQ,GAAGzC,IAAI,CAAC+D,KAAK,CAAClB,CAAC,CAAC;QACxB;MACJ,CAAC,MACI;QACDW,cAAc,CAACT,GAAG,CAAC;MACvB;IACJ;IACA;IACA;IACA;IACA;IACA;IACA;IACAmB,YAAY,CAACxB,IAAI,EAAE,IAAI,CAAC,CAAC,CAAC;IAC1BwB,YAAY,CAACxB,IAAI,EAAE,KAAK,CAAC;IACzByB,SAAS,CAACzB,IAAI,CAAC;IACf0B,gBAAgB,EAAE;IAClBC,uBAAuB,CAAC3B,IAAI,EAAE/B,KAAK,CAACT,OAAO,EAAEG,QAAQ,EAAE,IAAI,CAAC;IAC5DiE,cAAc,CAAC5B,IAAI,CAAC;IACpB,IAAIrD,aAAa,CAAC,qBAAqB,CAAC,EACpCkF,kBAAkB,CAAC7B,IAAI,CAAC;IAC5B;IACA7D,MAAM,CAACuC,IAAI,CAACT,KAAK,CAACK,MAAM,CAAC,CAACW,OAAO,CAAC,UAAU5B,GAAG,EAAE;MAC7C,IAAI,CAACyE,MAAM,CAAC9B,IAAI,EAAE3C,GAAG,CAACiE,KAAK,CAAC,GAAG,CAAC,CAAC,EAC7BH,MAAM,CAAC9D,GAAG,EAAE,CAAC,CAAC;IACtB,CAAC,CAAC;IACF;IACA,IAAIO,cAAc,IAAImC,QAAQ,CAACK,MAAM,EACjCJ,IAAI,CAACnC,YAAY,CAAC,GAAG,EAAE;IAC3BkC,QAAQ,CAACd,OAAO,CAAC,UAAU5B,GAAG,EAAE;MAC5B2C,IAAI,CAACnC,YAAY,CAAC,CAAC0B,IAAI,CAAClC,GAAG,CAAC;IAChC,CAAC,CAAC;IACF,IAAIV,aAAa,CAAC,sBAAsB,CAAC,IAAIA,aAAa,CAAC,cAAc,CAAC,EAAE;MACxER,MAAM,CAACuC,IAAI,CAACsB,IAAI,CAAC,CAACjB,MAAM,CAAC1B,GAAG,IAAIA,GAAG,KAAK,IAAI,IAAIA,GAAG,CAAC0E,QAAQ,CAAC,GAAG,CAAC,CAAC,CAAC9C,OAAO,CAAC5B,GAAG,IAAI;QAC9E,OAAO2C,IAAI,CAAC3C,GAAG,CAAC;MACpB,CAAC,CAAC;IACN;IACA,IAAIV,aAAa,CAAC,eAAe,CAAC,EAAE;MAChC;MACA,EAAE,CAACmC,MAAM,CAAC,GAAG3C,MAAM,CAACuC,IAAI,CAAClB,OAAO,CAAC,CAAC4B,GAAG,CAAC4C,CAAC,IAAIxE,OAAO,CAACwE,CAAC,CAAC,CAAC,CAAC,CAAC/C,OAAO,CAAC5C,KAAK,IAAI;QACrE,IAAIM,aAAa,CAAC,sBAAsB,CAAC,IAAIN,KAAK,CAAC0F,QAAQ,CAAC,GAAG,CAAC,EAAE;UAC9D,OAAO/B,IAAI,CAAC3D,KAAK,CAACiF,KAAK,CAAC,GAAG,CAAC,CAAClC,GAAG,CAAC6C,IAAI,IAAIzG,SAAS,CAACyG,IAAI,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC;QACxE;QACA,OAAOlC,IAAI,CAAC3D,KAAK,CAAC;MACtB,CAAC,CAAC;IACN;IACA;IACA,SAASyE,cAAc,CAACT,GAAG,EAAE;MACzB,MAAM8B,kBAAkB,GAAGC,iBAAiB,CAAC,GAAG,EAAE/B,GAAG,CAAC;MACtD,IAAI,OAAO8B,kBAAkB,KAAK,QAAQ,IAAI,OAAOA,kBAAkB,KAAK,QAAQ,EAAE;QAClFnC,IAAI,CAACC,CAAC,CAACV,IAAI,CAAC4C,kBAAkB,CAAC;MACnC;IACJ;IACA;IACA;IACA,SAASjB,QAAQ,CAACf,CAAC,EAAE9C,GAAG,EAAEC,IAAI,EAAE+E,iBAAiB,EAAE;MAC/C,IAAIC,EAAE;MACN,IAAIC,KAAK,GAAGvB,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC;MAC7C;MACA;MACA+D,KAAK,GAAG,OAAOA,KAAK,KAAK,QAAQ,IAAIC,KAAK,CAACD,KAAK,CAAC,GAAG,CAAC,GAAGA,KAAK;MAC7D,IAAIA,KAAK,KAAK,CAAC,EAAE;QACb,IAAI,CAACE,WAAW,CAACJ,iBAAiB,CAAC,EAAE;UACjCxC,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,6BAA6B,EAAEC,GAAG,CAAC,CAAC;QACzD;QACA8D,MAAM,CAAC9D,GAAG,EAAE+D,YAAY,CAAC/D,GAAG,CAAC,CAAC;QAC9B,OAAO8C,CAAC;MACZ;MACA,IAAIwC,SAAS,GAAGF,WAAW,CAACJ,iBAAiB,CAAC,GAAG,CAAC,GAAG,CAAC;MACtD,IAAI1F,aAAa,CAAC,oBAAoB,CAAC,EAAE;QACrC;QACA,IAAIW,IAAI,CAAC8C,MAAM,IAAID,CAAC,GAAG,CAAC,CAAC,GAAGwC,SAAS,GAAGJ,KAAK,EAAE;UAC3C1C,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,oCAAoC,EAAEC,GAAG,CAAC,CAAC;QAChE;QACAsF,SAAS,GAAGJ,KAAK;MACrB,CAAC,MACI;QACD;QACA;QACA,KAAKD,EAAE,GAAGnC,CAAC,GAAG,CAAC,EAAEmC,EAAE,GAAGhF,IAAI,CAAC8C,MAAM,EAAEkC,EAAE,EAAE,EAAE;UACrC,IAAI,CAAChF,IAAI,CAACgF,EAAE,CAAC,CAACvB,KAAK,CAAC,UAAU,CAAC,IAAIzD,IAAI,CAACgF,EAAE,CAAC,CAACvB,KAAK,CAACpC,QAAQ,CAAC,IAAIkC,oBAAoB,CAACvD,IAAI,CAACgF,EAAE,CAAC,CAAC,EACzFK,SAAS,EAAE,CAAC,KAEZ;QACR;QACA,IAAIA,SAAS,GAAGJ,KAAK,EACjB1C,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,oCAAoC,EAAEC,GAAG,CAAC,CAAC;MACpE;MACA,IAAIuF,QAAQ,GAAGC,IAAI,CAACC,GAAG,CAACH,SAAS,EAAEJ,KAAK,CAAC;MACzC,IAAI,CAACE,WAAW,CAACJ,iBAAiB,CAAC,IAAIO,QAAQ,GAAG,CAAC,EAAE;QACjDzB,MAAM,CAAC9D,GAAG,EAAEgF,iBAAiB,CAAC;QAC9BO,QAAQ,EAAE;MACd;MACA,KAAKN,EAAE,GAAGnC,CAAC,GAAG,CAAC,EAAEmC,EAAE,GAAIM,QAAQ,GAAGzC,CAAC,GAAG,CAAE,EAAEmC,EAAE,EAAE,EAAE;QAC5CnB,MAAM,CAAC9D,GAAG,EAAEC,IAAI,CAACgF,EAAE,CAAC,CAAC;MACzB;MACA,OAAQnC,CAAC,GAAGyC,QAAQ;IACxB;IACA;IACA;IACA;IACA,SAAS3B,QAAQ,CAACd,CAAC,EAAE9C,GAAG,EAAEC,IAAI,EAAE+E,iBAAiB,EAAE;MAC/C,IAAIU,SAAS,GAAG,EAAE;MAClB,IAAIpC,IAAI,GAAG0B,iBAAiB,IAAI/E,IAAI,CAAC6C,CAAC,GAAG,CAAC,CAAC;MAC3C;MACA,MAAM6C,UAAU,GAAGhC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC;MACpD,IAAIwC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAAI,CAAE,gBAAgB,CAACyC,IAAI,CAACD,IAAI,CAAE,EAAE;QACrEoC,SAAS,CAACxD,IAAI,CAAC,IAAI,CAAC;MACxB,CAAC,MACI,IAAIkD,WAAW,CAAC9B,IAAI,CAAC,IACrB8B,WAAW,CAACJ,iBAAiB,CAAC,IAAI,IAAI,CAACzB,IAAI,CAACD,IAAI,CAAC,IAAI,CAAChC,QAAQ,CAACiC,IAAI,CAACD,IAAI,CAAC,IAAI,CAACE,oBAAoB,CAACF,IAAI,CAAE,EAAE;QAC5G;QACA;QACA,IAAIhD,QAAQ,CAACN,GAAG,CAAC,KAAKf,SAAS,EAAE;UAC7B,MAAM2G,MAAM,GAAGtF,QAAQ,CAACN,GAAG,CAAC;UAC5B0F,SAAS,GAAGrD,KAAK,CAACC,OAAO,CAACsD,MAAM,CAAC,GAAGA,MAAM,GAAG,CAACA,MAAM,CAAC;QACzD;MACJ,CAAC,MACI;QACD;QACA,IAAI,CAACR,WAAW,CAACJ,iBAAiB,CAAC,EAAE;UACjCU,SAAS,CAACxD,IAAI,CAAC2D,YAAY,CAAC7F,GAAG,EAAEgF,iBAAiB,EAAE,IAAI,CAAC,CAAC;QAC9D;QACA,KAAK,IAAIC,EAAE,GAAGnC,CAAC,GAAG,CAAC,EAAEmC,EAAE,GAAGhF,IAAI,CAAC8C,MAAM,EAAEkC,EAAE,EAAE,EAAE;UACzC,IAAK,CAAC3F,aAAa,CAAC,eAAe,CAAC,IAAIoG,SAAS,CAAC3C,MAAM,GAAG,CAAC,IACvD4C,UAAU,IAAI,OAAOA,UAAU,KAAK,QAAQ,IAAID,SAAS,CAAC3C,MAAM,IAAI4C,UAAW,EAChF;UACJrC,IAAI,GAAGrD,IAAI,CAACgF,EAAE,CAAC;UACf,IAAI,IAAI,CAAC1B,IAAI,CAACD,IAAI,CAAC,IAAI,CAAChC,QAAQ,CAACiC,IAAI,CAACD,IAAI,CAAC,IAAI,CAACE,oBAAoB,CAACF,IAAI,CAAC,EACtE;UACJR,CAAC,GAAGmC,EAAE;UACNS,SAAS,CAACxD,IAAI,CAAC2D,YAAY,CAAC7F,GAAG,EAAEsD,IAAI,EAAEpD,aAAa,CAAC,CAAC;QAC1D;MACJ;MACA;MACA;MACA;MACA,IAAI,OAAOyF,UAAU,KAAK,QAAQ,KAAMA,UAAU,IAAID,SAAS,CAAC3C,MAAM,GAAG4C,UAAU,IAC9ER,KAAK,CAACQ,UAAU,CAAC,IAAID,SAAS,CAAC3C,MAAM,KAAK,CAAE,CAAC,EAAE;QAChDP,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,oCAAoC,EAAEC,GAAG,CAAC,CAAC;MAChE;MACA8D,MAAM,CAAC9D,GAAG,EAAE0F,SAAS,CAAC;MACtB,OAAO5C,CAAC;IACZ;IACA,SAASgB,MAAM,CAAC9D,GAAG,EAAE8F,GAAG,EAAqC;MAAA,IAAnCC,iBAAiB,uEAAG7F,aAAa;MACvD,IAAI,GAAG,CAACqD,IAAI,CAACvD,GAAG,CAAC,IAAIV,aAAa,CAAC,sBAAsB,CAAC,EAAE;QACxD,MAAMN,KAAK,GAAGgB,GAAG,CAACiE,KAAK,CAAC,GAAG,CAAC,CAAClC,GAAG,CAAC,UAAU6C,IAAI,EAAE;UAC7C,OAAOzG,SAAS,CAACyG,IAAI,CAAC;QAC1B,CAAC,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;QACZmB,WAAW,CAAChG,GAAG,EAAEhB,KAAK,CAAC;MAC3B;MACA,MAAMoD,KAAK,GAAGyD,YAAY,CAAC7F,GAAG,EAAE8F,GAAG,EAAEC,iBAAiB,CAAC;MACvD,MAAME,QAAQ,GAAGjG,GAAG,CAACiE,KAAK,CAAC,GAAG,CAAC;MAC/BiC,MAAM,CAACvD,IAAI,EAAEsD,QAAQ,EAAE7D,KAAK,CAAC;MAC7B;MACA,IAAIxB,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,EAAE;QACpBY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAAC4B,OAAO,CAAC,UAAUuE,CAAC,EAAE;UACpC,MAAMC,aAAa,GAAGD,CAAC,CAAClC,KAAK,CAAC,GAAG,CAAC;UAClCiC,MAAM,CAACvD,IAAI,EAAEyD,aAAa,EAAEhE,KAAK,CAAC;QACtC,CAAC,CAAC;MACN;MACA;MACA,IAAI6D,QAAQ,CAAClD,MAAM,GAAG,CAAC,IAAIzD,aAAa,CAAC,cAAc,CAAC,EAAE;QACtD;QACA,CAACsB,KAAK,CAACT,OAAO,CAAC8F,QAAQ,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,EAAErE,OAAO,CAAC,UAAUuE,CAAC,EAAE;UACpD,IAAIC,aAAa,GAAGD,CAAC,CAAClC,KAAK,CAAC,GAAG,CAAC;UAChC;UACA,MAAMoC,CAAC,GAAG,EAAE,CAAC5E,MAAM,CAACwE,QAAQ,CAAC;UAC7BI,CAAC,CAACC,KAAK,EAAE,CAAC,CAAC;UACXF,aAAa,GAAGA,aAAa,CAAC3E,MAAM,CAAC4E,CAAC,CAAC;UACvC;UACA;UACA,IAAI,CAAC,CAACzF,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,EAAE0E,QAAQ,CAAC0B,aAAa,CAACvB,IAAI,CAAC,GAAG,CAAC,CAAC,EAAE;YAC/DqB,MAAM,CAACvD,IAAI,EAAEyD,aAAa,EAAEhE,KAAK,CAAC;UACtC;QACJ,CAAC,CAAC;MACN;MACA;MACA,IAAIuB,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAAChB,SAAS,CAAC,IAAI,CAAC+D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EAAE;QAC9E,MAAMQ,IAAI,GAAG,CAACrB,GAAG,CAAC,CAACyB,MAAM,CAACb,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,CAAC;QACnDqB,IAAI,CAACO,OAAO,CAAC,UAAU5B,GAAG,EAAE;UACxBlB,MAAM,CAACyH,cAAc,CAAC1D,UAAU,EAAE7C,GAAG,EAAE;YACnCwG,UAAU,EAAE,IAAI;YAChBC,GAAG,GAAG;cACF,OAAOX,GAAG;YACd,CAAC;YACDY,GAAG,CAACtE,KAAK,EAAE;cACP0D,GAAG,GAAG,OAAO1D,KAAK,KAAK,QAAQ,GAAG9D,KAAK,CAACsB,SAAS,CAACwC,KAAK,CAAC,GAAGA,KAAK;YACpE;UACJ,CAAC,CAAC;QACN,CAAC,CAAC;MACN;IACJ;IACA,SAAS4D,WAAW,CAAChG,GAAG,EAAEhB,KAAK,EAAE;MAC7B,IAAI,EAAE4B,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,IAAIY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAAC+C,MAAM,CAAC,EAAE;QACpDnC,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,GAAG,CAAChB,KAAK,CAAC;QAC5ByB,UAAU,CAACzB,KAAK,CAAC,GAAG,IAAI;MAC5B;MACA,IAAI,EAAE4B,KAAK,CAACT,OAAO,CAACnB,KAAK,CAAC,IAAI4B,KAAK,CAACT,OAAO,CAACnB,KAAK,CAAC,CAAC+D,MAAM,CAAC,EAAE;QACxDiD,WAAW,CAAChH,KAAK,EAAEgB,GAAG,CAAC;MAC3B;IACJ;IACA,SAAS6F,YAAY,CAAC7F,GAAG,EAAE8F,GAAG,EAAEC,iBAAiB,EAAE;MAC/C;MACA,IAAIA,iBAAiB,EAAE;QACnBD,GAAG,GAAGa,WAAW,CAACb,GAAG,CAAC;MAC1B;MACA;MACA,IAAInC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAAI6C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,EAAE;QACzE,IAAI,OAAO6E,GAAG,KAAK,QAAQ,EACvBA,GAAG,GAAGA,GAAG,KAAK,MAAM;MAC5B;MACA,IAAI1D,KAAK,GAAGC,KAAK,CAACC,OAAO,CAACwD,GAAG,CAAC,GACxBA,GAAG,CAAC/D,GAAG,CAAC,UAAU6E,CAAC,EAAE;QAAE,OAAO7B,iBAAiB,CAAC/E,GAAG,EAAE4G,CAAC,CAAC;MAAE,CAAC,CAAC,GAC3D7B,iBAAiB,CAAC/E,GAAG,EAAE8F,GAAG,CAAC;MACjC;MACA,IAAInC,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,KAAKmE,WAAW,CAAChD,KAAK,CAAC,IAAI,OAAOA,KAAK,KAAK,SAAS,CAAC,EAAE;QAC1FA,KAAK,GAAGyE,SAAS,EAAE;MACvB;MACA;MACA,IAAIlD,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAAChB,SAAS,CAAC,IAAI+D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EAAE;QAC7E,IAAIwB,KAAK,CAACC,OAAO,CAACwD,GAAG,CAAC,EAClB1D,KAAK,GAAG0D,GAAG,CAAC/D,GAAG,CAAE+D,GAAG,IAAK;UAAE,OAAOxH,KAAK,CAACsB,SAAS,CAACkG,GAAG,CAAC;QAAE,CAAC,CAAC,CAAC,KAE3D1D,KAAK,GAAG9D,KAAK,CAACsB,SAAS,CAACkG,GAAG,CAAC;MACpC;MACA,OAAO1D,KAAK;IAChB;IACA,SAAS2C,iBAAiB,CAAC/E,GAAG,EAAEoC,KAAK,EAAE;MACnC,IAAI,CAAC9C,aAAa,CAAC,0BAA0B,CAAC,IAAIU,GAAG,KAAK,GAAG,EACzD,OAAOoC,KAAK;MAChB,IAAI,CAACuB,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACG,OAAO,CAAC,IAAI,CAAC4C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAAI,CAACuB,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,EAAE;QACrG,MAAM0E,kBAAkB,GAAGzI,eAAe,CAAC+D,KAAK,CAAC,IAAI9C,aAAa,CAAC,eAAe,CAAC,IAAKyH,MAAM,CAACC,aAAa,CAACxB,IAAI,CAACyB,KAAK,CAACC,UAAU,CAAE,GAAE9E,KAAM,EAAC,CAAC,CAAC,CAAE;QACjJ,IAAI0E,kBAAkB,IAAK,CAAC1B,WAAW,CAAChD,KAAK,CAAC,IAAIuB,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACI,OAAO,CAAE,EAAE;UACpFoB,KAAK,GAAG2E,MAAM,CAAC3E,KAAK,CAAC;QACzB;MACJ;MACA,OAAOA,KAAK;IAChB;IACA;IACA;IACA,SAASgC,SAAS,CAACzB,IAAI,EAAE;MACrB,MAAMwE,YAAY,GAAGrI,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;MACxC;MACA;MACAiE,uBAAuB,CAAC6C,YAAY,EAAEvG,KAAK,CAACT,OAAO,EAAEG,QAAQ,CAAC;MAC9DxB,MAAM,CAACuC,IAAI,CAACT,KAAK,CAACM,OAAO,CAAC,CAACU,OAAO,CAAC,UAAUwF,SAAS,EAAE;QACpD,MAAMC,UAAU,GAAG1E,IAAI,CAACyE,SAAS,CAAC,IAAID,YAAY,CAACC,SAAS,CAAC;QAC7D,IAAIC,UAAU,EAAE;UACZ,IAAI;YACA,IAAIjI,MAAM,GAAG,IAAI;YACjB,MAAMkI,kBAAkB,GAAGhJ,KAAK,CAACiJ,OAAO,CAACjJ,KAAK,CAACkJ,GAAG,EAAE,EAAEH,UAAU,CAAC;YACjE,MAAMI,aAAa,GAAG7G,KAAK,CAACM,OAAO,CAACkG,SAAS,CAAC;YAC9C,IAAI,OAAOK,aAAa,KAAK,UAAU,EAAE;cACrC,IAAI;gBACArI,MAAM,GAAGqI,aAAa,CAACH,kBAAkB,CAAC;cAC9C,CAAC,CACD,OAAOI,CAAC,EAAE;gBACNtI,MAAM,GAAGsI,CAAC;cACd;cACA,IAAItI,MAAM,YAAYiG,KAAK,EAAE;gBACzB7C,KAAK,GAAGpD,MAAM;gBACd;cACJ;YACJ,CAAC,MACI;cACDA,MAAM,GAAGd,KAAK,CAACqJ,OAAO,CAACL,kBAAkB,CAAC;YAC9C;YACAM,eAAe,CAACxI,MAAM,CAAC;UAC3B,CAAC,CACD,OAAOyI,EAAE,EAAE;YACP;YACA;YACA,IAAIA,EAAE,CAACC,IAAI,KAAK,kBAAkB,EAC9BtF,KAAK,GAAGqF,EAAE,CAAC,KACV,IAAIlF,IAAI,CAACyE,SAAS,CAAC,EACpB5E,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,8BAA8B,EAAEsH,UAAU,CAAC,CAAC;UACrE;QACJ;MACJ,CAAC,CAAC;IACN;IACA;IACA;IACA,SAASO,eAAe,CAACxI,MAAM,EAAE2I,IAAI,EAAE;MACnCjJ,MAAM,CAACuC,IAAI,CAACjC,MAAM,CAAC,CAACwC,OAAO,CAAC,UAAU5B,GAAG,EAAE;QACvC,MAAMoC,KAAK,GAAGhD,MAAM,CAACY,GAAG,CAAC;QACzB,MAAMgI,OAAO,GAAGD,IAAI,GAAGA,IAAI,GAAG,GAAG,GAAG/H,GAAG,GAAGA,GAAG;QAC7C;QACA;QACA;QACA,IAAI,OAAOoC,KAAK,KAAK,QAAQ,IAAIA,KAAK,KAAK,IAAI,IAAI,CAACC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,IAAI9C,aAAa,CAAC,cAAc,CAAC,EAAE;UACvG;UACAsI,eAAe,CAACxF,KAAK,EAAE4F,OAAO,CAAC;QACnC,CAAC,MACI;UACD;UACA;UACA,IAAI,CAACvD,MAAM,CAAC9B,IAAI,EAAEqF,OAAO,CAAC/D,KAAK,CAAC,GAAG,CAAC,CAAC,IAAKN,eAAe,CAACqE,OAAO,EAAEpH,KAAK,CAACC,MAAM,CAAC,IAAIvB,aAAa,CAAC,gBAAgB,CAAE,EAAE;YAClHwE,MAAM,CAACkE,OAAO,EAAE5F,KAAK,CAAC;UAC1B;QACJ;MACJ,CAAC,CAAC;IACN;IACA;IACA,SAASiC,gBAAgB,GAAG;MACxB,IAAI,OAAOhF,aAAa,KAAK,WAAW,EAAE;QACtCA,aAAa,CAACuC,OAAO,CAAC,UAAUqG,YAAY,EAAE;UAC1CL,eAAe,CAACK,YAAY,CAAC;QACjC,CAAC,CAAC;MACN;IACJ;IACA,SAAS9D,YAAY,CAACxB,IAAI,EAAEuF,UAAU,EAAE;MACpC,IAAI,OAAOxI,SAAS,KAAK,WAAW,EAChC;MACJ,MAAMyI,MAAM,GAAG,OAAOzI,SAAS,KAAK,QAAQ,GAAGA,SAAS,GAAG,EAAE;MAC7D,MAAM0I,GAAG,GAAG9J,KAAK,CAAC8J,GAAG,EAAE;MACvBtJ,MAAM,CAACuC,IAAI,CAAC+G,GAAG,CAAC,CAACxG,OAAO,CAAC,UAAUyG,MAAM,EAAE;QACvC,IAAIF,MAAM,KAAK,EAAE,IAAIE,MAAM,CAACC,WAAW,CAACH,MAAM,EAAE,CAAC,CAAC,KAAK,CAAC,EAAE;UACtD;UACA,MAAM9G,IAAI,GAAGgH,MAAM,CAACpE,KAAK,CAAC,IAAI,CAAC,CAAClC,GAAG,CAAC,UAAU/B,GAAG,EAAE8C,CAAC,EAAE;YAClD,IAAIA,CAAC,KAAK,CAAC,EAAE;cACT9C,GAAG,GAAGA,GAAG,CAACuI,SAAS,CAACJ,MAAM,CAACpF,MAAM,CAAC;YACtC;YACA,OAAO5E,SAAS,CAAC6B,GAAG,CAAC;UACzB,CAAC,CAAC;UACF,IAAI,CAAEkI,UAAU,IAAItH,KAAK,CAACM,OAAO,CAACG,IAAI,CAACwD,IAAI,CAAC,GAAG,CAAC,CAAC,IAAK,CAACqD,UAAU,KAAK,CAACzD,MAAM,CAAC9B,IAAI,EAAEtB,IAAI,CAAC,EAAE;YACvFyC,MAAM,CAACzC,IAAI,CAACwD,IAAI,CAAC,GAAG,CAAC,EAAEuD,GAAG,CAACC,MAAM,CAAC,CAAC;UACvC;QACJ;MACJ,CAAC,CAAC;IACN;IACA,SAAS9D,cAAc,CAAC5B,IAAI,EAAE;MAC1B,IAAIpD,MAAM;MACV,MAAMiJ,OAAO,GAAG,IAAIC,GAAG,EAAE;MACzB3J,MAAM,CAACuC,IAAI,CAACsB,IAAI,CAAC,CAACf,OAAO,CAAC,UAAU5B,GAAG,EAAE;QACrC,IAAI,CAACwI,OAAO,CAACE,GAAG,CAAC1I,GAAG,CAAC,EAAE;UAAE;UACrBT,MAAM,GAAGoE,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACQ,SAAS,CAAC;UAC9C,IAAI,OAAO7B,MAAM,KAAK,UAAU,EAAE;YAC9B,IAAI;cACA,MAAM6C,KAAK,GAAG2C,iBAAiB,CAAC/E,GAAG,EAAET,MAAM,CAACoD,IAAI,CAAC3C,GAAG,CAAC,CAAC,CAAC;cACtD,EAAE,CAACyB,MAAM,CAACb,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,EAAEA,GAAG,CAAC,CAAE4B,OAAO,CAAC+G,GAAG,IAAI;gBACtDH,OAAO,CAACI,GAAG,CAACD,GAAG,CAAC;gBAChBhG,IAAI,CAACgG,GAAG,CAAC,GAAGvG,KAAK;cACrB,CAAC,CAAC;YACN,CAAC,CACD,OAAOyG,GAAG,EAAE;cACRrG,KAAK,GAAGqG,GAAG;YACf;UACJ;QACJ;MACJ,CAAC,CAAC;IACN;IACA,SAASrE,kBAAkB,CAAC7B,IAAI,EAAE;MAC9B/B,KAAK,CAACS,IAAI,CAACO,OAAO,CAAE5B,GAAG,IAAK;QACxB;QACA,IAAI,CAACA,GAAG,CAAC8I,OAAO,CAAC,GAAG,CAAC,EACjB;QACJ,IAAI,OAAOnG,IAAI,CAAC3C,GAAG,CAAC,KAAK,WAAW,EAChC2C,IAAI,CAAC3C,GAAG,CAAC,GAAGf,SAAS;MAC7B,CAAC,CAAC;MACF,OAAO0D,IAAI;IACf;IACA,SAAS2B,uBAAuB,CAACyE,GAAG,EAAE5I,OAAO,EAAEG,QAAQ,EAAkB;MAAA,IAAhB0I,MAAM,uEAAG,KAAK;MACnElK,MAAM,CAACuC,IAAI,CAACf,QAAQ,CAAC,CAACsB,OAAO,CAAC,UAAU5B,GAAG,EAAE;QACzC,IAAI,CAACyE,MAAM,CAACsE,GAAG,EAAE/I,GAAG,CAACiE,KAAK,CAAC,GAAG,CAAC,CAAC,EAAE;UAC9BiC,MAAM,CAAC6C,GAAG,EAAE/I,GAAG,CAACiE,KAAK,CAAC,GAAG,CAAC,EAAE3D,QAAQ,CAACN,GAAG,CAAC,CAAC;UAC1C,IAAIgJ,MAAM,EACNtI,SAAS,CAACV,GAAG,CAAC,GAAG,IAAI;UACzB,CAACG,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,EAAE4B,OAAO,CAAC,UAAUuE,CAAC,EAAE;YACtC,IAAI1B,MAAM,CAACsE,GAAG,EAAE5C,CAAC,CAAClC,KAAK,CAAC,GAAG,CAAC,CAAC,EACzB;YACJiC,MAAM,CAAC6C,GAAG,EAAE5C,CAAC,CAAClC,KAAK,CAAC,GAAG,CAAC,EAAE3D,QAAQ,CAACN,GAAG,CAAC,CAAC;UAC5C,CAAC,CAAC;QACN;MACJ,CAAC,CAAC;IACN;IACA,SAASyE,MAAM,CAACsE,GAAG,EAAE1H,IAAI,EAAE;MACvB,IAAI4H,CAAC,GAAGF,GAAG;MACX,IAAI,CAACzJ,aAAa,CAAC,cAAc,CAAC,EAC9B+B,IAAI,GAAG,CAACA,IAAI,CAACwD,IAAI,CAAC,GAAG,CAAC,CAAC;MAC3BxD,IAAI,CAAC2C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACpC,OAAO,CAAC,UAAU5B,GAAG,EAAE;QACrCiJ,CAAC,GAAIA,CAAC,CAACjJ,GAAG,CAAC,IAAI,CAAC,CAAE;MACtB,CAAC,CAAC;MACF,MAAMA,GAAG,GAAGqB,IAAI,CAACA,IAAI,CAAC0B,MAAM,GAAG,CAAC,CAAC;MACjC,IAAI,OAAOkG,CAAC,KAAK,QAAQ,EACrB,OAAO,KAAK,CAAC,KAEb,OAAOjJ,GAAG,IAAIiJ,CAAC;IACvB;IACA,SAAS/C,MAAM,CAAC6C,GAAG,EAAE1H,IAAI,EAAEe,KAAK,EAAE;MAC9B,IAAI6G,CAAC,GAAGF,GAAG;MACX,IAAI,CAACzJ,aAAa,CAAC,cAAc,CAAC,EAC9B+B,IAAI,GAAG,CAACA,IAAI,CAACwD,IAAI,CAAC,GAAG,CAAC,CAAC;MAC3BxD,IAAI,CAAC2C,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAACpC,OAAO,CAAC,UAAU5B,GAAG,EAAE;QACrC;QACA;QACAA,GAAG,GAAGkJ,WAAW,CAAClJ,GAAG,CAAC;QACtB,IAAI,OAAOiJ,CAAC,KAAK,QAAQ,IAAIA,CAAC,CAACjJ,GAAG,CAAC,KAAKf,SAAS,EAAE;UAC/CgK,CAAC,CAACjJ,GAAG,CAAC,GAAG,CAAC,CAAC;QACf;QACA,IAAI,OAAOiJ,CAAC,CAACjJ,GAAG,CAAC,KAAK,QAAQ,IAAIqC,KAAK,CAACC,OAAO,CAAC2G,CAAC,CAACjJ,GAAG,CAAC,CAAC,EAAE;UACrD;UACA,IAAIqC,KAAK,CAACC,OAAO,CAAC2G,CAAC,CAACjJ,GAAG,CAAC,CAAC,EAAE;YACvBiJ,CAAC,CAACjJ,GAAG,CAAC,CAACkC,IAAI,CAAC,CAAC,CAAC,CAAC;UACnB,CAAC,MACI;YACD+G,CAAC,CAACjJ,GAAG,CAAC,GAAG,CAACiJ,CAAC,CAACjJ,GAAG,CAAC,EAAE,CAAC,CAAC,CAAC;UACzB;UACA;UACAiJ,CAAC,GAAGA,CAAC,CAACjJ,GAAG,CAAC,CAACiJ,CAAC,CAACjJ,GAAG,CAAC,CAAC+C,MAAM,GAAG,CAAC,CAAC;QACjC,CAAC,MACI;UACDkG,CAAC,GAAGA,CAAC,CAACjJ,GAAG,CAAC;QACd;MACJ,CAAC,CAAC;MACF;MACA;MACA,MAAMA,GAAG,GAAGkJ,WAAW,CAAC7H,IAAI,CAACA,IAAI,CAAC0B,MAAM,GAAG,CAAC,CAAC,CAAC;MAC9C,MAAMoG,WAAW,GAAGxF,eAAe,CAACtC,IAAI,CAACwD,IAAI,CAAC,GAAG,CAAC,EAAEjE,KAAK,CAACC,MAAM,CAAC;MACjE,MAAMuI,YAAY,GAAG/G,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC;MACzC,IAAIiH,SAAS,GAAG/J,aAAa,CAAC,2BAA2B,CAAC;MAC1D;MACA,IAAI,CAAC+J,SAAS,IAAI1F,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC,EAAE;QACjDkI,SAAS,GAAG,IAAI;QAChB,IAAK,CAACjE,WAAW,CAAC6D,CAAC,CAACjJ,GAAG,CAAC,CAAC,IAAIY,KAAK,CAACO,KAAK,CAACnB,GAAG,CAAC,KAAK,CAAC,IAAMqC,KAAK,CAACC,OAAO,CAAC2G,CAAC,CAACjJ,GAAG,CAAC,CAAC,IAAIiJ,CAAC,CAACjJ,GAAG,CAAC,CAAC+C,MAAM,KAAKnC,KAAK,CAACO,KAAK,CAACnB,GAAG,CAAE,EAAE;UACnHiJ,CAAC,CAACjJ,GAAG,CAAC,GAAGf,SAAS;QACtB;MACJ;MACA,IAAImD,KAAK,KAAKyE,SAAS,EAAE,EAAE;QACvBoC,CAAC,CAACjJ,GAAG,CAAC,GAAG6G,SAAS,CAACoC,CAAC,CAACjJ,GAAG,CAAC,CAAC;MAC9B,CAAC,MACI,IAAIqC,KAAK,CAACC,OAAO,CAAC2G,CAAC,CAACjJ,GAAG,CAAC,CAAC,EAAE;QAC5B,IAAIqJ,SAAS,IAAIF,WAAW,IAAIC,YAAY,EAAE;UAC1CH,CAAC,CAACjJ,GAAG,CAAC,GAAGV,aAAa,CAAC,0BAA0B,CAAC,GAAG2J,CAAC,CAACjJ,GAAG,CAAC,CAACyB,MAAM,CAACW,KAAK,CAAC,GAAG,CAACC,KAAK,CAACC,OAAO,CAAC2G,CAAC,CAACjJ,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAGiJ,CAAC,CAACjJ,GAAG,CAAC,GAAG,CAACiJ,CAAC,CAACjJ,GAAG,CAAC,CAAC,EAAEyB,MAAM,CAAC,CAACW,KAAK,CAAC,CAAC;QAC9I,CAAC,MACI,IAAI,CAACiH,SAAS,IAAI1H,OAAO,CAACwH,WAAW,CAAC,KAAKxH,OAAO,CAACyH,YAAY,CAAC,EAAE;UACnEH,CAAC,CAACjJ,GAAG,CAAC,GAAGoC,KAAK;QAClB,CAAC,MACI;UACD6G,CAAC,CAACjJ,GAAG,CAAC,GAAGiJ,CAAC,CAACjJ,GAAG,CAAC,CAACyB,MAAM,CAAC,CAACW,KAAK,CAAC,CAAC;QACnC;MACJ,CAAC,MACI,IAAI6G,CAAC,CAACjJ,GAAG,CAAC,KAAKf,SAAS,IAAIkK,WAAW,EAAE;QAC1CF,CAAC,CAACjJ,GAAG,CAAC,GAAGoJ,YAAY,GAAGhH,KAAK,GAAG,CAACA,KAAK,CAAC;MAC3C,CAAC,MACI,IAAIiH,SAAS,IAAI,EAAEJ,CAAC,CAACjJ,GAAG,CAAC,KAAKf,SAAS,IACxC0E,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,IAClC0C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,CAAC,EAAE;QACpCmI,CAAC,CAACjJ,GAAG,CAAC,GAAG,CAACiJ,CAAC,CAACjJ,GAAG,CAAC,EAAEoC,KAAK,CAAC;MAC5B,CAAC,MACI;QACD6G,CAAC,CAACjJ,GAAG,CAAC,GAAGoC,KAAK;MAClB;IACJ;IACA;IACA,SAASG,aAAa,GAAU;MAAA,kCAANtC,IAAI;QAAJA,IAAI;MAAA;MAC1BA,IAAI,CAAC2B,OAAO,CAAC,UAAUmH,GAAG,EAAE;QACxBjK,MAAM,CAACuC,IAAI,CAAC0H,GAAG,IAAI,CAAC,CAAC,CAAC,CAACnH,OAAO,CAAC,UAAU5B,GAAG,EAAE;UAC1C;UACA;UACA;UACA,IAAIY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,EAClB;UACJY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,GAAG,EAAE,CAACyB,MAAM,CAACtB,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,CAAC;UAClD;UACAY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAACyB,MAAM,CAACzB,GAAG,CAAC,CAAC4B,OAAO,CAAC,UAAUuE,CAAC,EAAE;YAChD,IAAI,GAAG,CAAC5C,IAAI,CAAC4C,CAAC,CAAC,IAAI7G,aAAa,CAAC,sBAAsB,CAAC,EAAE;cACtD,MAAMgK,CAAC,GAAGnL,SAAS,CAACgI,CAAC,CAAC;cACtB,IAAImD,CAAC,KAAKtJ,GAAG,IAAIY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAAC8I,OAAO,CAACQ,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnD1I,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAACkC,IAAI,CAACoH,CAAC,CAAC;gBAC1B7I,UAAU,CAAC6I,CAAC,CAAC,GAAG,IAAI;cACxB;YACJ;UACJ,CAAC,CAAC;UACF;UACA1I,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAACyB,MAAM,CAACzB,GAAG,CAAC,CAAC4B,OAAO,CAAC,UAAUuE,CAAC,EAAE;YAChD,IAAIA,CAAC,CAACpD,MAAM,GAAG,CAAC,IAAI,OAAO,CAACQ,IAAI,CAAC4C,CAAC,CAAC,IAAI7G,aAAa,CAAC,sBAAsB,CAAC,EAAE;cAC1E,MAAMgK,CAAC,GAAGlL,UAAU,CAAC+H,CAAC,EAAE,GAAG,CAAC;cAC5B,IAAImD,CAAC,KAAKtJ,GAAG,IAAIY,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAAC8I,OAAO,CAACQ,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;gBACnD1I,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAACkC,IAAI,CAACoH,CAAC,CAAC;gBAC1B7I,UAAU,CAAC6I,CAAC,CAAC,GAAG,IAAI;cACxB;YACJ;UACJ,CAAC,CAAC;UACF1I,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAAC4B,OAAO,CAAC,UAAUuE,CAAC,EAAE;YACpCvF,KAAK,CAACT,OAAO,CAACgG,CAAC,CAAC,GAAG,CAACnG,GAAG,CAAC,CAACyB,MAAM,CAACb,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,CAAC0B,MAAM,CAAC,UAAU6H,CAAC,EAAE;cACnE,OAAOpD,CAAC,KAAKoD,CAAC;YAClB,CAAC,CAAC,CAAC;UACP,CAAC,CAAC;QACN,CAAC,CAAC;MACN,CAAC,CAAC;IACN;IACA,SAAS5F,eAAe,CAAC3D,GAAG,EAAEwJ,IAAI,EAAE;MAChC,MAAMC,OAAO,GAAG,EAAE,CAAChI,MAAM,CAACb,KAAK,CAACT,OAAO,CAACH,GAAG,CAAC,IAAI,EAAE,EAAEA,GAAG,CAAC;MACxD,MAAMqB,IAAI,GAAGvC,MAAM,CAACuC,IAAI,CAACmI,IAAI,CAAC;MAC9B,MAAME,QAAQ,GAAGD,OAAO,CAACE,IAAI,CAAC3J,GAAG,IAAIqB,IAAI,CAACqD,QAAQ,CAAC1E,GAAG,CAAC,CAAC;MACxD,OAAO0J,QAAQ,GAAGF,IAAI,CAACE,QAAQ,CAAC,GAAG,KAAK;IAC5C;IACA,SAASE,UAAU,CAAC5J,GAAG,EAAE;MACrB,MAAM6J,SAAS,GAAG/K,MAAM,CAACuC,IAAI,CAACT,KAAK,CAAC;MACpC,MAAM6I,OAAO,GAAG,EAAE,CAAChI,MAAM,CAACoI,SAAS,CAAC9H,GAAG,CAAC4C,CAAC,IAAI/D,KAAK,CAAC+D,CAAC,CAAC,CAAC,CAAC;MACvD,OAAO8E,OAAO,CAACK,IAAI,CAAC,UAAUN,IAAI,EAAE;QAChC,OAAOnH,KAAK,CAACC,OAAO,CAACkH,IAAI,CAAC,GAAGA,IAAI,CAAC9E,QAAQ,CAAC1E,GAAG,CAAC,GAAGwJ,IAAI,CAACxJ,GAAG,CAAC;MAC/D,CAAC,CAAC;IACN;IACA,SAAS+J,gBAAgB,CAAC/G,GAAG,EAAe;MAAA,mCAAVgH,QAAQ;QAARA,QAAQ;MAAA;MACtC,MAAMP,OAAO,GAAG,EAAE,CAAChI,MAAM,CAAC,GAAGuI,QAAQ,CAAC;MACtC,OAAOP,OAAO,CAACK,IAAI,CAAC,UAAUG,OAAO,EAAE;QACnC,MAAMvG,KAAK,GAAGV,GAAG,CAACU,KAAK,CAACuG,OAAO,CAAC;QAChC,OAAOvG,KAAK,IAAIkG,UAAU,CAAClG,KAAK,CAAC,CAAC,CAAC,CAAC;MACxC,CAAC,CAAC;IACN;IACA;IACA,SAASwG,gBAAgB,CAAClH,GAAG,EAAE;MAC3B;MACA,IAAIA,GAAG,CAACU,KAAK,CAACpC,QAAQ,CAAC,IAAI,CAAC0B,GAAG,CAACU,KAAK,CAAC,SAAS,CAAC,EAAE;QAC9C,OAAO,KAAK;MAChB;MACA,IAAIyG,WAAW,GAAG,IAAI;MACtB,IAAI7G,IAAI;MACR,MAAMF,OAAO,GAAGJ,GAAG,CAACgB,KAAK,CAAC,CAAC,CAAC,CAACC,KAAK,CAAC,EAAE,CAAC;MACtC,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGd,OAAO,CAACL,MAAM,EAAEmB,CAAC,EAAE,EAAE;QACrCZ,IAAI,GAAGN,GAAG,CAACgB,KAAK,CAACE,CAAC,GAAG,CAAC,CAAC;QACvB,IAAI,CAAC0F,UAAU,CAACxG,OAAO,CAACc,CAAC,CAAC,CAAC,EAAE;UACzBiG,WAAW,GAAG,KAAK;UACnB;QACJ;QACA,IAAK/G,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,IAAId,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,KAAK,GAAG,IACzCZ,IAAI,KAAK,GAAG,IACX,UAAU,CAACC,IAAI,CAACH,OAAO,CAACc,CAAC,CAAC,CAAC,IAAI,0BAA0B,CAACX,IAAI,CAACD,IAAI,CAAE,IACrEF,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,IAAId,OAAO,CAACc,CAAC,GAAG,CAAC,CAAC,CAACR,KAAK,CAAC,IAAI,CAAE,EAAE;UAChD;QACJ;MACJ;MACA,OAAOyG,WAAW;IACtB;IACA,SAAS3G,oBAAoB,CAACR,GAAG,EAAE;MAC/B,OAAO1D,aAAa,CAAC,yBAAyB,CAAC,IAAI8K,eAAe,CAACpH,GAAG,CAAC;IAC3E;IACA,SAASoH,eAAe,CAACpH,GAAG,EAAE;MAC1BA,GAAG,GAAGA,GAAG,CAACE,OAAO,CAAC,QAAQ,EAAE,IAAI,CAAC;MACjC;MACA,IAAIF,GAAG,CAACU,KAAK,CAACpC,QAAQ,CAAC,EAAE;QACrB,OAAO,KAAK;MAChB;MACA;MACA,IAAI4I,gBAAgB,CAAClH,GAAG,CAAC,EAAE;QACvB,OAAO,KAAK;MAChB;MACA;MACA,MAAMqH,cAAc,GAAG,sBAAsB;MAC7C;MACA,MAAMC,UAAU,GAAG,cAAc;MACjC;MACA,MAAMC,kBAAkB,GAAG,eAAe;MAC1C;MACA,MAAMC,kBAAkB,GAAG,iBAAiB;MAC5C;MACA,MAAMC,6BAA6B,GAAG,mBAAmB;MACzD;MACA,OAAO,CAACV,gBAAgB,CAAC/G,GAAG,EAAEqH,cAAc,EAAE9I,cAAc,EAAE+I,UAAU,EAAEC,kBAAkB,EAAEC,kBAAkB,EAAEC,6BAA6B,CAAC;IACpJ;IACA;IACA;IACA,SAAS1G,YAAY,CAAC/D,GAAG,EAAE;MACvB,IAAI,CAAC2D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,IAClC,CAAC6C,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACK,MAAM,CAAC,IAClC,GAAEjB,GAAI,EAAC,IAAIM,QAAQ,EAAE;QACtB,OAAOA,QAAQ,CAACN,GAAG,CAAC;MACxB,CAAC,MACI;QACD,OAAO0K,cAAc,CAACC,SAAS,CAAC3K,GAAG,CAAC,CAAC;MACzC;IACJ;IACA;IACA,SAAS0K,cAAc,CAACE,IAAI,EAAE;MAC1B,MAAMC,GAAG,GAAG;QACR,CAAC3M,uBAAuB,CAAC4M,OAAO,GAAG,IAAI;QACvC,CAAC5M,uBAAuB,CAAC6M,MAAM,GAAG,EAAE;QACpC,CAAC7M,uBAAuB,CAAC8M,MAAM,GAAG/L,SAAS;QAC3C,CAACf,uBAAuB,CAAC+M,KAAK,GAAG;MACrC,CAAC;MACD,OAAOJ,GAAG,CAACD,IAAI,CAAC;IACpB;IACA;IACA,SAASD,SAAS,CAAC3K,GAAG,EAAE;MACpB,IAAI4K,IAAI,GAAG1M,uBAAuB,CAAC4M,OAAO;MAC1C,IAAInH,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACG,OAAO,CAAC,EACnC6J,IAAI,GAAG1M,uBAAuB,CAAC6M,MAAM,CAAC,KACrC,IAAIpH,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACI,OAAO,CAAC,EACxC4J,IAAI,GAAG1M,uBAAuB,CAAC8M,MAAM,CAAC,KACrC,IAAIrH,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACE,KAAK,CAAC,EACtC8J,IAAI,GAAG1M,uBAAuB,CAAC4M,OAAO,CAAC,KACtC,IAAInH,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EACvC+J,IAAI,GAAG1M,uBAAuB,CAAC+M,KAAK;MACxC,OAAOL,IAAI;IACf;IACA,SAASxF,WAAW,CAAC8F,GAAG,EAAE;MACtB,OAAOA,GAAG,KAAKjM,SAAS;IAC5B;IACA;IACA,SAASwD,kBAAkB,GAAG;MAC1B;MACA3D,MAAM,CAACuC,IAAI,CAACT,KAAK,CAACK,MAAM,CAAC,CAAC0I,IAAI,CAAC3J,GAAG,IAAI;QAClC,IAAI2D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACC,MAAM,CAAC,EAAE;UACpC2B,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,4DAA4D,EAAEC,GAAG,CAAC,CAAC;UACpF,OAAO,IAAI;QACf,CAAC,MACI,IAAI2D,eAAe,CAAC3D,GAAG,EAAEY,KAAK,CAACO,KAAK,CAAC,EAAE;UACxCqB,KAAK,GAAG6C,KAAK,CAACtF,EAAE,CAAC,2DAA2D,EAAEC,GAAG,CAAC,CAAC;UACnF,OAAO,IAAI;QACf;QACA,OAAO,KAAK;MAChB,CAAC,CAAC;IACN;IACA,OAAO;MACHG,OAAO,EAAErB,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE6B,KAAK,CAACT,OAAO,CAAC;MACzCwC,IAAI,EAAE7D,MAAM,CAACC,MAAM,CAAC8D,UAAU,EAAEF,IAAI,CAAC;MACrCrD,aAAa,EAAEA,aAAa;MAC5BoB,SAAS,EAAE5B,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE2B,SAAS,CAAC;MACvC8B,KAAK,EAAEA,KAAK;MACZ/B,UAAU,EAAE3B,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAE0B,UAAU;IAC5C,CAAC;EACL;AACJ;AACA;AACA;AACA,SAASL,cAAc,CAACD,OAAO,EAAE;EAC7B,MAAMgL,WAAW,GAAG,EAAE;EACtB,MAAMC,QAAQ,GAAGtM,MAAM,CAACuB,MAAM,CAAC,IAAI,CAAC;EACpC,IAAIgL,MAAM,GAAG,IAAI;EACjB;EACA;EACAvM,MAAM,CAACuC,IAAI,CAAClB,OAAO,CAAC,CAACyB,OAAO,CAAC,UAAU5B,GAAG,EAAE;IACxCmL,WAAW,CAACjJ,IAAI,CAAC,EAAE,CAACT,MAAM,CAACtB,OAAO,CAACH,GAAG,CAAC,EAAEA,GAAG,CAAC,CAAC;EAClD,CAAC,CAAC;EACF;EACA;EACA,OAAOqL,MAAM,EAAE;IACXA,MAAM,GAAG,KAAK;IACd,KAAK,IAAIvI,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGqI,WAAW,CAACpI,MAAM,EAAED,CAAC,EAAE,EAAE;MACzC,KAAK,IAAImC,EAAE,GAAGnC,CAAC,GAAG,CAAC,EAAEmC,EAAE,GAAGkG,WAAW,CAACpI,MAAM,EAAEkC,EAAE,EAAE,EAAE;QAChD,MAAMqG,SAAS,GAAGH,WAAW,CAACrI,CAAC,CAAC,CAACpB,MAAM,CAAC,UAAUkF,CAAC,EAAE;UACjD,OAAOuE,WAAW,CAAClG,EAAE,CAAC,CAAC6D,OAAO,CAAClC,CAAC,CAAC,KAAK,CAAC,CAAC;QAC5C,CAAC,CAAC;QACF,IAAI0E,SAAS,CAACvI,MAAM,EAAE;UAClBoI,WAAW,CAACrI,CAAC,CAAC,GAAGqI,WAAW,CAACrI,CAAC,CAAC,CAACrB,MAAM,CAAC0J,WAAW,CAAClG,EAAE,CAAC,CAAC;UACvDkG,WAAW,CAACI,MAAM,CAACtG,EAAE,EAAE,CAAC,CAAC;UACzBoG,MAAM,GAAG,IAAI;UACb;QACJ;MACJ;IACJ;EACJ;EACA;EACA;EACAF,WAAW,CAACvJ,OAAO,CAAC,UAAU4J,UAAU,EAAE;IACtCA,UAAU,GAAGA,UAAU,CAAC9J,MAAM,CAAC,UAAUkF,CAAC,EAAE9D,CAAC,EAAE2I,IAAI,EAAE;MACjD,OAAOA,IAAI,CAAC3C,OAAO,CAAClC,CAAC,CAAC,KAAK9D,CAAC;IAChC,CAAC,CAAC;IACF,MAAM4I,SAAS,GAAGF,UAAU,CAACvJ,GAAG,EAAE;IAClC,IAAIyJ,SAAS,KAAKzM,SAAS,IAAI,OAAOyM,SAAS,KAAK,QAAQ,EAAE;MAC1DN,QAAQ,CAACM,SAAS,CAAC,GAAGF,UAAU;IACpC;EACJ,CAAC,CAAC;EACF,OAAOJ,QAAQ;AACnB;AACA;AACA;AACA;AACA,SAASvE,SAAS,CAAC8E,IAAI,EAAE;EACrB,OAAOA,IAAI,KAAK1M,SAAS,GAAG0M,IAAI,GAAG,CAAC,GAAG,CAAC;AAC5C;AACA;AACA;AACA,SAASzC,WAAW,CAAClJ,GAAG,EAAE;EACtB,IAAIA,GAAG,KAAK,WAAW,EACnB,OAAO,aAAa;EACxB,OAAOA,GAAG;AACd;AACA,SAAS2G,WAAW,CAACb,GAAG,EAAE;EACtB,OAAQ,OAAOA,GAAG,KAAK,QAAQ,KAC1BA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,IAAIA,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,CAAC,IAClCA,GAAG,CAACA,GAAG,CAAC/C,MAAM,GAAG,CAAC,CAAC,KAAK+C,GAAG,CAAC,CAAC,CAAC,GAC5BA,GAAG,CAACyC,SAAS,CAAC,CAAC,EAAEzC,GAAG,CAAC/C,MAAM,GAAG,CAAC,CAAC,GAChC+C,GAAG;AACb"},"metadata":{},"sourceType":"module"}