{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSAsyncWASMModule = void 0;\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\nconst module_1 = require(\"./module\");\nconst runtime_asyncify_1 = require(\"./runtime-asyncify\");\n/**\n * Asyncified version of [[QuickJSWASMModule]].\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nclass QuickJSAsyncWASMModule extends module_1.QuickJSWASMModule {\n  /** @private */\n  constructor(module, ffi) {\n    super(module, ffi);\n    this.ffi = ffi;\n    this.module = module;\n  }\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  newRuntime() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const rt = new lifetime_1.Lifetime(this.ffi.QTS_NewRuntime(), undefined, rt_ptr => {\n      this.callbacks.deleteRuntime(rt_ptr);\n      this.ffi.QTS_FreeRuntime(rt_ptr);\n    });\n    const runtime = new runtime_asyncify_1.QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks\n    });\n    (0, module_1.applyBaseRuntimeOptions)(runtime, options);\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader);\n    }\n    return runtime;\n  }\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  newContext() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const runtime = this.newRuntime();\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime];\n    const context = runtime.newContext({\n      ...options,\n      ownedLifetimes: lifetimes\n    });\n    runtime.context = context;\n    return context;\n  }\n  /** Synchronous evalCode is not supported. */\n  evalCode() {\n    throw new errors_1.QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\");\n  }\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or\n   * [[QuickJSContextSync]] explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.\n   */\n  evalCodeAsync(code, options) {\n    // TODO: we should really figure out generator for the Promise monad...\n    return lifetime_1.Scope.withScopeAsync(async scope => {\n      const vm = scope.manage(this.newContext());\n      (0, module_1.applyModuleEvalRuntimeOptions)(vm.runtime, options);\n      const result = await vm.evalCodeAsync(code, \"eval.js\");\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1);\n      }\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error));\n        throw error;\n      }\n      const value = vm.dump(scope.manage(result.value));\n      return value;\n    });\n  }\n}\nexports.QuickJSAsyncWASMModule = QuickJSAsyncWASMModule;","map":{"version":3,"mappings":";;;;;;AAEA;AAEA;AACA;AAMA;AAGA;;;;;;;;;;;;;AAaA,MAAaA,sBAAuB,SAAQC,0BAAiB;EAM3D;EACAC,YAAYC,MAAoC,EAAEC,GAAoB;IACpE,KAAK,CAACD,MAAM,EAAEC,GAAG,CAAC;IAClB,IAAI,CAACA,GAAG,GAAGA,GAAG;IACd,IAAI,CAACD,MAAM,GAAGA,MAAM;EACtB;EAEA;;;;;EAKSE,UAAU,GAAkC;IAAA,IAAjCC,8EAA+B,EAAE;IACnD,MAAMC,EAAE,GAAG,IAAIC,mBAAQ,CAAC,IAAI,CAACJ,GAAG,CAACK,cAAc,EAAE,EAAEC,SAAS,EAAGC,MAAM,IAAI;MACvE,IAAI,CAACC,SAAS,CAACC,aAAa,CAACF,MAAM,CAAC;MACpC,IAAI,CAACP,GAAG,CAACU,eAAe,CAACH,MAAM,CAAC;IAClC,CAAC,CAAC;IACF,MAAMI,OAAO,GAAG,IAAIC,sCAAmB,CAAC;MACtCb,MAAM,EAAE,IAAI,CAACA,MAAM;MACnBC,GAAG,EAAE,IAAI,CAACA,GAAG;MACbG,EAAE;MACFK,SAAS,EAAE,IAAI,CAACA;KACjB,CAAC;IAEF,oCAAuB,EAACG,OAAO,EAAET,OAAO,CAAC;IAEzC,IAAIA,OAAO,CAACW,YAAY,EAAE;MACxBF,OAAO,CAACG,eAAe,CAACZ,OAAO,CAACW,YAAY,CAAC;;IAG/C,OAAOF,OAAO;EAChB;EAEA;;;;;EAKSI,UAAU,GAA6B;IAAA,IAA5Bb,8EAA0B,EAAE;IAC9C,MAAMS,OAAO,GAAG,IAAI,CAACV,UAAU,EAAE;IACjC,MAAMe,SAAS,GAAGd,OAAO,CAACe,cAAc,GAAGf,OAAO,CAACe,cAAc,CAACC,MAAM,CAAC,CAACP,OAAO,CAAC,CAAC,GAAG,CAACA,OAAO,CAAC;IAC/F,MAAMQ,OAAO,GAAGR,OAAO,CAACI,UAAU,CAAC;MAAE,GAAGb,OAAO;MAAEe,cAAc,EAAED;IAAS,CAAE,CAAC;IAC7EL,OAAO,CAACQ,OAAO,GAAGA,OAAO;IACzB,OAAOA,OAAO;EAChB;EAEA;EACSC,QAAQ;IACf,MAAM,IAAIC,8BAAqB,CAAC,+DAA+D,CAAC;EAClG;EAEA;;;;;;;;;;;EAWAC,aAAa,CAACC,IAAY,EAAErB,OAA0B;IACpD;IACA,OAAOE,gBAAK,CAACoB,cAAc,CAAC,MAAOC,KAAK,IAAI;MAC1C,MAAMC,EAAE,GAAGD,KAAK,CAACE,MAAM,CAAC,IAAI,CAACZ,UAAU,EAAE,CAAC;MAC1C,0CAA6B,EAACW,EAAE,CAACf,OAAO,EAAET,OAAO,CAAC;MAClD,MAAM0B,MAAM,GAAG,MAAMF,EAAE,CAACJ,aAAa,CAACC,IAAI,EAAE,SAAS,CAAC;MAEtD,IAAIrB,OAAO,CAAC2B,gBAAgB,KAAKvB,SAAS,EAAE;QAC1C;QACAoB,EAAE,CAACf,OAAO,CAACmB,cAAc,CAAC,CAAC,CAAC,CAAC;;MAG/B,IAAIF,MAAM,CAACG,KAAK,EAAE;QAChB,MAAMA,KAAK,GAAGL,EAAE,CAACM,IAAI,CAACP,KAAK,CAACE,MAAM,CAACC,MAAM,CAACG,KAAK,CAAC,CAAC;QACjD,MAAMA,KAAK;;MAGb,MAAME,KAAK,GAAGP,EAAE,CAACM,IAAI,CAACP,KAAK,CAACE,MAAM,CAACC,MAAM,CAACK,KAAK,CAAC,CAAC;MACjD,OAAOA,KAAK;IACd,CAAC,CAAC;EACJ;;AAxFFC","names":["QuickJSAsyncWASMModule","module_1","constructor","module","ffi","newRuntime","options","rt","lifetime_1","QTS_NewRuntime","undefined","rt_ptr","callbacks","deleteRuntime","QTS_FreeRuntime","runtime","runtime_asyncify_1","moduleLoader","setModuleLoader","newContext","lifetimes","ownedLifetimes","concat","context","evalCode","errors_1","evalCodeAsync","code","withScopeAsync","scope","vm","manage","result","memoryLimitBytes","setMemoryLimit","error","dump","value","exports"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\module-asyncify.ts"],"sourcesContent":["import { QuickJSAsyncContext } from \"./context-asyncify\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSNotImplemented } from \"./errors\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { Lifetime, Scope } from \"./lifetime\"\nimport {\n  applyBaseRuntimeOptions,\n  applyModuleEvalRuntimeOptions,\n  ModuleEvalOptions,\n  QuickJSWASMModule,\n} from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport { AsyncRuntimeOptions, ContextOptions, RuntimeOptions } from \"./types\"\n\n/**\n * Asyncified version of [[QuickJSWASMModule]].\n *\n * Due to limitations of Emscripten's ASYNCIFY process, only a single async\n * function call can happen at a time across the entire WebAssembly module.\n *\n * That means that all runtimes, contexts, functions, etc created inside this\n * WebAssembly are limited to a single concurrent async action.\n * **Multiple concurrent async actions is an error.**\n *\n * To allow for multiple concurrent async actions, you must create multiple WebAssembly\n * modules.\n */\nexport class QuickJSAsyncWASMModule extends QuickJSWASMModule {\n  /** @private */\n  protected ffi: QuickJSAsyncFFI\n  /** @private */\n  protected module: QuickJSAsyncEmscriptenModule\n\n  /** @private */\n  constructor(module: QuickJSAsyncEmscriptenModule, ffi: QuickJSAsyncFFI) {\n    super(module, ffi)\n    this.ffi = ffi\n    this.module = module\n  }\n\n  /**\n   * Create a new async runtime inside this WebAssembly module. All runtimes inside a\n   * module are limited to a single async call at a time. For multiple\n   * concurrent async actions, create multiple WebAssembly modules.\n   */\n  override newRuntime(options: AsyncRuntimeOptions = {}): QuickJSAsyncRuntime {\n    const rt = new Lifetime(this.ffi.QTS_NewRuntime(), undefined, (rt_ptr) => {\n      this.callbacks.deleteRuntime(rt_ptr)\n      this.ffi.QTS_FreeRuntime(rt_ptr)\n    })\n    const runtime = new QuickJSAsyncRuntime({\n      module: this.module,\n      ffi: this.ffi,\n      rt,\n      callbacks: this.callbacks,\n    })\n\n    applyBaseRuntimeOptions(runtime, options)\n\n    if (options.moduleLoader) {\n      runtime.setModuleLoader(options.moduleLoader)\n    }\n\n    return runtime\n  }\n\n  /**\n   * A simplified API to create a new [[QuickJSRuntime]] and a\n   * [[QuickJSContext]] inside that runtime at the same time. The runtime will\n   * be disposed when the context is disposed.\n   */\n  override newContext(options: ContextOptions = {}): QuickJSAsyncContext {\n    const runtime = this.newRuntime()\n    const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime]) : [runtime]\n    const context = runtime.newContext({ ...options, ownedLifetimes: lifetimes })\n    runtime.context = context\n    return context\n  }\n\n  /** Synchronous evalCode is not supported. */\n  override evalCode(): never {\n    throw new QuickJSNotImplemented(\"QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead\")\n  }\n\n  /**\n   * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or\n   * [[QuickJSContextSync]] explicitly.\n   *\n   * This version allows for asynchronous Ecmascript module loading.\n   *\n   * Note that only a single async action can occur at a time inside the entire WebAssembly module.\n   * **Multiple concurrent async actions is an error.**\n   *\n   * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.\n   */\n  evalCodeAsync(code: string, options: ModuleEvalOptions): Promise<unknown> {\n    // TODO: we should really figure out generator for the Promise monad...\n    return Scope.withScopeAsync(async (scope) => {\n      const vm = scope.manage(this.newContext())\n      applyModuleEvalRuntimeOptions(vm.runtime, options)\n      const result = await vm.evalCodeAsync(code, \"eval.js\")\n\n      if (options.memoryLimitBytes !== undefined) {\n        // Remove memory limit so we can dump the result without exceeding it.\n        vm.runtime.setMemoryLimit(-1)\n      }\n\n      if (result.error) {\n        const error = vm.dump(scope.manage(result.error))\n        throw error\n      }\n\n      const value = vm.dump(scope.manage(result.value))\n      return value\n    })\n  }\n}\n"]},"metadata":{},"sourceType":"script"}