{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSAsyncContext = void 0;\nconst context_1 = require(\"./context\");\nconst debug_1 = require(\"./debug\");\nconst types_1 = require(\"./types\");\n/**\n * Asyncified version of [[QuickJSContext]].\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nclass QuickJSAsyncContext extends context_1.QuickJSContext {\n  /**\n   * Asyncified version of [[evalCode]].\n   */\n  async evalCodeAsync(code) {\n    let filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"eval.js\";\n    let /** See [[EvalFlags]] for number semantics */\n    options = arguments.length > 2 ? arguments[2] : undefined;\n    const detectModule = options === undefined ? 1 : 0;\n    const flags = (0, types_1.evalOptionsToFlags)(options);\n    let resultPtr = 0;\n    try {\n      resultPtr = await this.memory.newHeapCharPointer(code).consume(charHandle => this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, charHandle.value, filename, detectModule, flags));\n    } catch (error) {\n      (0, debug_1.debugLog)(\"QTS_Eval_MaybeAsync threw\", error);\n      throw error;\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n      return {\n        error: this.memory.heapValueHandle(errorPtr)\n      };\n    }\n    return {\n      value: this.memory.heapValueHandle(resultPtr)\n    };\n  }\n  /**\n   * Similar to [[newFunction]].\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name, fn) {\n    return this.newFunction(name, fn);\n  }\n}\nexports.QuickJSAsyncContext = QuickJSAsyncContext;","map":{"version":3,"mappings":";;;;;;AAAA;AACA;AAOA;AAQA;;;;;;;AAOA,MAAaA,mBAAoB,SAAQC,wBAAc;EAWrD;;;EAGA,MAAMC,aAAa,CACjBC,IAAY,EAGyB;IAAA,IAFrCC,+EAAmB,SAAS;IAAA,IAC5B;IACAC,OAAqC;IAErC,MAAMC,YAAY,GAAID,OAAO,KAAKE,SAAS,GAAG,CAAC,GAAG,CAAsB;IACxE,MAAMC,KAAK,GAAG,8BAAkB,EAACH,OAAO,CAAc;IACtD,IAAII,SAAS,GAAG,CAAmB;IACnC,IAAI;MACFA,SAAS,GAAG,MAAM,IAAI,CAACC,MAAM,CAC1BC,kBAAkB,CAACR,IAAI,CAAC,CACxBS,OAAO,CAAEC,UAAU,IAClB,IAAI,CAACC,GAAG,CAACC,mBAAmB,CAC1B,IAAI,CAACC,GAAG,CAACC,KAAK,EACdJ,UAAU,CAACI,KAAK,EAChBb,QAAQ,EACRE,YAAY,EACZE,KAAK,CACN,CACF;KACJ,CAAC,OAAOU,KAAK,EAAE;MACd,oBAAQ,EAAC,2BAA2B,EAAEA,KAAK,CAAC;MAC5C,MAAMA,KAAK;;IAEb,MAAMC,QAAQ,GAAG,IAAI,CAACL,GAAG,CAACM,oBAAoB,CAAC,IAAI,CAACJ,GAAG,CAACC,KAAK,EAAER,SAAS,CAAC;IACzE,IAAIU,QAAQ,EAAE;MACZ,IAAI,CAACL,GAAG,CAACO,oBAAoB,CAAC,IAAI,CAACL,GAAG,CAACC,KAAK,EAAER,SAAS,CAAC;MACxD,OAAO;QAAES,KAAK,EAAE,IAAI,CAACR,MAAM,CAACY,eAAe,CAACH,QAAQ;MAAC,CAAE;;IAEzD,OAAO;MAAEF,KAAK,EAAE,IAAI,CAACP,MAAM,CAACY,eAAe,CAACb,SAAS;IAAC,CAAE;EAC1D;EAEA;;;;;;;;;;;;;EAaAc,qBAAqB,CAACC,IAAY,EAAEC,EAA+B;IACjE,OAAO,IAAI,CAACC,WAAW,CAACF,IAAI,EAAEC,EAAS,CAAC;EAC1C;;AA9DFE","names":["QuickJSAsyncContext","context_1","evalCodeAsync","code","filename","options","detectModule","undefined","flags","resultPtr","memory","newHeapCharPointer","consume","charHandle","ffi","QTS_Eval_MaybeAsync","ctx","value","error","errorPtr","QTS_ResolveException","QTS_FreeValuePointer","heapValueHandle","newAsyncifiedFunction","name","fn","newFunction","exports"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\context-asyncify.ts"],"sourcesContent":["import { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { QuickJSAsyncEmscriptenModule } from \"./emscripten-types\"\nimport { QuickJSAsyncFFI } from \"./variants\"\nimport { EvalDetectModule, EvalFlags, JSRuntimePointer, JSValuePointer } from \"./types-ffi\"\nimport { Lifetime } from \"./lifetime\"\nimport { QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport { ContextEvalOptions, evalOptionsToFlags, QuickJSHandle } from \"./types\"\nimport { VmCallResult } from \"./vm-interface\"\n\nexport type AsyncFunctionImplementation = (\n  this: QuickJSHandle,\n  ...args: QuickJSHandle[]\n) => Promise<QuickJSHandle | VmCallResult<QuickJSHandle> | void>\n\n/**\n * Asyncified version of [[QuickJSContext]].\n *\n * *Asyncify* allows normally synchronous code to wait for asynchronous Promises\n * or callbacks. The asyncified version of QuickJSContext can wait for async\n * host functions as though they were synchronous.\n */\nexport class QuickJSAsyncContext extends QuickJSContext {\n  public declare runtime: QuickJSAsyncRuntime\n  /** @private */\n  protected declare module: QuickJSAsyncEmscriptenModule\n  /** @private */\n  protected declare ffi: QuickJSAsyncFFI\n  /** @private */\n  protected declare rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected declare callbacks: QuickJSModuleCallbacks\n\n  /**\n   * Asyncified version of [[evalCode]].\n   */\n  async evalCodeAsync(\n    code: string,\n    filename: string = \"eval.js\",\n    /** See [[EvalFlags]] for number semantics */\n    options?: number | ContextEvalOptions\n  ): Promise<VmCallResult<QuickJSHandle>> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    let resultPtr = 0 as JSValuePointer\n    try {\n      resultPtr = await this.memory\n        .newHeapCharPointer(code)\n        .consume((charHandle) =>\n          this.ffi.QTS_Eval_MaybeAsync(\n            this.ctx.value,\n            charHandle.value,\n            filename,\n            detectModule,\n            flags\n          )\n        )\n    } catch (error) {\n      debugLog(\"QTS_Eval_MaybeAsync threw\", error)\n      throw error\n    }\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Similar to [[newFunction]].\n   * Convert an async host Javascript function into a synchronous QuickJS function value.\n   *\n   * Whenever QuickJS calls this function, the VM's stack will be unwound while\n   * waiting the async function to complete, and then restored when the returned\n   * promise resolves.\n   *\n   * Asyncified functions must never call other asyncified functions or\n   * `import`, even indirectly, because the stack cannot be unwound twice.\n   *\n   * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).\n   */\n  newAsyncifiedFunction(name: string, fn: AsyncFunctionImplementation): QuickJSHandle {\n    return this.newFunction(name, fn as any)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}