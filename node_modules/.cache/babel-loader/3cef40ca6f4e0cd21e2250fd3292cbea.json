{"ast":null,"code":"/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { FrameEvent } from '../api/Frame.js';\nimport { EventSubscription } from '../common/EventEmitter.js';\nimport { NetworkManagerEvent } from '../common/NetworkManagerEvents.js';\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { DisposableStack } from '../util/disposable.js';\nimport { FrameManagerEvent } from './FrameManagerEvents.js';\nconst puppeteerToProtocolLifecycle = new Map([['load', 'load'], ['domcontentloaded', 'DOMContentLoaded'], ['networkidle0', 'networkIdle'], ['networkidle2', 'networkAlmostIdle']]);\n/**\n * @internal\n */\nexport class LifecycleWatcher {\n  #expectedLifecycle;\n  #frame;\n  #timeout;\n  #navigationRequest = null;\n  #subscriptions = new DisposableStack();\n  #initialLoaderId;\n  #terminationDeferred;\n  #sameDocumentNavigationDeferred = Deferred.create();\n  #lifecycleDeferred = Deferred.create();\n  #newDocumentNavigationDeferred = Deferred.create();\n  #hasSameDocumentNavigation;\n  #swapped;\n  #navigationResponseReceived;\n  constructor(networkManager, frame, waitUntil, timeout) {\n    if (Array.isArray(waitUntil)) {\n      waitUntil = waitUntil.slice();\n    } else if (typeof waitUntil === 'string') {\n      waitUntil = [waitUntil];\n    }\n    this.#initialLoaderId = frame._loaderId;\n    this.#expectedLifecycle = waitUntil.map(value => {\n      const protocolEvent = puppeteerToProtocolLifecycle.get(value);\n      assert(protocolEvent, 'Unknown value for options.waitUntil: ' + value);\n      return protocolEvent;\n    });\n    this.#frame = frame;\n    this.#timeout = timeout;\n    this.#subscriptions.use(\n    // Revert if TODO #1 is done\n    new EventSubscription(frame._frameManager, FrameManagerEvent.LifecycleEvent, this.#checkLifecycleComplete.bind(this)));\n    this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameNavigatedWithinDocument, this.#navigatedWithinDocument.bind(this)));\n    this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameNavigated, this.#navigated.bind(this)));\n    this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameSwapped, this.#frameSwapped.bind(this)));\n    this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameSwappedByActivation, this.#frameSwapped.bind(this)));\n    this.#subscriptions.use(new EventSubscription(frame, FrameEvent.FrameDetached, this.#onFrameDetached.bind(this)));\n    this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.Request, this.#onRequest.bind(this)));\n    this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.Response, this.#onResponse.bind(this)));\n    this.#subscriptions.use(new EventSubscription(networkManager, NetworkManagerEvent.RequestFailed, this.#onRequestFailed.bind(this)));\n    this.#terminationDeferred = Deferred.create({\n      timeout: this.#timeout,\n      message: `Navigation timeout of ${this.#timeout} ms exceeded`\n    });\n    this.#checkLifecycleComplete();\n  }\n  #onRequest(request) {\n    if (request.frame() !== this.#frame || !request.isNavigationRequest()) {\n      return;\n    }\n    this.#navigationRequest = request;\n    // Resolve previous navigation response in case there are multiple\n    // navigation requests reported by the backend. This generally should not\n    // happen by it looks like it's possible.\n    this.#navigationResponseReceived?.resolve();\n    this.#navigationResponseReceived = Deferred.create();\n    if (request.response() !== null) {\n      this.#navigationResponseReceived?.resolve();\n    }\n  }\n  #onRequestFailed(request) {\n    if (this.#navigationRequest?._requestId !== request._requestId) {\n      return;\n    }\n    this.#navigationResponseReceived?.resolve();\n  }\n  #onResponse(response) {\n    if (this.#navigationRequest?._requestId !== response.request()._requestId) {\n      return;\n    }\n    this.#navigationResponseReceived?.resolve();\n  }\n  #onFrameDetached(frame) {\n    if (this.#frame === frame) {\n      this.#terminationDeferred.resolve(new Error('Navigating frame was detached'));\n      return;\n    }\n    this.#checkLifecycleComplete();\n  }\n  async navigationResponse() {\n    // Continue with a possibly null response.\n    await this.#navigationResponseReceived?.valueOrThrow();\n    return this.#navigationRequest ? this.#navigationRequest.response() : null;\n  }\n  sameDocumentNavigationPromise() {\n    return this.#sameDocumentNavigationDeferred.valueOrThrow();\n  }\n  newDocumentNavigationPromise() {\n    return this.#newDocumentNavigationDeferred.valueOrThrow();\n  }\n  lifecyclePromise() {\n    return this.#lifecycleDeferred.valueOrThrow();\n  }\n  terminationPromise() {\n    return this.#terminationDeferred.valueOrThrow();\n  }\n  #navigatedWithinDocument() {\n    this.#hasSameDocumentNavigation = true;\n    this.#checkLifecycleComplete();\n  }\n  #navigated(navigationType) {\n    if (navigationType === 'BackForwardCacheRestore') {\n      return this.#frameSwapped();\n    }\n    this.#checkLifecycleComplete();\n  }\n  #frameSwapped() {\n    this.#swapped = true;\n    this.#checkLifecycleComplete();\n  }\n  #checkLifecycleComplete() {\n    // We expect navigation to commit.\n    if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {\n      return;\n    }\n    this.#lifecycleDeferred.resolve();\n    if (this.#hasSameDocumentNavigation) {\n      this.#sameDocumentNavigationDeferred.resolve(undefined);\n    }\n    if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {\n      this.#newDocumentNavigationDeferred.resolve(undefined);\n    }\n    function checkLifecycle(frame, expectedLifecycle) {\n      for (const event of expectedLifecycle) {\n        if (!frame._lifecycleEvents.has(event)) {\n          return false;\n        }\n      }\n      // TODO(#1): Its possible we don't need this check\n      // CDP provided the correct order for Loading Events\n      // And NetworkIdle is a global state\n      // Consider removing\n      for (const child of frame.childFrames()) {\n        if (child._hasStartedLoading && !checkLifecycle(child, expectedLifecycle)) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n  dispose() {\n    this.#subscriptions.dispose();\n    this.#terminationDeferred.resolve(new Error('LifecycleWatcher disposed'));\n  }\n}","map":{"version":3,"mappings":"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","names":["FrameEvent","EventSubscription","NetworkManagerEvent","assert","Deferred","DisposableStack","FrameManagerEvent","puppeteerToProtocolLifecycle","Map","LifecycleWatcher","create","constructor","networkManager","frame","waitUntil","timeout","Array","isArray","slice","_loaderId","map","value","protocolEvent","get","use","_frameManager","LifecycleEvent","bind","FrameNavigatedWithinDocument","FrameNavigated","FrameSwapped","FrameSwappedByActivation","FrameDetached","Request","Response","RequestFailed","message","request","isNavigationRequest","resolve","response","_requestId","Error","navigationResponse","valueOrThrow","sameDocumentNavigationPromise","newDocumentNavigationPromise","lifecyclePromise","terminationPromise","navigationType","checkLifecycle","undefined","expectedLifecycle","event","_lifecycleEvents","has","child","childFrames","_hasStartedLoading","dispose"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\LifecycleWatcher.ts"],"sourcesContent":["/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport {type Frame, FrameEvent} from '../api/Frame.js';\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {TimeoutError} from '../common/Errors.js';\nimport {EventSubscription} from '../common/EventEmitter.js';\nimport {NetworkManagerEvent} from '../common/NetworkManagerEvents.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {DisposableStack} from '../util/disposable.js';\n\nimport type {CdpFrame} from './Frame.js';\nimport {FrameManagerEvent} from './FrameManagerEvents.js';\nimport type {NetworkManager} from './NetworkManager.js';\n\n/**\n * @public\n */\nexport type PuppeteerLifeCycleEvent =\n  /**\n   * Waits for the 'load' event.\n   */\n  | 'load'\n  /**\n   * Waits for the 'DOMContentLoaded' event.\n   */\n  | 'domcontentloaded'\n  /**\n   * Waits till there are no more than 0 network connections for at least `500`\n   * ms.\n   */\n  | 'networkidle0'\n  /**\n   * Waits till there are no more than 2 network connections for at least `500`\n   * ms.\n   */\n  | 'networkidle2';\n\n/**\n * @public\n */\nexport type ProtocolLifeCycleEvent =\n  | 'load'\n  | 'DOMContentLoaded'\n  | 'networkIdle'\n  | 'networkAlmostIdle';\n\nconst puppeteerToProtocolLifecycle = new Map<\n  PuppeteerLifeCycleEvent,\n  ProtocolLifeCycleEvent\n>([\n  ['load', 'load'],\n  ['domcontentloaded', 'DOMContentLoaded'],\n  ['networkidle0', 'networkIdle'],\n  ['networkidle2', 'networkAlmostIdle'],\n]);\n\n/**\n * @internal\n */\nexport class LifecycleWatcher {\n  #expectedLifecycle: ProtocolLifeCycleEvent[];\n  #frame: CdpFrame;\n  #timeout: number;\n  #navigationRequest: HTTPRequest | null = null;\n  #subscriptions = new DisposableStack();\n  #initialLoaderId: string;\n\n  #terminationDeferred: Deferred<Error>;\n  #sameDocumentNavigationDeferred = Deferred.create<undefined>();\n  #lifecycleDeferred = Deferred.create<void>();\n  #newDocumentNavigationDeferred = Deferred.create<undefined>();\n\n  #hasSameDocumentNavigation?: boolean;\n  #swapped?: boolean;\n\n  #navigationResponseReceived?: Deferred<void>;\n\n  constructor(\n    networkManager: NetworkManager,\n    frame: CdpFrame,\n    waitUntil: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[],\n    timeout: number\n  ) {\n    if (Array.isArray(waitUntil)) {\n      waitUntil = waitUntil.slice();\n    } else if (typeof waitUntil === 'string') {\n      waitUntil = [waitUntil];\n    }\n    this.#initialLoaderId = frame._loaderId;\n    this.#expectedLifecycle = waitUntil.map(value => {\n      const protocolEvent = puppeteerToProtocolLifecycle.get(value);\n      assert(protocolEvent, 'Unknown value for options.waitUntil: ' + value);\n      return protocolEvent as ProtocolLifeCycleEvent;\n    });\n\n    this.#frame = frame;\n    this.#timeout = timeout;\n    this.#subscriptions.use(\n      // Revert if TODO #1 is done\n      new EventSubscription(\n        frame._frameManager,\n        FrameManagerEvent.LifecycleEvent,\n        this.#checkLifecycleComplete.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        frame,\n        FrameEvent.FrameNavigatedWithinDocument,\n        this.#navigatedWithinDocument.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        frame,\n        FrameEvent.FrameNavigated,\n        this.#navigated.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        frame,\n        FrameEvent.FrameSwapped,\n        this.#frameSwapped.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        frame,\n        FrameEvent.FrameSwappedByActivation,\n        this.#frameSwapped.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        frame,\n        FrameEvent.FrameDetached,\n        this.#onFrameDetached.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        networkManager,\n        NetworkManagerEvent.Request,\n        this.#onRequest.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        networkManager,\n        NetworkManagerEvent.Response,\n        this.#onResponse.bind(this)\n      )\n    );\n    this.#subscriptions.use(\n      new EventSubscription(\n        networkManager,\n        NetworkManagerEvent.RequestFailed,\n        this.#onRequestFailed.bind(this)\n      )\n    );\n    this.#terminationDeferred = Deferred.create<Error>({\n      timeout: this.#timeout,\n      message: `Navigation timeout of ${this.#timeout} ms exceeded`,\n    });\n\n    this.#checkLifecycleComplete();\n  }\n\n  #onRequest(request: HTTPRequest): void {\n    if (request.frame() !== this.#frame || !request.isNavigationRequest()) {\n      return;\n    }\n    this.#navigationRequest = request;\n    // Resolve previous navigation response in case there are multiple\n    // navigation requests reported by the backend. This generally should not\n    // happen by it looks like it's possible.\n    this.#navigationResponseReceived?.resolve();\n    this.#navigationResponseReceived = Deferred.create();\n    if (request.response() !== null) {\n      this.#navigationResponseReceived?.resolve();\n    }\n  }\n\n  #onRequestFailed(request: HTTPRequest): void {\n    if (this.#navigationRequest?._requestId !== request._requestId) {\n      return;\n    }\n    this.#navigationResponseReceived?.resolve();\n  }\n\n  #onResponse(response: HTTPResponse): void {\n    if (this.#navigationRequest?._requestId !== response.request()._requestId) {\n      return;\n    }\n    this.#navigationResponseReceived?.resolve();\n  }\n\n  #onFrameDetached(frame: Frame): void {\n    if (this.#frame === frame) {\n      this.#terminationDeferred.resolve(\n        new Error('Navigating frame was detached')\n      );\n      return;\n    }\n    this.#checkLifecycleComplete();\n  }\n\n  async navigationResponse(): Promise<HTTPResponse | null> {\n    // Continue with a possibly null response.\n    await this.#navigationResponseReceived?.valueOrThrow();\n    return this.#navigationRequest ? this.#navigationRequest.response() : null;\n  }\n\n  sameDocumentNavigationPromise(): Promise<Error | undefined> {\n    return this.#sameDocumentNavigationDeferred.valueOrThrow();\n  }\n\n  newDocumentNavigationPromise(): Promise<Error | undefined> {\n    return this.#newDocumentNavigationDeferred.valueOrThrow();\n  }\n\n  lifecyclePromise(): Promise<void> {\n    return this.#lifecycleDeferred.valueOrThrow();\n  }\n\n  terminationPromise(): Promise<Error | TimeoutError | undefined> {\n    return this.#terminationDeferred.valueOrThrow();\n  }\n\n  #navigatedWithinDocument(): void {\n    this.#hasSameDocumentNavigation = true;\n    this.#checkLifecycleComplete();\n  }\n\n  #navigated(navigationType: Protocol.Page.NavigationType): void {\n    if (navigationType === 'BackForwardCacheRestore') {\n      return this.#frameSwapped();\n    }\n    this.#checkLifecycleComplete();\n  }\n\n  #frameSwapped(): void {\n    this.#swapped = true;\n    this.#checkLifecycleComplete();\n  }\n\n  #checkLifecycleComplete(): void {\n    // We expect navigation to commit.\n    if (!checkLifecycle(this.#frame, this.#expectedLifecycle)) {\n      return;\n    }\n    this.#lifecycleDeferred.resolve();\n    if (this.#hasSameDocumentNavigation) {\n      this.#sameDocumentNavigationDeferred.resolve(undefined);\n    }\n    if (this.#swapped || this.#frame._loaderId !== this.#initialLoaderId) {\n      this.#newDocumentNavigationDeferred.resolve(undefined);\n    }\n\n    function checkLifecycle(\n      frame: CdpFrame,\n      expectedLifecycle: ProtocolLifeCycleEvent[]\n    ): boolean {\n      for (const event of expectedLifecycle) {\n        if (!frame._lifecycleEvents.has(event)) {\n          return false;\n        }\n      }\n      // TODO(#1): Its possible we don't need this check\n      // CDP provided the correct order for Loading Events\n      // And NetworkIdle is a global state\n      // Consider removing\n      for (const child of frame.childFrames()) {\n        if (\n          child._hasStartedLoading &&\n          !checkLifecycle(child, expectedLifecycle)\n        ) {\n          return false;\n        }\n      }\n      return true;\n    }\n  }\n\n  dispose(): void {\n    this.#subscriptions.dispose();\n    this.#terminationDeferred.resolve(new Error('LifecycleWatcher disposed'));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}