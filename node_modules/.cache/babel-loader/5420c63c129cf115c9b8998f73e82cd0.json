{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ftp = void 0;\nconst basic_ftp_1 = require(\"basic-ftp\");\nconst stream_1 = require(\"stream\");\nconst path_1 = require(\"path\");\nconst debug_1 = __importDefault(require(\"debug\"));\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst debug = (0, debug_1.default)('get-uri:ftp');\n/**\n * Returns a Readable stream from an \"ftp:\" URI.\n */\nconst ftp = async function (url) {\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    cache\n  } = opts;\n  const filepath = decodeURIComponent(url.pathname);\n  let lastModified;\n  if (!filepath) {\n    throw new TypeError('No \"pathname\"!');\n  }\n  const client = new basic_ftp_1.Client();\n  try {\n    const host = url.hostname || url.host || 'localhost';\n    const port = parseInt(url.port || '0', 10) || 21;\n    const user = url.username ? decodeURIComponent(url.username) : undefined;\n    const password = url.password ? decodeURIComponent(url.password) : undefined;\n    await client.access({\n      host,\n      port,\n      user,\n      password,\n      ...opts\n    });\n    // first we have to figure out the Last Modified date.\n    // try the MDTM command first, which is an optional extension command.\n    try {\n      lastModified = await client.lastMod(filepath);\n    } catch (err) {\n      // handle the \"file not found\" error code\n      if (err.code === 550) {\n        throw new notfound_1.default();\n      }\n    }\n    if (!lastModified) {\n      // Try to get the last modified date via the LIST command (uses\n      // more bandwidth, but is more compatible with older FTP servers\n      const list = await client.list((0, path_1.dirname)(filepath));\n      // attempt to find the \"entry\" with a matching \"name\"\n      const name = (0, path_1.basename)(filepath);\n      const entry = list.find(e => e.name === name);\n      if (entry) {\n        lastModified = entry.modifiedAt;\n      }\n    }\n    if (lastModified) {\n      if (isNotModified()) {\n        throw new notmodified_1.default();\n      }\n    } else {\n      throw new notfound_1.default();\n    }\n    const stream = new stream_1.PassThrough();\n    const rs = stream;\n    client.downloadTo(stream, filepath).then(result => {\n      debug(result.message);\n      client.close();\n    });\n    rs.lastModified = lastModified;\n    return rs;\n  } catch (err) {\n    client.close();\n    throw err;\n  }\n  // called when `lastModified` is set, and a \"cache\" stream was provided\n  function isNotModified() {\n    if (cache?.lastModified && lastModified) {\n      return +cache.lastModified === +lastModified;\n    }\n    return false;\n  }\n};\nexports.ftp = ftp;","map":{"version":3,"mappings":";;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA,MAAMA,KAAK,GAAG,mBAAW,EAAC,aAAa,CAAC;AAUxC;;;AAGO,MAAMC,GAAG,GAA+B,gBAAOC,GAAG,EAAe;EAAA,IAAbC,IAAI,uEAAG,EAAE;EACnE,MAAM;IAAEC;EAAK,CAAE,GAAGD,IAAI;EACtB,MAAME,QAAQ,GAAGC,kBAAkB,CAACJ,GAAG,CAACK,QAAQ,CAAC;EACjD,IAAIC,YAA8B;EAElC,IAAI,CAACH,QAAQ,EAAE;IACd,MAAM,IAAII,SAAS,CAAC,gBAAgB,CAAC;;EAGtC,MAAMC,MAAM,GAAG,IAAIC,kBAAM,EAAE;EAE3B,IAAI;IACH,MAAMC,IAAI,GAAGV,GAAG,CAACW,QAAQ,IAAIX,GAAG,CAACU,IAAI,IAAI,WAAW;IACpD,MAAME,IAAI,GAAGC,QAAQ,CAACb,GAAG,CAACY,IAAI,IAAI,GAAG,EAAE,EAAE,CAAC,IAAI,EAAE;IAChD,MAAME,IAAI,GAAGd,GAAG,CAACe,QAAQ,GACtBX,kBAAkB,CAACJ,GAAG,CAACe,QAAQ,CAAC,GAChCC,SAAS;IACZ,MAAMC,QAAQ,GAAGjB,GAAG,CAACiB,QAAQ,GAC1Bb,kBAAkB,CAACJ,GAAG,CAACiB,QAAQ,CAAC,GAChCD,SAAS;IAEZ,MAAMR,MAAM,CAACU,MAAM,CAAC;MACnBR,IAAI;MACJE,IAAI;MACJE,IAAI;MACJG,QAAQ;MACR,GAAGhB;KACH,CAAC;IAEF;IACA;IACA,IAAI;MACHK,YAAY,GAAG,MAAME,MAAM,CAACW,OAAO,CAAChB,QAAQ,CAAC;KAC7C,CAAC,OAAOiB,GAAY,EAAE;MACtB;MACA,IAAKA,GAAwB,CAACC,IAAI,KAAK,GAAG,EAAE;QAC3C,MAAM,IAAIC,kBAAa,EAAE;;;IAI3B,IAAI,CAAChB,YAAY,EAAE;MAClB;MACA;MACA,MAAMiB,IAAI,GAAG,MAAMf,MAAM,CAACe,IAAI,CAAC,kBAAO,EAACpB,QAAQ,CAAC,CAAC;MAEjD;MACA,MAAMqB,IAAI,GAAG,mBAAQ,EAACrB,QAAQ,CAAC;MAC/B,MAAMsB,KAAK,GAAGF,IAAI,CAACG,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACH,IAAI,KAAKA,IAAI,CAAC;MAC/C,IAAIC,KAAK,EAAE;QACVnB,YAAY,GAAGmB,KAAK,CAACG,UAAU;;;IAIjC,IAAItB,YAAY,EAAE;MACjB,IAAIuB,aAAa,EAAE,EAAE;QACpB,MAAM,IAAIC,qBAAgB,EAAE;;KAE7B,MAAM;MACN,MAAM,IAAIR,kBAAa,EAAE;;IAG1B,MAAMS,MAAM,GAAG,IAAIC,oBAAW,EAAE;IAChC,MAAMC,EAAE,GAAGF,MAAqB;IAChCvB,MAAM,CAAC0B,UAAU,CAACH,MAAM,EAAE5B,QAAQ,CAAC,CAACgC,IAAI,CAAEC,MAAM,IAAI;MACnDtC,KAAK,CAACsC,MAAM,CAACC,OAAO,CAAC;MACrB7B,MAAM,CAAC8B,KAAK,EAAE;IACf,CAAC,CAAC;IACFL,EAAE,CAAC3B,YAAY,GAAGA,YAAY;IAC9B,OAAO2B,EAAE;GACT,CAAC,OAAOb,GAAG,EAAE;IACbZ,MAAM,CAAC8B,KAAK,EAAE;IACd,MAAMlB,GAAG;;EAGV;EACA,SAASS,aAAa;IACrB,IAAI3B,KAAK,EAAEI,YAAY,IAAIA,YAAY,EAAE;MACxC,OAAO,CAACJ,KAAK,CAACI,YAAY,KAAK,CAACA,YAAY;;IAE7C,OAAO,KAAK;EACb;AACD,CAAC;AAjFYiC,WAAG","names":["debug","ftp","url","opts","cache","filepath","decodeURIComponent","pathname","lastModified","TypeError","client","basic_ftp_1","host","hostname","port","parseInt","user","username","undefined","password","access","lastMod","err","code","notfound_1","list","name","entry","find","e","modifiedAt","isNotModified","notmodified_1","stream","stream_1","rs","downloadTo","then","result","message","close","exports"],"sources":["../src/ftp.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}