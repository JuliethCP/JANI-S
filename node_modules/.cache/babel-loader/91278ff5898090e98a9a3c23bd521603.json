{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.file = void 0;\nconst debug_1 = __importDefault(require(\"debug\"));\nconst fs_1 = require(\"fs\");\nconst fs_extra_1 = require(\"fs-extra\");\nconst notfound_1 = __importDefault(require(\"./notfound\"));\nconst notmodified_1 = __importDefault(require(\"./notmodified\"));\nconst url_1 = require(\"url\");\nconst debug = (0, debug_1.default)('get-uri:file');\n/**\n * Returns a `fs.ReadStream` instance from a \"file:\" URI.\n */\nconst file = async function (_ref) {\n  let {\n    href: uri\n  } = _ref;\n  let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    cache,\n    flags = 'r',\n    mode = 438 // =0666\n  } = opts;\n  try {\n    // Convert URI â†’ Path\n    const filepath = (0, url_1.fileURLToPath)(uri);\n    debug('Normalized pathname: %o', filepath);\n    // `open()` first to get a file descriptor and ensure that the file\n    // exists.\n    const fd = await (0, fs_extra_1.open)(filepath, flags, mode);\n    // Now `fstat()` to check the `mtime` and store the stat object for\n    // the cache.\n    const stat = await (0, fs_extra_1.fstat)(fd);\n    // if a `cache` was provided, check if the file has not been modified\n    if (cache && cache.stat && stat && isNotModified(cache.stat, stat)) {\n      throw new notmodified_1.default();\n    }\n    // `fs.ReadStream` takes care of calling `fs.close()` on the\n    // fd after it's done reading\n    // @ts-expect-error `@types/node` doesn't allow `null` as file path :/\n    const rs = (0, fs_1.createReadStream)(null, {\n      autoClose: true,\n      ...opts,\n      fd\n    });\n    rs.stat = stat;\n    return rs;\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      throw new notfound_1.default();\n    }\n    throw err;\n  }\n};\nexports.file = file;\n// returns `true` if the `mtime` of the 2 stat objects are equal\nfunction isNotModified(prev, curr) {\n  return +prev.mtime === +curr.mtime;\n}","map":{"version":3,"mappings":";;;;;;;;;;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA,MAAMA,KAAK,GAAG,mBAAW,EAAC,cAAc,CAAC;AAczC;;;AAIO,MAAMC,IAAI,GAAgC,sBAG7C;EAAA,IAFH;IAAEC,IAAI,EAAEC;EAAG,CAAE;EAAA,IACbC,IAAI,uEAAG,EAAE;EAET,MAAM;IACLC,KAAK;IACLC,KAAK,GAAG,GAAG;IACXC,IAAI,GAAG,GAAG,CAAE;GACZ,GAAGH,IAAI;EAER,IAAI;IACH;IACA,MAAMI,QAAQ,GAAG,uBAAa,EAACL,GAAG,CAAC;IACnCH,KAAK,CAAC,yBAAyB,EAAEQ,QAAQ,CAAC;IAE1C;IACA;IACA,MAAMC,EAAE,GAAG,MAAM,mBAAI,EAACD,QAAQ,EAAEF,KAAK,EAAEC,IAAI,CAAC;IAE5C;IACA;IACA,MAAMG,IAAI,GAAG,MAAM,oBAAK,EAACD,EAAE,CAAC;IAE5B;IACA,IAAIJ,KAAK,IAAIA,KAAK,CAACK,IAAI,IAAIA,IAAI,IAAIC,aAAa,CAACN,KAAK,CAACK,IAAI,EAAEA,IAAI,CAAC,EAAE;MACnE,MAAM,IAAIE,qBAAgB,EAAE;;IAG7B;IACA;IACA;IACA,MAAMC,EAAE,GAAG,yBAAgB,EAAC,IAAI,EAAE;MACjCC,SAAS,EAAE,IAAI;MACf,GAAGV,IAAI;MACPK;KACA,CAAiB;IAClBI,EAAE,CAACH,IAAI,GAAGA,IAAI;IACd,OAAOG,EAAE;GACT,CAAC,OAAOE,GAAY,EAAE;IACtB,IAAKA,GAA6B,CAACC,IAAI,KAAK,QAAQ,EAAE;MACrD,MAAM,IAAIC,kBAAa,EAAE;;IAE1B,MAAMF,GAAG;;AAEX,CAAC;AA5CYG,YAAI;AA8CjB;AACA,SAASP,aAAa,CAACQ,IAAW,EAAEC,IAAW;EAC9C,OAAO,CAACD,IAAI,CAACE,KAAK,KAAK,CAACD,IAAI,CAACC,KAAK;AACnC","names":["debug","file","href","uri","opts","cache","flags","mode","filepath","fd","stat","isNotModified","notmodified_1","rs","autoClose","err","code","notfound_1","exports","prev","curr","mtime"],"sources":["../src/file.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}