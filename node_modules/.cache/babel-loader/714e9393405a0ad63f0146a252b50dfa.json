{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst createdFunctions = new Map();\n/**\n * Creates a function from a string.\n *\n * @internal\n */\nexport const createFunction = functionValue => {\n  let fn = createdFunctions.get(functionValue);\n  if (fn) {\n    return fn;\n  }\n  fn = new Function(`return ${functionValue}`)();\n  createdFunctions.set(functionValue, fn);\n  return fn;\n};\n/**\n * @internal\n */\nexport function stringifyFunction(fn) {\n  let value = fn.toString();\n  try {\n    new Function(`(${value})`);\n  } catch {\n    // This means we might have a function shorthand (e.g. `test(){}`). Let's\n    // try prefixing.\n    let prefix = 'function ';\n    if (value.startsWith('async ')) {\n      prefix = `async ${prefix}`;\n      value = value.substring('async '.length);\n    }\n    value = `${prefix}${value}`;\n    try {\n      new Function(`(${value})`);\n    } catch {\n      // We tried hard to serialize, but there's a weird beast here.\n      throw new Error('Passed function cannot be serialized!');\n    }\n  }\n  return value;\n}\n/**\n * Replaces `PLACEHOLDER`s with the given replacements.\n *\n * All replacements must be valid JS code.\n *\n * @example\n *\n * ```ts\n * interpolateFunction(() => PLACEHOLDER('test'), {test: 'void 0'});\n * // Equivalent to () => void 0\n * ```\n *\n * @internal\n */\nexport const interpolateFunction = (fn, replacements) => {\n  let value = stringifyFunction(fn);\n  for (const [name, jsValue] of Object.entries(replacements)) {\n    value = value.replace(new RegExp(`PLACEHOLDER\\\\(\\\\s*(?:'${name}'|\"${name}\")\\\\s*\\\\)`, 'g'),\n    // Wrapping this ensures tersers that accidently inline PLACEHOLDER calls\n    // are still valid. Without, we may get calls like ()=>{...}() which is\n    // not valid.\n    `(${jsValue})`);\n  }\n  return createFunction(value);\n};","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAeA,MAAMA,gBAAgB,GAAG,IAAIC,GAAG,EAA2C;AAE3E;;;;;AAKA,OAAO,MAAMC,cAAc,GACzBC,aAAqB,IACgB;EACrC,IAAIC,EAAE,GAAGJ,gBAAgB,CAACK,GAAG,CAACF,aAAa,CAAC;EAC5C,IAAIC,EAAE,EAAE;IACN,OAAOA,EAAE;;EAEXA,EAAE,GAAG,IAAIE,QAAQ,CAAC,UAAUH,aAAa,EAAE,CAAC,EAEhC;EACZH,gBAAgB,CAACO,GAAG,CAACJ,aAAa,EAAEC,EAAE,CAAC;EACvC,OAAOA,EAAE;AACX,CAAC;AAED;;;AAGA,OAAM,SAAUI,iBAAiB,CAACJ,EAA+B;EAC/D,IAAIK,KAAK,GAAGL,EAAE,CAACM,QAAQ,EAAE;EACzB,IAAI;IACF,IAAIJ,QAAQ,CAAC,IAAIG,KAAK,GAAG,CAAC;GAC3B,CAAC,MAAM;IACN;IACA;IACA,IAAIE,MAAM,GAAG,WAAW;IACxB,IAAIF,KAAK,CAACG,UAAU,CAAC,QAAQ,CAAC,EAAE;MAC9BD,MAAM,GAAG,SAASA,MAAM,EAAE;MAC1BF,KAAK,GAAGA,KAAK,CAACI,SAAS,CAAC,QAAQ,CAACC,MAAM,CAAC;;IAE1CL,KAAK,GAAG,GAAGE,MAAM,GAAGF,KAAK,EAAE;IAC3B,IAAI;MACF,IAAIH,QAAQ,CAAC,IAAIG,KAAK,GAAG,CAAC;KAC3B,CAAC,MAAM;MACN;MACA,MAAM,IAAIM,KAAK,CAAC,uCAAuC,CAAC;;;EAG5D,OAAON,KAAK;AACd;AAEA;;;;;;;;;;;;;;AAcA,OAAO,MAAMO,mBAAmB,GAAG,CACjCZ,EAAK,EACLa,YAAoC,KAC/B;EACL,IAAIR,KAAK,GAAGD,iBAAiB,CAACJ,EAAE,CAAC;EACjC,KAAK,MAAM,CAACc,IAAI,EAAEC,OAAO,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACJ,YAAY,CAAC,EAAE;IAC1DR,KAAK,GAAGA,KAAK,CAACa,OAAO,CACnB,IAAIC,MAAM,CAAC,yBAAyBL,IAAI,MAAMA,IAAI,WAAW,EAAE,GAAG,CAAC;IACnE;IACA;IACA;IACA,IAAIC,OAAO,GAAG,CACf;;EAEH,OAAOjB,cAAc,CAACO,KAAK,CAAiB;AAC9C,CAAC","names":["createdFunctions","Map","createFunction","functionValue","fn","get","Function","set","stringifyFunction","value","toString","prefix","startsWith","substring","length","Error","interpolateFunction","replacements","name","jsValue","Object","entries","replace","RegExp"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\util\\Function.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nconst createdFunctions = new Map<string, (...args: unknown[]) => unknown>();\n\n/**\n * Creates a function from a string.\n *\n * @internal\n */\nexport const createFunction = (\n  functionValue: string\n): ((...args: unknown[]) => unknown) => {\n  let fn = createdFunctions.get(functionValue);\n  if (fn) {\n    return fn;\n  }\n  fn = new Function(`return ${functionValue}`)() as (\n    ...args: unknown[]\n  ) => unknown;\n  createdFunctions.set(functionValue, fn);\n  return fn;\n};\n\n/**\n * @internal\n */\nexport function stringifyFunction(fn: (...args: never) => unknown): string {\n  let value = fn.toString();\n  try {\n    new Function(`(${value})`);\n  } catch {\n    // This means we might have a function shorthand (e.g. `test(){}`). Let's\n    // try prefixing.\n    let prefix = 'function ';\n    if (value.startsWith('async ')) {\n      prefix = `async ${prefix}`;\n      value = value.substring('async '.length);\n    }\n    value = `${prefix}${value}`;\n    try {\n      new Function(`(${value})`);\n    } catch {\n      // We tried hard to serialize, but there's a weird beast here.\n      throw new Error('Passed function cannot be serialized!');\n    }\n  }\n  return value;\n}\n\n/**\n * Replaces `PLACEHOLDER`s with the given replacements.\n *\n * All replacements must be valid JS code.\n *\n * @example\n *\n * ```ts\n * interpolateFunction(() => PLACEHOLDER('test'), {test: 'void 0'});\n * // Equivalent to () => void 0\n * ```\n *\n * @internal\n */\nexport const interpolateFunction = <T extends (...args: never[]) => unknown>(\n  fn: T,\n  replacements: Record<string, string>\n): T => {\n  let value = stringifyFunction(fn);\n  for (const [name, jsValue] of Object.entries(replacements)) {\n    value = value.replace(\n      new RegExp(`PLACEHOLDER\\\\(\\\\s*(?:'${name}'|\"${name}\")\\\\s*\\\\)`, 'g'),\n      // Wrapping this ensures tersers that accidently inline PLACEHOLDER calls\n      // are still valid. Without, we may get calls like ()=>{...}() which is\n      // not valid.\n      `(${jsValue})`\n    );\n  }\n  return createFunction(value) as unknown as T;\n};\n\ndeclare global {\n  /**\n   * Used for interpolation with {@link interpolateFunction}.\n   *\n   * @internal\n   */\n  function PLACEHOLDER<T>(name: string): T;\n}\n"]},"metadata":{},"sourceType":"module"}