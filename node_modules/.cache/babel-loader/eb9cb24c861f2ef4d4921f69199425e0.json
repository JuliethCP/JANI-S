{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSRuntime = void 0;\nconst asyncify_helpers_1 = require(\"./asyncify-helpers\");\nconst context_1 = require(\"./context\");\nconst debug_1 = require(\"./debug\");\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\nconst memory_1 = require(\"./memory\");\nconst types_1 = require(\"./types\");\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with [[setInterruptHandler]]\n * (called regularly while the interpreter runs), [[setMemoryLimit]], and\n * [[setMaxStackSize]].\n * Use [[computeMemoryUsage]] or [[dumpMemoryUsage]] to guide memory limit\n * tuning.\n *\n * Configure ES module loading with [[setModuleLoader]].\n */\nclass QuickJSRuntime {\n  /** @private */\n  constructor(args) {\n    /** @private */\n    this.scope = new lifetime_1.Scope();\n    /** @private */\n    this.contextMap = new Map();\n    this.cToHostCallbacks = {\n      shouldInterrupt: rt => {\n        if (rt !== this.rt.value) {\n          throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\");\n        }\n        const fn = this.interruptHandler;\n        if (!fn) {\n          throw new Error(\"QuickJSContext had no interrupt handler\");\n        }\n        return fn(this) ? 1 : 0;\n      },\n      loadModuleSource: (0, asyncify_helpers_1.maybeAsyncFn)(this, function* (awaited, rt, ctx, moduleName) {\n        const moduleLoader = this.moduleLoader;\n        if (!moduleLoader) {\n          throw new Error(\"Runtime has no module loader\");\n        }\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\");\n        }\n        const context = this.contextMap.get(ctx) ?? this.newContext({\n          contextPointer: ctx\n        });\n        try {\n          const result = yield* awaited(moduleLoader(moduleName, context));\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            (0, debug_1.debugLog)(\"cToHostLoadModule: loader returned error\", result.error);\n            throw result.error;\n          }\n          const moduleSource = typeof result === \"string\" ? result : \"value\" in result ? result.value : result;\n          return this.memory.newHeapCharPointer(moduleSource).value;\n        } catch (error) {\n          (0, debug_1.debugLog)(\"cToHostLoadModule: caught error\", error);\n          context.throw(error);\n          return 0;\n        }\n      }),\n      normalizeModule: (0, asyncify_helpers_1.maybeAsyncFn)(this, function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n        const moduleNormalizer = this.moduleNormalizer;\n        if (!moduleNormalizer) {\n          throw new Error(\"Runtime has no module normalizer\");\n        }\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\");\n        }\n        const context = this.contextMap.get(ctx) ?? this.newContext({\n          /* TODO: Does this happen? Are we responsible for disposing? I don't think so */\n          contextPointer: ctx\n        });\n        try {\n          const result = yield* awaited(moduleNormalizer(baseModuleName, moduleNameRequest, context));\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            (0, debug_1.debugLog)(\"cToHostNormalizeModule: normalizer returned error\", result.error);\n            throw result.error;\n          }\n          const name = typeof result === \"string\" ? result : result.value;\n          return context.getMemory(this.rt.value).newHeapCharPointer(name).value;\n        } catch (error) {\n          (0, debug_1.debugLog)(\"normalizeModule: caught error\", error);\n          context.throw(error);\n          return 0;\n        }\n      })\n    };\n    args.ownedLifetimes?.forEach(lifetime => this.scope.manage(lifetime));\n    this.module = args.module;\n    this.memory = new memory_1.ModuleMemory(this.module);\n    this.ffi = args.ffi;\n    this.rt = args.rt;\n    this.callbacks = args.callbacks;\n    this.scope.manage(this.rt);\n    this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks);\n    this.executePendingJobs = this.executePendingJobs.bind(this);\n  }\n  get alive() {\n    return this.scope.alive;\n  }\n  dispose() {\n    return this.scope.dispose();\n  }\n  newContext() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {\n      throw new Error(\"TODO: Custom intrinsics are not supported yet\");\n    }\n    const ctx = new lifetime_1.Lifetime(options.contextPointer || this.ffi.QTS_NewContext(this.rt.value), undefined, ctx_ptr => {\n      this.contextMap.delete(ctx_ptr);\n      this.callbacks.deleteContext(ctx_ptr);\n      this.ffi.QTS_FreeContext(ctx_ptr);\n    });\n    const context = new context_1.QuickJSContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: options.ownedLifetimes,\n      runtime: this,\n      callbacks: this.callbacks\n    });\n    this.contextMap.set(ctx.value, context);\n    return context;\n  }\n  /**\n   * Set the loader for EcmaScript modules requested by any context in this\n   * runtime.\n   *\n   * The loader can be removed with [[removeModuleLoader]].\n   */\n  setModuleLoader(moduleLoader, moduleNormalizer) {\n    this.moduleLoader = moduleLoader;\n    this.moduleNormalizer = moduleNormalizer;\n    this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0);\n  }\n  /**\n   * Remove the the loader set by [[setModuleLoader]]. This disables module loading.\n   */\n  removeModuleLoader() {\n    this.moduleLoader = undefined;\n    this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value);\n  }\n  // Runtime management -------------------------------------------------------\n  /**\n   * In QuickJS, promises and async functions create pendingJobs. These do not execute\n   * immediately and need to be run by calling [[executePendingJobs]].\n   *\n   * @return true if there is at least one pendingJob queued up.\n   */\n  hasPendingJob() {\n    return Boolean(this.ffi.QTS_IsJobPending(this.rt.value));\n  }\n  /**\n   * Set a callback which is regularly called by the QuickJS engine when it is\n   * executing code. This callback can be used to implement an execution\n   * timeout.\n   *\n   * The interrupt handler can be removed with [[removeInterruptHandler]].\n   */\n  setInterruptHandler(cb) {\n    const prevInterruptHandler = this.interruptHandler;\n    this.interruptHandler = cb;\n    if (!prevInterruptHandler) {\n      this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value);\n    }\n  }\n  /**\n   * Remove the interrupt handler, if any.\n   * See [[setInterruptHandler]].\n   */\n  removeInterruptHandler() {\n    if (this.interruptHandler) {\n      this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value);\n      this.interruptHandler = undefined;\n    }\n  }\n  /**\n   * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n   * executed (default all pendingJobs), the queue is exhausted, or the runtime\n   * encounters an exception.\n   *\n   * In QuickJS, promises and async functions *inside the runtime* create\n   * pendingJobs. These do not execute immediately and need to triggered to run.\n   *\n   * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n   * at most `maxJobsToExecute` before returning.\n   *\n   * @return On success, the number of executed jobs. On error, the exception\n   * that stopped execution, and the context it occurred in. Note that\n   * executePendingJobs will not normally return errors thrown inside async\n   * functions or rejected promises. Those errors are available by calling\n   * [[resolvePromise]] on the promise handle returned by the async function.\n   */\n  executePendingJobs() {\n    let maxJobsToExecute = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;\n    const ctxPtrOut = this.memory.newMutablePointerArray(1);\n    const valuePtr = this.ffi.QTS_ExecutePendingJob(this.rt.value, maxJobsToExecute ?? -1, ctxPtrOut.value.ptr);\n    const ctxPtr = ctxPtrOut.value.typedArray[0];\n    ctxPtrOut.dispose();\n    if (ctxPtr === 0) {\n      // No jobs executed.\n      this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr);\n      return {\n        value: 0\n      };\n    }\n    const context = this.contextMap.get(ctxPtr) ?? this.newContext({\n      contextPointer: ctxPtr\n    });\n    const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr);\n    const typeOfRet = context.typeof(resultValue);\n    if (typeOfRet === \"number\") {\n      const executedJobs = context.getNumber(resultValue);\n      resultValue.dispose();\n      return {\n        value: executedJobs\n      };\n    } else {\n      const error = Object.assign(resultValue, {\n        context\n      });\n      return {\n        error\n      };\n    }\n  }\n  /**\n   * Set the max memory this runtime can allocate.\n   * To remove the limit, set to `-1`.\n   */\n  setMemoryLimit(limitBytes) {\n    if (limitBytes < 0 && limitBytes !== -1) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\");\n    }\n    this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes);\n  }\n  /**\n   * Compute memory usage for this runtime. Returns the result as a handle to a\n   * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.\n   * Calling this method will allocate more memory inside the runtime. The information\n   * is accurate as of just before the call to `computeMemoryUsage`.\n   * For a human-digestible representation, see [[dumpMemoryUsage]].\n   */\n  computeMemoryUsage() {\n    const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value);\n    return serviceContextMemory.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value));\n  }\n  /**\n   * @returns a human-readable description of memory usage in this runtime.\n   * For programmatic access to this information, see [[computeMemoryUsage]].\n   */\n  dumpMemoryUsage() {\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value));\n  }\n  /**\n   * Set the max stack size for this runtime, in bytes.\n   * To remove the limit, set to `0`.\n   */\n  setMaxStackSize(stackSize) {\n    if (stackSize < 0) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\");\n    }\n    this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize);\n  }\n  /**\n   * Assert that `handle` is owned by this runtime.\n   * @throws QuickJSWrongOwner if owned by a different runtime.\n   */\n  assertOwned(handle) {\n    if (handle.owner && handle.owner.rt !== this.rt) {\n      throw new errors_1.QuickJSWrongOwner(`Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`);\n    }\n  }\n  getSystemContext() {\n    if (!this.context) {\n      // We own this context and should dispose of it.\n      this.context = this.scope.manage(this.newContext());\n    }\n    return this.context;\n  }\n}\nexports.QuickJSRuntime = QuickJSRuntime;","map":{"version":3,"mappings":"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","names":["QuickJSRuntime","constructor","args","lifetime_1","Map","shouldInterrupt","rt","value","Error","fn","interruptHandler","loadModuleSource","awaited","ctx","moduleName","moduleLoader","context","contextMap","get","newContext","contextPointer","result","error","moduleSource","memory","newHeapCharPointer","throw","normalizeModule","baseModuleName","moduleNameRequest","moduleNormalizer","name","getMemory","ownedLifetimes","forEach","lifetime","scope","manage","module","memory_1","ffi","callbacks","setRuntimeCallbacks","cToHostCallbacks","executePendingJobs","bind","alive","dispose","options","intrinsics","types_1","QTS_NewContext","undefined","ctx_ptr","delete","deleteContext","QTS_FreeContext","context_1","runtime","set","setModuleLoader","QTS_RuntimeEnableModuleLoader","removeModuleLoader","QTS_RuntimeDisableModuleLoader","hasPendingJob","Boolean","QTS_IsJobPending","setInterruptHandler","cb","prevInterruptHandler","QTS_RuntimeEnableInterruptHandler","removeInterruptHandler","QTS_RuntimeDisableInterruptHandler","maxJobsToExecute","ctxPtrOut","newMutablePointerArray","valuePtr","QTS_ExecutePendingJob","ptr","ctxPtr","typedArray","QTS_FreeValuePointerRuntime","resultValue","heapValueHandle","typeOfRet","typeof","executedJobs","getNumber","Object","assign","setMemoryLimit","limitBytes","QTS_RuntimeSetMemoryLimit","computeMemoryUsage","serviceContextMemory","getSystemContext","QTS_RuntimeComputeMemoryUsage","dumpMemoryUsage","consumeHeapCharPointer","QTS_RuntimeDumpMemoryUsage","setMaxStackSize","stackSize","QTS_RuntimeSetMaxStackSize","assertOwned","handle","owner","errors_1","exports"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\runtime.ts"],"sourcesContent":["import { maybeAsyncFn } from \"./asyncify-helpers\"\nimport { QuickJSContext } from \"./context\"\nimport { debugLog } from \"./debug\"\nimport { EitherModule } from \"./emscripten-types\"\nimport { QuickJSWrongOwner } from \"./errors\"\nimport {\n  BorrowedHeapCharPointer,\n  JSContextPointer,\n  JSContextPointerPointer,\n  JSModuleDefPointer,\n  JSRuntimePointer,\n} from \"./types-ffi\"\nimport { Disposable, Lifetime, Scope } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport { QuickJSModuleCallbacks, RuntimeCallbacks } from \"./module\"\nimport {\n  ContextOptions,\n  DefaultIntrinsics,\n  EitherFFI,\n  JSModuleLoader,\n  JSModuleNormalizer,\n  QuickJSHandle,\n} from \"./types\"\nimport { SuccessOrFail } from \"./vm-interface\"\n\n/**\n * Callback called regularly while the VM executes code.\n * Determines if a VM's execution should be interrupted.\n *\n * @returns `true` to interrupt JS execution inside the VM.\n * @returns `false` or `undefined` to continue JS execution inside the VM.\n */\nexport type InterruptHandler = (runtime: QuickJSRuntime) => boolean | undefined\n\n/**\n * Used as an optional for the results of executing pendingJobs.\n * On success, `value` contains the number of async jobs executed\n * by the runtime.\n * @source\n */\nexport type ExecutePendingJobsResult = SuccessOrFail<\n  /** Number of jobs successfully executed. */\n  number,\n  /** The error that occurred. */\n  QuickJSHandle & {\n    /** The context where the error occurred. */\n    context: QuickJSContext\n  }\n>\n\n/**\n * A runtime represents a Javascript runtime corresponding to an object heap.\n * Several runtimes can exist at the same time but they cannot exchange objects.\n * Inside a given runtime, no multi-threading is supported.\n *\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain.\n *\n * Create a runtime via {@link QuickJSWASMModule.newRuntime}.\n *\n * You should create separate runtime instances for untrusted code from\n * different sources for isolation. However, stronger isolation is also\n * available (at the cost of memory usage), by creating separate WebAssembly\n * modules to further isolate untrusted code.\n * See {@link newQuickJSWASMModule}.\n *\n * Implement memory and CPU constraints with [[setInterruptHandler]]\n * (called regularly while the interpreter runs), [[setMemoryLimit]], and\n * [[setMaxStackSize]].\n * Use [[computeMemoryUsage]] or [[dumpMemoryUsage]] to guide memory limit\n * tuning.\n *\n * Configure ES module loading with [[setModuleLoader]].\n */\nexport class QuickJSRuntime implements Disposable {\n  /**\n   * If this runtime was created as as part of a context, points to the context\n   * associated with the runtime.\n   *\n   * If this runtime was created stand-alone, this may or may not contain a context.\n   * A context here may be allocated if one is needed by the runtime, eg for [[computeMemoryUsage]].\n   */\n  public context: QuickJSContext | undefined\n\n  /** @private */\n  protected module: EitherModule\n  /** @private */\n  protected memory: ModuleMemory\n  /** @private */\n  protected ffi: EitherFFI\n  /** @private */\n  protected rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected callbacks: QuickJSModuleCallbacks\n  /** @private */\n  protected scope = new Scope()\n\n  /** @private */\n  protected contextMap = new Map<JSContextPointer, QuickJSContext>()\n  /** @private */\n  protected moduleLoader: JSModuleLoader | undefined\n  /** @private */\n  protected moduleNormalizer: JSModuleNormalizer | undefined\n\n  /** @private */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    rt: Lifetime<JSRuntimePointer>\n    callbacks: QuickJSModuleCallbacks\n    ownedLifetimes?: Disposable[]\n  }) {\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.module = args.module\n    this.memory = new ModuleMemory(this.module)\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.callbacks = args.callbacks\n    this.scope.manage(this.rt)\n    this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks)\n\n    this.executePendingJobs = this.executePendingJobs.bind(this)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  newContext(options: ContextOptions = {}): QuickJSContext {\n    if (options.intrinsics && options.intrinsics !== DefaultIntrinsics) {\n      throw new Error(\"TODO: Custom intrinsics are not supported yet\")\n    }\n\n    const ctx = new Lifetime(\n      options.contextPointer || this.ffi.QTS_NewContext(this.rt.value),\n      undefined,\n      (ctx_ptr) => {\n        this.contextMap.delete(ctx_ptr)\n        this.callbacks.deleteContext(ctx_ptr)\n        this.ffi.QTS_FreeContext(ctx_ptr)\n      }\n    )\n\n    const context = new QuickJSContext({\n      module: this.module,\n      ctx,\n      ffi: this.ffi,\n      rt: this.rt,\n      ownedLifetimes: options.ownedLifetimes,\n      runtime: this,\n      callbacks: this.callbacks,\n    })\n    this.contextMap.set(ctx.value, context)\n\n    return context\n  }\n\n  /**\n   * Set the loader for EcmaScript modules requested by any context in this\n   * runtime.\n   *\n   * The loader can be removed with [[removeModuleLoader]].\n   */\n  setModuleLoader(moduleLoader: JSModuleLoader, moduleNormalizer?: JSModuleNormalizer): void {\n    this.moduleLoader = moduleLoader\n    this.moduleNormalizer = moduleNormalizer\n    this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0)\n  }\n\n  /**\n   * Remove the the loader set by [[setModuleLoader]]. This disables module loading.\n   */\n  removeModuleLoader(): void {\n    this.moduleLoader = undefined\n    this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value)\n  }\n\n  // Runtime management -------------------------------------------------------\n\n  /**\n   * In QuickJS, promises and async functions create pendingJobs. These do not execute\n   * immediately and need to be run by calling [[executePendingJobs]].\n   *\n   * @return true if there is at least one pendingJob queued up.\n   */\n  hasPendingJob(): boolean {\n    return Boolean(this.ffi.QTS_IsJobPending(this.rt.value))\n  }\n\n  private interruptHandler: InterruptHandler | undefined\n\n  /**\n   * Set a callback which is regularly called by the QuickJS engine when it is\n   * executing code. This callback can be used to implement an execution\n   * timeout.\n   *\n   * The interrupt handler can be removed with [[removeInterruptHandler]].\n   */\n  setInterruptHandler(cb: InterruptHandler) {\n    const prevInterruptHandler = this.interruptHandler\n    this.interruptHandler = cb\n    if (!prevInterruptHandler) {\n      this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value)\n    }\n  }\n\n  /**\n   * Remove the interrupt handler, if any.\n   * See [[setInterruptHandler]].\n   */\n  removeInterruptHandler() {\n    if (this.interruptHandler) {\n      this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value)\n      this.interruptHandler = undefined\n    }\n  }\n\n  /**\n   * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are\n   * executed (default all pendingJobs), the queue is exhausted, or the runtime\n   * encounters an exception.\n   *\n   * In QuickJS, promises and async functions *inside the runtime* create\n   * pendingJobs. These do not execute immediately and need to triggered to run.\n   *\n   * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute\n   * at most `maxJobsToExecute` before returning.\n   *\n   * @return On success, the number of executed jobs. On error, the exception\n   * that stopped execution, and the context it occurred in. Note that\n   * executePendingJobs will not normally return errors thrown inside async\n   * functions or rejected promises. Those errors are available by calling\n   * [[resolvePromise]] on the promise handle returned by the async function.\n   */\n  executePendingJobs(maxJobsToExecute: number | void = -1): ExecutePendingJobsResult {\n    const ctxPtrOut = this.memory.newMutablePointerArray<JSContextPointerPointer>(1)\n    const valuePtr = this.ffi.QTS_ExecutePendingJob(\n      this.rt.value,\n      maxJobsToExecute ?? -1,\n      ctxPtrOut.value.ptr\n    )\n\n    const ctxPtr = ctxPtrOut.value.typedArray[0] as JSContextPointer\n    ctxPtrOut.dispose()\n    if (ctxPtr === 0) {\n      // No jobs executed.\n      this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr)\n      return { value: 0 }\n    }\n\n    const context =\n      this.contextMap.get(ctxPtr) ??\n      this.newContext({\n        contextPointer: ctxPtr,\n      })\n\n    const resultValue = context.getMemory(this.rt.value).heapValueHandle(valuePtr)\n    const typeOfRet = context.typeof(resultValue)\n    if (typeOfRet === \"number\") {\n      const executedJobs = context.getNumber(resultValue)\n      resultValue.dispose()\n      return { value: executedJobs }\n    } else {\n      const error = Object.assign(resultValue, { context })\n      return {\n        error,\n      }\n    }\n  }\n\n  /**\n   * Set the max memory this runtime can allocate.\n   * To remove the limit, set to `-1`.\n   */\n  setMemoryLimit(limitBytes: number) {\n    if (limitBytes < 0 && limitBytes !== -1) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass -1\")\n    }\n\n    this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes)\n  }\n\n  /**\n   * Compute memory usage for this runtime. Returns the result as a handle to a\n   * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.\n   * Calling this method will allocate more memory inside the runtime. The information\n   * is accurate as of just before the call to `computeMemoryUsage`.\n   * For a human-digestible representation, see [[dumpMemoryUsage]].\n   */\n  computeMemoryUsage(): QuickJSHandle {\n    const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value)\n    return serviceContextMemory.heapValueHandle(\n      this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value)\n    )\n  }\n\n  /**\n   * @returns a human-readable description of memory usage in this runtime.\n   * For programmatic access to this information, see [[computeMemoryUsage]].\n   */\n  dumpMemoryUsage(): string {\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value))\n  }\n\n  /**\n   * Set the max stack size for this runtime, in bytes.\n   * To remove the limit, set to `0`.\n   */\n  setMaxStackSize(stackSize: number) {\n    if (stackSize < 0) {\n      throw new Error(\"Cannot set memory limit to negative number. To unset, pass 0.\")\n    }\n\n    this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize)\n  }\n\n  /**\n   * Assert that `handle` is owned by this runtime.\n   * @throws QuickJSWrongOwner if owned by a different runtime.\n   */\n  assertOwned(handle: QuickJSHandle) {\n    if (handle.owner && handle.owner.rt !== this.rt) {\n      throw new QuickJSWrongOwner(\n        `Handle is not owned by this runtime: ${handle.owner.rt.value} != ${this.rt.value}`\n      )\n    }\n  }\n\n  private getSystemContext() {\n    if (!this.context) {\n      // We own this context and should dispose of it.\n      this.context = this.scope.manage(this.newContext())\n    }\n    return this.context\n  }\n\n  private cToHostCallbacks: RuntimeCallbacks = {\n    shouldInterrupt: (rt) => {\n      if (rt !== this.rt.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS interrupt with mismatched rt\")\n      }\n\n      const fn = this.interruptHandler\n      if (!fn) {\n        throw new Error(\"QuickJSContext had no interrupt handler\")\n      }\n\n      return fn(this) ? 1 : 0\n    },\n\n    loadModuleSource: maybeAsyncFn(this, function* (awaited, rt, ctx, moduleName) {\n      const moduleLoader = this.moduleLoader\n      if (!moduleLoader) {\n        throw new Error(\"Runtime has no module loader\")\n      }\n\n      if (rt !== this.rt.value) {\n        throw new Error(\"Runtime pointer mismatch\")\n      }\n\n      const context =\n        this.contextMap.get(ctx) ??\n        this.newContext({\n          contextPointer: ctx,\n        })\n\n      try {\n        const result = yield* awaited(moduleLoader(moduleName, context))\n\n        if (typeof result === \"object\" && \"error\" in result && result.error) {\n          debugLog(\"cToHostLoadModule: loader returned error\", result.error)\n          throw result.error\n        }\n\n        const moduleSource =\n          typeof result === \"string\" ? result : \"value\" in result ? result.value : result\n\n        return this.memory.newHeapCharPointer(moduleSource).value\n      } catch (error) {\n        debugLog(\"cToHostLoadModule: caught error\", error)\n        context.throw(error as any)\n        return 0 as BorrowedHeapCharPointer\n      }\n    }),\n\n    normalizeModule: maybeAsyncFn(\n      this,\n      function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {\n        const moduleNormalizer = this.moduleNormalizer\n        if (!moduleNormalizer) {\n          throw new Error(\"Runtime has no module normalizer\")\n        }\n\n        if (rt !== this.rt.value) {\n          throw new Error(\"Runtime pointer mismatch\")\n        }\n\n        const context =\n          this.contextMap.get(ctx) ??\n          this.newContext({\n            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */\n            contextPointer: ctx,\n          })\n\n        try {\n          const result = yield* awaited(\n            moduleNormalizer(baseModuleName, moduleNameRequest, context)\n          )\n\n          if (typeof result === \"object\" && \"error\" in result && result.error) {\n            debugLog(\"cToHostNormalizeModule: normalizer returned error\", result.error)\n            throw result.error\n          }\n\n          const name = typeof result === \"string\" ? result : result.value\n          return context.getMemory(this.rt.value).newHeapCharPointer(name).value\n        } catch (error) {\n          debugLog(\"normalizeModule: caught error\", error)\n          context.throw(error as any)\n          return 0 as BorrowedHeapCharPointer\n        }\n      }\n    ),\n  }\n}\n"]},"metadata":{},"sourceType":"script"}