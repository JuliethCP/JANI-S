{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport mitt from '../../third_party/mitt/mitt.js';\nimport { disposeSymbol } from '../util/disposable.js';\n/**\n * The EventEmitter class that many Puppeteer classes extend.\n *\n * @remarks\n *\n * This allows you to listen to events that Puppeteer classes fire and act\n * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and\n * {@link EventEmitter.off | off} to bind\n * and unbind to event listeners.\n *\n * @public\n */\nexport class EventEmitter {\n  #emitter;\n  #handlers = new Map();\n  /**\n   * @internal\n   */\n  constructor() {\n    this.#emitter = mitt(this.#handlers);\n  }\n  /**\n   * Bind an event listener to fire when an event occurs.\n   * @param type - the event type you'd like to listen to. Can be a string or symbol.\n   * @param handler - the function to be called when the event occurs.\n   * @returns `this` to enable you to chain method calls.\n   */\n  on(type, handler) {\n    this.#emitter.on(type, handler);\n    return this;\n  }\n  /**\n   * Remove an event listener from firing.\n   * @param type - the event type you'd like to stop listening to.\n   * @param handler - the function that should be removed.\n   * @returns `this` to enable you to chain method calls.\n   */\n  off(type, handler) {\n    this.#emitter.off(type, handler);\n    return this;\n  }\n  /**\n   * Remove an event listener.\n   *\n   * @deprecated please use {@link EventEmitter.off} instead.\n   */\n  removeListener(type, handler) {\n    this.off(type, handler);\n    return this;\n  }\n  /**\n   * Add an event listener.\n   *\n   * @deprecated please use {@link EventEmitter.on} instead.\n   */\n  addListener(type, handler) {\n    this.on(type, handler);\n    return this;\n  }\n  /**\n   * Emit an event and call any associated listeners.\n   *\n   * @param type - the event you'd like to emit\n   * @param eventData - any data you'd like to emit with the event\n   * @returns `true` if there are any listeners, `false` if there are not.\n   */\n  emit(type, event) {\n    this.#emitter.emit(type, event);\n    return this.listenerCount(type) > 0;\n  }\n  /**\n   * Like `on` but the listener will only be fired once and then it will be removed.\n   * @param type - the event you'd like to listen to\n   * @param handler - the handler function to run when the event occurs\n   * @returns `this` to enable you to chain method calls.\n   */\n  once(type, handler) {\n    const onceHandler = eventData => {\n      handler(eventData);\n      this.off(type, onceHandler);\n    };\n    return this.on(type, onceHandler);\n  }\n  /**\n   * Gets the number of listeners for a given event.\n   *\n   * @param type - the event to get the listener count for\n   * @returns the number of listeners bound to the given event\n   */\n  listenerCount(type) {\n    return this.#handlers.get(type)?.length || 0;\n  }\n  /**\n   * Removes all listeners. If given an event argument, it will remove only\n   * listeners for that event.\n   *\n   * @param type - the event to remove listeners for.\n   * @returns `this` to enable you to chain method calls.\n   */\n  removeAllListeners(type) {\n    if (type === undefined || type === '*') {\n      this.#handlers.clear();\n    } else {\n      this.#handlers.delete(type);\n    }\n    return this;\n  }\n}\n/**\n * @internal\n */\nexport class EventSubscription {\n  #target;\n  #type;\n  #handler;\n  constructor(target, type, handler) {\n    this.#target = target;\n    this.#type = type;\n    this.#handler = handler;\n    this.#target.on(this.#type, this.#handler);\n  }\n  [disposeSymbol]() {\n    this.#target.off(this.#type, this.#handler);\n  }\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAgBA,OAAOA,IAIN,MAAM,gCAAgC;AACvC,SAAQC,aAAa,QAAO,uBAAuB;AAqDnD;;;;;;;;;;;;AAYA,OAAM,MAAOC,YAAY;EAGvB,QAAQ;EACR,SAAS,GAA0D,IAAIC,GAAG,EAAE;EAE5E;;;EAGAC;IACE,IAAI,CAAC,QAAQ,GAAGJ,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC;EACtC;EAEA;;;;;;EAMAK,EAAE,CACAC,IAAS,EACTC,OAAiD;IAEjD,IAAI,CAAC,QAAQ,CAACF,EAAE,CAACC,IAAI,EAAEC,OAAO,CAAC;IAC/B,OAAO,IAAI;EACb;EAEA;;;;;;EAMAC,GAAG,CACDF,IAAS,EACTC,OAAkD;IAElD,IAAI,CAAC,QAAQ,CAACC,GAAG,CAACF,IAAI,EAAEC,OAAO,CAAC;IAChC,OAAO,IAAI;EACb;EAEA;;;;;EAKAE,cAAc,CACZH,IAAS,EACTC,OAAiD;IAEjD,IAAI,CAACC,GAAG,CAACF,IAAI,EAAEC,OAAO,CAAC;IACvB,OAAO,IAAI;EACb;EAEA;;;;;EAKAG,WAAW,CACTJ,IAAS,EACTC,OAAiD;IAEjD,IAAI,CAACF,EAAE,CAACC,IAAI,EAAEC,OAAO,CAAC;IACtB,OAAO,IAAI;EACb;EAEA;;;;;;;EAOAI,IAAI,CACFL,IAAS,EACTM,KAAsC;IAEtC,IAAI,CAAC,QAAQ,CAACD,IAAI,CAACL,IAAI,EAAEM,KAAK,CAAC;IAC/B,OAAO,IAAI,CAACC,aAAa,CAACP,IAAI,CAAC,GAAG,CAAC;EACrC;EAEA;;;;;;EAMAQ,IAAI,CACFR,IAAS,EACTC,OAAiD;IAEjD,MAAMQ,WAAW,GAA6CC,SAAS,IAAG;MACxET,OAAO,CAACS,SAAS,CAAC;MAClB,IAAI,CAACR,GAAG,CAACF,IAAI,EAAES,WAAW,CAAC;IAC7B,CAAC;IAED,OAAO,IAAI,CAACV,EAAE,CAACC,IAAI,EAAES,WAAW,CAAC;EACnC;EAEA;;;;;;EAMAF,aAAa,CAACP,IAAsC;IAClD,OAAO,IAAI,CAAC,SAAS,CAACW,GAAG,CAACX,IAAI,CAAC,EAAEY,MAAM,IAAI,CAAC;EAC9C;EAEA;;;;;;;EAOAC,kBAAkB,CAACb,IAAuC;IACxD,IAAIA,IAAI,KAAKc,SAAS,IAAId,IAAI,KAAK,GAAG,EAAE;MACtC,IAAI,CAAC,SAAS,CAACe,KAAK,EAAE;KACvB,MAAM;MACL,IAAI,CAAC,SAAS,CAACC,MAAM,CAAChB,IAAI,CAAC;;IAE7B,OAAO,IAAI;EACb;;AAGF;;;AAGA,OAAM,MAAOiB,iBAAiB;EAK5B,OAAO;EACP,KAAK;EACL,QAAQ;EAERnB,YAAYoB,MAAc,EAAElB,IAAU,EAAEC,OAAuB;IAC7D,IAAI,CAAC,OAAO,GAAGiB,MAAM;IACrB,IAAI,CAAC,KAAK,GAAGlB,IAAI;IACjB,IAAI,CAAC,QAAQ,GAAGC,OAAO;IACvB,IAAI,CAAC,OAAO,CAACF,EAAE,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC;EAC5C;EAEA,CAACJ,aAAa,IAAC;IACb,IAAI,CAAC,OAAO,CAACO,GAAG,CAAC,IAAI,CAAC,KAAK,EAAE,IAAI,CAAC,QAAQ,CAAC;EAC7C","names":["mitt","disposeSymbol","EventEmitter","Map","constructor","on","type","handler","off","removeListener","addListener","emit","event","listenerCount","once","onceHandler","eventData","get","length","removeAllListeners","undefined","clear","delete","EventSubscription","target"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\common\\EventEmitter.ts"],"sourcesContent":["/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport mitt, {\n  type Emitter,\n  type EventHandlerMap,\n  type EventType,\n} from '../../third_party/mitt/mitt.js';\nimport {disposeSymbol} from '../util/disposable.js';\n\nexport type {\n  /**\n   * @public\n   */\n  EventType,\n} from '../../third_party/mitt/mitt.js';\n\n/**\n * @public\n */\nexport type Handler<T = unknown> = (event: T) => void;\n\n/**\n * @public\n */\nexport interface CommonEventEmitter<Events extends Record<EventType, unknown>> {\n  on<Key extends keyof Events>(type: Key, handler: Handler<Events[Key]>): this;\n  off<Key extends keyof Events>(\n    type: Key,\n    handler?: Handler<Events[Key]>\n  ): this;\n  emit<Key extends keyof Events>(type: Key, event: Events[Key]): boolean;\n  /* To maintain parity with the built in NodeJS event emitter which uses removeListener\n   * rather than `off`.\n   * If you're implementing new code you should use `off`.\n   */\n  addListener<Key extends keyof Events>(\n    type: Key,\n    handler: Handler<Events[Key]>\n  ): this;\n  removeListener<Key extends keyof Events>(\n    type: Key,\n    handler: Handler<Events[Key]>\n  ): this;\n  once<Key extends keyof Events>(\n    type: Key,\n    handler: Handler<Events[Key]>\n  ): this;\n  listenerCount(event: keyof Events): number;\n\n  removeAllListeners(event?: keyof Events): this;\n}\n\n/**\n * @public\n */\nexport type EventsWithWildcard<Events extends Record<EventType, unknown>> =\n  Events & {\n    '*': Events[keyof Events];\n  };\n\n/**\n * The EventEmitter class that many Puppeteer classes extend.\n *\n * @remarks\n *\n * This allows you to listen to events that Puppeteer classes fire and act\n * accordingly. Therefore you'll mostly use {@link EventEmitter.on | on} and\n * {@link EventEmitter.off | off} to bind\n * and unbind to event listeners.\n *\n * @public\n */\nexport class EventEmitter<Events extends Record<EventType, unknown>>\n  implements CommonEventEmitter<EventsWithWildcard<Events>>\n{\n  #emitter: Emitter<Events & {'*': Events[keyof Events]}>;\n  #handlers: EventHandlerMap<Events & {'*': Events[keyof Events]}> = new Map();\n\n  /**\n   * @internal\n   */\n  constructor() {\n    this.#emitter = mitt(this.#handlers);\n  }\n\n  /**\n   * Bind an event listener to fire when an event occurs.\n   * @param type - the event type you'd like to listen to. Can be a string or symbol.\n   * @param handler - the function to be called when the event occurs.\n   * @returns `this` to enable you to chain method calls.\n   */\n  on<Key extends keyof EventsWithWildcard<Events>>(\n    type: Key,\n    handler: Handler<EventsWithWildcard<Events>[Key]>\n  ): this {\n    this.#emitter.on(type, handler);\n    return this;\n  }\n\n  /**\n   * Remove an event listener from firing.\n   * @param type - the event type you'd like to stop listening to.\n   * @param handler - the function that should be removed.\n   * @returns `this` to enable you to chain method calls.\n   */\n  off<Key extends keyof EventsWithWildcard<Events>>(\n    type: Key,\n    handler?: Handler<EventsWithWildcard<Events>[Key]>\n  ): this {\n    this.#emitter.off(type, handler);\n    return this;\n  }\n\n  /**\n   * Remove an event listener.\n   *\n   * @deprecated please use {@link EventEmitter.off} instead.\n   */\n  removeListener<Key extends keyof EventsWithWildcard<Events>>(\n    type: Key,\n    handler: Handler<EventsWithWildcard<Events>[Key]>\n  ): this {\n    this.off(type, handler);\n    return this;\n  }\n\n  /**\n   * Add an event listener.\n   *\n   * @deprecated please use {@link EventEmitter.on} instead.\n   */\n  addListener<Key extends keyof EventsWithWildcard<Events>>(\n    type: Key,\n    handler: Handler<EventsWithWildcard<Events>[Key]>\n  ): this {\n    this.on(type, handler);\n    return this;\n  }\n\n  /**\n   * Emit an event and call any associated listeners.\n   *\n   * @param type - the event you'd like to emit\n   * @param eventData - any data you'd like to emit with the event\n   * @returns `true` if there are any listeners, `false` if there are not.\n   */\n  emit<Key extends keyof EventsWithWildcard<Events>>(\n    type: Key,\n    event: EventsWithWildcard<Events>[Key]\n  ): boolean {\n    this.#emitter.emit(type, event);\n    return this.listenerCount(type) > 0;\n  }\n\n  /**\n   * Like `on` but the listener will only be fired once and then it will be removed.\n   * @param type - the event you'd like to listen to\n   * @param handler - the handler function to run when the event occurs\n   * @returns `this` to enable you to chain method calls.\n   */\n  once<Key extends keyof EventsWithWildcard<Events>>(\n    type: Key,\n    handler: Handler<EventsWithWildcard<Events>[Key]>\n  ): this {\n    const onceHandler: Handler<EventsWithWildcard<Events>[Key]> = eventData => {\n      handler(eventData);\n      this.off(type, onceHandler);\n    };\n\n    return this.on(type, onceHandler);\n  }\n\n  /**\n   * Gets the number of listeners for a given event.\n   *\n   * @param type - the event to get the listener count for\n   * @returns the number of listeners bound to the given event\n   */\n  listenerCount(type: keyof EventsWithWildcard<Events>): number {\n    return this.#handlers.get(type)?.length || 0;\n  }\n\n  /**\n   * Removes all listeners. If given an event argument, it will remove only\n   * listeners for that event.\n   *\n   * @param type - the event to remove listeners for.\n   * @returns `this` to enable you to chain method calls.\n   */\n  removeAllListeners(type?: keyof EventsWithWildcard<Events>): this {\n    if (type === undefined || type === '*') {\n      this.#handlers.clear();\n    } else {\n      this.#handlers.delete(type);\n    }\n    return this;\n  }\n}\n\n/**\n * @internal\n */\nexport class EventSubscription<\n  Target extends CommonEventEmitter<Record<Type, Event>>,\n  Type extends EventType = EventType,\n  Event = unknown,\n> {\n  #target: Target;\n  #type: Type;\n  #handler: Handler<Event>;\n\n  constructor(target: Target, type: Type, handler: Handler<Event>) {\n    this.#target = target;\n    this.#type = type;\n    this.#handler = handler;\n    this.#target.on(this.#type, this.#handler);\n  }\n\n  [disposeSymbol](): void {\n    this.#target.off(this.#type, this.#handler);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}