{"ast":null,"code":"var __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { mergeMap, from, EMPTY, defer, filter, first, identity, ignoreElements, retry, throwIfEmpty, race, catchError, defaultIfEmpty, firstValueFrom, fromEvent, map, merge, noop, pipe, raceWith, tap } from '../../../third_party/rxjs/rxjs.js';\nimport { EventEmitter } from '../../common/EventEmitter.js';\nimport { debugError, timeout } from '../../common/util.js';\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport var LocatorEvent;\n(function (LocatorEvent) {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  LocatorEvent[\"Action\"] = \"action\";\n})(LocatorEvent || (LocatorEvent = {}));\nexport {\n/**\n * @deprecated Use {@link LocatorEvent}.\n */\nLocatorEvent as LocatorEmittedEvents };\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * @public\n */\nexport class Locator extends EventEmitter {\n  /**\n   * Creates a race between multiple locators but ensures that only a single one\n   * acts.\n   *\n   * @public\n   */\n  static race(locators) {\n    return RaceLocator.create(locators);\n  }\n  /**\n   * @internal\n   */\n  visibility = null;\n  /**\n   * @internal\n   */\n  _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n  /**\n   * @internal\n   */\n  operators = {\n    conditions: (conditions, signal) => {\n      return mergeMap(handle => {\n        return merge(...conditions.map(condition => {\n          return condition(handle, signal);\n        })).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: signal => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(fromEvent(signal, 'abort').pipe(map(() => {\n          throw signal.reason;\n        })));\n      }\n      candidates.push(timeout(this._timeout));\n      return pipe(retry({\n        delay: RETRY_DELAY\n      }), raceWith(...candidates));\n    }\n  };\n  // Determines when the locator will timeout for actions.\n  get timeout() {\n    return this._timeout;\n  }\n  setTimeout(timeout) {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n  setVisibility(visibility) {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n  setWaitForEnabled(value) {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n  setEnsureElementIsInTheViewport(value) {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n  setWaitForStableBoundingBox(value) {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n  /**\n   * @internal\n   */\n  copyOptions(locator) {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = (handle, signal) => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(handle.frame.waitForFunction(element => {\n      if (!(element instanceof HTMLElement)) {\n        return true;\n      }\n      const isNativeFormControl = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTION', 'OPTGROUP'].includes(element.nodeName);\n      return !isNativeFormControl || !element.hasAttribute('disabled');\n    }, {\n      timeout: this._timeout,\n      signal\n    }, handle)).pipe(ignoreElements());\n  };\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = handle => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(handle.evaluate(element => {\n        return new Promise(resolve => {\n          window.requestAnimationFrame(() => {\n            const rect1 = element.getBoundingClientRect();\n            window.requestAnimationFrame(() => {\n              const rect2 = element.getBoundingClientRect();\n              resolve([{\n                x: rect1.x,\n                y: rect1.y,\n                width: rect1.width,\n                height: rect1.height\n              }, {\n                x: rect2.x,\n                y: rect2.y,\n                width: rect2.width,\n                height: rect2.height\n              }]);\n            });\n          });\n        });\n      }));\n    }).pipe(first(_ref => {\n      let [rect1, rect2] = _ref;\n      return rect1.x === rect2.x && rect1.y === rect2.y && rect1.width === rect2.width && rect1.height === rect2.height;\n    }), retry({\n      delay: RETRY_DELAY\n    }), ignoreElements());\n  };\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = handle => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({\n      threshold: 0\n    })).pipe(filter(isIntersectingViewport => {\n      return !isIntersectingViewport;\n    }), mergeMap(() => {\n      return from(handle.scrollIntoView());\n    }), mergeMap(() => {\n      return defer(() => {\n        return from(handle.isIntersectingViewport({\n          threshold: 0\n        }));\n      }).pipe(first(identity), retry({\n        delay: RETRY_DELAY\n      }), ignoreElements());\n    }));\n  };\n  #click(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.click(options)).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #fill(value, options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded, this.#waitForEnabledIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.evaluate(el => {\n        if (el instanceof HTMLSelectElement) {\n          return 'select';\n        }\n        if (el instanceof HTMLTextAreaElement) {\n          return 'typeable-input';\n        }\n        if (el instanceof HTMLInputElement) {\n          if (new Set(['textarea', 'text', 'url', 'tel', 'search', 'password', 'number', 'email']).has(el.type)) {\n            return 'typeable-input';\n          } else {\n            return 'other-input';\n          }\n        }\n        if (el.isContentEditable) {\n          return 'contenteditable';\n        }\n        return 'unknown';\n      })).pipe(mergeMap(inputType => {\n        switch (inputType) {\n          case 'select':\n            return from(handle.select(value).then(noop));\n          case 'contenteditable':\n          case 'typeable-input':\n            return from(handle.evaluate((input, newValue) => {\n              const currentValue = input.isContentEditable ? input.innerText : input.value;\n              // Clear the input if the current value does not match the filled\n              // out value.\n              if (newValue.length <= currentValue.length || !newValue.startsWith(input.value)) {\n                if (input.isContentEditable) {\n                  input.innerText = '';\n                } else {\n                  input.value = '';\n                }\n                return newValue;\n              }\n              const originalValue = input.isContentEditable ? input.innerText : input.value;\n              // If the value is partially filled out, only type the rest. Move\n              // cursor to the end of the common prefix.\n              if (input.isContentEditable) {\n                input.innerText = '';\n                input.innerText = originalValue;\n              } else {\n                input.value = '';\n                input.value = originalValue;\n              }\n              return newValue.substring(originalValue.length);\n            }, value)).pipe(mergeMap(textToType => {\n              return from(handle.type(textToType));\n            }));\n          case 'other-input':\n            return from(handle.focus()).pipe(mergeMap(() => {\n              return from(handle.evaluate((input, value) => {\n                input.value = value;\n                input.dispatchEvent(new Event('input', {\n                  bubbles: true\n                }));\n                input.dispatchEvent(new Event('change', {\n                  bubbles: true\n                }));\n              }, value));\n            }));\n          case 'unknown':\n            throw new Error(`Element cannot be filled out.`);\n        }\n      })).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #hover(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.hover()).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  #scroll(options) {\n    const signal = options?.signal;\n    return this._wait(options).pipe(this.operators.conditions([this.#ensureElementIsInTheViewportIfNeeded, this.#waitForStableBoundingBoxIfNeeded], signal), tap(() => {\n      return this.emit(LocatorEvent.Action, undefined);\n    }), mergeMap(handle => {\n      return from(handle.evaluate((el, scrollTop, scrollLeft) => {\n        if (scrollTop !== undefined) {\n          el.scrollTop = scrollTop;\n        }\n        if (scrollLeft !== undefined) {\n          el.scrollLeft = scrollLeft;\n        }\n      }, options?.scrollTop, options?.scrollLeft)).pipe(catchError(err => {\n        void handle.dispose().catch(debugError);\n        throw err;\n      }));\n    }), this.operators.retryAndRaceWithSignalAndTimer(signal));\n  }\n  /**\n   * Clones the locator.\n   */\n  clone() {\n    return this._clone();\n  }\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options) {\n    return await firstValueFrom(this._wait(options).pipe(this.operators.retryAndRaceWithSignalAndTimer(options?.signal)));\n  }\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      const handle = __addDisposableResource(env_1, await this.waitHandle(options), false);\n      return await handle.jsonValue();\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map(mapper) {\n    return new MappedLocator(this._clone(), handle => {\n      // SAFETY: TypeScript cannot deduce the type.\n      return handle.evaluateHandle(mapper);\n    });\n  }\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter(predicate) {\n    return new FilteredLocator(this._clone(), async (handle, signal) => {\n      await handle.frame.waitForFunction(predicate, {\n        signal,\n        timeout: this._timeout\n      }, handle);\n      return true;\n    });\n  }\n  /**\n   * Creates an expectation that is evaluated against located handles.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @internal\n   */\n  filterHandle(predicate) {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @internal\n   */\n  mapHandle(mapper) {\n    return new MappedLocator(this._clone(), mapper);\n  }\n  click(options) {\n    return firstValueFrom(this.#click(options));\n  }\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. contenteditable, selector, inputs are\n   * supported.\n   */\n  fill(value, options) {\n    return firstValueFrom(this.#fill(value, options));\n  }\n  hover(options) {\n    return firstValueFrom(this.#hover(options));\n  }\n  scroll(options) {\n    return firstValueFrom(this.#scroll(options));\n  }\n}\n/**\n * @internal\n */\nexport class FunctionLocator extends Locator {\n  static create(pageOrFrame, func) {\n    return new FunctionLocator(pageOrFrame, func).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());\n  }\n  #pageOrFrame;\n  #func;\n  constructor(pageOrFrame, func) {\n    super();\n    this.#pageOrFrame = pageOrFrame;\n    this.#func = func;\n  }\n  _clone() {\n    return new FunctionLocator(this.#pageOrFrame, this.#func);\n  }\n  _wait(options) {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(this.#pageOrFrame.waitForFunction(this.#func, {\n        timeout: this.timeout,\n        signal\n      }));\n    }).pipe(throwIfEmpty());\n  }\n}\n/**\n * @internal\n */\nexport class DelegatedLocator extends Locator {\n  #delegate;\n  constructor(delegate) {\n    super();\n    this.#delegate = delegate;\n    this.copyOptions(this.#delegate);\n  }\n  get delegate() {\n    return this.#delegate;\n  }\n  setTimeout(timeout) {\n    const locator = super.setTimeout(timeout);\n    locator.#delegate = this.#delegate.setTimeout(timeout);\n    return locator;\n  }\n  setVisibility(visibility) {\n    const locator = super.setVisibility(visibility);\n    locator.#delegate = locator.#delegate.setVisibility(visibility);\n    return locator;\n  }\n  setWaitForEnabled(value) {\n    const locator = super.setWaitForEnabled(value);\n    locator.#delegate = this.#delegate.setWaitForEnabled(value);\n    return locator;\n  }\n  setEnsureElementIsInTheViewport(value) {\n    const locator = super.setEnsureElementIsInTheViewport(value);\n    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);\n    return locator;\n  }\n  setWaitForStableBoundingBox(value) {\n    const locator = super.setWaitForStableBoundingBox(value);\n    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);\n    return locator;\n  }\n}\n/**\n * @internal\n */\nexport class FilteredLocator extends DelegatedLocator {\n  #predicate;\n  constructor(base, predicate) {\n    super(base);\n    this.#predicate = predicate;\n  }\n  _clone() {\n    return new FilteredLocator(this.delegate.clone(), this.#predicate).copyOptions(this);\n  }\n  _wait(options) {\n    return this.delegate._wait(options).pipe(mergeMap(handle => {\n      return from(Promise.resolve(this.#predicate(handle, options?.signal))).pipe(filter(value => {\n        return value;\n      }), map(() => {\n        // SAFETY: It passed the predicate, so this is correct.\n        return handle;\n      }));\n    }), throwIfEmpty());\n  }\n}\n/**\n * @internal\n */\nexport class MappedLocator extends DelegatedLocator {\n  #mapper;\n  constructor(base, mapper) {\n    super(base);\n    this.#mapper = mapper;\n  }\n  _clone() {\n    return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(this);\n  }\n  _wait(options) {\n    return this.delegate._wait(options).pipe(mergeMap(handle => {\n      return from(Promise.resolve(this.#mapper(handle, options?.signal)));\n    }));\n  }\n}\n/**\n * @internal\n */\nexport class NodeLocator extends Locator {\n  static create(pageOrFrame, selector) {\n    return new NodeLocator(pageOrFrame, selector).setTimeout('getDefaultTimeout' in pageOrFrame ? pageOrFrame.getDefaultTimeout() : pageOrFrame.page().getDefaultTimeout());\n  }\n  #pageOrFrame;\n  #selector;\n  constructor(pageOrFrame, selector) {\n    super();\n    this.#pageOrFrame = pageOrFrame;\n    this.#selector = selector;\n  }\n  /**\n   * Waits for the element to become visible or hidden. visibility === 'visible'\n   * means that the element has a computed style, the visibility property other\n   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===\n   * 'hidden' means the opposite of that.\n   */\n  #waitForVisibilityIfNeeded = handle => {\n    if (!this.visibility) {\n      return EMPTY;\n    }\n    return (() => {\n      switch (this.visibility) {\n        case 'hidden':\n          return defer(() => {\n            return from(handle.isHidden());\n          });\n        case 'visible':\n          return defer(() => {\n            return from(handle.isVisible());\n          });\n      }\n    })().pipe(first(identity), retry({\n      delay: RETRY_DELAY\n    }), ignoreElements());\n  };\n  _clone() {\n    return new NodeLocator(this.#pageOrFrame, this.#selector).copyOptions(this);\n  }\n  _wait(options) {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(this.#pageOrFrame.waitForSelector(this.#selector, {\n        visible: false,\n        timeout: this._timeout,\n        signal\n      }));\n    }).pipe(filter(value => {\n      return value !== null;\n    }), throwIfEmpty(), this.operators.conditions([this.#waitForVisibilityIfNeeded], signal));\n  }\n}\nfunction checkLocatorArray(locators) {\n  for (const locator of locators) {\n    if (!(locator instanceof Locator)) {\n      throw new Error('Unknown locator for race candidate');\n    }\n  }\n  return locators;\n}\n/**\n * @internal\n */\nexport class RaceLocator extends Locator {\n  static create(locators) {\n    const array = checkLocatorArray(locators);\n    return new RaceLocator(array);\n  }\n  #locators;\n  constructor(locators) {\n    super();\n    this.#locators = locators;\n  }\n  _clone() {\n    return new RaceLocator(this.#locators.map(locator => {\n      return locator.clone();\n    })).copyOptions(this);\n  }\n  _wait(options) {\n    return race(...this.#locators.map(locator => {\n      return locator._wait(options);\n    }));\n  }\n}\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;","map":{"version":3,"mappings":"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","names":["mergeMap","from","EMPTY","defer","filter","first","identity","ignoreElements","retry","throwIfEmpty","race","catchError","defaultIfEmpty","firstValueFrom","fromEvent","map","merge","noop","pipe","raceWith","tap","EventEmitter","debugError","timeout","LocatorEvent","LocatorEmittedEvents","Locator","locators","RaceLocator","create","visibility","_timeout","operators","conditions","signal","handle","condition","retryAndRaceWithSignalAndTimer","candidates","push","reason","delay","RETRY_DELAY","setTimeout","locator","_clone","setVisibility","setWaitForEnabled","value","setEnsureElementIsInTheViewport","setWaitForStableBoundingBox","copyOptions","frame","waitForFunction","element","HTMLElement","isNativeFormControl","includes","nodeName","hasAttribute","evaluate","Promise","resolve","window","requestAnimationFrame","rect1","getBoundingClientRect","rect2","x","y","width","height","isIntersectingViewport","threshold","scrollIntoView","options","_wait","emit","Action","undefined","click","err","dispose","catch","el","HTMLSelectElement","HTMLTextAreaElement","HTMLInputElement","Set","has","type","isContentEditable","inputType","select","then","input","newValue","currentValue","innerText","length","startsWith","originalValue","substring","textToType","focus","dispatchEvent","Event","bubbles","Error","hover","scrollTop","scrollLeft","clone","waitHandle","wait","jsonValue","mapper","MappedLocator","evaluateHandle","predicate","FilteredLocator","filterHandle","mapHandle","fill","scroll","FunctionLocator","pageOrFrame","func","getDefaultTimeout","page","constructor","DelegatedLocator","delegate","base","NodeLocator","selector","isHidden","isVisible","waitForSelector","visible","checkLocatorArray","array"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\api\\locators\\locators.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {EventType} from '../../../third_party/mitt/mitt.js';\nimport type {\n  Observable,\n  OperatorFunction,\n} from '../../../third_party/rxjs/rxjs.js';\nimport {\n  mergeMap,\n  from,\n  EMPTY,\n  defer,\n  filter,\n  first,\n  identity,\n  ignoreElements,\n  retry,\n  throwIfEmpty,\n  race,\n  catchError,\n  defaultIfEmpty,\n  firstValueFrom,\n  fromEvent,\n  map,\n  merge,\n  noop,\n  pipe,\n  raceWith,\n  tap,\n} from '../../../third_party/rxjs/rxjs.js';\nimport {EventEmitter} from '../../common/EventEmitter.js';\nimport type {Awaitable, HandleFor, NodeFor} from '../../common/types.js';\nimport {debugError, timeout} from '../../common/util.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from '../ElementHandle.js';\nimport type {Frame} from '../Frame.js';\nimport type {Page} from '../Page.js';\n\n/**\n * @public\n */\nexport type VisibilityOption = 'hidden' | 'visible' | null;\n/**\n * @public\n */\nexport interface LocatorOptions {\n  /**\n   * Whether to wait for the element to be `visible` or `hidden`. `null` to\n   * disable visibility checks.\n   */\n  visibility: VisibilityOption;\n  /**\n   * Total timeout for the entire locator operation.\n   *\n   * Pass `0` to disable timeout.\n   *\n   * @defaultValue `Page.getDefaultTimeout()`\n   */\n  timeout: number;\n  /**\n   * Whether to scroll the element into viewport if not in the viewprot already.\n   * @defaultValue `true`\n   */\n  ensureElementIsInTheViewport: boolean;\n  /**\n   * Whether to wait for input elements to become enabled before the action.\n   * Applicable to `click` and `fill` actions.\n   * @defaultValue `true`\n   */\n  waitForEnabled: boolean;\n  /**\n   * Whether to wait for the element's bounding box to be same between two\n   * animation frames.\n   * @defaultValue `true`\n   */\n  waitForStableBoundingBox: boolean;\n}\n/**\n * @public\n */\nexport interface ActionOptions {\n  signal?: AbortSignal;\n}\n/**\n * @public\n */\nexport type LocatorClickOptions = ClickOptions & ActionOptions;\n/**\n * @public\n */\nexport interface LocatorScrollOptions extends ActionOptions {\n  scrollTop?: number;\n  scrollLeft?: number;\n}\n/**\n * All the events that a locator instance may emit.\n *\n * @public\n */\nexport enum LocatorEvent {\n  /**\n   * Emitted every time before the locator performs an action on the located element(s).\n   */\n  Action = 'action',\n}\nexport {\n  /**\n   * @deprecated Use {@link LocatorEvent}.\n   */\n  LocatorEvent as LocatorEmittedEvents,\n};\n/**\n * @public\n */\nexport interface LocatorEvents extends Record<EventType, unknown> {\n  [LocatorEvent.Action]: undefined;\n}\nexport type {\n  /**\n   * @deprecated Use {@link LocatorEvents}.\n   */\n  LocatorEvents as LocatorEventObject,\n};\n/**\n * Locators describe a strategy of locating objects and performing an action on\n * them. If the action fails because the object is not ready for the action, the\n * whole operation is retried. Various preconditions for a successful action are\n * checked automatically.\n *\n * @public\n */\nexport abstract class Locator<T> extends EventEmitter<LocatorEvents> {\n  /**\n   * Creates a race between multiple locators but ensures that only a single one\n   * acts.\n   *\n   * @public\n   */\n  static race<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return RaceLocator.create(locators);\n  }\n\n  /**\n   * Used for nominally typing {@link Locator}.\n   */\n  declare _?: T;\n\n  /**\n   * @internal\n   */\n  protected visibility: VisibilityOption = null;\n  /**\n   * @internal\n   */\n  protected _timeout = 30000;\n  #ensureElementIsInTheViewport = true;\n  #waitForEnabled = true;\n  #waitForStableBoundingBox = true;\n\n  /**\n   * @internal\n   */\n  protected operators = {\n    conditions: (\n      conditions: Array<Action<T, never>>,\n      signal?: AbortSignal\n    ): OperatorFunction<HandleFor<T>, HandleFor<T>> => {\n      return mergeMap((handle: HandleFor<T>) => {\n        return merge(\n          ...conditions.map(condition => {\n            return condition(handle, signal);\n          })\n        ).pipe(defaultIfEmpty(handle));\n      });\n    },\n    retryAndRaceWithSignalAndTimer: <T>(\n      signal?: AbortSignal\n    ): OperatorFunction<T, T> => {\n      const candidates = [];\n      if (signal) {\n        candidates.push(\n          fromEvent(signal, 'abort').pipe(\n            map(() => {\n              throw signal.reason;\n            })\n          )\n        );\n      }\n      candidates.push(timeout(this._timeout));\n      return pipe(\n        retry({delay: RETRY_DELAY}),\n        raceWith<T, never[]>(...candidates)\n      );\n    },\n  };\n\n  // Determines when the locator will timeout for actions.\n  get timeout(): number {\n    return this._timeout;\n  }\n\n  setTimeout(timeout: number): Locator<T> {\n    const locator = this._clone();\n    locator._timeout = timeout;\n    return locator;\n  }\n\n  setVisibility<NodeType extends Node>(\n    this: Locator<NodeType>,\n    visibility: VisibilityOption\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.visibility = visibility;\n    return locator;\n  }\n\n  setWaitForEnabled<NodeType extends Node>(\n    this: Locator<NodeType>,\n    value: boolean\n  ): Locator<NodeType> {\n    const locator = this._clone();\n    locator.#waitForEnabled = value;\n    return locator;\n  }\n\n  setEnsureElementIsInTheViewport<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#ensureElementIsInTheViewport = value;\n    return locator;\n  }\n\n  setWaitForStableBoundingBox<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: boolean\n  ): Locator<ElementType> {\n    const locator = this._clone();\n    locator.#waitForStableBoundingBox = value;\n    return locator;\n  }\n\n  /**\n   * @internal\n   */\n  copyOptions<T>(locator: Locator<T>): this {\n    this._timeout = locator._timeout;\n    this.visibility = locator.visibility;\n    this.#waitForEnabled = locator.#waitForEnabled;\n    this.#ensureElementIsInTheViewport = locator.#ensureElementIsInTheViewport;\n    this.#waitForStableBoundingBox = locator.#waitForStableBoundingBox;\n    return this;\n  }\n\n  /**\n   * If the element has a \"disabled\" property, wait for the element to be\n   * enabled.\n   */\n  #waitForEnabledIfNeeded = <ElementType extends Node>(\n    handle: HandleFor<ElementType>,\n    signal?: AbortSignal\n  ): Observable<never> => {\n    if (!this.#waitForEnabled) {\n      return EMPTY;\n    }\n    return from(\n      handle.frame.waitForFunction(\n        element => {\n          if (!(element instanceof HTMLElement)) {\n            return true;\n          }\n          const isNativeFormControl = [\n            'BUTTON',\n            'INPUT',\n            'SELECT',\n            'TEXTAREA',\n            'OPTION',\n            'OPTGROUP',\n          ].includes(element.nodeName);\n          return !isNativeFormControl || !element.hasAttribute('disabled');\n        },\n        {\n          timeout: this._timeout,\n          signal,\n        },\n        handle\n      )\n    ).pipe(ignoreElements());\n  };\n\n  /**\n   * Compares the bounding box of the element for two consecutive animation\n   * frames and waits till they are the same.\n   */\n  #waitForStableBoundingBoxIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#waitForStableBoundingBox) {\n      return EMPTY;\n    }\n    return defer(() => {\n      // Note we don't use waitForFunction because that relies on RAF.\n      return from(\n        handle.evaluate(element => {\n          return new Promise<[BoundingBox, BoundingBox]>(resolve => {\n            window.requestAnimationFrame(() => {\n              const rect1 = element.getBoundingClientRect();\n              window.requestAnimationFrame(() => {\n                const rect2 = element.getBoundingClientRect();\n                resolve([\n                  {\n                    x: rect1.x,\n                    y: rect1.y,\n                    width: rect1.width,\n                    height: rect1.height,\n                  },\n                  {\n                    x: rect2.x,\n                    y: rect2.y,\n                    width: rect2.width,\n                    height: rect2.height,\n                  },\n                ]);\n              });\n            });\n          });\n        })\n      );\n    }).pipe(\n      first(([rect1, rect2]) => {\n        return (\n          rect1.x === rect2.x &&\n          rect1.y === rect2.y &&\n          rect1.width === rect2.width &&\n          rect1.height === rect2.height\n        );\n      }),\n      retry({delay: RETRY_DELAY}),\n      ignoreElements()\n    );\n  };\n\n  /**\n   * Checks if the element is in the viewport and auto-scrolls it if it is not.\n   */\n  #ensureElementIsInTheViewportIfNeeded = <ElementType extends Element>(\n    handle: HandleFor<ElementType>\n  ): Observable<never> => {\n    if (!this.#ensureElementIsInTheViewport) {\n      return EMPTY;\n    }\n    return from(handle.isIntersectingViewport({threshold: 0})).pipe(\n      filter(isIntersectingViewport => {\n        return !isIntersectingViewport;\n      }),\n      mergeMap(() => {\n        return from(handle.scrollIntoView());\n      }),\n      mergeMap(() => {\n        return defer(() => {\n          return from(handle.isIntersectingViewport({threshold: 0}));\n        }).pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n      })\n    );\n  };\n\n  #click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(handle.click(options)).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n          this.#waitForEnabledIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(\n          (handle as unknown as ElementHandle<HTMLElement>).evaluate(el => {\n            if (el instanceof HTMLSelectElement) {\n              return 'select';\n            }\n            if (el instanceof HTMLTextAreaElement) {\n              return 'typeable-input';\n            }\n            if (el instanceof HTMLInputElement) {\n              if (\n                new Set([\n                  'textarea',\n                  'text',\n                  'url',\n                  'tel',\n                  'search',\n                  'password',\n                  'number',\n                  'email',\n                ]).has(el.type)\n              ) {\n                return 'typeable-input';\n              } else {\n                return 'other-input';\n              }\n            }\n\n            if (el.isContentEditable) {\n              return 'contenteditable';\n            }\n\n            return 'unknown';\n          })\n        )\n          .pipe(\n            mergeMap(inputType => {\n              switch (inputType) {\n                case 'select':\n                  return from(handle.select(value).then(noop));\n                case 'contenteditable':\n                case 'typeable-input':\n                  return from(\n                    (\n                      handle as unknown as ElementHandle<HTMLInputElement>\n                    ).evaluate((input, newValue) => {\n                      const currentValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // Clear the input if the current value does not match the filled\n                      // out value.\n                      if (\n                        newValue.length <= currentValue.length ||\n                        !newValue.startsWith(input.value)\n                      ) {\n                        if (input.isContentEditable) {\n                          input.innerText = '';\n                        } else {\n                          input.value = '';\n                        }\n                        return newValue;\n                      }\n                      const originalValue = input.isContentEditable\n                        ? input.innerText\n                        : input.value;\n\n                      // If the value is partially filled out, only type the rest. Move\n                      // cursor to the end of the common prefix.\n                      if (input.isContentEditable) {\n                        input.innerText = '';\n                        input.innerText = originalValue;\n                      } else {\n                        input.value = '';\n                        input.value = originalValue;\n                      }\n                      return newValue.substring(originalValue.length);\n                    }, value)\n                  ).pipe(\n                    mergeMap(textToType => {\n                      return from(handle.type(textToType));\n                    })\n                  );\n                case 'other-input':\n                  return from(handle.focus()).pipe(\n                    mergeMap(() => {\n                      return from(\n                        handle.evaluate((input, value) => {\n                          (input as HTMLInputElement).value = value;\n                          input.dispatchEvent(\n                            new Event('input', {bubbles: true})\n                          );\n                          input.dispatchEvent(\n                            new Event('change', {bubbles: true})\n                          );\n                        }, value)\n                      );\n                    })\n                  );\n                case 'unknown':\n                  throw new Error(`Element cannot be filled out.`);\n              }\n            })\n          )\n          .pipe(\n            catchError(err => {\n              void handle.dispose().catch(debugError);\n              throw err;\n            })\n          );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(handle.hover()).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  #scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Observable<void> {\n    const signal = options?.signal;\n    return this._wait(options).pipe(\n      this.operators.conditions(\n        [\n          this.#ensureElementIsInTheViewportIfNeeded,\n          this.#waitForStableBoundingBoxIfNeeded,\n        ],\n        signal\n      ),\n      tap(() => {\n        return this.emit(LocatorEvent.Action, undefined);\n      }),\n      mergeMap(handle => {\n        return from(\n          handle.evaluate(\n            (el, scrollTop, scrollLeft) => {\n              if (scrollTop !== undefined) {\n                el.scrollTop = scrollTop;\n              }\n              if (scrollLeft !== undefined) {\n                el.scrollLeft = scrollLeft;\n              }\n            },\n            options?.scrollTop,\n            options?.scrollLeft\n          )\n        ).pipe(\n          catchError(err => {\n            void handle.dispose().catch(debugError);\n            throw err;\n          })\n        );\n      }),\n      this.operators.retryAndRaceWithSignalAndTimer(signal)\n    );\n  }\n\n  /**\n   * @internal\n   */\n  abstract _clone(): Locator<T>;\n\n  /**\n   * @internal\n   */\n  abstract _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>>;\n\n  /**\n   * Clones the locator.\n   */\n  clone(): Locator<T> {\n    return this._clone();\n  }\n\n  /**\n   * Waits for the locator to get a handle from the page.\n   *\n   * @public\n   */\n  async waitHandle(options?: Readonly<ActionOptions>): Promise<HandleFor<T>> {\n    return await firstValueFrom(\n      this._wait(options).pipe(\n        this.operators.retryAndRaceWithSignalAndTimer(options?.signal)\n      )\n    );\n  }\n\n  /**\n   * Waits for the locator to get the serialized value from the page.\n   *\n   * Note this requires the value to be JSON-serializable.\n   *\n   * @public\n   */\n  async wait(options?: Readonly<ActionOptions>): Promise<T> {\n    using handle = await this.waitHandle(options);\n    return await handle.jsonValue();\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @public\n   */\n  map<To>(mapper: Mapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), handle => {\n      // SAFETY: TypeScript cannot deduce the type.\n      return (handle as any).evaluateHandle(mapper);\n    });\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located values.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @public\n   */\n  filter<S extends T>(predicate: Predicate<T, S>): Locator<S> {\n    return new FilteredLocator(this._clone(), async (handle, signal) => {\n      await (handle as ElementHandle<Node>).frame.waitForFunction(\n        predicate,\n        {signal, timeout: this._timeout},\n        handle\n      );\n      return true;\n    });\n  }\n\n  /**\n   * Creates an expectation that is evaluated against located handles.\n   *\n   * If the expectations do not match, then the locator will retry.\n   *\n   * @internal\n   */\n  filterHandle<S extends T>(\n    predicate: Predicate<HandleFor<T>, HandleFor<S>>\n  ): Locator<S> {\n    return new FilteredLocator(this._clone(), predicate);\n  }\n\n  /**\n   * Maps the locator using the provided mapper.\n   *\n   * @internal\n   */\n  mapHandle<To>(mapper: HandleMapper<T, To>): Locator<To> {\n    return new MappedLocator(this._clone(), mapper);\n  }\n\n  click<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorClickOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#click(options));\n  }\n\n  /**\n   * Fills out the input identified by the locator using the provided value. The\n   * type of the input is determined at runtime and the appropriate fill-out\n   * method is chosen based on the type. contenteditable, selector, inputs are\n   * supported.\n   */\n  fill<ElementType extends Element>(\n    this: Locator<ElementType>,\n    value: string,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#fill(value, options));\n  }\n\n  hover<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<ActionOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#hover(options));\n  }\n\n  scroll<ElementType extends Element>(\n    this: Locator<ElementType>,\n    options?: Readonly<LocatorScrollOptions>\n  ): Promise<void> {\n    return firstValueFrom(this.#scroll(options));\n  }\n}\n\n/**\n * @internal\n */\nexport class FunctionLocator<T> extends Locator<T> {\n  static create<Ret>(\n    pageOrFrame: Page | Frame,\n    func: () => Awaitable<Ret>\n  ): Locator<Ret> {\n    return new FunctionLocator<Ret>(pageOrFrame, func).setTimeout(\n      'getDefaultTimeout' in pageOrFrame\n        ? pageOrFrame.getDefaultTimeout()\n        : pageOrFrame.page().getDefaultTimeout()\n    );\n  }\n\n  #pageOrFrame: Page | Frame;\n  #func: () => Awaitable<T>;\n\n  private constructor(pageOrFrame: Page | Frame, func: () => Awaitable<T>) {\n    super();\n\n    this.#pageOrFrame = pageOrFrame;\n    this.#func = func;\n  }\n\n  override _clone(): FunctionLocator<T> {\n    return new FunctionLocator(this.#pageOrFrame, this.#func);\n  }\n\n  _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(\n        this.#pageOrFrame.waitForFunction(this.#func, {\n          timeout: this.timeout,\n          signal,\n        })\n      );\n    }).pipe(throwIfEmpty());\n  }\n}\n\n/**\n * @public\n */\nexport type Predicate<From, To extends From = From> =\n  | ((value: From) => value is To)\n  | ((value: From) => Awaitable<boolean>);\n/**\n * @internal\n */\nexport type HandlePredicate<From, To extends From = From> =\n  | ((value: HandleFor<From>, signal?: AbortSignal) => value is HandleFor<To>)\n  | ((value: HandleFor<From>, signal?: AbortSignal) => Awaitable<boolean>);\n\n/**\n * @internal\n */\nexport abstract class DelegatedLocator<T, U> extends Locator<U> {\n  #delegate: Locator<T>;\n\n  constructor(delegate: Locator<T>) {\n    super();\n\n    this.#delegate = delegate;\n    this.copyOptions(this.#delegate);\n  }\n\n  protected get delegate(): Locator<T> {\n    return this.#delegate;\n  }\n\n  override setTimeout(timeout: number): DelegatedLocator<T, U> {\n    const locator = super.setTimeout(timeout) as DelegatedLocator<T, U>;\n    locator.#delegate = this.#delegate.setTimeout(timeout);\n    return locator;\n  }\n\n  override setVisibility<ValueType extends Node, NodeType extends Node>(\n    this: DelegatedLocator<ValueType, NodeType>,\n    visibility: VisibilityOption\n  ): DelegatedLocator<ValueType, NodeType> {\n    const locator = super.setVisibility<NodeType>(\n      visibility\n    ) as DelegatedLocator<ValueType, NodeType>;\n    locator.#delegate = locator.#delegate.setVisibility<ValueType>(visibility);\n    return locator;\n  }\n\n  override setWaitForEnabled<ValueType extends Node, NodeType extends Node>(\n    this: DelegatedLocator<ValueType, NodeType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, NodeType> {\n    const locator = super.setWaitForEnabled<NodeType>(\n      value\n    ) as DelegatedLocator<ValueType, NodeType>;\n    locator.#delegate = this.#delegate.setWaitForEnabled(value);\n    return locator;\n  }\n\n  override setEnsureElementIsInTheViewport<\n    ValueType extends Element,\n    ElementType extends Element,\n  >(\n    this: DelegatedLocator<ValueType, ElementType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, ElementType> {\n    const locator = super.setEnsureElementIsInTheViewport<ElementType>(\n      value\n    ) as DelegatedLocator<ValueType, ElementType>;\n    locator.#delegate = this.#delegate.setEnsureElementIsInTheViewport(value);\n    return locator;\n  }\n\n  override setWaitForStableBoundingBox<\n    ValueType extends Element,\n    ElementType extends Element,\n  >(\n    this: DelegatedLocator<ValueType, ElementType>,\n    value: boolean\n  ): DelegatedLocator<ValueType, ElementType> {\n    const locator = super.setWaitForStableBoundingBox<ElementType>(\n      value\n    ) as DelegatedLocator<ValueType, ElementType>;\n    locator.#delegate = this.#delegate.setWaitForStableBoundingBox(value);\n    return locator;\n  }\n\n  abstract override _clone(): DelegatedLocator<T, U>;\n  abstract override _wait(): Observable<HandleFor<U>>;\n}\n\n/**\n * @internal\n */\nexport class FilteredLocator<From, To extends From> extends DelegatedLocator<\n  From,\n  To\n> {\n  #predicate: HandlePredicate<From, To>;\n\n  constructor(base: Locator<From>, predicate: HandlePredicate<From, To>) {\n    super(base);\n    this.#predicate = predicate;\n  }\n\n  override _clone(): FilteredLocator<From, To> {\n    return new FilteredLocator(\n      this.delegate.clone(),\n      this.#predicate\n    ).copyOptions(this);\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<To>> {\n    return this.delegate._wait(options).pipe(\n      mergeMap(handle => {\n        return from(\n          Promise.resolve(this.#predicate(handle, options?.signal))\n        ).pipe(\n          filter(value => {\n            return value;\n          }),\n          map(() => {\n            // SAFETY: It passed the predicate, so this is correct.\n            return handle as HandleFor<To>;\n          })\n        );\n      }),\n      throwIfEmpty()\n    );\n  }\n}\n\n/**\n * @public\n */\nexport type Mapper<From, To> = (value: From) => Awaitable<To>;\n/**\n * @internal\n */\nexport type HandleMapper<From, To> = (\n  value: HandleFor<From>,\n  signal?: AbortSignal\n) => Awaitable<HandleFor<To>>;\n/**\n * @internal\n */\nexport class MappedLocator<From, To> extends DelegatedLocator<From, To> {\n  #mapper: HandleMapper<From, To>;\n\n  constructor(base: Locator<From>, mapper: HandleMapper<From, To>) {\n    super(base);\n    this.#mapper = mapper;\n  }\n\n  override _clone(): MappedLocator<From, To> {\n    return new MappedLocator(this.delegate.clone(), this.#mapper).copyOptions(\n      this\n    );\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<To>> {\n    return this.delegate._wait(options).pipe(\n      mergeMap(handle => {\n        return from(Promise.resolve(this.#mapper(handle, options?.signal)));\n      })\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport type Action<T, U> = (\n  element: HandleFor<T>,\n  signal?: AbortSignal\n) => Observable<U>;\n/**\n * @internal\n */\nexport class NodeLocator<T extends Node> extends Locator<T> {\n  static create<Selector extends string>(\n    pageOrFrame: Page | Frame,\n    selector: Selector\n  ): Locator<NodeFor<Selector>> {\n    return new NodeLocator<NodeFor<Selector>>(pageOrFrame, selector).setTimeout(\n      'getDefaultTimeout' in pageOrFrame\n        ? pageOrFrame.getDefaultTimeout()\n        : pageOrFrame.page().getDefaultTimeout()\n    );\n  }\n\n  #pageOrFrame: Page | Frame;\n  #selector: string;\n\n  private constructor(pageOrFrame: Page | Frame, selector: string) {\n    super();\n\n    this.#pageOrFrame = pageOrFrame;\n    this.#selector = selector;\n  }\n\n  /**\n   * Waits for the element to become visible or hidden. visibility === 'visible'\n   * means that the element has a computed style, the visibility property other\n   * than 'hidden' or 'collapse' and non-empty bounding box. visibility ===\n   * 'hidden' means the opposite of that.\n   */\n  #waitForVisibilityIfNeeded = (handle: HandleFor<T>): Observable<never> => {\n    if (!this.visibility) {\n      return EMPTY;\n    }\n\n    return (() => {\n      switch (this.visibility) {\n        case 'hidden':\n          return defer(() => {\n            return from(handle.isHidden());\n          });\n        case 'visible':\n          return defer(() => {\n            return from(handle.isVisible());\n          });\n      }\n    })().pipe(first(identity), retry({delay: RETRY_DELAY}), ignoreElements());\n  };\n\n  override _clone(): NodeLocator<T> {\n    return new NodeLocator<T>(this.#pageOrFrame, this.#selector).copyOptions(\n      this\n    );\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    const signal = options?.signal;\n    return defer(() => {\n      return from(\n        this.#pageOrFrame.waitForSelector(this.#selector, {\n          visible: false,\n          timeout: this._timeout,\n          signal,\n        }) as Promise<HandleFor<T> | null>\n      );\n    }).pipe(\n      filter((value): value is NonNullable<typeof value> => {\n        return value !== null;\n      }),\n      throwIfEmpty(),\n      this.operators.conditions([this.#waitForVisibilityIfNeeded], signal)\n    );\n  }\n}\n\n/**\n * @public\n */\nexport type AwaitedLocator<T> = T extends Locator<infer S> ? S : never;\nfunction checkLocatorArray<T extends readonly unknown[] | []>(\n  locators: T\n): ReadonlyArray<Locator<AwaitedLocator<T[number]>>> {\n  for (const locator of locators) {\n    if (!(locator instanceof Locator)) {\n      throw new Error('Unknown locator for race candidate');\n    }\n  }\n  return locators as ReadonlyArray<Locator<AwaitedLocator<T[number]>>>;\n}\n/**\n * @internal\n */\nexport class RaceLocator<T> extends Locator<T> {\n  static create<T extends readonly unknown[]>(\n    locators: T\n  ): Locator<AwaitedLocator<T[number]>> {\n    const array = checkLocatorArray(locators);\n    return new RaceLocator(array);\n  }\n\n  #locators: ReadonlyArray<Locator<T>>;\n\n  constructor(locators: ReadonlyArray<Locator<T>>) {\n    super();\n    this.#locators = locators;\n  }\n\n  override _clone(): RaceLocator<T> {\n    return new RaceLocator<T>(\n      this.#locators.map(locator => {\n        return locator.clone();\n      })\n    ).copyOptions(this);\n  }\n\n  override _wait(options?: Readonly<ActionOptions>): Observable<HandleFor<T>> {\n    return race(\n      ...this.#locators.map(locator => {\n        return locator._wait(options);\n      })\n    );\n  }\n}\n\n/**\n * For observables coming from promises, a delay is needed, otherwise RxJS will\n * never yield in a permanent failure for a promise.\n *\n * We also don't want RxJS to do promise operations to often, so we bump the\n * delay up to 100ms.\n *\n * @internal\n */\nexport const RETRY_DELAY = 100;\n"]},"metadata":{},"sourceType":"module"}