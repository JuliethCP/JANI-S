{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { delay, filter, filterAsync, first, firstValueFrom, from, fromEvent, map, merge, of, raceWith, startWith, switchMap } from '../../third_party/rxjs/rxjs.js';\nimport { TargetCloseError } from '../common/Errors.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { NetworkManagerEvent } from '../common/NetworkManagerEvents.js';\nimport { paperFormats } from '../common/PDFOptions.js';\nimport { TimeoutSettings } from '../common/TimeoutSettings.js';\nimport { debugError, importFSPromises, isNumber, isString, timeout, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { guarded } from '../util/decorators.js';\nimport { AsyncDisposableStack, asyncDisposeSymbol, DisposableStack, disposeSymbol } from '../util/disposable.js';\nimport { FunctionLocator, Locator, NodeLocator } from './locators/locators.js';\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options) {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n  options.allowViewportExpansion ??= options.captureBeyondViewport;\n}\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nlet Page = (() => {\n  let _classSuper = EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _screenshot_decorators;\n  return class Page extends _classSuper {\n    static #_ = (() => {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    })();\n    /**\n     * @internal\n     */\n    _isDragging = (__runInitializers(this, _instanceExtraInitializers), false);\n    /**\n     * @internal\n     */\n    _timeoutSettings = new TimeoutSettings();\n    #requestHandlers = new WeakMap();\n    /**\n     * @internal\n     */\n    constructor() {\n      super();\n    }\n    /**\n     * `true` if the service worker are being bypassed, `false` otherwise.\n     */\n    isServiceWorkerBypassed() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * `true` if drag events are being intercepted, `false` otherwise.\n     *\n     * @deprecated We no longer support intercepting drag payloads. Use the new\n     * drag APIs found on {@link ElementHandle} to drag (or just use the\n     * {@link Page.mouse}).\n     */\n    isDragInterceptionEnabled() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * `true` if the page has JavaScript enabled, `false` otherwise.\n     */\n    isJavaScriptEnabled() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Listen to page events.\n     *\n     * @remarks\n     * This method exists to define event typings and handle proper wireup of\n     * cooperative request interception. Actual event listening and dispatching is\n     * delegated to {@link EventEmitter}.\n     *\n     * @internal\n     */\n    on(type, handler) {\n      if (type !== \"request\" /* PageEvent.Request */) {\n        return super.on(type, handler);\n      }\n      let wrapper = this.#requestHandlers.get(handler);\n      if (wrapper === undefined) {\n        wrapper = event => {\n          event.enqueueInterceptAction(() => {\n            return handler(event);\n          });\n        };\n        this.#requestHandlers.set(handler, wrapper);\n      }\n      return super.on(type, wrapper);\n    }\n    /**\n     * @internal\n     */\n    off(type, handler) {\n      if (type === \"request\" /* PageEvent.Request */) {\n        handler = this.#requestHandlers.get(handler) || handler;\n      }\n      return super.off(type, handler);\n    }\n    waitForFileChooser() {\n      throw new Error('Not implemented');\n    }\n    async setGeolocation() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * A target this page was created from.\n     */\n    target() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Creates a Chrome Devtools Protocol session attached to the page.\n     */\n    createCDPSession() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * {@inheritDoc Touchscreen}\n     */\n    get touchscreen() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * All of the dedicated {@link\n     * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n     * WebWorkers} associated with the page.\n     *\n     * @remarks\n     * This does not contain ServiceWorkers\n     */\n    workers() {\n      throw new Error('Not implemented');\n    }\n    async setRequestInterception() {\n      throw new Error('Not implemented');\n    }\n    async setBypassServiceWorker() {\n      throw new Error('Not implemented');\n    }\n    async setDragInterception() {\n      throw new Error('Not implemented');\n    }\n    setOfflineMode() {\n      throw new Error('Not implemented');\n    }\n    emulateNetworkConditions() {\n      throw new Error('Not implemented');\n    }\n    locator(selectorOrFunc) {\n      if (typeof selectorOrFunc === 'string') {\n        return NodeLocator.create(this, selectorOrFunc);\n      } else {\n        return FunctionLocator.create(this, selectorOrFunc);\n      }\n    }\n    /**\n     * A shortcut for {@link Locator.race} that does not require static imports.\n     *\n     * @internal\n     */\n    locatorRace(locators) {\n      return Locator.race(locators);\n    }\n    /**\n     * Runs `document.querySelector` within the page. If no element matches the\n     * selector, the return value resolves to `null`.\n     *\n     * @param selector - A `selector` to query page for\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query page for.\n     */\n    async $(selector) {\n      return await this.mainFrame().$(selector);\n    }\n    /**\n     * The method runs `document.querySelectorAll` within the page. If no elements\n     * match the selector, the return value resolves to `[]`.\n     * @remarks\n     * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n     * @param selector - A `selector` to query page for\n     */\n    async $$(selector) {\n      return await this.mainFrame().$$(selector);\n    }\n    /**\n     * @remarks\n     *\n     * The only difference between {@link Page.evaluate | page.evaluate} and\n     * `page.evaluateHandle` is that `evaluateHandle` will return the value\n     * wrapped in an in-page object.\n     *\n     * If the function passed to `page.evaluateHandle` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle('document');\n     * ```\n     *\n     * @example\n     * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluateHandle(() => document.body);\n     * const resultHandle = await page.evaluateHandle(\n     *   body => body.innerHTML,\n     *   aHandle\n     * );\n     * console.log(await resultHandle.jsonValue());\n     * await resultHandle.dispose();\n     * ```\n     *\n     * Most of the time this function returns a {@link JSHandle},\n     * but if `pageFunction` returns a reference to an element,\n     * you instead get an {@link ElementHandle} back:\n     *\n     * @example\n     *\n     * ```ts\n     * const button = await page.evaluateHandle(() =>\n     *   document.querySelector('button')\n     * );\n     * // can call `click` because `button` is an `ElementHandle`\n     * await button.click();\n     * ```\n     *\n     * The TypeScript definitions assume that `evaluateHandle` returns\n     * a `JSHandle`, but if you know it's going to return an\n     * `ElementHandle`, pass it as the generic argument:\n     *\n     * ```ts\n     * const button = await page.evaluateHandle<ElementHandle>(...);\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     */\n    async evaluateHandle(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * This method runs `document.querySelector` within the page and passes the\n     * result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     *\n     * If no element is found matching `selector`, the method will throw an error.\n     *\n     * If `pageFunction` returns a promise `$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const searchValue = await page.$eval('#search', el => el.value);\n     * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n     * const html = await page.$eval('.main-container', el => el.outerHTML);\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * const searchValue = await page.$eval(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const searchValue = await page.$eval<string>(\n     *   '#search',\n     *   (el: HTMLInputElement) => el.value\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of `document.querySelector(selector)` as its\n     * first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $eval(selector, pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n      for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n        args[_key2 - 2] = arguments[_key2];\n      }\n      return await this.mainFrame().$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * This method runs `Array.from(document.querySelectorAll(selector))` within\n     * the page and passes the result as the first argument to the `pageFunction`.\n     *\n     * @remarks\n     * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n     * resolve and then return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * // get the amount of divs on the page\n     * const divCount = await page.$$eval('div', divs => divs.length);\n     *\n     * // get the text content of all the `.options` elements:\n     * const options = await page.$$eval('div > span.options', options => {\n     *   return options.map(option => option.textContent);\n     * });\n     * ```\n     *\n     * If you are using TypeScript, you may have to provide an explicit type to the\n     * first argument of the `pageFunction`.\n     * By default it is typed as `Element[]`, but you may need to provide a more\n     * specific sub-type:\n     *\n     * @example\n     *\n     * ```ts\n     * // if you don't provide HTMLInputElement here, TS will error\n     * // as `value` is not on `Element`\n     * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n     *   return elements.map(e => e.value);\n     * });\n     * ```\n     *\n     * The compiler should be able to infer the return type\n     * from the `pageFunction` you provide. If it is unable to, you can use the generic\n     * type to tell the compiler what return type you expect from `$$eval`:\n     *\n     * @example\n     *\n     * ```ts\n     * // The compiler can infer the return type in this case, but if it can't\n     * // or if you want to be more explicit, provide it as the generic type.\n     * const allInputValues = await page.$$eval<string[]>(\n     *   'input',\n     *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n     * );\n     * ```\n     *\n     * @param selector - the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to query for\n     * @param pageFunction - the function to be evaluated in the page context.\n     * Will be passed the result of\n     * `Array.from(document.querySelectorAll(selector))` as its first argument.\n     * @param args - any additional arguments to pass through to `pageFunction`.\n     *\n     * @returns The result of calling `pageFunction`. If it returns an element it\n     * is wrapped in an {@link ElementHandle}, else the raw value itself is\n     * returned.\n     */\n    async $$eval(selector, pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n      return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * The method evaluates the XPath expression relative to the page document as\n     * its context node. If there are no such elements, the method resolves to an\n     * empty array.\n     *\n     * @remarks\n     * Shortcut for {@link Frame.$x | Page.mainFrame().$x(expression) }.\n     *\n     * @param expression - Expression to evaluate\n     */\n    async $x(expression) {\n      return await this.mainFrame().$x(expression);\n    }\n    async cookies() {\n      throw new Error('Not implemented');\n    }\n    async deleteCookie() {\n      throw new Error('Not implemented');\n    }\n    async setCookie() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired URL or content.\n     *\n     * @remarks\n     * Shortcut for\n     * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n     *\n     * @param options - Options for the script.\n     * @returns An {@link ElementHandle | element handle} to the injected\n     * `<script>` element.\n     */\n    async addScriptTag(options) {\n      return await this.mainFrame().addScriptTag(options);\n    }\n    async addStyleTag(options) {\n      return await this.mainFrame().addStyleTag(options);\n    }\n    async removeExposedFunction() {\n      throw new Error('Not implemented');\n    }\n    async authenticate() {\n      throw new Error('Not implemented');\n    }\n    async setExtraHTTPHeaders() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Object containing metrics as key/value pairs.\n     *\n     * @returns\n     *\n     * - `Timestamp` : The timestamp when the metrics sample was taken.\n     *\n     * - `Documents` : Number of documents in the page.\n     *\n     * - `Frames` : Number of frames in the page.\n     *\n     * - `JSEventListeners` : Number of events in the page.\n     *\n     * - `Nodes` : Number of DOM nodes in the page.\n     *\n     * - `LayoutCount` : Total number of full or partial page layout.\n     *\n     * - `RecalcStyleCount` : Total number of page style recalculations.\n     *\n     * - `LayoutDuration` : Combined durations of all page layouts.\n     *\n     * - `RecalcStyleDuration` : Combined duration of all page style\n     *   recalculations.\n     *\n     * - `ScriptDuration` : Combined duration of JavaScript execution.\n     *\n     * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n     *\n     * - `JSHeapUsedSize` : Used JavaScript heap size.\n     *\n     * - `JSHeapTotalSize` : Total JavaScript heap size.\n     *\n     * @remarks\n     * All timestamps are in monotonic time: monotonically increasing time\n     * in seconds since an arbitrary point in the past.\n     */\n    async metrics() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * The page's URL.\n     * @remarks Shortcut for\n     * {@link Frame.url | page.mainFrame().url()}.\n     */\n    url() {\n      return this.mainFrame().url();\n    }\n    /**\n     * The full HTML contents of the page, including the DOCTYPE.\n     */\n    async content() {\n      return await this.mainFrame().content();\n    }\n    /**\n     * Set the content of the page.\n     *\n     * @param html - HTML markup to assign to the page.\n     * @param options - Parameters that has some properties.\n     * @remarks\n     * The parameter `options` might have the following options.\n     *\n     * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n     *   to 30 seconds, pass `0` to disable timeout. The default value can be\n     *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n     *   {@link Page.setDefaultTimeout} methods.\n     *\n     * - `waitUntil`: When to consider setting markup succeeded, defaults to\n     *   `load`. Given an array of event strings, setting content is considered\n     *   to be successful after all events have been fired. Events can be\n     *   either:<br/>\n     * - `load` : consider setting content to be finished when the `load` event\n     *   is fired.<br/>\n     * - `domcontentloaded` : consider setting content to be finished when the\n     *   `DOMContentLoaded` event is fired.<br/>\n     * - `networkidle0` : consider setting content to be finished when there are\n     *   no more than 0 network connections for at least `500` ms.<br/>\n     * - `networkidle2` : consider setting content to be finished when there are\n     *   no more than 2 network connections for at least `500` ms.\n     */\n    async setContent(html, options) {\n      await this.mainFrame().setContent(html, options);\n    }\n    /**\n     * Navigates the page to the given `url`.\n     *\n     * @remarks\n     * Navigation to `about:blank` or navigation to the same URL with a different\n     * hash will succeed and return `null`.\n     *\n     * :::warning\n     *\n     * Headless mode doesn't support navigation to a PDF document. See the {@link\n     * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n     * issue}.\n     *\n     * :::\n     *\n     * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n     *\n     * @param url - URL to navigate page to. The URL should include scheme, e.g.\n     * `https://`\n     * @param options - Options to configure waiting behavior.\n     * @returns A promise which resolves to the main resource response. In case of\n     * multiple redirects, the navigation will resolve with the response of the\n     * last redirect.\n     * @throws If:\n     *\n     * - there's an SSL error (e.g. in case of self-signed certificates).\n     * - target URL is invalid.\n     * - the timeout is exceeded during navigation.\n     * - the remote server does not respond or is unreachable.\n     * - the main resource failed to load.\n     *\n     * This method will not throw an error when any valid HTTP status code is\n     * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n     * Server Error\". The status code for such responses can be retrieved by\n     * calling {@link HTTPResponse.status}.\n     */\n    async goto(url, options) {\n      return await this.mainFrame().goto(url, options);\n    }\n    /**\n     * Waits for the page to navigate to a new URL or to reload. It is useful when\n     * you run code that will indirectly cause the page to navigate.\n     *\n     * @example\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(), // The promise resolves after navigation has finished\n     *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n     * ]);\n     * ```\n     *\n     * @remarks\n     * Usage of the\n     * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n     * to change the URL is considered a navigation.\n     *\n     * @param options - Navigation parameters which might have the following\n     * properties:\n     * @returns A `Promise` which resolves to the main resource response.\n     *\n     * - In case of multiple redirects, the navigation will resolve with the\n     *   response of the last redirect.\n     * - In case of navigation to a different anchor or navigation due to History\n     *   API usage, the navigation will resolve with `null`.\n     */\n    async waitForNavigation() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return await this.mainFrame().waitForNavigation(options);\n    }\n    /**\n     * @internal\n     */\n    _waitForNetworkIdle(networkManager, idleTime) {\n      let requestsInFlight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      return merge(fromEvent(networkManager, NetworkManagerEvent.Request), fromEvent(networkManager, NetworkManagerEvent.Response), fromEvent(networkManager, NetworkManagerEvent.RequestFailed)).pipe(startWith(undefined), filter(() => {\n        return networkManager.inFlightRequestsCount() <= requestsInFlight;\n      }), switchMap(v => {\n        return of(v).pipe(delay(idleTime));\n      }));\n    }\n    /**\n     * Waits for a frame matching the given conditions to appear.\n     *\n     * @example\n     *\n     * ```ts\n     * const frame = await page.waitForFrame(async frame => {\n     *   return frame.name() === 'Test';\n     * });\n     * ```\n     */\n    async waitForFrame(urlOrPredicate) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        timeout: ms = this.getDefaultTimeout()\n      } = options;\n      if (isString(urlOrPredicate)) {\n        urlOrPredicate = frame => {\n          return urlOrPredicate === frame.url();\n        };\n      }\n      return await firstValueFrom(merge(fromEvent(this, \"frameattached\" /* PageEvent.FrameAttached */), fromEvent(this, \"framenavigated\" /* PageEvent.FrameNavigated */), from(this.frames())).pipe(filterAsync(urlOrPredicate), first(), raceWith(timeout(ms), fromEvent(this, \"close\" /* PageEvent.Close */).pipe(map(() => {\n        throw new TargetCloseError('Page closed.');\n      })))));\n    }\n    async goBack() {\n      throw new Error('Not implemented');\n    }\n    async goForward() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Emulates a given device's metrics and user agent.\n     *\n     * To aid emulation, Puppeteer provides a list of known devices that can be\n     * via {@link KnownDevices}.\n     *\n     * @remarks\n     * This method is a shortcut for calling two methods:\n     * {@link Page.setUserAgent} and {@link Page.setViewport}.\n     *\n     * @remarks\n     * This method will resize the page. A lot of websites don't expect phones to\n     * change size, so you should emulate before navigating to the page.\n     *\n     * @example\n     *\n     * ```ts\n     * import {KnownDevices} from 'puppeteer';\n     * const iPhone = KnownDevices['iPhone 6'];\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   await page.emulate(iPhone);\n     *   await page.goto('https://www.google.com');\n     *   // other actions...\n     *   await browser.close();\n     * })();\n     * ```\n     */\n    async emulate(device) {\n      await Promise.all([this.setUserAgent(device.userAgent), this.setViewport(device.viewport)]);\n    }\n    async setJavaScriptEnabled() {\n      throw new Error('Not implemented');\n    }\n    async emulateMediaType() {\n      throw new Error('Not implemented');\n    }\n    async emulateCPUThrottling() {\n      throw new Error('Not implemented');\n    }\n    async emulateMediaFeatures() {\n      throw new Error('Not implemented');\n    }\n    async emulateTimezone() {\n      throw new Error('Not implemented');\n    }\n    async emulateIdleState() {\n      throw new Error('Not implemented');\n    }\n    async emulateVisionDeficiency() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Evaluates a function in the page's context and returns the result.\n     *\n     * If the function passed to `page.evaluate` returns a Promise, the\n     * function will wait for the promise to resolve and return its value.\n     *\n     * @example\n     *\n     * ```ts\n     * const result = await frame.evaluate(() => {\n     *   return Promise.resolve(8 * 7);\n     * });\n     * console.log(result); // prints \"56\"\n     * ```\n     *\n     * You can pass a string instead of a function (although functions are\n     * recommended as they are easier to debug and use with TypeScript):\n     *\n     * @example\n     *\n     * ```ts\n     * const aHandle = await page.evaluate('1 + 2');\n     * ```\n     *\n     * To get the best TypeScript experience, you should pass in as the\n     * generic the type of `pageFunction`:\n     *\n     * ```ts\n     * const aHandle = await page.evaluate(() => 2);\n     * ```\n     *\n     * @example\n     *\n     * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n     * as arguments to the `pageFunction`:\n     *\n     * ```ts\n     * const bodyHandle = await page.$('body');\n     * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n     * await bodyHandle.dispose();\n     * ```\n     *\n     * @param pageFunction - a function that is run within the page\n     * @param args - arguments to be passed to the pageFunction\n     *\n     * @returns the return value of `pageFunction`.\n     */\n    async evaluate(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n        args[_key4 - 1] = arguments[_key4];\n      }\n      return await this.mainFrame().evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async _maybeWriteBufferToFile(path, buffer) {\n      if (!path) {\n        return;\n      }\n      const fs = await importFSPromises();\n      await fs.writeFile(path, buffer);\n    }\n    /**\n     * Captures a screencast of this {@link Page | page}.\n     *\n     * @remarks\n     *\n     * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n     * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n     *\n     * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n     *\n     * @example\n     * Recording a {@link Page | page}:\n     *\n     * ```\n     * import puppeteer from 'puppeteer';\n     *\n     * // Launch a browser\n     * const browser = await puppeteer.launch();\n     *\n     * // Create a new page\n     * const page = await browser.newPage();\n     *\n     * // Go to your site.\n     * await page.goto(\"https://www.example.com\");\n     *\n     * // Start recording.\n     * const recorder = await page.screencast({path: 'recording.webm'});\n     *\n     * // Do something.\n     *\n     * // Stop recording.\n     * await recorder.stop();\n     *\n     * browser.close();\n     * ```\n     *\n     * @param options - Configures screencast behavior.\n     *\n     * @experimental\n     */\n    async screencast() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const [{\n        ScreenRecorder\n      }, [width, height, devicePixelRatio]] = await Promise.all([import('../node/ScreenRecorder.js'), this.#getNativePixelDimensions()]);\n      let crop;\n      if (options.crop) {\n        const {\n          x,\n          y,\n          width: cropWidth,\n          height: cropHeight\n        } = roundRectangle(normalizeRectangle(options.crop));\n        if (x < 0 || y < 0) {\n          throw new Error(`\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`);\n        }\n        if (cropWidth <= 0 || cropHeight <= 0) {\n          throw new Error(`\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`);\n        }\n        const viewportWidth = width / devicePixelRatio;\n        const viewportHeight = width / devicePixelRatio;\n        if (x + cropWidth > viewportWidth) {\n          throw new Error(`\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`);\n        }\n        if (y + cropHeight > viewportHeight) {\n          throw new Error(`\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`);\n        }\n        crop = {\n          x: x * devicePixelRatio,\n          y: y * devicePixelRatio,\n          width: cropWidth * devicePixelRatio,\n          height: cropHeight * devicePixelRatio\n        };\n      }\n      if (options.speed !== undefined && options.speed <= 0) {\n        throw new Error(`\\`speed\\` must be greater than 0.`);\n      }\n      if (options.scale !== undefined && options.scale <= 0) {\n        throw new Error(`\\`scale\\` must be greater than 0.`);\n      }\n      const recorder = new ScreenRecorder(this, width, height, {\n        ...options,\n        path: options.ffmpegPath,\n        crop\n      });\n      try {\n        await this._startScreencast();\n      } catch (error) {\n        void recorder.stop();\n        throw error;\n      }\n      if (options.path) {\n        const {\n          createWriteStream\n        } = await import('fs');\n        const stream = createWriteStream(options.path, 'binary');\n        recorder.pipe(stream);\n      }\n      return recorder;\n    }\n    #screencastSessionCount = 0;\n    #startScreencastPromise;\n    /**\n     * @internal\n     */\n    async _startScreencast() {\n      ++this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        this.#startScreencastPromise = this.mainFrame().client.send('Page.startScreencast', {\n          format: 'png'\n        }).then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n      }\n      await this.#startScreencastPromise;\n    }\n    /**\n     * @internal\n     */\n    async _stopScreencast() {\n      --this.#screencastSessionCount;\n      if (!this.#startScreencastPromise) {\n        return;\n      }\n      this.#startScreencastPromise = undefined;\n      if (this.#screencastSessionCount === 0) {\n        await this.mainFrame().client.send('Page.stopScreencast');\n      }\n    }\n    /**\n     * Gets the native, non-emulated dimensions of the viewport.\n     */\n    async #getNativePixelDimensions() {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const viewport = this.viewport();\n        const stack = __addDisposableResource(env_1, new DisposableStack(), false);\n        if (viewport && viewport.deviceScaleFactor !== 0) {\n          await this.setViewport({\n            ...viewport,\n            deviceScaleFactor: 0\n          });\n          stack.defer(() => {\n            void this.setViewport(viewport).catch(debugError);\n          });\n        }\n        return await this.mainFrame().isolatedRealm().evaluate(() => {\n          return [window.visualViewport.width * window.devicePixelRatio, window.visualViewport.height * window.devicePixelRatio, window.devicePixelRatio];\n        });\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    async screenshot() {\n      let userOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.bringToFront();\n        // TODO: use structuredClone after Node 16 support is dropped.Â«\n        const options = {\n          ...userOptions,\n          clip: userOptions.clip ? {\n            ...userOptions.clip\n          } : undefined\n        };\n        if (options.type === undefined && options.path !== undefined) {\n          const filePath = options.path;\n          // Note we cannot use Node.js here due to browser compatability.\n          const extension = filePath.slice(filePath.lastIndexOf('.') + 1).toLowerCase();\n          switch (extension) {\n            case 'png':\n              options.type = 'png';\n              break;\n            case 'jpeg':\n            case 'jpg':\n              options.type = 'jpeg';\n              break;\n            case 'webp':\n              options.type = 'webp';\n              break;\n          }\n        }\n        if (options.quality !== undefined) {\n          if (options.quality < 0 && options.quality > 100) {\n            throw new Error(`Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`);\n          }\n          if (options.type === undefined || !['jpeg', 'webp'].includes(options.type)) {\n            throw new Error(`${options.type ?? 'png'} screenshots do not support 'quality'.`);\n          }\n        }\n        assert(!options.clip || !options.fullPage, \"'clip' and 'fullPage' are exclusive\");\n        if (options.clip) {\n          if (options.clip.width <= 0) {\n            throw new Error(\"'width' in 'clip' must be positive.\");\n          }\n          if (options.clip.height <= 0) {\n            throw new Error(\"'height' in 'clip' must be positive.\");\n          }\n        }\n        setDefaultScreenshotOptions(options);\n        options.clip = options.clip && roundRectangle(normalizeRectangle(options.clip));\n        const stack = __addDisposableResource(env_2, new AsyncDisposableStack(), true);\n        if (options.allowViewportExpansion || options.captureBeyondViewport) {\n          if (options.fullPage) {\n            const dimensions = await this.mainFrame().isolatedRealm().evaluate(() => {\n              const {\n                scrollHeight,\n                scrollWidth\n              } = document.documentElement;\n              const {\n                height: viewportHeight,\n                width: viewportWidth\n              } = window.visualViewport;\n              return {\n                height: Math.max(scrollHeight, viewportHeight),\n                width: Math.max(scrollWidth, viewportWidth)\n              };\n            });\n            options.clip = {\n              ...dimensions,\n              x: 0,\n              y: 0\n            };\n            stack.use(await this._createTemporaryViewportContainingBox(options.clip));\n          } else if (options.clip && !options.captureBeyondViewport) {\n            stack.use(options.clip && (await this._createTemporaryViewportContainingBox(options.clip)));\n          } else if (!options.clip) {\n            options.captureBeyondViewport = false;\n          }\n        }\n        const data = await this._screenshot(options);\n        if (options.encoding === 'base64') {\n          return data;\n        }\n        const buffer = Buffer.from(data, 'base64');\n        await this._maybeWriteBufferToFile(options.path, buffer);\n        return buffer;\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_2);\n        if (result_1) await result_1;\n      }\n    }\n    /**\n     * @internal\n     */\n    async _createTemporaryViewportContainingBox(clip) {\n      const env_3 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const viewport = await this.mainFrame().isolatedRealm().evaluate(() => {\n          return {\n            pageLeft: window.visualViewport.pageLeft,\n            pageTop: window.visualViewport.pageTop,\n            width: window.visualViewport.width,\n            height: window.visualViewport.height\n          };\n        });\n        const stack = __addDisposableResource(env_3, new AsyncDisposableStack(), true);\n        if (clip.x < viewport.pageLeft || clip.y < viewport.pageTop) {\n          await this.evaluate((left, top) => {\n            window.scroll({\n              left,\n              top,\n              behavior: 'instant'\n            });\n          }, Math.floor(clip.x), Math.floor(clip.y));\n          stack.defer(async () => {\n            await this.evaluate((left, top) => {\n              window.scroll({\n                left,\n                top,\n                behavior: 'instant'\n              });\n            }, viewport.pageLeft, viewport.pageTop).catch(debugError);\n          });\n        }\n        if (clip.width + clip.x > viewport.width || clip.height + clip.y > viewport.height) {\n          const originalViewport = this.viewport() ?? {\n            width: 0,\n            height: 0\n          };\n          // We add 1 for fractional x and y.\n          await this.setViewport({\n            width: Math.max(viewport.width, Math.ceil(clip.width + clip.x)),\n            height: Math.max(viewport.height, Math.ceil(clip.height + clip.y))\n          });\n          stack.defer(async () => {\n            await this.setViewport(originalViewport).catch(debugError);\n          });\n        }\n        return stack.move();\n      } catch (e_3) {\n        env_3.error = e_3;\n        env_3.hasError = true;\n      } finally {\n        const result_2 = __disposeResources(env_3);\n        if (result_2) await result_2;\n      }\n    }\n    /**\n     * @internal\n     */\n    _getPDFOptions() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      let lengthUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'in';\n      const defaults = {\n        scale: 1,\n        displayHeaderFooter: false,\n        headerTemplate: '',\n        footerTemplate: '',\n        printBackground: false,\n        landscape: false,\n        pageRanges: '',\n        preferCSSPageSize: false,\n        omitBackground: false,\n        timeout: 30000,\n        tagged: false\n      };\n      let width = 8.5;\n      let height = 11;\n      if (options.format) {\n        const format = paperFormats[options.format.toLowerCase()];\n        assert(format, 'Unknown paper format: ' + options.format);\n        width = format.width;\n        height = format.height;\n      } else {\n        width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;\n        height = convertPrintParameterToInches(options.height, lengthUnit) ?? height;\n      }\n      const margin = {\n        top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,\n        left: convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,\n        bottom: convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,\n        right: convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0\n      };\n      return {\n        ...defaults,\n        ...options,\n        width,\n        height,\n        margin\n      };\n    }\n    async createPDFStream() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * The page's title\n     *\n     * @remarks\n     * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n     */\n    async title() {\n      return await this.mainFrame().title();\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page | Page.mouse} to click in the center of the\n     * element. If there's no element matching `selector`, the method throws an\n     * error.\n     * @remarks Bear in mind that if `click()` triggers a navigation event and\n     * there's a separate `page.waitForNavigation()` promise to be resolved, you\n     * may end up with a race condition that yields unexpected results. The\n     * correct pattern for click and wait for navigation is the following:\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   page.click(selector, clickOptions),\n     * ]);\n     * ```\n     *\n     * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n     * @param selector - A `selector` to search for element to click. If there are\n     * multiple elements satisfying the `selector`, the first will be clicked\n     * @param options - `Object`\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully clicked. The Promise will be rejected if there is no element\n     * matching `selector`.\n     */\n    click(selector, options) {\n      return this.mainFrame().click(selector, options);\n    }\n    /**\n     * This method fetches an element with `selector` and focuses it. If there's no\n     * element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n     * of an element to focus. If there are multiple elements satisfying the\n     * selector, the first will be focused.\n     * @returns Promise which resolves when the element matching selector is\n     * successfully focused. The promise will be rejected if there is no element\n     * matching selector.\n     * @remarks\n     * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n     */\n    focus(selector) {\n      return this.mainFrame().focus(selector);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page | Page.mouse}\n     * to hover over the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * to search for element to hover. If there are multiple elements satisfying\n     * the selector, the first will be hovered.\n     * @returns Promise which resolves when the element matching `selector` is\n     * successfully hovered. Promise gets rejected if there's no element matching\n     * `selector`.\n     * @remarks\n     * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n     */\n    hover(selector) {\n      return this.mainFrame().hover(selector);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * page.select('select#colors', 'blue'); // single selection\n     * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n     * to query the page for\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first one\n     * is taken into account.\n     * @returns\n     *\n     * @remarks\n     * Shortcut for {@link Frame.select | page.mainFrame().select()}\n     */\n    select(selector) {\n      for (var _len5 = arguments.length, values = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        values[_key5 - 1] = arguments[_key5];\n      }\n      return this.mainFrame().select(selector, ...values);\n    }\n    /**\n     * This method fetches an element with `selector`, scrolls it into view if\n     * needed, and then uses {@link Page | Page.touchscreen}\n     * to tap in the center of the element.\n     * If there's no element matching `selector`, the method throws an error.\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n     * to search for element to tap. If there are multiple elements satisfying the\n     * selector, the first will be tapped.\n     * @returns\n     * @remarks\n     * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n     */\n    tap(selector) {\n      return this.mainFrame().tap(selector);\n    }\n    /**\n     * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n     * in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n     * @example\n     *\n     * ```ts\n     * await page.type('#mytextarea', 'Hello');\n     * // Types instantly\n     * await page.type('#mytextarea', 'World', {delay: 100});\n     * // Types slower, like a user\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * of an element to type into. If there are multiple elements satisfying the\n     * selector, the first will be used.\n     * @param text - A text to type into a focused element.\n     * @param options - have property `delay` which is the Time to wait between\n     * key presses in milliseconds. Defaults to `0`.\n     * @returns\n     * @remarks\n     */\n    type(selector, text, options) {\n      return this.mainFrame().type(selector, text, options);\n    }\n    /**\n     * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n     *\n     * Causes your script to wait for the given number of milliseconds.\n     *\n     * @remarks\n     * It's generally recommended to not wait for a number of seconds, but instead\n     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n     *\n     * @example\n     *\n     * Wait for 1 second:\n     *\n     * ```ts\n     * await page.waitForTimeout(1000);\n     * ```\n     *\n     * @param milliseconds - the number of milliseconds to wait.\n     */\n    waitForTimeout(milliseconds) {\n      return this.mainFrame().waitForTimeout(milliseconds);\n    }\n    /**\n     * Wait for the `selector` to appear in page. If at the moment of calling the\n     * method the `selector` already exists, the method will return immediately. If\n     * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * @example\n     * This method works across navigations:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n     * of an element to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves when element specified by selector string\n     * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n     * selector is not found in DOM.\n     * @remarks\n     * The optional Parameter in Arguments `options` are:\n     *\n     * - `visible`: A boolean wait for element to be present in DOM and to be\n     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n     *   properties. Defaults to `false`.\n     *\n     * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n     *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n     *   `false`.\n     *\n     * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n     *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n     *   by using the {@link Page.setDefaultTimeout} method.\n     */\n    async waitForSelector(selector) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return await this.mainFrame().waitForSelector(selector, options);\n    }\n    /**\n     * Wait for the `xpath` to appear in page. If at the moment of calling the\n     * method the `xpath` already exists, the method will return immediately. If\n     * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * @example\n     * This method works across navigation\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .waitForXPath('//img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param xpath - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n     * element to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves when element specified by xpath string is\n     * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n     * not found in DOM, otherwise resolves to `ElementHandle`.\n     * @remarks\n     * The optional Argument `options` have properties:\n     *\n     * - `visible`: A boolean to wait for element to be present in DOM and to be\n     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n     *   properties. Defaults to `false`.\n     *\n     * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n     *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n     *   Defaults to `false`.\n     *\n     * - `timeout`: A number which is maximum time to wait for in milliseconds.\n     *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default\n     *   value can be changed by using the {@link Page.setDefaultTimeout} method.\n     */\n    waitForXPath(xpath, options) {\n      return this.mainFrame().waitForXPath(xpath, options);\n    }\n    /**\n     * Waits for a function to finish evaluating in the page's context.\n     *\n     * @example\n     * The {@link Page.waitForFunction} can be used to observe viewport size change:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n     *   await page.setViewport({width: 50, height: 50});\n     *   await watchDog;\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @example\n     * To pass arguments from node.js to the predicate of\n     * {@link Page.waitForFunction} function:\n     *\n     * ```ts\n     * const selector = '.foo';\n     * await page.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {},\n     *   selector\n     * );\n     * ```\n     *\n     * @example\n     * The predicate of {@link Page.waitForFunction} can be asynchronous too:\n     *\n     * ```ts\n     * const username = 'github-username';\n     * await page.waitForFunction(\n     *   async username => {\n     *     const githubResponse = await fetch(\n     *       `https://api.github.com/users/${username}`\n     *     );\n     *     const githubUser = await githubResponse.json();\n     *     // show the avatar\n     *     const img = document.createElement('img');\n     *     img.src = githubUser.avatar_url;\n     *     // wait 3 seconds\n     *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n     *     img.remove();\n     *   },\n     *   {},\n     *   username\n     * );\n     * ```\n     *\n     * @param pageFunction - Function to be evaluated in browser context\n     * @param options - Options for configuring waiting behavior.\n     */\n    waitForFunction(pageFunction, options) {\n      for (var _len6 = arguments.length, args = new Array(_len6 > 2 ? _len6 - 2 : 0), _key6 = 2; _key6 < _len6; _key6++) {\n        args[_key6 - 2] = arguments[_key6];\n      }\n      return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n    }\n    waitForDevicePrompt() {\n      throw new Error('Not implemented');\n    }\n    /** @internal */\n    [(_screenshot_decorators = [guarded(function () {\n      return this.browser();\n    })], disposeSymbol)]() {\n      return void this.close().catch(debugError);\n    }\n    /** @internal */\n    [asyncDisposeSymbol]() {\n      return this.close();\n    }\n  };\n})();\nexport { Page };\n/**\n * @internal\n */\nexport const supportedMetrics = new Set(['Timestamp', 'Documents', 'Frames', 'JSEventListeners', 'Nodes', 'LayoutCount', 'RecalcStyleCount', 'LayoutDuration', 'RecalcStyleDuration', 'ScriptDuration', 'TaskDuration', 'JSHeapUsedSize', 'JSHeapTotalSize']);\n/**\n * @internal\n */\nexport const unitToPixels = {\n  px: 1,\n  in: 96,\n  cm: 37.8,\n  mm: 3.78\n};\nfunction convertPrintParameterToInches(parameter) {\n  let lengthUnit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'in';\n  if (typeof parameter === 'undefined') {\n    return undefined;\n  }\n  let pixels;\n  if (isNumber(parameter)) {\n    // Treat numbers as pixel values to be aligned with phantom's paperSize.\n    pixels = parameter;\n  } else if (isString(parameter)) {\n    const text = parameter;\n    let unit = text.substring(text.length - 2).toLowerCase();\n    let valueText = '';\n    if (unit in unitToPixels) {\n      valueText = text.substring(0, text.length - 2);\n    } else {\n      // In case of unknown unit try to parse the whole parameter as number of pixels.\n      // This is consistent with phantom's paperSize behavior.\n      unit = 'px';\n      valueText = text;\n    }\n    const value = Number(valueText);\n    assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n    pixels = value * unitToPixels[unit];\n  } else {\n    throw new Error('page.pdf() Cannot handle parameter type: ' + typeof parameter);\n  }\n  return pixels / unitToPixels[lengthUnit];\n}\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle(clip) {\n  return {\n    ...clip,\n    ...(clip.width < 0 ? {\n      x: clip.x + clip.width,\n      width: -clip.width\n    } : {\n      x: clip.x,\n      width: clip.width\n    }),\n    ...(clip.height < 0 ? {\n      y: clip.y + clip.height,\n      height: -clip.height\n    } : {\n      y: clip.y,\n      height: clip.height\n    })\n  };\n}\nfunction roundRectangle(clip) {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {\n    ...clip,\n    x,\n    y,\n    width,\n    height\n  };\n}","map":{"version":3,"mappings":"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","names":["delay","filter","filterAsync","first","firstValueFrom","from","fromEvent","map","merge","of","raceWith","startWith","switchMap","TargetCloseError","EventEmitter","NetworkManagerEvent","paperFormats","TimeoutSettings","debugError","importFSPromises","isNumber","isString","timeout","withSourcePuppeteerURLIfNone","assert","guarded","AsyncDisposableStack","asyncDisposeSymbol","DisposableStack","disposeSymbol","FunctionLocator","Locator","NodeLocator","setDefaultScreenshotOptions","options","optimizeForSpeed","type","fromSurface","fullPage","omitBackground","encoding","captureBeyondViewport","allowViewportExpansion","Page","_classSuper","__esDecorate","kind","name","static","private","access","has","get","screenshot","metadata","_isDragging","_timeoutSettings","WeakMap","constructor","isServiceWorkerBypassed","Error","isDragInterceptionEnabled","isJavaScriptEnabled","on","handler","wrapper","undefined","event","enqueueInterceptAction","set","off","waitForFileChooser","setGeolocation","target","createCDPSession","touchscreen","workers","setRequestInterception","setBypassServiceWorker","setDragInterception","setOfflineMode","emulateNetworkConditions","locator","selectorOrFunc","create","locatorRace","locators","race","$","selector","mainFrame","$$","evaluateHandle","pageFunction","args","$eval","$$eval","$x","expression","cookies","deleteCookie","setCookie","addScriptTag","addStyleTag","removeExposedFunction","authenticate","setExtraHTTPHeaders","metrics","url","content","setContent","html","goto","waitForNavigation","_waitForNetworkIdle","networkManager","idleTime","requestsInFlight","Request","Response","RequestFailed","pipe","inFlightRequestsCount","v","waitForFrame","urlOrPredicate","ms","getDefaultTimeout","frame","frames","goBack","goForward","emulate","device","Promise","all","setUserAgent","userAgent","setViewport","viewport","setJavaScriptEnabled","emulateMediaType","emulateCPUThrottling","emulateMediaFeatures","emulateTimezone","emulateIdleState","emulateVisionDeficiency","evaluate","_maybeWriteBufferToFile","path","buffer","fs","writeFile","screencast","ScreenRecorder","width","height","devicePixelRatio","crop","x","y","cropWidth","cropHeight","roundRectangle","normalizeRectangle","viewportWidth","viewportHeight","speed","scale","recorder","ffmpegPath","_startScreencast","error","stop","createWriteStream","stream","client","send","format","then","resolve","once","_stopScreencast","stack","deviceScaleFactor","defer","catch","isolatedRealm","window","visualViewport","userOptions","bringToFront","clip","filePath","extension","slice","lastIndexOf","toLowerCase","quality","includes","dimensions","scrollHeight","scrollWidth","document","documentElement","Math","max","use","_createTemporaryViewportContainingBox","data","_screenshot","Buffer","pageLeft","pageTop","left","top","scroll","behavior","floor","originalViewport","ceil","move","_getPDFOptions","lengthUnit","defaults","displayHeaderFooter","headerTemplate","footerTemplate","printBackground","landscape","pageRanges","preferCSSPageSize","tagged","convertPrintParameterToInches","margin","bottom","right","createPDFStream","title","click","focus","hover","select","values","tap","text","waitForTimeout","milliseconds","waitForSelector","waitForXPath","xpath","waitForFunction","waitForDevicePrompt","browser","close","supportedMetrics","Set","unitToPixels","px","in","cm","mm","parameter","pixels","unit","substring","length","valueText","value","Number","isNaN","round"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\api\\Page.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Readable} from 'stream';\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {\n  delay,\n  filter,\n  filterAsync,\n  first,\n  firstValueFrom,\n  from,\n  fromEvent,\n  map,\n  merge,\n  of,\n  raceWith,\n  startWith,\n  switchMap,\n  type Observable,\n} from '../../third_party/rxjs/rxjs.js';\nimport type {HTTPRequest} from '../api/HTTPRequest.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {BidiNetworkManager} from '../bidi/NetworkManager.js';\nimport type {Accessibility} from '../cdp/Accessibility.js';\nimport type {Coverage} from '../cdp/Coverage.js';\nimport type {DeviceRequestPrompt} from '../cdp/DeviceRequestPrompt.js';\nimport type {\n  NetworkManager as CdpNetworkManager,\n  Credentials,\n  NetworkConditions,\n} from '../cdp/NetworkManager.js';\nimport type {Tracing} from '../cdp/Tracing.js';\nimport type {WebWorker} from '../cdp/WebWorker.js';\nimport type {ConsoleMessage} from '../common/ConsoleMessage.js';\nimport type {Device} from '../common/Device.js';\nimport {TargetCloseError} from '../common/Errors.js';\nimport {\n  EventEmitter,\n  type EventsWithWildcard,\n  type EventType,\n  type Handler,\n} from '../common/EventEmitter.js';\nimport type {FileChooser} from '../common/FileChooser.js';\nimport {NetworkManagerEvent} from '../common/NetworkManagerEvents.js';\nimport {\n  paperFormats,\n  type LowerCasePaperFormat,\n  type ParsedPDFOptions,\n  type PDFOptions,\n} from '../common/PDFOptions.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {\n  Awaitable,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {\n  debugError,\n  importFSPromises,\n  isNumber,\n  isString,\n  timeout,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport type {Viewport} from '../common/Viewport.js';\nimport type {ScreenRecorder} from '../node/ScreenRecorder.js';\nimport {assert} from '../util/assert.js';\nimport {guarded} from '../util/decorators.js';\nimport {\n  AsyncDisposableStack,\n  asyncDisposeSymbol,\n  DisposableStack,\n  disposeSymbol,\n} from '../util/disposable.js';\n\nimport type {Browser} from './Browser.js';\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {CDPSession} from './CDPSession.js';\nimport type {Dialog} from './Dialog.js';\nimport type {\n  BoundingBox,\n  ClickOptions,\n  ElementHandle,\n} from './ElementHandle.js';\nimport type {\n  Frame,\n  FrameAddScriptTagOptions,\n  FrameAddStyleTagOptions,\n  FrameWaitForFunctionOptions,\n  GoToOptions,\n  WaitForOptions,\n} from './Frame.js';\nimport type {\n  Keyboard,\n  KeyboardTypeOptions,\n  Mouse,\n  Touchscreen,\n} from './Input.js';\nimport type {JSHandle} from './JSHandle.js';\nimport {\n  FunctionLocator,\n  Locator,\n  NodeLocator,\n  type AwaitedLocator,\n} from './locators/locators.js';\nimport type {Target} from './Target.js';\n\n/**\n * @public\n */\nexport interface Metrics {\n  Timestamp?: number;\n  Documents?: number;\n  Frames?: number;\n  JSEventListeners?: number;\n  Nodes?: number;\n  LayoutCount?: number;\n  RecalcStyleCount?: number;\n  LayoutDuration?: number;\n  RecalcStyleDuration?: number;\n  ScriptDuration?: number;\n  TaskDuration?: number;\n  JSHeapUsedSize?: number;\n  JSHeapTotalSize?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitTimeoutOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} method.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n}\n\n/**\n * @public\n */\nexport interface WaitForSelectorOptions {\n  /**\n   * Wait for the selected element to be present in DOM and to be visible, i.e.\n   * to not have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  visible?: boolean;\n  /**\n   * Wait for the selected element to not be found in the DOM or to be hidden,\n   * i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *\n   * @defaultValue `false`\n   */\n  hidden?: boolean;\n  /**\n   * Maximum time to wait in milliseconds. Pass `0` to disable timeout.\n   *\n   * The default value can be changed by using {@link Page.setDefaultTimeout}\n   *\n   * @defaultValue `30_000` (30 seconds)\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForSelector call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface GeolocationOptions {\n  /**\n   * Latitude between `-90` and `90`.\n   */\n  longitude: number;\n  /**\n   * Longitude between `-180` and `180`.\n   */\n  latitude: number;\n  /**\n   * Optional non-negative accuracy value.\n   */\n  accuracy?: number;\n}\n\n/**\n * @public\n */\nexport interface MediaFeature {\n  name: string;\n  value: string;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotClip extends BoundingBox {\n  /**\n   * @defaultValue `1`\n   */\n  scale?: number;\n}\n\n/**\n * @public\n */\nexport interface ScreenshotOptions {\n  /**\n   * @defaultValue `false`\n   */\n  optimizeForSpeed?: boolean;\n  /**\n   * @defaultValue `'png'`\n   */\n  type?: 'png' | 'jpeg' | 'webp';\n  /**\n   * Quality of the image, between 0-100. Not applicable to `png` images.\n   */\n  quality?: number;\n  /**\n   * Capture the screenshot from the surface, rather than the view.\n   *\n   * @defaultValue `true`\n   */\n  fromSurface?: boolean;\n  /**\n   * When `true`, takes a screenshot of the full page.\n   *\n   * @defaultValue `false`\n   */\n  fullPage?: boolean;\n  /**\n   * Hides default white background and allows capturing screenshots with transparency.\n   *\n   * @defaultValue `false`\n   */\n  omitBackground?: boolean;\n  /**\n   * The file path to save the image to. The screenshot type will be inferred\n   * from file extension. If path is a relative path, then it is resolved\n   * relative to current working directory. If no path is provided, the image\n   * won't be saved to the disk.\n   */\n  path?: string;\n  /**\n   * Specifies the region of the page to clip.\n   */\n  clip?: ScreenshotClip;\n  /**\n   * Encoding of the image.\n   *\n   * @defaultValue `'binary'`\n   */\n  encoding?: 'base64' | 'binary';\n  /**\n   * Capture the screenshot beyond the viewport.\n   *\n   * @defaultValue `true`\n   */\n  captureBeyondViewport?: boolean;\n  /**\n   * TODO(jrandolf): Investigate whether viewport expansion is a better\n   * alternative for cross-browser screenshots as opposed to\n   * `captureBeyondViewport`.\n   *\n   * @internal\n   */\n  allowViewportExpansion?: boolean;\n}\n\n/**\n * @experimental\n */\nexport interface ScreencastOptions {\n  /**\n   * File path to save the screencast to.\n   */\n  path?: `${string}.webm`;\n  /**\n   * Specifies the region of the viewport to crop.\n   */\n  crop?: BoundingBox;\n  /**\n   * Scales the output video.\n   *\n   * For example, `0.5` will shrink the width and height of the output video by\n   * half. `2` will double the width and height of the output video.\n   *\n   * @defaultValue `1`\n   */\n  scale?: number;\n  /**\n   * Specifies the speed to record at.\n   *\n   * For example, `0.5` will slowdown the output video by 50%. `2` will double the\n   * speed of the output video.\n   *\n   * @defaultValue `1`\n   */\n  speed?: number;\n  /**\n   * Path to the [ffmpeg](https://ffmpeg.org/).\n   *\n   * Required if `ffmpeg` is not in your PATH.\n   */\n  ffmpegPath?: string;\n}\n\n/**\n * All the events that a page instance may emit.\n *\n * @public\n */\nexport const enum PageEvent {\n  /**\n   * Emitted when the page closes.\n   */\n  Close = 'close',\n  /**\n   * Emitted when JavaScript within the page calls one of console API methods,\n   * e.g. `console.log` or `console.dir`. Also emitted if the page throws an\n   * error or a warning.\n   *\n   * @remarks\n   * A `console` event provides a {@link ConsoleMessage} representing the\n   * console message that was logged.\n   *\n   * @example\n   * An example of handling `console` event:\n   *\n   * ```ts\n   * page.on('console', msg => {\n   *   for (let i = 0; i < msg.args().length; ++i)\n   *     console.log(`${i}: ${msg.args()[i]}`);\n   * });\n   * page.evaluate(() => console.log('hello', 5, {foo: 'bar'}));\n   * ```\n   */\n  Console = 'console',\n  /**\n   * Emitted when a JavaScript dialog appears, such as `alert`, `prompt`,\n   * `confirm` or `beforeunload`. Puppeteer can respond to the dialog via\n   * {@link Dialog.accept} or {@link Dialog.dismiss}.\n   */\n  Dialog = 'dialog',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded | DOMContentLoaded }\n   * event is dispatched.\n   */\n  DOMContentLoaded = 'domcontentloaded',\n  /**\n   * Emitted when the page crashes. Will contain an `Error`.\n   */\n  Error = 'error',\n  /** Emitted when a frame is attached. Will contain a {@link Frame}. */\n  FrameAttached = 'frameattached',\n  /** Emitted when a frame is detached. Will contain a {@link Frame}. */\n  FrameDetached = 'framedetached',\n  /**\n   * Emitted when a frame is navigated to a new URL. Will contain a\n   * {@link Frame}.\n   */\n  FrameNavigated = 'framenavigated',\n  /**\n   * Emitted when the JavaScript\n   * {@link https://developer.mozilla.org/en-US/docs/Web/Events/load | load}\n   * event is dispatched.\n   */\n  Load = 'load',\n  /**\n   * Emitted when the JavaScript code makes a call to `console.timeStamp`. For\n   * the list of metrics see {@link Page.metrics | page.metrics}.\n   *\n   * @remarks\n   * Contains an object with two properties:\n   *\n   * - `title`: the title passed to `console.timeStamp`\n   * - `metrics`: object containing metrics as key/value pairs. The values will\n   *   be `number`s.\n   */\n  Metrics = 'metrics',\n  /**\n   * Emitted when an uncaught exception happens within the page. Contains an\n   * `Error`.\n   */\n  PageError = 'pageerror',\n  /**\n   * Emitted when the page opens a new tab or window.\n   *\n   * Contains a {@link Page} corresponding to the popup window.\n   *\n   * @example\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.click('a[target=_blank]'),\n   * ]);\n   * ```\n   *\n   * ```ts\n   * const [popup] = await Promise.all([\n   *   new Promise(resolve => page.once('popup', resolve)),\n   *   page.evaluate(() => window.open('https://example.com')),\n   * ]);\n   * ```\n   */\n  Popup = 'popup',\n  /**\n   * Emitted when a page issues a request and contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * The object is readonly. See {@link Page.setRequestInterception} for\n   * intercepting and mutating requests.\n   */\n  Request = 'request',\n  /**\n   * Emitted when a request ended up loading from cache. Contains a\n   * {@link HTTPRequest}.\n   *\n   * @remarks\n   * For certain requests, might contain undefined.\n   * {@link https://crbug.com/750469}\n   */\n  RequestServedFromCache = 'requestservedfromcache',\n  /**\n   * Emitted when a request fails, for example by timing out.\n   *\n   * Contains a {@link HTTPRequest}.\n   *\n   * @remarks\n   * HTTP Error responses, such as 404 or 503, are still successful responses\n   * from HTTP standpoint, so request will complete with `requestfinished` event\n   * and not with `requestfailed`.\n   */\n  RequestFailed = 'requestfailed',\n  /**\n   * Emitted when a request finishes successfully. Contains a\n   * {@link HTTPRequest}.\n   */\n  RequestFinished = 'requestfinished',\n  /**\n   * Emitted when a response is received. Contains a {@link HTTPResponse}.\n   */\n  Response = 'response',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is spawned by the page.\n   */\n  WorkerCreated = 'workercreated',\n  /**\n   * Emitted when a dedicated\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}\n   * is destroyed by the page.\n   */\n  WorkerDestroyed = 'workerdestroyed',\n}\n\nexport {\n  /**\n   * All the events that a page instance may emit.\n   *\n   * @deprecated Use {@link PageEvent}.\n   */\n  PageEvent as PageEmittedEvents,\n};\n\n/**\n * Denotes the objects received by callback functions for page events.\n *\n * See {@link PageEvent} for more detail on the events and when they are\n * emitted.\n *\n * @public\n */\nexport interface PageEvents extends Record<EventType, unknown> {\n  [PageEvent.Close]: undefined;\n  [PageEvent.Console]: ConsoleMessage;\n  [PageEvent.Dialog]: Dialog;\n  [PageEvent.DOMContentLoaded]: undefined;\n  [PageEvent.Error]: Error;\n  [PageEvent.FrameAttached]: Frame;\n  [PageEvent.FrameDetached]: Frame;\n  [PageEvent.FrameNavigated]: Frame;\n  [PageEvent.Load]: undefined;\n  [PageEvent.Metrics]: {title: string; metrics: Metrics};\n  [PageEvent.PageError]: Error;\n  [PageEvent.Popup]: Page | null;\n  [PageEvent.Request]: HTTPRequest;\n  [PageEvent.Response]: HTTPResponse;\n  [PageEvent.RequestFailed]: HTTPRequest;\n  [PageEvent.RequestFinished]: HTTPRequest;\n  [PageEvent.RequestServedFromCache]: HTTPRequest;\n  [PageEvent.WorkerCreated]: WebWorker;\n  [PageEvent.WorkerDestroyed]: WebWorker;\n}\n\nexport type {\n  /**\n   * @deprecated Use {@link PageEvents}.\n   */\n  PageEvents as PageEventObject,\n};\n\n/**\n * @public\n */\nexport interface NewDocumentScriptEvaluation {\n  identifier: string;\n}\n\n/**\n * @internal\n */\nexport function setDefaultScreenshotOptions(options: ScreenshotOptions): void {\n  options.optimizeForSpeed ??= false;\n  options.type ??= 'png';\n  options.fromSurface ??= true;\n  options.fullPage ??= false;\n  options.omitBackground ??= false;\n  options.encoding ??= 'binary';\n  options.captureBeyondViewport ??= true;\n  options.allowViewportExpansion ??= options.captureBeyondViewport;\n}\n\n/**\n * Page provides methods to interact with a single tab or\n * {@link https://developer.chrome.com/extensions/background_pages | extension background page}\n * in the browser.\n *\n * :::note\n *\n * One Browser instance might have multiple Page instances.\n *\n * :::\n *\n * @example\n * This example creates a page, navigates it to a URL, and then saves a screenshot:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   await page.screenshot({path: 'screenshot.png'});\n *   await browser.close();\n * })();\n * ```\n *\n * The Page class extends from Puppeteer's {@link EventEmitter} class and will\n * emit various events which are documented in the {@link PageEvent} enum.\n *\n * @example\n * This example logs a message for a single page `load` event:\n *\n * ```ts\n * page.once('load', () => console.log('Page loaded!'));\n * ```\n *\n * To unsubscribe from events use the {@link EventEmitter.off} method:\n *\n * ```ts\n * function logRequest(interceptedRequest) {\n *   console.log('A request was made:', interceptedRequest.url());\n * }\n * page.on('request', logRequest);\n * // Sometime later...\n * page.off('request', logRequest);\n * ```\n *\n * @public\n */\nexport abstract class Page extends EventEmitter<PageEvents> {\n  /**\n   * @internal\n   */\n  _isDragging = false;\n  /**\n   * @internal\n   */\n  _timeoutSettings = new TimeoutSettings();\n\n  #requestHandlers = new WeakMap<Handler<HTTPRequest>, Handler<HTTPRequest>>();\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * `true` if the service worker are being bypassed, `false` otherwise.\n   */\n  isServiceWorkerBypassed(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * `true` if drag events are being intercepted, `false` otherwise.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page.mouse}).\n   */\n  isDragInterceptionEnabled(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * `true` if the page has JavaScript enabled, `false` otherwise.\n   */\n  isJavaScriptEnabled(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Listen to page events.\n   *\n   * @remarks\n   * This method exists to define event typings and handle proper wireup of\n   * cooperative request interception. Actual event listening and dispatching is\n   * delegated to {@link EventEmitter}.\n   *\n   * @internal\n   */\n  override on<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type !== PageEvent.Request) {\n      return super.on(type, handler);\n    }\n    let wrapper = this.#requestHandlers.get(\n      handler as (event: PageEvents[PageEvent.Request]) => void\n    );\n    if (wrapper === undefined) {\n      wrapper = (event: HTTPRequest) => {\n        event.enqueueInterceptAction(() => {\n          return handler(event as EventsWithWildcard<PageEvents>[K]);\n        });\n      };\n      this.#requestHandlers.set(\n        handler as (event: PageEvents[PageEvent.Request]) => void,\n        wrapper\n      );\n    }\n    return super.on(\n      type,\n      wrapper as (event: EventsWithWildcard<PageEvents>[K]) => void\n    );\n  }\n\n  /**\n   * @internal\n   */\n  override off<K extends keyof EventsWithWildcard<PageEvents>>(\n    type: K,\n    handler: (event: EventsWithWildcard<PageEvents>[K]) => void\n  ): this {\n    if (type === PageEvent.Request) {\n      handler =\n        (this.#requestHandlers.get(\n          handler as (\n            event: EventsWithWildcard<PageEvents>[PageEvent.Request]\n          ) => void\n        ) as (event: EventsWithWildcard<PageEvents>[K]) => void) || handler;\n    }\n    return super.off(type, handler);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers file\n   * choosing.\n   *\n   * :::caution\n   *\n   * This must be called before the file chooser is launched. It will not return\n   * a currently active file chooser.\n   *\n   * :::\n   *\n   * @remarks\n   * In the \"headful\" browser, this method results in the native file picker\n   * dialog `not showing up` for the user.\n   *\n   * @example\n   * The following example clicks a button that issues a file chooser\n   * and then responds with `/tmp/myfile.pdf` as if a user has selected this file.\n   *\n   * ```ts\n   * const [fileChooser] = await Promise.all([\n   *   page.waitForFileChooser(),\n   *   page.click('#upload-file-button'),\n   *   // some button that triggers file selection\n   * ]);\n   * await fileChooser.accept(['/tmp/myfile.pdf']);\n   * ```\n   */\n  waitForFileChooser(options?: WaitTimeoutOptions): Promise<FileChooser>;\n  waitForFileChooser(): Promise<FileChooser> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Sets the page's geolocation.\n   *\n   * @remarks\n   * Consider using {@link BrowserContext.overridePermissions} to grant\n   * permissions for the page to read its geolocation.\n   *\n   * @example\n   *\n   * ```ts\n   * await page.setGeolocation({latitude: 59.95, longitude: 30.31667});\n   * ```\n   */\n  async setGeolocation(options: GeolocationOptions): Promise<void>;\n  async setGeolocation(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * A target this page was created from.\n   */\n  target(): Target {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Get the browser the page belongs to.\n   */\n  abstract browser(): Browser;\n\n  /**\n   * Get the browser context that the page belongs to.\n   */\n  abstract browserContext(): BrowserContext;\n\n  /**\n   * The page's main frame.\n   *\n   * @remarks\n   * Page is guaranteed to have a main frame which persists during navigations.\n   */\n  abstract mainFrame(): Frame;\n\n  /**\n   * Creates a Chrome Devtools Protocol session attached to the page.\n   */\n  createCDPSession(): Promise<CDPSession> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Keyboard}\n   */\n  abstract get keyboard(): Keyboard;\n\n  /**\n   * {@inheritDoc Touchscreen}\n   */\n  get touchscreen(): Touchscreen {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Coverage}\n   */\n  abstract get coverage(): Coverage;\n\n  /**\n   * {@inheritDoc Tracing}\n   */\n  abstract get tracing(): Tracing;\n\n  /**\n   * {@inheritDoc Accessibility}\n   */\n  abstract get accessibility(): Accessibility;\n\n  /**\n   * An array of all frames attached to the page.\n   */\n  abstract frames(): Frame[];\n\n  /**\n   * All of the dedicated {@link\n   * https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API |\n   * WebWorkers} associated with the page.\n   *\n   * @remarks\n   * This does not contain ServiceWorkers\n   */\n  workers(): WebWorker[] {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Activating request interception enables {@link HTTPRequest.abort},\n   * {@link HTTPRequest.continue} and {@link HTTPRequest.respond} methods. This\n   * provides the capability to modify network requests that are made by a page.\n   *\n   * Once request interception is enabled, every request will stall unless it's\n   * continued, responded or aborted; or completed using the browser cache.\n   *\n   * See the\n   * {@link https://pptr.dev/next/guides/request-interception|Request interception guide}\n   * for more details.\n   *\n   * @example\n   * An example of a naÃ¯ve request interceptor that aborts all image requests:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.setRequestInterception(true);\n   *   page.on('request', interceptedRequest => {\n   *     if (\n   *       interceptedRequest.url().endsWith('.png') ||\n   *       interceptedRequest.url().endsWith('.jpg')\n   *     )\n   *       interceptedRequest.abort();\n   *     else interceptedRequest.continue();\n   *   });\n   *   await page.goto('https://example.com');\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param value - Whether to enable request interception.\n   */\n  async setRequestInterception(value: boolean): Promise<void>;\n  async setRequestInterception(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Toggles ignoring of service worker for each request.\n   *\n   * @param bypass - Whether to bypass service worker and load from network.\n   */\n  async setBypassServiceWorker(bypass: boolean): Promise<void>;\n  async setBypassServiceWorker(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param enabled - Whether to enable drag interception.\n   *\n   * @deprecated We no longer support intercepting drag payloads. Use the new\n   * drag APIs found on {@link ElementHandle} to drag (or just use the\n   * {@link Page.mouse}).\n   */\n  async setDragInterception(enabled: boolean): Promise<void>;\n  async setDragInterception(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Sets the network connection to offline.\n   *\n   * It does not change the parameters used in {@link Page.emulateNetworkConditions}\n   *\n   * @param enabled - When `true`, enables offline mode for the page.\n   */\n  setOfflineMode(enabled: boolean): Promise<void>;\n  setOfflineMode(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This does not affect WebSockets and WebRTC PeerConnections (see\n   * https://crbug.com/563644). To set the page offline, you can use\n   * {@link Page.setOfflineMode}.\n   *\n   * A list of predefined network conditions can be used by importing\n   * {@link PredefinedNetworkConditions}.\n   *\n   * @example\n   *\n   * ```ts\n   * import {PredefinedNetworkConditions} from 'puppeteer';\n   * const slow3G = PredefinedNetworkConditions['Slow 3G'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulateNetworkConditions(slow3G);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param networkConditions - Passing `null` disables network condition\n   * emulation.\n   */\n  emulateNetworkConditions(\n    networkConditions: NetworkConditions | null\n  ): Promise<void>;\n  emulateNetworkConditions(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This setting will change the default maximum navigation time for the\n   * following methods and related shortcuts:\n   *\n   * - {@link Page.goBack | page.goBack(options)}\n   *\n   * - {@link Page.goForward | page.goForward(options)}\n   *\n   * - {@link Page.goto | page.goto(url,options)}\n   *\n   * - {@link Page.reload | page.reload(options)}\n   *\n   * - {@link Page.setContent | page.setContent(html,options)}\n   *\n   * - {@link Page.waitForNavigation | page.waitForNavigation(options)}\n   *   @param timeout - Maximum navigation time in milliseconds.\n   */\n  abstract setDefaultNavigationTimeout(timeout: number): void;\n\n  /**\n   * @param timeout - Maximum time in milliseconds.\n   */\n  abstract setDefaultTimeout(timeout: number): void;\n\n  /**\n   * Maximum time in milliseconds.\n   */\n  abstract getDefaultTimeout(): number;\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n\n  /**\n   * A shortcut for {@link Locator.race} that does not require static imports.\n   *\n   * @internal\n   */\n  locatorRace<Locators extends readonly unknown[] | []>(\n    locators: Locators\n  ): Locator<AwaitedLocator<Locators[number]>> {\n    return Locator.race(locators);\n  }\n\n  /**\n   * Runs `document.querySelector` within the page. If no element matches the\n   * selector, the return value resolves to `null`.\n   *\n   * @param selector - A `selector` to query page for\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query page for.\n   */\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().$(selector);\n  }\n\n  /**\n   * The method runs `document.querySelectorAll` within the page. If no elements\n   * match the selector, the return value resolves to `[]`.\n   * @remarks\n   * Shortcut for {@link Frame.$$ | Page.mainFrame().$$(selector) }.\n   * @param selector - A `selector` to query page for\n   */\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    return await this.mainFrame().$$(selector);\n  }\n\n  /**\n   * @remarks\n   *\n   * The only difference between {@link Page.evaluate | page.evaluate} and\n   * `page.evaluateHandle` is that `evaluateHandle` will return the value\n   * wrapped in an in-page object.\n   *\n   * If the function passed to `page.evaluateHandle` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle('document');\n   * ```\n   *\n   * @example\n   * {@link JSHandle} instances can be passed as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluateHandle(() => document.body);\n   * const resultHandle = await page.evaluateHandle(\n   *   body => body.innerHTML,\n   *   aHandle\n   * );\n   * console.log(await resultHandle.jsonValue());\n   * await resultHandle.dispose();\n   * ```\n   *\n   * Most of the time this function returns a {@link JSHandle},\n   * but if `pageFunction` returns a reference to an element,\n   * you instead get an {@link ElementHandle} back:\n   *\n   * @example\n   *\n   * ```ts\n   * const button = await page.evaluateHandle(() =>\n   *   document.querySelector('button')\n   * );\n   * // can call `click` because `button` is an `ElementHandle`\n   * await button.click();\n   * ```\n   *\n   * The TypeScript definitions assume that `evaluateHandle` returns\n   * a `JSHandle`, but if you know it's going to return an\n   * `ElementHandle`, pass it as the generic argument:\n   *\n   * ```ts\n   * const button = await page.evaluateHandle<ElementHandle>(...);\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * This method iterates the JavaScript heap and finds all objects with the\n   * given prototype.\n   *\n   * @example\n   *\n   * ```ts\n   * // Create a Map object\n   * await page.evaluate(() => (window.map = new Map()));\n   * // Get a handle to the Map object prototype\n   * const mapPrototype = await page.evaluateHandle(() => Map.prototype);\n   * // Query all map instances into an array\n   * const mapInstances = await page.queryObjects(mapPrototype);\n   * // Count amount of map objects in heap\n   * const count = await page.evaluate(maps => maps.length, mapInstances);\n   * await mapInstances.dispose();\n   * await mapPrototype.dispose();\n   * ```\n   *\n   * @param prototypeHandle - a handle to the object prototype.\n   * @returns Promise which resolves to a handle to an array of objects with\n   * this prototype.\n   */\n  abstract queryObjects<Prototype>(\n    prototypeHandle: JSHandle<Prototype>\n  ): Promise<JSHandle<Prototype[]>>;\n\n  /**\n   * This method runs `document.querySelector` within the page and passes the\n   * result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   *\n   * If no element is found matching `selector`, the method will throw an error.\n   *\n   * If `pageFunction` returns a promise `$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await page.$eval('#search', el => el.value);\n   * const preloadHref = await page.$eval('link[rel=preload]', el => el.href);\n   * const html = await page.$eval('.main-container', el => el.outerHTML);\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * const searchValue = await page.$eval(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const searchValue = await page.$eval<string>(\n   *   '#search',\n   *   (el: HTMLInputElement) => el.value\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of `document.querySelector(selector)` as its\n   * first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    return await this.mainFrame().$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * This method runs `Array.from(document.querySelectorAll(selector))` within\n   * the page and passes the result as the first argument to the `pageFunction`.\n   *\n   * @remarks\n   * If `pageFunction` returns a promise `$$eval` will wait for the promise to\n   * resolve and then return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * // get the amount of divs on the page\n   * const divCount = await page.$$eval('div', divs => divs.length);\n   *\n   * // get the text content of all the `.options` elements:\n   * const options = await page.$$eval('div > span.options', options => {\n   *   return options.map(option => option.textContent);\n   * });\n   * ```\n   *\n   * If you are using TypeScript, you may have to provide an explicit type to the\n   * first argument of the `pageFunction`.\n   * By default it is typed as `Element[]`, but you may need to provide a more\n   * specific sub-type:\n   *\n   * @example\n   *\n   * ```ts\n   * // if you don't provide HTMLInputElement here, TS will error\n   * // as `value` is not on `Element`\n   * await page.$$eval('input', (elements: HTMLInputElement[]) => {\n   *   return elements.map(e => e.value);\n   * });\n   * ```\n   *\n   * The compiler should be able to infer the return type\n   * from the `pageFunction` you provide. If it is unable to, you can use the generic\n   * type to tell the compiler what return type you expect from `$$eval`:\n   *\n   * @example\n   *\n   * ```ts\n   * // The compiler can infer the return type in this case, but if it can't\n   * // or if you want to be more explicit, provide it as the generic type.\n   * const allInputValues = await page.$$eval<string[]>(\n   *   'input',\n   *   (elements: HTMLInputElement[]) => elements.map(e => e.textContent)\n   * );\n   * ```\n   *\n   * @param selector - the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to query for\n   * @param pageFunction - the function to be evaluated in the page context.\n   * Will be passed the result of\n   * `Array.from(document.querySelectorAll(selector))` as its first argument.\n   * @param args - any additional arguments to pass through to `pageFunction`.\n   *\n   * @returns The result of calling `pageFunction`. If it returns an element it\n   * is wrapped in an {@link ElementHandle}, else the raw value itself is\n   * returned.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    return await this.mainFrame().$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * The method evaluates the XPath expression relative to the page document as\n   * its context node. If there are no such elements, the method resolves to an\n   * empty array.\n   *\n   * @remarks\n   * Shortcut for {@link Frame.$x | Page.mainFrame().$x(expression) }.\n   *\n   * @param expression - Expression to evaluate\n   */\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>> {\n    return await this.mainFrame().$x(expression);\n  }\n\n  /**\n   * If no URLs are specified, this method returns cookies for the current page\n   * URL. If URLs are specified, only cookies for those URLs are returned.\n   */\n  async cookies(...urls: string[]): Promise<Protocol.Network.Cookie[]>;\n  async cookies(): Promise<Protocol.Network.Cookie[]> {\n    throw new Error('Not implemented');\n  }\n\n  async deleteCookie(\n    ...cookies: Protocol.Network.DeleteCookiesRequest[]\n  ): Promise<void>;\n  async deleteCookie(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @example\n   *\n   * ```ts\n   * await page.setCookie(cookieObject1, cookieObject2);\n   * ```\n   */\n  async setCookie(...cookies: Protocol.Network.CookieParam[]): Promise<void>;\n  async setCookie(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Adds a `<script>` tag into the page with the desired URL or content.\n   *\n   * @remarks\n   * Shortcut for\n   * {@link Frame.addScriptTag | page.mainFrame().addScriptTag(options)}.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    return await this.mainFrame().addScriptTag(options);\n  }\n\n  /**\n   * Adds a `<link rel=\"stylesheet\">` tag into the page with the desired URL or\n   * a `<style type=\"text/css\">` tag with the content.\n   *\n   * Shortcut for\n   * {@link Frame.(addStyleTag:2) | page.mainFrame().addStyleTag(options)}.\n   *\n   * @returns An {@link ElementHandle | element handle} to the injected `<link>`\n   * or `<style>` element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    return await this.mainFrame().addStyleTag(options);\n  }\n\n  /**\n   * The method adds a function called `name` on the page's `window` object.\n   * When called, the function executes `puppeteerFunction` in node.js and\n   * returns a `Promise` which resolves to the return value of\n   * `puppeteerFunction`.\n   *\n   * If the puppeteerFunction returns a `Promise`, it will be awaited.\n   *\n   * :::note\n   *\n   * Functions installed via `page.exposeFunction` survive navigations.\n   *\n   * :::note\n   *\n   * @example\n   * An example of adding an `md5` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import crypto from 'crypto';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('md5', text =>\n   *     crypto.createHash('md5').update(text).digest('hex')\n   *   );\n   *   await page.evaluate(async () => {\n   *     // use window.md5 to compute hashes\n   *     const myString = 'PUPPETEER';\n   *     const myHash = await window.md5(myString);\n   *     console.log(`md5 of ${myString} is ${myHash}`);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * An example of adding a `window.readfile` function into the page:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * import fs from 'fs';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   page.on('console', msg => console.log(msg.text()));\n   *   await page.exposeFunction('readfile', async filePath => {\n   *     return new Promise((resolve, reject) => {\n   *       fs.readFile(filePath, 'utf8', (err, text) => {\n   *         if (err) reject(err);\n   *         else resolve(text);\n   *       });\n   *     });\n   *   });\n   *   await page.evaluate(async () => {\n   *     // use window.readfile to read contents of a file\n   *     const content = await window.readfile('/etc/hosts');\n   *     console.log(content);\n   *   });\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param name - Name of the function on the window object\n   * @param pptrFunction - Callback function which will be called in Puppeteer's\n   * context.\n   */\n  abstract exposeFunction(\n    name: string,\n    pptrFunction: Function | {default: Function}\n  ): Promise<void>;\n\n  /**\n   * The method removes a previously added function via ${@link Page.exposeFunction}\n   * called `name` from the page's `window` object.\n   */\n  async removeExposedFunction(name: string): Promise<void>;\n  async removeExposedFunction(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Provide credentials for `HTTP authentication`.\n   *\n   * @remarks\n   * To disable authentication, pass `null`.\n   */\n  async authenticate(credentials: Credentials): Promise<void>;\n  async authenticate(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The extra HTTP headers will be sent with every request the page initiates.\n   *\n   * :::tip\n   *\n   * All HTTP header names are lowercased. (HTTP headers are\n   * case-insensitive, so this shouldnât impact your server code.)\n   *\n   * :::\n   *\n   * :::note\n   *\n   * page.setExtraHTTPHeaders does not guarantee the order of headers in\n   * the outgoing requests.\n   *\n   * :::\n   *\n   * @param headers - An object containing additional HTTP headers to be sent\n   * with every request. All header values must be strings.\n   */\n  async setExtraHTTPHeaders(headers: Record<string, string>): Promise<void>;\n  async setExtraHTTPHeaders(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param userAgent - Specific user agent to use in this page\n   * @param userAgentData - Specific user agent client hint data to use in this\n   * page\n   * @returns Promise which resolves when the user agent is set.\n   */\n  abstract setUserAgent(\n    userAgent: string,\n    userAgentMetadata?: Protocol.Emulation.UserAgentMetadata\n  ): Promise<void>;\n\n  /**\n   * Object containing metrics as key/value pairs.\n   *\n   * @returns\n   *\n   * - `Timestamp` : The timestamp when the metrics sample was taken.\n   *\n   * - `Documents` : Number of documents in the page.\n   *\n   * - `Frames` : Number of frames in the page.\n   *\n   * - `JSEventListeners` : Number of events in the page.\n   *\n   * - `Nodes` : Number of DOM nodes in the page.\n   *\n   * - `LayoutCount` : Total number of full or partial page layout.\n   *\n   * - `RecalcStyleCount` : Total number of page style recalculations.\n   *\n   * - `LayoutDuration` : Combined durations of all page layouts.\n   *\n   * - `RecalcStyleDuration` : Combined duration of all page style\n   *   recalculations.\n   *\n   * - `ScriptDuration` : Combined duration of JavaScript execution.\n   *\n   * - `TaskDuration` : Combined duration of all tasks performed by the browser.\n   *\n   * - `JSHeapUsedSize` : Used JavaScript heap size.\n   *\n   * - `JSHeapTotalSize` : Total JavaScript heap size.\n   *\n   * @remarks\n   * All timestamps are in monotonic time: monotonically increasing time\n   * in seconds since an arbitrary point in the past.\n   */\n  async metrics(): Promise<Metrics> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * The page's URL.\n   * @remarks Shortcut for\n   * {@link Frame.url | page.mainFrame().url()}.\n   */\n  url(): string {\n    return this.mainFrame().url();\n  }\n\n  /**\n   * The full HTML contents of the page, including the DOCTYPE.\n   */\n  async content(): Promise<string> {\n    return await this.mainFrame().content();\n  }\n\n  /**\n   * Set the content of the page.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Parameters that has some properties.\n   * @remarks\n   * The parameter `options` might have the following options.\n   *\n   * - `timeout` : Maximum time in milliseconds for resources to load, defaults\n   *   to 30 seconds, pass `0` to disable timeout. The default value can be\n   *   changed by using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider setting markup succeeded, defaults to\n   *   `load`. Given an array of event strings, setting content is considered\n   *   to be successful after all events have been fired. Events can be\n   *   either:<br/>\n   * - `load` : consider setting content to be finished when the `load` event\n   *   is fired.<br/>\n   * - `domcontentloaded` : consider setting content to be finished when the\n   *   `DOMContentLoaded` event is fired.<br/>\n   * - `networkidle0` : consider setting content to be finished when there are\n   *   no more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider setting content to be finished when there are\n   *   no more than 2 network connections for at least `500` ms.\n   */\n  async setContent(html: string, options?: WaitForOptions): Promise<void> {\n    await this.mainFrame().setContent(html, options);\n  }\n\n  /**\n   * Navigates the page to the given `url`.\n   *\n   * @remarks\n   * Navigation to `about:blank` or navigation to the same URL with a different\n   * hash will succeed and return `null`.\n   *\n   * :::warning\n   *\n   * Headless mode doesn't support navigation to a PDF document. See the {@link\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * :::\n   *\n   * Shortcut for {@link Frame.goto | page.mainFrame().goto(url, options)}.\n   *\n   * @param url - URL to navigate page to. The URL should include scheme, e.g.\n   * `https://`\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @throws If:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   * - target URL is invalid.\n   * - the timeout is exceeded during navigation.\n   * - the remote server does not respond or is unreachable.\n   * - the main resource failed to load.\n   *\n   * This method will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\". The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   */\n  async goto(url: string, options?: GoToOptions): Promise<HTTPResponse | null> {\n    return await this.mainFrame().goto(url, options);\n  }\n\n  /**\n   * Reloads the page.\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   */\n  abstract reload(options?: WaitForOptions): Promise<HTTPResponse | null>;\n\n  /**\n   * Waits for the page to navigate to a new URL or to reload. It is useful when\n   * you run code that will indirectly cause the page to navigate.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(), // The promise resolves after navigation has finished\n   *   page.click('a.my-link'), // Clicking the link will indirectly cause a navigation\n   * ]);\n   * ```\n   *\n   * @remarks\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @param options - Navigation parameters which might have the following\n   * properties:\n   * @returns A `Promise` which resolves to the main resource response.\n   *\n   * - In case of multiple redirects, the navigation will resolve with the\n   *   response of the last redirect.\n   * - In case of navigation to a different anchor or navigation due to History\n   *   API usage, the navigation will resolve with `null`.\n   */\n  async waitForNavigation(\n    options: WaitForOptions = {}\n  ): Promise<HTTPResponse | null> {\n    return await this.mainFrame().waitForNavigation(options);\n  }\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched request\n   * @example\n   *\n   * ```ts\n   * const firstRequest = await page.waitForRequest(\n   *   'https://example.com/resource'\n   * );\n   * const finalRequest = await page.waitForRequest(\n   *   request => request.url() === 'https://example.com'\n   * );\n   * return finalRequest.response()?.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Waiting Parameters have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds, pass\n   *   `0` to disable the timeout. The default value can be changed by using the\n   *   {@link Page.setDefaultTimeout} method.\n   */\n  abstract waitForRequest(\n    urlOrPredicate: string | ((req: HTTPRequest) => boolean | Promise<boolean>),\n    options?: {timeout?: number}\n  ): Promise<HTTPRequest>;\n\n  /**\n   * @param urlOrPredicate - A URL or predicate to wait for.\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves to the matched response.\n   * @example\n   *\n   * ```ts\n   * const firstResponse = await page.waitForResponse(\n   *   'https://example.com/resource'\n   * );\n   * const finalResponse = await page.waitForResponse(\n   *   response =>\n   *     response.url() === 'https://example.com' && response.status() === 200\n   * );\n   * const finalResponse = await page.waitForResponse(async response => {\n   *   return (await response.text()).includes('<html>');\n   * });\n   * return finalResponse.ok();\n   * ```\n   *\n   * @remarks\n   * Optional Parameter have:\n   *\n   * - `timeout`: Maximum wait time in milliseconds, defaults to `30` seconds,\n   *   pass `0` to disable the timeout. The default value can be changed by using\n   *   the {@link Page.setDefaultTimeout} method.\n   */\n  abstract waitForResponse(\n    urlOrPredicate:\n      | string\n      | ((res: HTTPResponse) => boolean | Promise<boolean>),\n    options?: {timeout?: number}\n  ): Promise<HTTPResponse>;\n\n  /**\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when network is idle\n   */\n  abstract waitForNetworkIdle(options?: {\n    idleTime?: number;\n    timeout?: number;\n  }): Promise<void>;\n\n  /**\n   * @internal\n   */\n  _waitForNetworkIdle(\n    networkManager: BidiNetworkManager | CdpNetworkManager,\n    idleTime: number,\n    requestsInFlight = 0\n  ): Observable<void> {\n    return merge(\n      fromEvent(\n        networkManager,\n        NetworkManagerEvent.Request as unknown as string\n      ) as Observable<void>,\n      fromEvent(\n        networkManager,\n        NetworkManagerEvent.Response as unknown as string\n      ) as Observable<void>,\n      fromEvent(\n        networkManager,\n        NetworkManagerEvent.RequestFailed as unknown as string\n      ) as Observable<void>\n    ).pipe(\n      startWith(undefined),\n      filter(() => {\n        return networkManager.inFlightRequestsCount() <= requestsInFlight;\n      }),\n      switchMap(v => {\n        return of(v).pipe(delay(idleTime));\n      })\n    );\n  }\n\n  /**\n   * Waits for a frame matching the given conditions to appear.\n   *\n   * @example\n   *\n   * ```ts\n   * const frame = await page.waitForFrame(async frame => {\n   *   return frame.name() === 'Test';\n   * });\n   * ```\n   */\n  async waitForFrame(\n    urlOrPredicate: string | ((frame: Frame) => Awaitable<boolean>),\n    options: WaitTimeoutOptions = {}\n  ): Promise<Frame> {\n    const {timeout: ms = this.getDefaultTimeout()} = options;\n\n    if (isString(urlOrPredicate)) {\n      urlOrPredicate = (frame: Frame) => {\n        return urlOrPredicate === frame.url();\n      };\n    }\n\n    return await firstValueFrom(\n      merge(\n        fromEvent(this, PageEvent.FrameAttached) as Observable<Frame>,\n        fromEvent(this, PageEvent.FrameNavigated) as Observable<Frame>,\n        from(this.frames())\n      ).pipe(\n        filterAsync(urlOrPredicate),\n        first(),\n        raceWith(\n          timeout(ms),\n          fromEvent(this, PageEvent.Close).pipe(\n            map(() => {\n              throw new TargetCloseError('Page closed.');\n            })\n          )\n        )\n      )\n    );\n  }\n\n  /**\n   * This method navigate to the previous page in history.\n   * @param options - Navigation parameters\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go back, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil` : When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  async goBack(options?: WaitForOptions): Promise<HTTPResponse | null>;\n  async goBack(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method navigate to the next page in history.\n   * @param options - Navigation Parameter\n   * @returns Promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect. If can not go forward, resolves to `null`.\n   * @remarks\n   * The argument `options` might have the following properties:\n   *\n   * - `timeout` : Maximum navigation time in milliseconds, defaults to 30\n   *   seconds, pass 0 to disable timeout. The default value can be changed by\n   *   using the {@link Page.setDefaultNavigationTimeout} or\n   *   {@link Page.setDefaultTimeout} methods.\n   *\n   * - `waitUntil`: When to consider navigation succeeded, defaults to `load`.\n   *   Given an array of event strings, navigation is considered to be\n   *   successful after all events have been fired. Events can be either:<br/>\n   * - `load` : consider navigation to be finished when the load event is\n   *   fired.<br/>\n   * - `domcontentloaded` : consider navigation to be finished when the\n   *   DOMContentLoaded event is fired.<br/>\n   * - `networkidle0` : consider navigation to be finished when there are no\n   *   more than 0 network connections for at least `500` ms.<br/>\n   * - `networkidle2` : consider navigation to be finished when there are no\n   *   more than 2 network connections for at least `500` ms.\n   */\n  async goForward(options?: WaitForOptions): Promise<HTTPResponse | null>;\n  async goForward(): Promise<HTTPResponse | null> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Brings page to front (activates tab).\n   */\n  abstract bringToFront(): Promise<void>;\n\n  /**\n   * Emulates a given device's metrics and user agent.\n   *\n   * To aid emulation, Puppeteer provides a list of known devices that can be\n   * via {@link KnownDevices}.\n   *\n   * @remarks\n   * This method is a shortcut for calling two methods:\n   * {@link Page.setUserAgent} and {@link Page.setViewport}.\n   *\n   * @remarks\n   * This method will resize the page. A lot of websites don't expect phones to\n   * change size, so you should emulate before navigating to the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import {KnownDevices} from 'puppeteer';\n   * const iPhone = KnownDevices['iPhone 6'];\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.emulate(iPhone);\n   *   await page.goto('https://www.google.com');\n   *   // other actions...\n   *   await browser.close();\n   * })();\n   * ```\n   */\n  async emulate(device: Device): Promise<void> {\n    await Promise.all([\n      this.setUserAgent(device.userAgent),\n      this.setViewport(device.viewport),\n    ]);\n  }\n\n  /**\n   * @param enabled - Whether or not to enable JavaScript on the page.\n   * @remarks\n   * NOTE: changing this value won't affect scripts that have already been run.\n   * It will take full effect on the next navigation.\n   */\n  async setJavaScriptEnabled(enabled: boolean): Promise<void>;\n  async setJavaScriptEnabled(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Toggles bypassing page's Content-Security-Policy.\n   * @param enabled - sets bypassing of page's Content-Security-Policy.\n   * @remarks\n   * NOTE: CSP bypassing happens at the moment of CSP initialization rather than\n   * evaluation. Usually, this means that `page.setBypassCSP` should be called\n   * before navigating to the domain.\n   */\n  abstract setBypassCSP(enabled: boolean): Promise<void>;\n\n  /**\n   * @param type - Changes the CSS media type of the page. The only allowed\n   * values are `screen`, `print` and `null`. Passing `null` disables CSS media\n   * emulation.\n   * @example\n   *\n   * ```ts\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // â true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // â false\n   *\n   * await page.emulateMediaType('print');\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // â false\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // â true\n   *\n   * await page.emulateMediaType(null);\n   * await page.evaluate(() => matchMedia('screen').matches);\n   * // â true\n   * await page.evaluate(() => matchMedia('print').matches);\n   * // â false\n   * ```\n   */\n  async emulateMediaType(type?: string): Promise<void>;\n  async emulateMediaType(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Enables CPU throttling to emulate slow CPUs.\n   * @param factor - slowdown factor (1 is no throttle, 2 is 2x slowdown, etc).\n   */\n  async emulateCPUThrottling(factor: number | null): Promise<void>;\n  async emulateCPUThrottling(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param features - `<?Array<Object>>` Given an array of media feature\n   * objects, emulates CSS media features on the page. Each media feature object\n   * must have the following properties:\n   * @example\n   *\n   * ```ts\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // â true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // â false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // â true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // â false\n   *\n   * await page.emulateMediaFeatures([\n   *   {name: 'prefers-color-scheme', value: 'dark'},\n   *   {name: 'prefers-reduced-motion', value: 'reduce'},\n   * ]);\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: dark)').matches\n   * );\n   * // â true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-color-scheme: light)').matches\n   * );\n   * // â false\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: reduce)').matches\n   * );\n   * // â true\n   * await page.evaluate(\n   *   () => matchMedia('(prefers-reduced-motion: no-preference)').matches\n   * );\n   * // â false\n   *\n   * await page.emulateMediaFeatures([{name: 'color-gamut', value: 'p3'}]);\n   * await page.evaluate(() => matchMedia('(color-gamut: srgb)').matches);\n   * // â true\n   * await page.evaluate(() => matchMedia('(color-gamut: p3)').matches);\n   * // â true\n   * await page.evaluate(() => matchMedia('(color-gamut: rec2020)').matches);\n   * // â false\n   * ```\n   */\n  async emulateMediaFeatures(features?: MediaFeature[]): Promise<void>;\n  async emulateMediaFeatures(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @param timezoneId - Changes the timezone of the page. See\n   * {@link https://source.chromium.org/chromium/chromium/deps/icu.git/+/faee8bc70570192d82d2978a71e2a615788597d1:source/data/misc/metaZones.txt | ICUâs metaZones.txt}\n   * for a list of supported timezone IDs. Passing\n   * `null` disables timezone emulation.\n   */\n  async emulateTimezone(timezoneId?: string): Promise<void>;\n  async emulateTimezone(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Emulates the idle state.\n   * If no arguments set, clears idle state emulation.\n   *\n   * @example\n   *\n   * ```ts\n   * // set idle emulation\n   * await page.emulateIdleState({isUserActive: true, isScreenUnlocked: false});\n   *\n   * // do some checks here\n   * ...\n   *\n   * // clear idle emulation\n   * await page.emulateIdleState();\n   * ```\n   *\n   * @param overrides - Mock idle state. If not set, clears idle overrides\n   */\n  async emulateIdleState(overrides?: {\n    isUserActive: boolean;\n    isScreenUnlocked: boolean;\n  }): Promise<void>;\n  async emulateIdleState(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Simulates the given vision deficiency on the page.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   await page.goto('https://v8.dev/blog/10-years');\n   *\n   *   await page.emulateVisionDeficiency('achromatopsia');\n   *   await page.screenshot({path: 'achromatopsia.png'});\n   *\n   *   await page.emulateVisionDeficiency('deuteranopia');\n   *   await page.screenshot({path: 'deuteranopia.png'});\n   *\n   *   await page.emulateVisionDeficiency('blurredVision');\n   *   await page.screenshot({path: 'blurred-vision.png'});\n   *\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param type - the type of deficiency to simulate, or `'none'` to reset.\n   */\n  async emulateVisionDeficiency(\n    type?: Protocol.Emulation.SetEmulatedVisionDeficiencyRequest['type']\n  ): Promise<void>;\n  async emulateVisionDeficiency(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * `page.setViewport` will resize the page. A lot of websites don't expect\n   * phones to change size, so you should set the viewport before navigating to\n   * the page.\n   *\n   * In the case of multiple pages in a single browser, each page can have its\n   * own viewport size.\n   * @example\n   *\n   * ```ts\n   * const page = await browser.newPage();\n   * await page.setViewport({\n   *   width: 640,\n   *   height: 480,\n   *   deviceScaleFactor: 1,\n   * });\n   * await page.goto('https://example.com');\n   * ```\n   *\n   * @param viewport -\n   * @remarks\n   * Argument viewport have following properties:\n   *\n   * - `width`: page width in pixels. required\n   *\n   * - `height`: page height in pixels. required\n   *\n   * - `deviceScaleFactor`: Specify device scale factor (can be thought of as\n   *   DPR). Defaults to `1`.\n   *\n   * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults\n   *   to `false`.\n   *\n   * - `hasTouch`: Specifies if viewport supports touch events. Defaults to `false`\n   *\n   * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to false.\n   *\n   * NOTE: in certain cases, setting viewport will reload the page in order to\n   * set the isMobile or hasTouch properties.\n   */\n  abstract setViewport(viewport: Viewport): Promise<void>;\n\n  /**\n   * Current page viewport settings.\n   *\n   * @returns\n   *\n   * - `width`: page's width in pixels\n   *\n   * - `height`: page's height in pixels\n   *\n   * - `deviceScaleFactor`: Specify device scale factor (can be though of as\n   *   dpr). Defaults to `1`.\n   *\n   * - `isMobile`: Whether the meta viewport tag is taken into account. Defaults\n   *   to `false`.\n   *\n   * - `hasTouch`: Specifies if viewport supports touch events. Defaults to\n   *   `false`.\n   *\n   * - `isLandScape`: Specifies if viewport is in landscape mode. Defaults to\n   *   `false`.\n   */\n  abstract viewport(): Viewport | null;\n\n  /**\n   * Evaluates a function in the page's context and returns the result.\n   *\n   * If the function passed to `page.evaluate` returns a Promise, the\n   * function will wait for the promise to resolve and return its value.\n   *\n   * @example\n   *\n   * ```ts\n   * const result = await frame.evaluate(() => {\n   *   return Promise.resolve(8 * 7);\n   * });\n   * console.log(result); // prints \"56\"\n   * ```\n   *\n   * You can pass a string instead of a function (although functions are\n   * recommended as they are easier to debug and use with TypeScript):\n   *\n   * @example\n   *\n   * ```ts\n   * const aHandle = await page.evaluate('1 + 2');\n   * ```\n   *\n   * To get the best TypeScript experience, you should pass in as the\n   * generic the type of `pageFunction`:\n   *\n   * ```ts\n   * const aHandle = await page.evaluate(() => 2);\n   * ```\n   *\n   * @example\n   *\n   * {@link ElementHandle} instances (including {@link JSHandle}s) can be passed\n   * as arguments to the `pageFunction`:\n   *\n   * ```ts\n   * const bodyHandle = await page.$('body');\n   * const html = await page.evaluate(body => body.innerHTML, bodyHandle);\n   * await bodyHandle.dispose();\n   * ```\n   *\n   * @param pageFunction - a function that is run within the page\n   * @param args - arguments to be passed to the pageFunction\n   *\n   * @returns the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainFrame().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Adds a function which would be invoked in one of the following scenarios:\n   *\n   * - whenever the page is navigated\n   *\n   * - whenever the child frame is attached or navigated. In this case, the\n   *   function is invoked in the context of the newly attached frame.\n   *\n   * The function is invoked after the document was created but before any of\n   * its scripts were run. This is useful to amend the JavaScript environment,\n   * e.g. to seed `Math.random`.\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param args - Arguments to pass to `pageFunction`\n   * @example\n   * An example of overriding the navigator.languages property before the page loads:\n   *\n   * ```ts\n   * // preload.js\n   *\n   * // overwrite the `languages` property to use a custom getter\n   * Object.defineProperty(navigator, 'languages', {\n   *   get: function () {\n   *     return ['en-US', 'en', 'bn'];\n   *   },\n   * });\n   *\n   * // In your puppeteer script, assuming the preload.js file is\n   * // in same folder of our script.\n   * const preloadFile = fs.readFileSync('./preload.js', 'utf8');\n   * await page.evaluateOnNewDocument(preloadFile);\n   * ```\n   */\n  abstract evaluateOnNewDocument<\n    Params extends unknown[],\n    Func extends (...args: Params) => unknown = (...args: Params) => unknown,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<NewDocumentScriptEvaluation>;\n\n  /**\n   * Removes script that injected into page by Page.evaluateOnNewDocument.\n   *\n   * @param identifier - script identifier\n   */\n  abstract removeScriptToEvaluateOnNewDocument(\n    identifier: string\n  ): Promise<void>;\n\n  /**\n   * Toggles ignoring cache for each request based on the enabled state. By\n   * default, caching is enabled.\n   * @param enabled - sets the `enabled` state of cache\n   * @defaultValue `true`\n   */\n  abstract setCacheEnabled(enabled?: boolean): Promise<void>;\n\n  /**\n   * @internal\n   */\n  async _maybeWriteBufferToFile(\n    path: string | undefined,\n    buffer: Buffer\n  ): Promise<void> {\n    if (!path) {\n      return;\n    }\n\n    const fs = await importFSPromises();\n\n    await fs.writeFile(path, buffer);\n  }\n\n  /**\n   * Captures a screencast of this {@link Page | page}.\n   *\n   * @remarks\n   *\n   * All recordings will be {@link https://www.webmproject.org/ | WebM} format using\n   * the {@link https://www.webmproject.org/vp9/ | VP9} video codec. The FPS is 30.\n   *\n   * You must have {@link https://ffmpeg.org/ | ffmpeg} installed on your system.\n   *\n   * @example\n   * Recording a {@link Page | page}:\n   *\n   * ```\n   * import puppeteer from 'puppeteer';\n   *\n   * // Launch a browser\n   * const browser = await puppeteer.launch();\n   *\n   * // Create a new page\n   * const page = await browser.newPage();\n   *\n   * // Go to your site.\n   * await page.goto(\"https://www.example.com\");\n   *\n   * // Start recording.\n   * const recorder = await page.screencast({path: 'recording.webm'});\n   *\n   * // Do something.\n   *\n   * // Stop recording.\n   * await recorder.stop();\n   *\n   * browser.close();\n   * ```\n   *\n   * @param options - Configures screencast behavior.\n   *\n   * @experimental\n   */\n  async screencast(\n    options: Readonly<ScreencastOptions> = {}\n  ): Promise<ScreenRecorder> {\n    const [{ScreenRecorder}, [width, height, devicePixelRatio]] =\n      await Promise.all([\n        import('../node/ScreenRecorder.js'),\n        this.#getNativePixelDimensions(),\n      ]);\n\n    let crop: BoundingBox | undefined;\n    if (options.crop) {\n      const {\n        x,\n        y,\n        width: cropWidth,\n        height: cropHeight,\n      } = roundRectangle(normalizeRectangle(options.crop));\n      if (x < 0 || y < 0) {\n        throw new Error(\n          `\\`crop.x\\` and \\`crop.y\\` must be greater than or equal to 0.`\n        );\n      }\n      if (cropWidth <= 0 || cropHeight <= 0) {\n        throw new Error(\n          `\\`crop.height\\` and \\`crop.width\\` must be greater than or equal to 0.`\n        );\n      }\n\n      const viewportWidth = width / devicePixelRatio;\n      const viewportHeight = width / devicePixelRatio;\n      if (x + cropWidth > viewportWidth) {\n        throw new Error(\n          `\\`crop.width\\` cannot be larger than the viewport width (${viewportWidth}).`\n        );\n      }\n      if (y + cropHeight > viewportHeight) {\n        throw new Error(\n          `\\`crop.height\\` cannot be larger than the viewport height (${viewportHeight}).`\n        );\n      }\n\n      crop = {\n        x: x * devicePixelRatio,\n        y: y * devicePixelRatio,\n        width: cropWidth * devicePixelRatio,\n        height: cropHeight * devicePixelRatio,\n      };\n    }\n    if (options.speed !== undefined && options.speed <= 0) {\n      throw new Error(`\\`speed\\` must be greater than 0.`);\n    }\n    if (options.scale !== undefined && options.scale <= 0) {\n      throw new Error(`\\`scale\\` must be greater than 0.`);\n    }\n\n    const recorder = new ScreenRecorder(this, width, height, {\n      ...options,\n      path: options.ffmpegPath,\n      crop,\n    });\n    try {\n      await this._startScreencast();\n    } catch (error) {\n      void recorder.stop();\n      throw error;\n    }\n    if (options.path) {\n      const {createWriteStream} = await import('fs');\n      const stream = createWriteStream(options.path, 'binary');\n      recorder.pipe(stream);\n    }\n    return recorder;\n  }\n\n  #screencastSessionCount = 0;\n  #startScreencastPromise: Promise<void> | undefined;\n\n  /**\n   * @internal\n   */\n  async _startScreencast(): Promise<void> {\n    ++this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      this.#startScreencastPromise = this.mainFrame()\n        .client.send('Page.startScreencast', {format: 'png'})\n        .then(() => {\n          // Wait for the first frame.\n          return new Promise(resolve => {\n            return this.mainFrame().client.once('Page.screencastFrame', () => {\n              return resolve();\n            });\n          });\n        });\n    }\n    await this.#startScreencastPromise;\n  }\n\n  /**\n   * @internal\n   */\n  async _stopScreencast(): Promise<void> {\n    --this.#screencastSessionCount;\n    if (!this.#startScreencastPromise) {\n      return;\n    }\n    this.#startScreencastPromise = undefined;\n    if (this.#screencastSessionCount === 0) {\n      await this.mainFrame().client.send('Page.stopScreencast');\n    }\n  }\n\n  /**\n   * Gets the native, non-emulated dimensions of the viewport.\n   */\n  async #getNativePixelDimensions(): Promise<\n    readonly [width: number, height: number, devicePixelRatio: number]\n  > {\n    const viewport = this.viewport();\n    using stack = new DisposableStack();\n    if (viewport && viewport.deviceScaleFactor !== 0) {\n      await this.setViewport({...viewport, deviceScaleFactor: 0});\n      stack.defer(() => {\n        void this.setViewport(viewport).catch(debugError);\n      });\n    }\n    return await this.mainFrame()\n      .isolatedRealm()\n      .evaluate(() => {\n        return [\n          window.visualViewport!.width * window.devicePixelRatio,\n          window.visualViewport!.height * window.devicePixelRatio,\n          window.devicePixelRatio,\n        ] as const;\n      });\n  }\n\n  /**\n   * Captures a screenshot of this {@link Page | page}.\n   *\n   * @param options - Configures screenshot behavior.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Buffer>;\n  @guarded(function () {\n    return this.browser();\n  })\n  async screenshot(\n    userOptions: Readonly<ScreenshotOptions> = {}\n  ): Promise<Buffer | string> {\n    await this.bringToFront();\n\n    // TODO: use structuredClone after Node 16 support is dropped.Â«\n    const options = {\n      ...userOptions,\n      clip: userOptions.clip\n        ? {\n            ...userOptions.clip,\n          }\n        : undefined,\n    };\n    if (options.type === undefined && options.path !== undefined) {\n      const filePath = options.path;\n      // Note we cannot use Node.js here due to browser compatability.\n      const extension = filePath\n        .slice(filePath.lastIndexOf('.') + 1)\n        .toLowerCase();\n      switch (extension) {\n        case 'png':\n          options.type = 'png';\n          break;\n        case 'jpeg':\n        case 'jpg':\n          options.type = 'jpeg';\n          break;\n        case 'webp':\n          options.type = 'webp';\n          break;\n      }\n    }\n    if (options.quality !== undefined) {\n      if (options.quality < 0 && options.quality > 100) {\n        throw new Error(\n          `Expected 'quality' (${options.quality}) to be between 0 and 100, inclusive.`\n        );\n      }\n      if (\n        options.type === undefined ||\n        !['jpeg', 'webp'].includes(options.type)\n      ) {\n        throw new Error(\n          `${options.type ?? 'png'} screenshots do not support 'quality'.`\n        );\n      }\n    }\n    assert(\n      !options.clip || !options.fullPage,\n      \"'clip' and 'fullPage' are exclusive\"\n    );\n    if (options.clip) {\n      if (options.clip.width <= 0) {\n        throw new Error(\"'width' in 'clip' must be positive.\");\n      }\n      if (options.clip.height <= 0) {\n        throw new Error(\"'height' in 'clip' must be positive.\");\n      }\n    }\n\n    setDefaultScreenshotOptions(options);\n\n    options.clip =\n      options.clip && roundRectangle(normalizeRectangle(options.clip));\n\n    await using stack = new AsyncDisposableStack();\n    if (options.allowViewportExpansion || options.captureBeyondViewport) {\n      if (options.fullPage) {\n        const dimensions = await this.mainFrame()\n          .isolatedRealm()\n          .evaluate(() => {\n            const {scrollHeight, scrollWidth} = document.documentElement;\n            const {height: viewportHeight, width: viewportWidth} =\n              window.visualViewport!;\n            return {\n              height: Math.max(scrollHeight, viewportHeight),\n              width: Math.max(scrollWidth, viewportWidth),\n            };\n          });\n        options.clip = {...dimensions, x: 0, y: 0};\n        stack.use(\n          await this._createTemporaryViewportContainingBox(options.clip)\n        );\n      } else if (options.clip && !options.captureBeyondViewport) {\n        stack.use(\n          options.clip &&\n            (await this._createTemporaryViewportContainingBox(options.clip))\n        );\n      } else if (!options.clip) {\n        options.captureBeyondViewport = false;\n      }\n    }\n\n    const data = await this._screenshot(options);\n    if (options.encoding === 'base64') {\n      return data;\n    }\n    const buffer = Buffer.from(data, 'base64');\n    await this._maybeWriteBufferToFile(options.path, buffer);\n    return buffer;\n  }\n\n  /**\n   * @internal\n   */\n  abstract _screenshot(options: Readonly<ScreenshotOptions>): Promise<string>;\n\n  /**\n   * @internal\n   */\n  async _createTemporaryViewportContainingBox(\n    clip: ScreenshotClip\n  ): Promise<AsyncDisposable> {\n    const viewport = await this.mainFrame()\n      .isolatedRealm()\n      .evaluate(() => {\n        return {\n          pageLeft: window.visualViewport!.pageLeft,\n          pageTop: window.visualViewport!.pageTop,\n          width: window.visualViewport!.width,\n          height: window.visualViewport!.height,\n        };\n      });\n    await using stack = new AsyncDisposableStack();\n    if (clip.x < viewport.pageLeft || clip.y < viewport.pageTop) {\n      await this.evaluate(\n        (left, top) => {\n          window.scroll({left, top, behavior: 'instant'});\n        },\n        Math.floor(clip.x),\n        Math.floor(clip.y)\n      );\n      stack.defer(async () => {\n        await this.evaluate(\n          (left, top) => {\n            window.scroll({left, top, behavior: 'instant'});\n          },\n          viewport.pageLeft,\n          viewport.pageTop\n        ).catch(debugError);\n      });\n    }\n    if (\n      clip.width + clip.x > viewport.width ||\n      clip.height + clip.y > viewport.height\n    ) {\n      const originalViewport = this.viewport() ?? {\n        width: 0,\n        height: 0,\n      };\n      // We add 1 for fractional x and y.\n      await this.setViewport({\n        width: Math.max(viewport.width, Math.ceil(clip.width + clip.x)),\n        height: Math.max(viewport.height, Math.ceil(clip.height + clip.y)),\n      });\n      stack.defer(async () => {\n        await this.setViewport(originalViewport).catch(debugError);\n      });\n    }\n    return stack.move();\n  }\n\n  /**\n   * @internal\n   */\n  _getPDFOptions(\n    options: PDFOptions = {},\n    lengthUnit: 'in' | 'cm' = 'in'\n  ): ParsedPDFOptions {\n    const defaults: Omit<ParsedPDFOptions, 'width' | 'height' | 'margin'> = {\n      scale: 1,\n      displayHeaderFooter: false,\n      headerTemplate: '',\n      footerTemplate: '',\n      printBackground: false,\n      landscape: false,\n      pageRanges: '',\n      preferCSSPageSize: false,\n      omitBackground: false,\n      timeout: 30000,\n      tagged: false,\n    };\n\n    let width = 8.5;\n    let height = 11;\n    if (options.format) {\n      const format =\n        paperFormats[options.format.toLowerCase() as LowerCasePaperFormat];\n      assert(format, 'Unknown paper format: ' + options.format);\n      width = format.width;\n      height = format.height;\n    } else {\n      width = convertPrintParameterToInches(options.width, lengthUnit) ?? width;\n      height =\n        convertPrintParameterToInches(options.height, lengthUnit) ?? height;\n    }\n\n    const margin = {\n      top: convertPrintParameterToInches(options.margin?.top, lengthUnit) || 0,\n      left:\n        convertPrintParameterToInches(options.margin?.left, lengthUnit) || 0,\n      bottom:\n        convertPrintParameterToInches(options.margin?.bottom, lengthUnit) || 0,\n      right:\n        convertPrintParameterToInches(options.margin?.right, lengthUnit) || 0,\n    };\n\n    return {\n      ...defaults,\n      ...options,\n      width,\n      height,\n      margin,\n    };\n  }\n\n  /**\n   * Generates a PDF of the page with the `print` CSS media type.\n   * @remarks\n   *\n   * To generate a PDF with the `screen` media type, call\n   * {@link Page.emulateMediaType | `page.emulateMediaType('screen')`} before\n   * calling `page.pdf()`.\n   *\n   * By default, `page.pdf()` generates a pdf with modified colors for printing.\n   * Use the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-print-color-adjust | `-webkit-print-color-adjust`}\n   * property to force rendering of exact colors.\n   *\n   * @param options - options for generating the PDF.\n   */\n  async createPDFStream(options?: PDFOptions): Promise<Readable>;\n  async createPDFStream(): Promise<Readable> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * {@inheritDoc Page.createPDFStream}\n   */\n  abstract pdf(options?: PDFOptions): Promise<Buffer>;\n\n  /**\n   * The page's title\n   *\n   * @remarks\n   * Shortcut for {@link Frame.title | page.mainFrame().title()}.\n   */\n  async title(): Promise<string> {\n    return await this.mainFrame().title();\n  }\n\n  abstract close(options?: {runBeforeUnload?: boolean}): Promise<void>;\n\n  /**\n   * Indicates that the page has been closed.\n   * @returns\n   */\n  abstract isClosed(): boolean;\n\n  /**\n   * {@inheritDoc Mouse}\n   */\n  abstract get mouse(): Mouse;\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse} to click in the center of the\n   * element. If there's no element matching `selector`, the method throws an\n   * error.\n   * @remarks Bear in mind that if `click()` triggers a navigation event and\n   * there's a separate `page.waitForNavigation()` promise to be resolved, you\n   * may end up with a race condition that yields unexpected results. The\n   * correct pattern for click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   page.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * Shortcut for {@link Frame.click | page.mainFrame().click(selector[, options]) }.\n   * @param selector - A `selector` to search for element to click. If there are\n   * multiple elements satisfying the `selector`, the first will be clicked\n   * @param options - `Object`\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully clicked. The Promise will be rejected if there is no element\n   * matching `selector`.\n   */\n  click(selector: string, options?: Readonly<ClickOptions>): Promise<void> {\n    return this.mainFrame().click(selector, options);\n  }\n\n  /**\n   * This method fetches an element with `selector` and focuses it. If there's no\n   * element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector }\n   * of an element to focus. If there are multiple elements satisfying the\n   * selector, the first will be focused.\n   * @returns Promise which resolves when the element matching selector is\n   * successfully focused. The promise will be rejected if there is no element\n   * matching selector.\n   * @remarks\n   * Shortcut for {@link Frame.focus | page.mainFrame().focus(selector)}.\n   */\n  focus(selector: string): Promise<void> {\n    return this.mainFrame().focus(selector);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.mouse}\n   * to hover over the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * to search for element to hover. If there are multiple elements satisfying\n   * the selector, the first will be hovered.\n   * @returns Promise which resolves when the element matching `selector` is\n   * successfully hovered. Promise gets rejected if there's no element matching\n   * `selector`.\n   * @remarks\n   * Shortcut for {@link Page.hover | page.mainFrame().hover(selector)}.\n   */\n  hover(selector: string): Promise<void> {\n    return this.mainFrame().hover(selector);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * page.select('select#colors', 'blue'); // single selection\n   * page.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to query the page for\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first one\n   * is taken into account.\n   * @returns\n   *\n   * @remarks\n   * Shortcut for {@link Frame.select | page.mainFrame().select()}\n   */\n  select(selector: string, ...values: string[]): Promise<string[]> {\n    return this.mainFrame().select(selector, ...values);\n  }\n\n  /**\n   * This method fetches an element with `selector`, scrolls it into view if\n   * needed, and then uses {@link Page | Page.touchscreen}\n   * to tap in the center of the element.\n   * If there's no element matching `selector`, the method throws an error.\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | Selector}\n   * to search for element to tap. If there are multiple elements satisfying the\n   * selector, the first will be tapped.\n   * @returns\n   * @remarks\n   * Shortcut for {@link Frame.tap | page.mainFrame().tap(selector)}.\n   */\n  tap(selector: string): Promise<void> {\n    return this.mainFrame().tap(selector);\n  }\n\n  /**\n   * Sends a `keydown`, `keypress/input`, and `keyup` event for each character\n   * in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`, use {@link Keyboard.press}.\n   * @example\n   *\n   * ```ts\n   * await page.type('#mytextarea', 'Hello');\n   * // Types instantly\n   * await page.type('#mytextarea', 'World', {delay: 100});\n   * // Types slower, like a user\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to type into. If there are multiple elements satisfying the\n   * selector, the first will be used.\n   * @param text - A text to type into a focused element.\n   * @param options - have property `delay` which is the Time to wait between\n   * key presses in milliseconds. Defaults to `0`.\n   * @returns\n   * @remarks\n   */\n  type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    return this.mainFrame().type(selector, text, options);\n  }\n\n  /**\n   * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n   *\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```ts\n   * await page.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n  waitForTimeout(milliseconds: number): Promise<void> {\n    return this.mainFrame().waitForTimeout(milliseconds);\n  }\n\n  /**\n   * Wait for the `selector` to appear in page. If at the moment of calling the\n   * method the `selector` already exists, the method will return immediately. If\n   * the `selector` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigations:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors | selector}\n   * of an element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by selector string\n   * is added to DOM. Resolves to `null` if waiting for hidden: `true` and\n   * selector is not found in DOM.\n   * @remarks\n   * The optional Parameter in Arguments `options` are:\n   *\n   * - `visible`: A boolean wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: Wait for element to not be found in the DOM or to be hidden,\n   *   i.e. have `display: none` or `visibility: hidden` CSS properties. Defaults to\n   *   `false`.\n   *\n   * - `timeout`: maximum time to wait for in milliseconds. Defaults to `30000`\n   *   (30 seconds). Pass `0` to disable timeout. The default value can be changed\n   *   by using the {@link Page.setDefaultTimeout} method.\n   */\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    return await this.mainFrame().waitForSelector(selector, options);\n  }\n\n  /**\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * @example\n   * This method works across navigation\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForXPath('//img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param xpath - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n   * element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by xpath string is\n   * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n   * not found in DOM, otherwise resolves to `ElementHandle`.\n   * @remarks\n   * The optional Argument `options` have properties:\n   *\n   * - `visible`: A boolean to wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n   *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *   Defaults to `false`.\n   *\n   * - `timeout`: A number which is maximum time to wait for in milliseconds.\n   *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The default\n   *   value can be changed by using the {@link Page.setDefaultTimeout} method.\n   */\n  waitForXPath(\n    xpath: string,\n    options?: WaitForSelectorOptions\n  ): Promise<ElementHandle<Node> | null> {\n    return this.mainFrame().waitForXPath(xpath, options);\n  }\n\n  /**\n   * Waits for a function to finish evaluating in the page's context.\n   *\n   * @example\n   * The {@link Page.waitForFunction} can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   const watchDog = page.waitForFunction('window.innerWidth < 100');\n   *   await page.setViewport({width: 50, height: 50});\n   *   await watchDog;\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @example\n   * To pass arguments from node.js to the predicate of\n   * {@link Page.waitForFunction} function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await page.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {},\n   *   selector\n   * );\n   * ```\n   *\n   * @example\n   * The predicate of {@link Page.waitForFunction} can be asynchronous too:\n   *\n   * ```ts\n   * const username = 'github-username';\n   * await page.waitForFunction(\n   *   async username => {\n   *     const githubResponse = await fetch(\n   *       `https://api.github.com/users/${username}`\n   *     );\n   *     const githubUser = await githubResponse.json();\n   *     // show the avatar\n   *     const img = document.createElement('img');\n   *     img.src = githubUser.avatar_url;\n   *     // wait 3 seconds\n   *     await new Promise((resolve, reject) => setTimeout(resolve, 3000));\n   *     img.remove();\n   *   },\n   *   {},\n   *   username\n   * );\n   * ```\n   *\n   * @param pageFunction - Function to be evaluated in browser context\n   * @param options - Options for configuring waiting behavior.\n   */\n  waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options?: FrameWaitForFunctionOptions,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return this.mainFrame().waitForFunction(pageFunction, options, ...args);\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   page.waitForDevicePrompt(),\n   *   page.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n  waitForDevicePrompt(): Promise<DeviceRequestPrompt> {\n    throw new Error('Not implemented');\n  }\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.close().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.close();\n  }\n}\n\n/**\n * @internal\n */\nexport const supportedMetrics = new Set<string>([\n  'Timestamp',\n  'Documents',\n  'Frames',\n  'JSEventListeners',\n  'Nodes',\n  'LayoutCount',\n  'RecalcStyleCount',\n  'LayoutDuration',\n  'RecalcStyleDuration',\n  'ScriptDuration',\n  'TaskDuration',\n  'JSHeapUsedSize',\n  'JSHeapTotalSize',\n]);\n\n/**\n * @internal\n */\nexport const unitToPixels = {\n  px: 1,\n  in: 96,\n  cm: 37.8,\n  mm: 3.78,\n};\n\nfunction convertPrintParameterToInches(\n  parameter?: string | number,\n  lengthUnit: 'in' | 'cm' = 'in'\n): number | undefined {\n  if (typeof parameter === 'undefined') {\n    return undefined;\n  }\n  let pixels;\n  if (isNumber(parameter)) {\n    // Treat numbers as pixel values to be aligned with phantom's paperSize.\n    pixels = parameter;\n  } else if (isString(parameter)) {\n    const text = parameter;\n    let unit = text.substring(text.length - 2).toLowerCase();\n    let valueText = '';\n    if (unit in unitToPixels) {\n      valueText = text.substring(0, text.length - 2);\n    } else {\n      // In case of unknown unit try to parse the whole parameter as number of pixels.\n      // This is consistent with phantom's paperSize behavior.\n      unit = 'px';\n      valueText = text;\n    }\n    const value = Number(valueText);\n    assert(!isNaN(value), 'Failed to parse parameter value: ' + text);\n    pixels = value * unitToPixels[unit as keyof typeof unitToPixels];\n  } else {\n    throw new Error(\n      'page.pdf() Cannot handle parameter type: ' + typeof parameter\n    );\n  }\n  return pixels / unitToPixels[lengthUnit];\n}\n\n/** @see https://w3c.github.io/webdriver-bidi/#normalize-rect */\nfunction normalizeRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  return {\n    ...clip,\n    ...(clip.width < 0\n      ? {\n          x: clip.x + clip.width,\n          width: -clip.width,\n        }\n      : {\n          x: clip.x,\n          width: clip.width,\n        }),\n    ...(clip.height < 0\n      ? {\n          y: clip.y + clip.height,\n          height: -clip.height,\n        }\n      : {\n          y: clip.y,\n          height: clip.height,\n        }),\n  };\n}\n\nfunction roundRectangle<BoundingBoxType extends BoundingBox>(\n  clip: Readonly<BoundingBoxType>\n): BoundingBoxType {\n  const x = Math.round(clip.x);\n  const y = Math.round(clip.y);\n  const width = Math.round(clip.width + clip.x - x);\n  const height = Math.round(clip.height + clip.y - y);\n  return {...clip, x, y, width, height};\n}\n"]},"metadata":{},"sourceType":"module"}