{"ast":null,"code":"var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\nfunction mkdirP(p, opts, f, made) {\n  if (typeof opts === 'function') {\n    f = opts;\n    opts = {};\n  } else if (!opts || typeof opts !== 'object') {\n    opts = {\n      mode: opts\n    };\n  }\n  var mode = opts.mode;\n  var xfs = opts.fs || fs;\n  if (mode === undefined) {\n    mode = _0777 & ~process.umask();\n  }\n  if (!made) made = null;\n  var cb = f || function () {};\n  p = path.resolve(p);\n  xfs.mkdir(p, mode, function (er) {\n    if (!er) {\n      made = made || p;\n      return cb(null, made);\n    }\n    switch (er.code) {\n      case 'ENOENT':\n        mkdirP(path.dirname(p), opts, function (er, made) {\n          if (er) cb(er, made);else mkdirP(p, opts, cb, made);\n        });\n        break;\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        xfs.stat(p, function (er2, stat) {\n          // if the stat fails, then that's super weird.\n          // let the original error be the failure reason.\n          if (er2 || !stat.isDirectory()) cb(er, made);else cb(null, made);\n        });\n        break;\n    }\n  });\n}\nmkdirP.sync = function sync(p, opts, made) {\n  if (!opts || typeof opts !== 'object') {\n    opts = {\n      mode: opts\n    };\n  }\n  var mode = opts.mode;\n  var xfs = opts.fs || fs;\n  if (mode === undefined) {\n    mode = _0777 & ~process.umask();\n  }\n  if (!made) made = null;\n  p = path.resolve(p);\n  try {\n    xfs.mkdirSync(p, mode);\n    made = made || p;\n  } catch (err0) {\n    switch (err0.code) {\n      case 'ENOENT':\n        made = sync(path.dirname(p), opts, made);\n        sync(p, opts, made);\n        break;\n\n      // In the case of any other error, just see if there's a dir\n      // there already.  If so, then hooray!  If not, then something\n      // is borked.\n      default:\n        var stat;\n        try {\n          stat = xfs.statSync(p);\n        } catch (err1) {\n          throw err0;\n        }\n        if (!stat.isDirectory()) throw err0;\n        break;\n    }\n  }\n  return made;\n};","map":{"version":3,"names":["path","require","fs","_0777","parseInt","module","exports","mkdirP","mkdirp","p","opts","f","made","mode","xfs","undefined","process","umask","cb","resolve","mkdir","er","code","dirname","stat","er2","isDirectory","sync","mkdirSync","err0","statSync","err1"],"sources":["D:/Julieth-Campos/PSO/node_modules/mkdirp-classic/index.js"],"sourcesContent":["var path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}