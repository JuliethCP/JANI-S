{"ast":null,"code":"import { HTTPResponse } from '../api/HTTPResponse.js';\nimport { ProtocolError } from '../common/Errors.js';\nimport { SecurityDetails } from '../common/SecurityDetails.js';\nimport { Deferred } from '../util/Deferred.js';\n/**\n * @internal\n */\nexport class CdpHTTPResponse extends HTTPResponse {\n  #client;\n  #request;\n  #contentPromise = null;\n  #bodyLoadedDeferred = Deferred.create();\n  #remoteAddress;\n  #status;\n  #statusText;\n  #url;\n  #fromDiskCache;\n  #fromServiceWorker;\n  #headers = {};\n  #securityDetails;\n  #timing;\n  constructor(client, request, responsePayload, extraInfo) {\n    super();\n    this.#client = client;\n    this.#request = request;\n    this.#remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort\n    };\n    this.#statusText = this.#parseStatusTextFromExtraInfo(extraInfo) || responsePayload.statusText;\n    this.#url = request.url();\n    this.#fromDiskCache = !!responsePayload.fromDiskCache;\n    this.#fromServiceWorker = !!responsePayload.fromServiceWorker;\n    this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;\n    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;\n    for (const [key, value] of Object.entries(headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n    this.#securityDetails = responsePayload.securityDetails ? new SecurityDetails(responsePayload.securityDetails) : null;\n    this.#timing = responsePayload.timing || null;\n  }\n  #parseStatusTextFromExtraInfo(extraInfo) {\n    if (!extraInfo || !extraInfo.headersText) {\n      return;\n    }\n    const firstLine = extraInfo.headersText.split('\\r', 1)[0];\n    if (!firstLine) {\n      return;\n    }\n    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);\n    if (!match) {\n      return;\n    }\n    const statusText = match[1];\n    if (!statusText) {\n      return;\n    }\n    return statusText;\n  }\n  _resolveBody(err) {\n    if (err) {\n      return this.#bodyLoadedDeferred.reject(err);\n    }\n    return this.#bodyLoadedDeferred.resolve();\n  }\n  remoteAddress() {\n    return this.#remoteAddress;\n  }\n  url() {\n    return this.#url;\n  }\n  status() {\n    return this.#status;\n  }\n  statusText() {\n    return this.#statusText;\n  }\n  headers() {\n    return this.#headers;\n  }\n  securityDetails() {\n    return this.#securityDetails;\n  }\n  timing() {\n    return this.#timing;\n  }\n  buffer() {\n    if (!this.#contentPromise) {\n      this.#contentPromise = this.#bodyLoadedDeferred.valueOrThrow().then(async () => {\n        try {\n          const response = await this.#client.send('Network.getResponseBody', {\n            requestId: this.#request._requestId\n          });\n          return Buffer.from(response.body, response.base64Encoded ? 'base64' : 'utf8');\n        } catch (error) {\n          if (error instanceof ProtocolError && error.originalMessage === 'No resource with given identifier found') {\n            throw new ProtocolError('Could not load body for this request. This might happen if the request is a preflight request.');\n          }\n          throw error;\n        }\n      });\n    }\n    return this.#contentPromise;\n  }\n  request() {\n    return this.#request;\n  }\n  fromCache() {\n    return this.#fromDiskCache || this.#request._fromMemoryCache;\n  }\n  fromServiceWorker() {\n    return this.#fromServiceWorker;\n  }\n  frame() {\n    return this.#request.frame();\n  }\n}","map":{"version":3,"mappings":"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","names":["HTTPResponse","ProtocolError","SecurityDetails","Deferred","CdpHTTPResponse","create","constructor","client","request","responsePayload","extraInfo","ip","remoteIPAddress","port","remotePort","statusText","url","fromDiskCache","fromServiceWorker","statusCode","status","headers","key","value","Object","entries","toLowerCase","securityDetails","timing","headersText","firstLine","split","match","_resolveBody","err","reject","resolve","remoteAddress","buffer","valueOrThrow","then","response","send","requestId","_requestId","Buffer","from","body","base64Encoded","error","originalMessage","fromCache","_fromMemoryCache","frame"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\HTTPResponse.ts"],"sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Frame} from '../api/Frame.js';\nimport {HTTPResponse, type RemoteAddress} from '../api/HTTPResponse.js';\nimport {ProtocolError} from '../common/Errors.js';\nimport {SecurityDetails} from '../common/SecurityDetails.js';\nimport {Deferred} from '../util/Deferred.js';\n\nimport type {CdpHTTPRequest} from './HTTPRequest.js';\n\n/**\n * @internal\n */\nexport class CdpHTTPResponse extends HTTPResponse {\n  #client: CDPSession;\n  #request: CdpHTTPRequest;\n  #contentPromise: Promise<Buffer> | null = null;\n  #bodyLoadedDeferred = Deferred.create<void, Error>();\n  #remoteAddress: RemoteAddress;\n  #status: number;\n  #statusText: string;\n  #url: string;\n  #fromDiskCache: boolean;\n  #fromServiceWorker: boolean;\n  #headers: Record<string, string> = {};\n  #securityDetails: SecurityDetails | null;\n  #timing: Protocol.Network.ResourceTiming | null;\n\n  constructor(\n    client: CDPSession,\n    request: CdpHTTPRequest,\n    responsePayload: Protocol.Network.Response,\n    extraInfo: Protocol.Network.ResponseReceivedExtraInfoEvent | null\n  ) {\n    super();\n    this.#client = client;\n    this.#request = request;\n\n    this.#remoteAddress = {\n      ip: responsePayload.remoteIPAddress,\n      port: responsePayload.remotePort,\n    };\n    this.#statusText =\n      this.#parseStatusTextFromExtraInfo(extraInfo) ||\n      responsePayload.statusText;\n    this.#url = request.url();\n    this.#fromDiskCache = !!responsePayload.fromDiskCache;\n    this.#fromServiceWorker = !!responsePayload.fromServiceWorker;\n\n    this.#status = extraInfo ? extraInfo.statusCode : responsePayload.status;\n    const headers = extraInfo ? extraInfo.headers : responsePayload.headers;\n    for (const [key, value] of Object.entries(headers)) {\n      this.#headers[key.toLowerCase()] = value;\n    }\n\n    this.#securityDetails = responsePayload.securityDetails\n      ? new SecurityDetails(responsePayload.securityDetails)\n      : null;\n    this.#timing = responsePayload.timing || null;\n  }\n\n  #parseStatusTextFromExtraInfo(\n    extraInfo: Protocol.Network.ResponseReceivedExtraInfoEvent | null\n  ): string | undefined {\n    if (!extraInfo || !extraInfo.headersText) {\n      return;\n    }\n    const firstLine = extraInfo.headersText.split('\\r', 1)[0];\n    if (!firstLine) {\n      return;\n    }\n    const match = firstLine.match(/[^ ]* [^ ]* (.*)/);\n    if (!match) {\n      return;\n    }\n    const statusText = match[1];\n    if (!statusText) {\n      return;\n    }\n    return statusText;\n  }\n\n  _resolveBody(err?: Error): void {\n    if (err) {\n      return this.#bodyLoadedDeferred.reject(err);\n    }\n    return this.#bodyLoadedDeferred.resolve();\n  }\n\n  override remoteAddress(): RemoteAddress {\n    return this.#remoteAddress;\n  }\n\n  override url(): string {\n    return this.#url;\n  }\n\n  override status(): number {\n    return this.#status;\n  }\n\n  override statusText(): string {\n    return this.#statusText;\n  }\n\n  override headers(): Record<string, string> {\n    return this.#headers;\n  }\n\n  override securityDetails(): SecurityDetails | null {\n    return this.#securityDetails;\n  }\n\n  override timing(): Protocol.Network.ResourceTiming | null {\n    return this.#timing;\n  }\n\n  override buffer(): Promise<Buffer> {\n    if (!this.#contentPromise) {\n      this.#contentPromise = this.#bodyLoadedDeferred\n        .valueOrThrow()\n        .then(async () => {\n          try {\n            const response = await this.#client.send(\n              'Network.getResponseBody',\n              {\n                requestId: this.#request._requestId,\n              }\n            );\n            return Buffer.from(\n              response.body,\n              response.base64Encoded ? 'base64' : 'utf8'\n            );\n          } catch (error) {\n            if (\n              error instanceof ProtocolError &&\n              error.originalMessage ===\n                'No resource with given identifier found'\n            ) {\n              throw new ProtocolError(\n                'Could not load body for this request. This might happen if the request is a preflight request.'\n              );\n            }\n\n            throw error;\n          }\n        });\n    }\n    return this.#contentPromise;\n  }\n\n  override request(): CdpHTTPRequest {\n    return this.#request;\n  }\n\n  override fromCache(): boolean {\n    return this.#fromDiskCache || this.#request._fromMemoryCache;\n  }\n\n  override fromServiceWorker(): boolean {\n    return this.#fromServiceWorker;\n  }\n\n  override frame(): Frame | null {\n    return this.#request.frame();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}