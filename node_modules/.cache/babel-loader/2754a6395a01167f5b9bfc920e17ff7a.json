{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.QuickJSContext = void 0;\nconst debug_1 = require(\"./debug\");\nconst deferred_promise_1 = require(\"./deferred-promise\");\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\nconst memory_1 = require(\"./memory\");\nconst types_1 = require(\"./types\");\n/**\n * @private\n */\nclass ContextMemory extends memory_1.ModuleMemory {\n  /** @private */\n  constructor(args) {\n    super(args.module);\n    this.scope = new lifetime_1.Scope();\n    this.copyJSValue = ptr => {\n      return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr);\n    };\n    this.freeJSValue = ptr => {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr);\n    };\n    args.ownedLifetimes?.forEach(lifetime => this.scope.manage(lifetime));\n    this.owner = args.owner;\n    this.module = args.module;\n    this.ffi = args.ffi;\n    this.rt = args.rt;\n    this.ctx = this.scope.manage(args.ctx);\n  }\n  get alive() {\n    return this.scope.alive;\n  }\n  dispose() {\n    return this.scope.dispose();\n  }\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage(lifetime) {\n    return this.scope.manage(lifetime);\n  }\n  consumeJSCharPointer(ptr) {\n    const str = this.module.UTF8ToString(ptr);\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr);\n    return str;\n  }\n  heapValueHandle(ptr) {\n    return new lifetime_1.Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner);\n  }\n}\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime.newContext} or {@link QuickJSWASMModule.newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * [[newNumber]], [[newString]], [[newArray]], [[newObject]],\n * [[newFunction]], and [[newPromise]].\n *\n * Call [[setProp]] or [[defineProp]] to customize objects. Use those methods\n * with [[global]] to expose the values you create to the interior of the\n * interpreter, so they can be used in [[evalCode]].\n *\n * Use [[evalCode]] or [[callFunction]] to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call [[executePendingJobs]]. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using [[runtime]].\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nclass QuickJSContext {\n  /**\n   * Use {@link QuickJS.createVm} to create a QuickJSContext instance.\n   */\n  constructor(args) {\n    /** @private */\n    this._undefined = undefined;\n    /** @private */\n    this._null = undefined;\n    /** @private */\n    this._false = undefined;\n    /** @private */\n    this._true = undefined;\n    /** @private */\n    this._global = undefined;\n    /** @private */\n    this._BigInt = undefined;\n    /** @private */\n    this.fnNextId = -32768; // min value of signed 16bit int used by Quickjs\n    /** @private */\n    this.fnMaps = new Map();\n    /**\n     * @hidden\n     */\n    this.cToHostCallbacks = {\n      callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n        if (ctx !== this.ctx.value) {\n          throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\");\n        }\n        const fn = this.getFunction(fn_id);\n        if (!fn) {\n          // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n          throw new Error(`QuickJSContext had no callback with id ${fn_id}`);\n        }\n        return lifetime_1.Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n          const thisHandle = scope.manage(new lifetime_1.WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));\n          const argHandles = new Array(argc);\n          for (let i = 0; i < argc; i++) {\n            const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i);\n            argHandles[i] = scope.manage(new lifetime_1.WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));\n          }\n          try {\n            const result = yield* awaited(fn.apply(thisHandle, argHandles));\n            if (result) {\n              if (\"error\" in result && result.error) {\n                (0, debug_1.debugLog)(\"throw error\", result.error);\n                throw result.error;\n              }\n              const handle = scope.manage(result instanceof lifetime_1.Lifetime ? result : result.value);\n              return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value);\n            }\n            return 0;\n          } catch (error) {\n            return this.errorToHandle(error).consume(errorHandle => this.ffi.QTS_Throw(this.ctx.value, errorHandle.value));\n          }\n        });\n      }\n    };\n    this.runtime = args.runtime;\n    this.module = args.module;\n    this.ffi = args.ffi;\n    this.rt = args.rt;\n    this.ctx = args.ctx;\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime\n    });\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks);\n    this.dump = this.dump.bind(this);\n    this.getString = this.getString.bind(this);\n    this.getNumber = this.getNumber.bind(this);\n    this.resolvePromise = this.resolvePromise.bind(this);\n  }\n  // @implement Disposable ----------------------------------------------------\n  get alive() {\n    return this.memory.alive;\n  }\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose();\n  }\n  // Globals ------------------------------------------------------------------\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined() {\n    if (this._undefined) {\n      return this._undefined;\n    }\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined();\n    return this._undefined = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null() {\n    if (this._null) {\n      return this._null;\n    }\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull();\n    return this._null = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true() {\n    if (this._true) {\n      return this._true;\n    }\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue();\n    return this._true = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false() {\n    if (this._false) {\n      return this._false;\n    }\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse();\n    return this._false = new lifetime_1.StaticLifetime(ptr);\n  }\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global() {\n    if (this._global) {\n      return this._global;\n    }\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value);\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr));\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new lifetime_1.StaticLifetime(ptr, this.runtime);\n    return this._global;\n  }\n  // New values ---------------------------------------------------------------\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num) {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num));\n  }\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str) {\n    const ptr = this.memory.newHeapCharPointer(str).consume(charHandle => this.ffi.QTS_NewString(this.ctx.value, charHandle.value));\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description) {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\";\n    const ptr = this.memory.newHeapCharPointer(key).consume(charHandle => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0));\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key) {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\";\n    const ptr = this.memory.newHeapCharPointer(description).consume(charHandle => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1));\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num) {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\");\n      this.memory.manage(bigIntHandle);\n      this._BigInt = new lifetime_1.StaticLifetime(bigIntHandle.value, this.runtime);\n    }\n    const bigIntHandle = this._BigInt;\n    const asString = String(num);\n    return this.newString(asString).consume(handle => this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle)));\n  }\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype) {\n    if (prototype) {\n      this.runtime.assertOwned(prototype);\n    }\n    const ptr = prototype ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value) : this.ffi.QTS_NewObject(this.ctx.value);\n    return this.memory.heapValueHandle(ptr);\n  }\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray() {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value);\n    return this.memory.heapValueHandle(ptr);\n  }\n  newPromise(value) {\n    const deferredPromise = lifetime_1.Scope.withScope(scope => {\n      const mutablePointerArray = scope.manage(this.memory.newMutablePointerArray(2));\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(this.ctx.value, mutablePointerArray.value.ptr);\n      const promiseHandle = this.memory.heapValueHandle(promisePtr);\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(jsvaluePtr => this.memory.heapValueHandle(jsvaluePtr));\n      return new deferred_promise_1.QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle\n      });\n    });\n    if (value && typeof value === \"function\") {\n      value = new Promise(value);\n    }\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, error => error instanceof lifetime_1.Lifetime ? deferredPromise.reject(error) : this.newError(error).consume(deferredPromise.reject));\n    }\n    return deferredPromise;\n  }\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See [[VmFunctionImplementation]] for more details.\n   *\n   * A [[VmFunctionImplementation]] should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * To implement an async function, create a promise with [[newPromise]], then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name, fn) {\n    const fnId = ++this.fnNextId;\n    this.setFunction(fnId, fn);\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name));\n  }\n  newError(error) {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume(handle => this.setProp(errorHandle, \"name\", handle));\n      }\n      if (error.message !== undefined) {\n        this.newString(error.message).consume(handle => this.setProp(errorHandle, \"message\", handle));\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume(handle => this.setProp(errorHandle, \"message\", handle));\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume(handle => this.setProp(errorHandle, \"message\", handle));\n    }\n    return errorHandle;\n  }\n  // Read values --------------------------------------------------------------\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle) {\n    this.runtime.assertOwned(handle);\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value));\n  }\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle) {\n    this.runtime.assertOwned(handle);\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value);\n  }\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle) {\n    this.runtime.assertOwned(handle);\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value));\n  }\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle) {\n    this.runtime.assertOwned(handle);\n    const key = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value));\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value);\n    return isGlobal ? Symbol.for(key) : Symbol(key);\n  }\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle) {\n    this.runtime.assertOwned(handle);\n    const asString = this.getString(handle);\n    return BigInt(asString);\n  }\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle) {\n    this.runtime.assertOwned(promiseLikeHandle);\n    const vmResolveResult = lifetime_1.Scope.withScope(scope => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"));\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"));\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle);\n    });\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult);\n    }\n    return new Promise(resolve => {\n      lifetime_1.Scope.withScope(scope => {\n        const resolveHandle = scope.manage(this.newFunction(\"resolve\", value => {\n          resolve({\n            value: value && value.dup()\n          });\n        }));\n        const rejectHandle = scope.manage(this.newFunction(\"reject\", error => {\n          resolve({\n            error: error && error.dup()\n          });\n        }));\n        const promiseHandle = scope.manage(vmResolveResult.value);\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"));\n        this.unwrapResult(this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)).dispose();\n      });\n    });\n  }\n  // Properties ---------------------------------------------------------------\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle, key) {\n    this.runtime.assertOwned(handle);\n    const ptr = this.borrowPropertyKey(key).consume(quickJSKey => this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value));\n    const result = this.memory.heapValueHandle(ptr);\n    return result;\n  }\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using [[defineProp]] to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle, key, value) {\n    this.runtime.assertOwned(handle);\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume(quickJSKey => this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value));\n  }\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(handle, key, descriptor) {\n    this.runtime.assertOwned(handle);\n    lifetime_1.Scope.withScope(scope => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key));\n      const value = descriptor.value || this.undefined;\n      const configurable = Boolean(descriptor.configurable);\n      const enumerable = Boolean(descriptor.enumerable);\n      const hasValue = Boolean(descriptor.value);\n      const get = descriptor.get ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get)) : this.undefined;\n      const set = descriptor.set ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set)) : this.undefined;\n      this.ffi.QTS_DefineProp(this.ctx.value, handle.value, quickJSKey.value, value.value, get.value, set.value, configurable, enumerable, hasValue);\n    });\n  }\n  // Evaluation ---------------------------------------------------------------\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(func, thisVal) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n    this.runtime.assertOwned(func);\n    const resultPtr = this.memory.toPointerArray(args).consume(argsArrayPtr => this.ffi.QTS_Call(this.ctx.value, func.value, thisVal.value, args.length, argsArrayPtr.value));\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n      return {\n        error: this.memory.heapValueHandle(errorPtr)\n      };\n    }\n    return {\n      value: this.memory.heapValueHandle(resultPtr)\n    };\n  }\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   * Evaluates the Javascript source `code` in the global scope of this VM.\n   * When working with async code, you many need to call [[executePendingJobs]]\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(code) {\n    let filename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"eval.js\";\n    let\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See [[EvalFlags]] for number semantics.\n     */\n    options = arguments.length > 2 ? arguments[2] : undefined;\n    const detectModule = options === undefined ? 1 : 0;\n    const flags = (0, types_1.evalOptionsToFlags)(options);\n    const resultPtr = this.memory.newHeapCharPointer(code).consume(charHandle => this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags));\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);\n      return {\n        error: this.memory.heapValueHandle(errorPtr)\n      };\n    }\n    return {\n      value: this.memory.heapValueHandle(resultPtr)\n    };\n  }\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error) {\n    return this.errorToHandle(error).consume(handle => this.ffi.QTS_Throw(this.ctx.value, handle.value));\n  }\n  /**\n   * @private\n   */\n  borrowPropertyKey(key) {\n    if (typeof key === \"number\") {\n      return this.newNumber(key);\n    }\n    if (typeof key === \"string\") {\n      return this.newString(key);\n    }\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new lifetime_1.StaticLifetime(key.value, this.runtime);\n  }\n  /**\n   * @private\n   */\n  getMemory(rt) {\n    if (rt === this.rt.value) {\n      return this.memory;\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\");\n    }\n  }\n  // Utilities ----------------------------------------------------------------\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle) {\n    this.runtime.assertOwned(handle);\n    const type = this.typeof(handle);\n    if (type === \"string\") {\n      return this.getString(handle);\n    } else if (type === \"number\") {\n      return this.getNumber(handle);\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle);\n    } else if (type === \"undefined\") {\n      return undefined;\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle);\n    }\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value));\n    try {\n      return JSON.parse(str);\n    } catch (err) {\n      return str;\n    }\n  }\n  /**\n   * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a\n   * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult(result) {\n    if (result.error) {\n      const context = \"context\" in result.error ? result.error.context : this;\n      const cause = result.error.consume(error => this.dump(error));\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const {\n          message,\n          name,\n          stack\n        } = cause;\n        const exception = new errors_1.QuickJSUnwrapError(\"\");\n        const hostStack = exception.stack;\n        if (typeof name === \"string\") {\n          exception.name = cause.name;\n        }\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`;\n        }\n        Object.assign(exception, {\n          cause,\n          context,\n          message\n        });\n        throw exception;\n      }\n      throw new errors_1.QuickJSUnwrapError(cause, context);\n    }\n    return result.value;\n  }\n  /** @private */\n  getFunction(fn_id) {\n    const map_id = fn_id >> 8;\n    const fnMap = this.fnMaps.get(map_id);\n    if (!fnMap) {\n      return undefined;\n    }\n    return fnMap.get(fn_id);\n  }\n  /** @private */\n  setFunction(fn_id, handle) {\n    const map_id = fn_id >> 8;\n    let fnMap = this.fnMaps.get(map_id);\n    if (!fnMap) {\n      fnMap = new Map();\n      this.fnMaps.set(map_id, fnMap);\n    }\n    return fnMap.set(fn_id, handle);\n  }\n  errorToHandle(error) {\n    if (error instanceof lifetime_1.Lifetime) {\n      return error;\n    }\n    return this.newError(error);\n  }\n}\nexports.QuickJSContext = QuickJSContext;","map":{"version":3,"mappings":"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","names":["ContextMemory","memory_1","constructor","args","module","lifetime_1","ptr","ffi","QTS_DupValuePointer","ctx","value","QTS_FreeValuePointer","ownedLifetimes","forEach","lifetime","scope","manage","owner","rt","alive","dispose","consumeJSCharPointer","str","UTF8ToString","QTS_FreeCString","heapValueHandle","copyJSValue","freeJSValue","QuickJSContext","undefined","Map","callFunction","this_ptr","argc","argv","fn_id","Error","fn","getFunction","withScopeMaybeAsync","awaited","thisHandle","memory","runtime","argHandles","Array","i","QTS_ArgvGetJSValueConstPointer","result","apply","error","handle","errorToHandle","consume","errorHandle","QTS_Throw","callbacks","setContextCallbacks","cToHostCallbacks","dump","bind","getString","getNumber","resolvePromise","_undefined","QTS_GetUndefined","null","_null","QTS_GetNull","true","_true","QTS_GetTrue","false","_false","QTS_GetFalse","global","_global","QTS_GetGlobalObject","newNumber","num","QTS_NewFloat64","newString","newHeapCharPointer","charHandle","QTS_NewString","newUniqueSymbol","description","key","QTS_NewSymbol","newSymbolFor","newBigInt","_BigInt","bigIntHandle","getProp","asString","String","unwrapResult","newObject","prototype","assertOwned","QTS_NewObjectProto","QTS_NewObject","newArray","QTS_NewArray","newPromise","deferredPromise","withScope","mutablePointerArray","newMutablePointerArray","promisePtr","QTS_NewPromiseCapability","promiseHandle","resolveHandle","rejectHandle","from","typedArray","map","jsvaluePtr","deferred_promise_1","context","Promise","resolve","then","reject","newError","newFunction","name","fnId","fnNextId","setFunction","QTS_NewFunction","QTS_NewError","setProp","message","typeof","consumeHeapCharPointer","QTS_Typeof","QTS_GetFloat64","QTS_GetString","getSymbol","QTS_GetSymbolDescriptionOrKey","isGlobal","QTS_IsGlobalSymbol","Symbol","for","getBigInt","BigInt","promiseLikeHandle","vmResolveResult","vmPromise","vmPromiseResolve","dup","promiseThenHandle","borrowPropertyKey","quickJSKey","QTS_GetProp","QTS_SetProp","defineProp","descriptor","configurable","Boolean","enumerable","hasValue","get","set","QTS_DefineProp","func","thisVal","resultPtr","toPointerArray","argsArrayPtr","QTS_Call","length","errorPtr","QTS_ResolveException","evalCode","code","filename","options","detectModule","flags","QTS_Eval","throw","getMemory","type","QTS_Dump","JSON","parse","err","cause","stack","exception","errors_1","hostStack","Object","assign","map_id","fnMap","fnMaps","exports"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\context.ts"],"sourcesContent":["import { debugLog } from \"./debug\"\nimport { QuickJSDeferredPromise } from \"./deferred-promise\"\nimport type { EitherModule } from \"./emscripten-types\"\nimport { QuickJSUnwrapError } from \"./errors\"\nimport {\n  EvalDetectModule,\n  EvalFlags,\n  JSBorrowedCharPointer,\n  JSContextPointer,\n  JSModuleDefPointer,\n  JSRuntimePointer,\n  JSValueConstPointer,\n  JSValuePointer,\n  JSValuePointerPointer,\n  JSVoidPointer,\n} from \"./types-ffi\"\nimport { Disposable, Lifetime, Scope, StaticLifetime, WeakLifetime } from \"./lifetime\"\nimport { ModuleMemory } from \"./memory\"\nimport { ContextCallbacks, QuickJSModuleCallbacks } from \"./module\"\nimport { QuickJSRuntime } from \"./runtime\"\nimport {\n  ContextEvalOptions,\n  EitherFFI,\n  evalOptionsToFlags,\n  JSValue,\n  PromiseExecutor,\n  QuickJSHandle,\n} from \"./types\"\nimport {\n  LowLevelJavascriptVm,\n  SuccessOrFail,\n  VmCallResult,\n  VmFunctionImplementation,\n  VmPropertyDescriptor,\n} from \"./vm-interface\"\n\n/**\n * Property key for getting or setting a property on a handle with\n * [[QuickJSContext.getProp]], [[QuickJSContext.setProp]], or [[QuickJSContext.defineProp]].\n */\nexport type QuickJSPropertyKey = number | string | QuickJSHandle\n\n/**\n * @private\n */\nclass ContextMemory extends ModuleMemory implements Disposable {\n  readonly owner: QuickJSRuntime\n  readonly ctx: Lifetime<JSContextPointer>\n  readonly rt: Lifetime<JSRuntimePointer>\n  readonly module: EitherModule\n  readonly ffi: EitherFFI\n  readonly scope = new Scope()\n\n  /** @private */\n  constructor(args: {\n    owner: QuickJSRuntime\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    ownedLifetimes?: Disposable[]\n  }) {\n    super(args.module)\n    args.ownedLifetimes?.forEach((lifetime) => this.scope.manage(lifetime))\n    this.owner = args.owner\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = this.scope.manage(args.ctx)\n  }\n\n  get alive() {\n    return this.scope.alive\n  }\n\n  dispose() {\n    return this.scope.dispose()\n  }\n\n  /**\n   * Track `lifetime` so that it is disposed when this scope is disposed.\n   */\n  manage<T extends Disposable>(lifetime: T): T {\n    return this.scope.manage(lifetime)\n  }\n\n  copyJSValue = (ptr: JSValuePointer | JSValueConstPointer) => {\n    return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr)\n  }\n\n  freeJSValue = (ptr: JSValuePointer) => {\n    this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr)\n  }\n\n  consumeJSCharPointer(ptr: JSBorrowedCharPointer): string {\n    const str = this.module.UTF8ToString(ptr)\n    this.ffi.QTS_FreeCString(this.ctx.value, ptr)\n    return str\n  }\n\n  heapValueHandle(ptr: JSValuePointer): JSValue {\n    return new Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner)\n  }\n}\n\n/**\n * QuickJSContext wraps a QuickJS Javascript context (JSContext*) within a\n * runtime. The contexts within the same runtime may exchange objects freely.\n * You can think of separate runtimes like different domains in a browser, and\n * the contexts within a runtime like the different windows open to the same\n * domain. The {@link runtime} references the context's runtime.\n *\n * This class's methods return {@link QuickJSHandle}, which wrap C pointers (JSValue*).\n * It's the caller's responsibility to call `.dispose()` on any\n * handles you create to free memory once you're done with the handle.\n *\n * Use {@link QuickJSRuntime.newContext} or {@link QuickJSWASMModule.newContext}\n * to create a new QuickJSContext.\n *\n * Create QuickJS values inside the interpreter with methods like\n * [[newNumber]], [[newString]], [[newArray]], [[newObject]],\n * [[newFunction]], and [[newPromise]].\n *\n * Call [[setProp]] or [[defineProp]] to customize objects. Use those methods\n * with [[global]] to expose the values you create to the interior of the\n * interpreter, so they can be used in [[evalCode]].\n *\n * Use [[evalCode]] or [[callFunction]] to execute Javascript inside the VM. If\n * you're using asynchronous code inside the QuickJSContext, you may need to also\n * call [[executePendingJobs]]. Executing code inside the runtime returns a\n * result object representing successful execution or an error. You must dispose\n * of any such results to avoid leaking memory inside the VM.\n *\n * Implement memory and CPU constraints at the runtime level, using [[runtime]].\n * See {@link QuickJSRuntime} for more information.\n *\n */\n// TODO: Manage own callback registration\nexport class QuickJSContext implements LowLevelJavascriptVm<QuickJSHandle>, Disposable {\n  /**\n   * The runtime that created this context.\n   */\n  public readonly runtime: QuickJSRuntime\n\n  /** @private */\n  protected readonly ctx: Lifetime<JSContextPointer>\n  /** @private */\n  protected readonly rt: Lifetime<JSRuntimePointer>\n  /** @private */\n  protected readonly module: EitherModule\n  /** @private */\n  protected readonly ffi: EitherFFI\n  /** @private */\n  protected memory: ContextMemory\n\n  /** @private */\n  protected _undefined: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _null: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _false: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _true: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _global: QuickJSHandle | undefined = undefined\n  /** @private */\n  protected _BigInt: QuickJSHandle | undefined = undefined\n\n  /**\n   * Use {@link QuickJS.createVm} to create a QuickJSContext instance.\n   */\n  constructor(args: {\n    module: EitherModule\n    ffi: EitherFFI\n    ctx: Lifetime<JSContextPointer>\n    rt: Lifetime<JSRuntimePointer>\n    runtime: QuickJSRuntime\n    ownedLifetimes?: Disposable[]\n    callbacks: QuickJSModuleCallbacks\n  }) {\n    this.runtime = args.runtime\n    this.module = args.module\n    this.ffi = args.ffi\n    this.rt = args.rt\n    this.ctx = args.ctx\n    this.memory = new ContextMemory({\n      ...args,\n      owner: this.runtime,\n    })\n    args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks)\n    this.dump = this.dump.bind(this)\n    this.getString = this.getString.bind(this)\n    this.getNumber = this.getNumber.bind(this)\n    this.resolvePromise = this.resolvePromise.bind(this)\n  }\n\n  // @implement Disposable ----------------------------------------------------\n\n  get alive() {\n    return this.memory.alive\n  }\n\n  /**\n   * Dispose of this VM's underlying resources.\n   *\n   * @throws Calling this method without disposing of all created handles\n   * will result in an error.\n   */\n  dispose() {\n    this.memory.dispose()\n  }\n\n  // Globals ------------------------------------------------------------------\n\n  /**\n   * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).\n   */\n  get undefined(): QuickJSHandle {\n    if (this._undefined) {\n      return this._undefined\n    }\n\n    // Undefined is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetUndefined()\n    return (this._undefined = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).\n   */\n  get null(): QuickJSHandle {\n    if (this._null) {\n      return this._null\n    }\n\n    // Null is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetNull()\n    return (this._null = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).\n   */\n  get true(): QuickJSHandle {\n    if (this._true) {\n      return this._true\n    }\n\n    // True is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetTrue()\n    return (this._true = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).\n   */\n  get false(): QuickJSHandle {\n    if (this._false) {\n      return this._false\n    }\n\n    // False is a constant, immutable value in QuickJS.\n    const ptr = this.ffi.QTS_GetFalse()\n    return (this._false = new StaticLifetime(ptr))\n  }\n\n  /**\n   * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).\n   * A handle to the global object inside the interpreter.\n   * You can set properties to create global variables.\n   */\n  get global(): QuickJSHandle {\n    if (this._global) {\n      return this._global\n    }\n\n    // The global is a JSValue, but since it's lifetime is as long as the VM's,\n    // we should manage it.\n    const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value)\n\n    // Automatically clean up this reference when we dispose\n    this.memory.manage(this.memory.heapValueHandle(ptr))\n\n    // This isn't technically a static lifetime, but since it has the same\n    // lifetime as the VM, it's okay to fake one since when the VM is\n    // disposed, no other functions will accept the value.\n    this._global = new StaticLifetime(ptr, this.runtime)\n    return this._global\n  }\n\n  // New values ---------------------------------------------------------------\n\n  /**\n   * Converts a Javascript number into a QuickJS value.\n   */\n  newNumber(num: number): QuickJSHandle {\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num))\n  }\n\n  /**\n   * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.\n   */\n  newString(str: string): QuickJSHandle {\n    const ptr = this.memory\n      .newHeapCharPointer(str)\n      .consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.\n   * No two symbols created with this function will be the same value.\n   */\n  newUniqueSymbol(description: string | symbol): QuickJSHandle {\n    const key = (typeof description === \"symbol\" ? description.description : description) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(key)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.\n   * All symbols created with the same key will be the same value.\n   */\n  newSymbolFor(key: string | symbol): QuickJSHandle {\n    const description = (typeof key === \"symbol\" ? key.description : key) ?? \"\"\n    const ptr = this.memory\n      .newHeapCharPointer(description)\n      .consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1))\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.\n   */\n  newBigInt(num: bigint): QuickJSHandle {\n    if (!this._BigInt) {\n      const bigIntHandle = this.getProp(this.global, \"BigInt\")\n      this.memory.manage(bigIntHandle)\n      this._BigInt = new StaticLifetime(bigIntHandle.value as JSValueConstPointer, this.runtime)\n    }\n\n    const bigIntHandle = this._BigInt\n    const asString = String(num)\n    return this.newString(asString).consume((handle) =>\n      this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle))\n    )\n  }\n\n  /**\n   * `{}`.\n   * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).\n   *\n   * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).\n   */\n  newObject(prototype?: QuickJSHandle): QuickJSHandle {\n    if (prototype) {\n      this.runtime.assertOwned(prototype)\n    }\n    const ptr = prototype\n      ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype.value)\n      : this.ffi.QTS_NewObject(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * `[]`.\n   * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).\n   */\n  newArray(): QuickJSHandle {\n    const ptr = this.ffi.QTS_NewArray(this.ctx.value)\n    return this.memory.heapValueHandle(ptr)\n  }\n\n  /**\n   * Create a new [[QuickJSDeferredPromise]]. Use `deferred.resolve(handle)` and\n   * `deferred.reject(handle)` to fulfill the promise handle available at `deferred.handle`.\n   * Note that you are responsible for calling `deferred.dispose()` to free the underlying\n   * resources; see the documentation on [[QuickJSDeferredPromise]] for details.\n   */\n  newPromise(): QuickJSDeferredPromise\n  /**\n   * Create a new [[QuickJSDeferredPromise]] that resolves when the\n   * given native Promise<QuickJSHandle> resolves. Rejections will be coerced\n   * to a QuickJS error.\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(promise: Promise<QuickJSHandle>): QuickJSDeferredPromise\n  /**\n   * Construct a new native Promise<QuickJSHandle>, and then convert it into a\n   * [[QuickJSDeferredPromise]].\n   *\n   * You can still resolve/reject the created promise \"early\" using its methods.\n   */\n  newPromise(\n    newPromiseFn: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle>\n  ): QuickJSDeferredPromise\n  newPromise(\n    value?: PromiseExecutor<QuickJSHandle, Error | QuickJSHandle> | Promise<QuickJSHandle>\n  ): QuickJSDeferredPromise {\n    const deferredPromise = Scope.withScope((scope) => {\n      const mutablePointerArray = scope.manage(\n        this.memory.newMutablePointerArray<JSValuePointerPointer>(2)\n      )\n      const promisePtr = this.ffi.QTS_NewPromiseCapability(\n        this.ctx.value,\n        mutablePointerArray.value.ptr\n      )\n      const promiseHandle = this.memory.heapValueHandle(promisePtr)\n      const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map(\n        (jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr as any)\n      )\n      return new QuickJSDeferredPromise({\n        context: this,\n        promiseHandle,\n        resolveHandle,\n        rejectHandle,\n      })\n    })\n\n    if (value && typeof value === \"function\") {\n      value = new Promise(value)\n    }\n\n    if (value) {\n      Promise.resolve(value).then(deferredPromise.resolve, (error) =>\n        error instanceof Lifetime\n          ? deferredPromise.reject(error)\n          : this.newError(error).consume(deferredPromise.reject)\n      )\n    }\n\n    return deferredPromise\n  }\n\n  /**\n   * Convert a Javascript function into a QuickJS function value.\n   * See [[VmFunctionImplementation]] for more details.\n   *\n   * A [[VmFunctionImplementation]] should not free its arguments or its return\n   * value. A VmFunctionImplementation should also not retain any references to\n   * its return value.\n   *\n   * To implement an async function, create a promise with [[newPromise]], then\n   * return the deferred promise handle from `deferred.handle` from your\n   * function implementation:\n   *\n   * ```\n   * const deferred = vm.newPromise()\n   * someNativeAsyncFunction().then(deferred.resolve)\n   * return deferred.handle\n   * ```\n   */\n  newFunction(name: string, fn: VmFunctionImplementation<QuickJSHandle>): QuickJSHandle {\n    const fnId = ++this.fnNextId\n    this.setFunction(fnId, fn)\n    return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name))\n  }\n\n  newError(error: { name: string; message: string }): QuickJSHandle\n  newError(message: string): QuickJSHandle\n  newError(): QuickJSHandle\n  newError(error?: string | { name: string; message: string }): QuickJSHandle {\n    const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value))\n\n    if (error && typeof error === \"object\") {\n      if (error.name !== undefined) {\n        this.newString(error.name).consume((handle) => this.setProp(errorHandle, \"name\", handle))\n      }\n\n      if (error.message !== undefined) {\n        this.newString(error.message).consume((handle) =>\n          this.setProp(errorHandle, \"message\", handle)\n        )\n      }\n    } else if (typeof error === \"string\") {\n      this.newString(error).consume((handle) => this.setProp(errorHandle, \"message\", handle))\n    } else if (error !== undefined) {\n      // This isn't supported in the type signature but maybe it will make life easier.\n      this.newString(String(error)).consume((handle) =>\n        this.setProp(errorHandle, \"message\", handle)\n      )\n    }\n\n    return errorHandle\n  }\n\n  // Read values --------------------------------------------------------------\n\n  /**\n   * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).\n   *\n   * @remarks\n   * Does not support BigInt values correctly.\n   */\n  typeof(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript number.\n   * @returns `NaN` on error, otherwise a `number`.\n   */\n  getNumber(handle: QuickJSHandle): number {\n    this.runtime.assertOwned(handle)\n    return this.ffi.QTS_GetFloat64(this.ctx.value, handle.value)\n  }\n\n  /**\n   * Converts `handle` to a Javascript string.\n   */\n  getString(handle: QuickJSHandle): string {\n    this.runtime.assertOwned(handle)\n    return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle.value))\n  }\n\n  /**\n   * Converts `handle` into a Javascript symbol. If the symbol is in the global\n   * registry in the guest, it will be created with Symbol.for on the host.\n   */\n  getSymbol(handle: QuickJSHandle): symbol {\n    this.runtime.assertOwned(handle)\n    const key = this.memory.consumeJSCharPointer(\n      this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle.value)\n    )\n    const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle.value)\n    return isGlobal ? Symbol.for(key) : Symbol(key)\n  }\n\n  /**\n   * Converts `handle` to a Javascript bigint.\n   */\n  getBigInt(handle: QuickJSHandle): bigint {\n    this.runtime.assertOwned(handle)\n    const asString = this.getString(handle)\n    return BigInt(asString)\n  }\n\n  /**\n   * `Promise.resolve(value)`.\n   * Convert a handle containing a Promise-like value inside the VM into an\n   * actual promise on the host.\n   *\n   * @remarks\n   * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.\n   *\n   * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.\n   */\n  resolvePromise(promiseLikeHandle: QuickJSHandle): Promise<VmCallResult<QuickJSHandle>> {\n    this.runtime.assertOwned(promiseLikeHandle)\n    const vmResolveResult = Scope.withScope((scope) => {\n      const vmPromise = scope.manage(this.getProp(this.global, \"Promise\"))\n      const vmPromiseResolve = scope.manage(this.getProp(vmPromise, \"resolve\"))\n      return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle)\n    })\n    if (vmResolveResult.error) {\n      return Promise.resolve(vmResolveResult)\n    }\n\n    return new Promise<VmCallResult<QuickJSHandle>>((resolve) => {\n      Scope.withScope((scope) => {\n        const resolveHandle = scope.manage(\n          this.newFunction(\"resolve\", (value) => {\n            resolve({ value: value && value.dup() })\n          })\n        )\n\n        const rejectHandle = scope.manage(\n          this.newFunction(\"reject\", (error) => {\n            resolve({ error: error && error.dup() })\n          })\n        )\n\n        const promiseHandle = scope.manage(vmResolveResult.value)\n        const promiseThenHandle = scope.manage(this.getProp(promiseHandle, \"then\"))\n        this.unwrapResult(\n          this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)\n        ).dispose()\n      })\n    })\n  }\n\n  // Properties ---------------------------------------------------------------\n\n  /**\n   * `handle[key]`.\n   * Get a property from a JSValue.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string (which will be converted automatically).\n   */\n  getProp(handle: QuickJSHandle, key: QuickJSPropertyKey): QuickJSHandle {\n    this.runtime.assertOwned(handle)\n    const ptr = this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_GetProp(this.ctx.value, handle.value, quickJSKey.value)\n    )\n    const result = this.memory.heapValueHandle(ptr)\n\n    return result\n  }\n\n  /**\n   * `handle[key] = value`.\n   * Set a property on a JSValue.\n   *\n   * @remarks\n   * Note that the QuickJS authors recommend using [[defineProp]] to define new\n   * properties.\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  setProp(handle: QuickJSHandle, key: QuickJSPropertyKey, value: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    // free newly allocated value if key was a string or number. No-op if string was already\n    // a QuickJS handle.\n    this.borrowPropertyKey(key).consume((quickJSKey) =>\n      this.ffi.QTS_SetProp(this.ctx.value, handle.value, quickJSKey.value, value.value)\n    )\n  }\n\n  /**\n   * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).\n   *\n   * @param key - The property may be specified as a JSValue handle, or as a\n   * Javascript string or number (which will be converted automatically to a JSValue).\n   */\n  defineProp(\n    handle: QuickJSHandle,\n    key: QuickJSPropertyKey,\n    descriptor: VmPropertyDescriptor<QuickJSHandle>\n  ): void {\n    this.runtime.assertOwned(handle)\n    Scope.withScope((scope) => {\n      const quickJSKey = scope.manage(this.borrowPropertyKey(key))\n\n      const value = descriptor.value || this.undefined\n      const configurable = Boolean(descriptor.configurable)\n      const enumerable = Boolean(descriptor.enumerable)\n      const hasValue = Boolean(descriptor.value)\n      const get = descriptor.get\n        ? scope.manage(this.newFunction(descriptor.get.name, descriptor.get))\n        : this.undefined\n      const set = descriptor.set\n        ? scope.manage(this.newFunction(descriptor.set.name, descriptor.set))\n        : this.undefined\n\n      this.ffi.QTS_DefineProp(\n        this.ctx.value,\n        handle.value,\n        quickJSKey.value,\n        value.value,\n        get.value,\n        set.value,\n        configurable,\n        enumerable,\n        hasValue\n      )\n    })\n  }\n\n  // Evaluation ---------------------------------------------------------------\n\n  /**\n   * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).\n   * Call a JSValue as a function.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * @returns A result. If the function threw synchronously, `result.error` be a\n   * handle to the exception. Otherwise `result.value` will be a handle to the\n   * value.\n   */\n  callFunction(\n    func: QuickJSHandle,\n    thisVal: QuickJSHandle,\n    ...args: QuickJSHandle[]\n  ): VmCallResult<QuickJSHandle> {\n    this.runtime.assertOwned(func)\n    const resultPtr = this.memory\n      .toPointerArray(args)\n      .consume((argsArrayPtr) =>\n        this.ffi.QTS_Call(\n          this.ctx.value,\n          func.value,\n          thisVal.value,\n          args.length,\n          argsArrayPtr.value\n        )\n      )\n\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).\n   * Evaluates the Javascript source `code` in the global scope of this VM.\n   * When working with async code, you many need to call [[executePendingJobs]]\n   * to execute callbacks pending after synchronous evaluation returns.\n   *\n   * See [[unwrapResult]], which will throw if the function returned an error, or\n   * return the result handle directly. If evaluation returned a handle containing\n   * a promise, use [[resolvePromise]] to convert it to a native promise and\n   * [[executePendingJobs]] to finish evaluating the promise.\n   *\n   * *Note*: to protect against infinite loops, provide an interrupt handler to\n   * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to\n   * create a time-based deadline.\n   *\n   * @returns The last statement's value. If the code threw synchronously,\n   * `result.error` will be a handle to the exception. If execution was\n   * interrupted, the error will have name `InternalError` and message\n   * `interrupted`.\n   */\n  evalCode(\n    code: string,\n    filename: string = \"eval.js\",\n    /**\n     * If no options are passed, a heuristic will be used to detect if `code` is\n     * an ES module.\n     *\n     * See [[EvalFlags]] for number semantics.\n     */\n    options?: number | ContextEvalOptions\n  ): VmCallResult<QuickJSHandle> {\n    const detectModule = (options === undefined ? 1 : 0) as EvalDetectModule\n    const flags = evalOptionsToFlags(options) as EvalFlags\n    const resultPtr = this.memory\n      .newHeapCharPointer(code)\n      .consume((charHandle) =>\n        this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags)\n      )\n    const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr)\n    if (errorPtr) {\n      this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr)\n      return { error: this.memory.heapValueHandle(errorPtr) }\n    }\n    return { value: this.memory.heapValueHandle(resultPtr) }\n  }\n\n  /**\n   * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.\n   * @experimental\n   */\n  throw(error: Error | QuickJSHandle) {\n    return this.errorToHandle(error).consume((handle) =>\n      this.ffi.QTS_Throw(this.ctx.value, handle.value)\n    )\n  }\n\n  /**\n   * @private\n   */\n  protected borrowPropertyKey(key: QuickJSPropertyKey): QuickJSHandle {\n    if (typeof key === \"number\") {\n      return this.newNumber(key)\n    }\n\n    if (typeof key === \"string\") {\n      return this.newString(key)\n    }\n\n    // key is already a JSValue, but we're borrowing it. Return a static handle\n    // for internal use only.\n    return new StaticLifetime(key.value as JSValueConstPointer, this.runtime)\n  }\n\n  /**\n   * @private\n   */\n  getMemory(rt: JSRuntimePointer): ContextMemory {\n    if (rt === this.rt.value) {\n      return this.memory\n    } else {\n      throw new Error(\"Private API. Cannot get memory from a different runtime\")\n    }\n  }\n\n  // Utilities ----------------------------------------------------------------\n\n  /**\n   * Dump a JSValue to Javascript in a best-effort fashion.\n   * Returns `handle.toString()` if it cannot be serialized to JSON.\n   */\n  dump(handle: QuickJSHandle) {\n    this.runtime.assertOwned(handle)\n    const type = this.typeof(handle)\n    if (type === \"string\") {\n      return this.getString(handle)\n    } else if (type === \"number\") {\n      return this.getNumber(handle)\n    } else if (type === \"bigint\") {\n      return this.getBigInt(handle)\n    } else if (type === \"undefined\") {\n      return undefined\n    } else if (type === \"symbol\") {\n      return this.getSymbol(handle)\n    }\n\n    const str = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle.value))\n    try {\n      return JSON.parse(str)\n    } catch (err) {\n      return str\n    }\n  }\n\n  /**\n   * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a\n   * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.\n   * If the result is a success, returns the value.\n   * If the result is an error, converts the error to a native object and throws the error.\n   */\n  unwrapResult<T>(result: SuccessOrFail<T, QuickJSHandle>): T {\n    if (result.error) {\n      const context: QuickJSContext =\n        \"context\" in result.error ? (result.error as { context: QuickJSContext }).context : this\n      const cause = result.error.consume((error) => this.dump(error))\n\n      if (cause && typeof cause === \"object\" && typeof cause.message === \"string\") {\n        const { message, name, stack } = cause\n        const exception = new QuickJSUnwrapError(\"\")\n        const hostStack = exception.stack\n\n        if (typeof name === \"string\") {\n          exception.name = cause.name\n        }\n\n        if (typeof stack === \"string\") {\n          exception.stack = `${name}: ${message}\\n${cause.stack}Host: ${hostStack}`\n        }\n\n        Object.assign(exception, { cause, context, message })\n        throw exception\n      }\n\n      throw new QuickJSUnwrapError(cause, context)\n    }\n\n    return result.value\n  }\n\n  /** @private */\n  protected fnNextId = -32768 // min value of signed 16bit int used by Quickjs\n  /** @private */\n  protected fnMaps = new Map<number, Map<number, VmFunctionImplementation<QuickJSHandle>>>()\n\n  /** @private */\n  protected getFunction(fn_id: number): VmFunctionImplementation<QuickJSHandle> | undefined {\n    const map_id = fn_id >> 8\n    const fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      return undefined\n    }\n    return fnMap.get(fn_id)\n  }\n\n  /** @private */\n  protected setFunction(fn_id: number, handle: VmFunctionImplementation<QuickJSHandle>) {\n    const map_id = fn_id >> 8\n    let fnMap = this.fnMaps.get(map_id)\n    if (!fnMap) {\n      fnMap = new Map<number, VmFunctionImplementation<QuickJSHandle>>()\n      this.fnMaps.set(map_id, fnMap)\n    }\n    return fnMap.set(fn_id, handle)\n  }\n\n  /**\n   * @hidden\n   */\n  private cToHostCallbacks: ContextCallbacks = {\n    callFunction: (ctx, this_ptr, argc, argv, fn_id) => {\n      if (ctx !== this.ctx.value) {\n        throw new Error(\"QuickJSContext instance received C -> JS call with mismatched ctx\")\n      }\n\n      const fn = this.getFunction(fn_id)\n      if (!fn) {\n        // this \"throw\" is not catch-able from the TS side. could we somehow handle this higher up?\n        throw new Error(`QuickJSContext had no callback with id ${fn_id}`)\n      }\n\n      return Scope.withScopeMaybeAsync(this, function* (awaited, scope) {\n        const thisHandle = scope.manage(\n          new WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)\n        )\n        const argHandles = new Array<QuickJSHandle>(argc)\n        for (let i = 0; i < argc; i++) {\n          const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i)\n          argHandles[i] = scope.manage(\n            new WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime)\n          )\n        }\n\n        try {\n          const result = yield* awaited(fn.apply(thisHandle, argHandles))\n          if (result) {\n            if (\"error\" in result && result.error) {\n              debugLog(\"throw error\", result.error)\n              throw result.error\n            }\n            const handle = scope.manage(result instanceof Lifetime ? result : result.value)\n            return this.ffi.QTS_DupValuePointer(this.ctx.value, handle.value)\n          }\n          return 0 as JSValuePointer\n        } catch (error) {\n          return this.errorToHandle(error as Error).consume((errorHandle) =>\n            this.ffi.QTS_Throw(this.ctx.value, errorHandle.value)\n          )\n        }\n      }) as JSValuePointer\n    },\n  }\n\n  private errorToHandle(error: Error | QuickJSHandle): QuickJSHandle {\n    if (error instanceof Lifetime) {\n      return error\n    }\n\n    return this.newError(error)\n  }\n}\n"]},"metadata":{},"sourceType":"script"}