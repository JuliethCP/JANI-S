{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.TestQuickJSWASMModule = void 0;\nconst errors_1 = require(\"./errors\");\nconst lifetime_1 = require(\"./lifetime\");\n/**\n * A test wrapper of [[QuickJSWASMModule]] that keeps a reference to each\n * context or runtime created.\n *\n * Call [[disposeAll]] to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call [[assertNoMemoryAllocated]] at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nclass TestQuickJSWASMModule {\n  constructor(parent) {\n    this.parent = parent;\n    this.contexts = new Set();\n    this.runtimes = new Set();\n  }\n  newRuntime(options) {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [new lifetime_1.Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)), ...(options?.ownedLifetimes ?? [])]\n    });\n    this.runtimes.add(runtime);\n    return runtime;\n  }\n  newContext(options) {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [new lifetime_1.Lifetime(undefined, undefined, () => this.contexts.delete(context)), ...(options?.ownedLifetimes ?? [])]\n    });\n    this.contexts.add(context);\n    return context;\n  }\n  evalCode(code, options) {\n    return this.parent.evalCode(code, options);\n  }\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes];\n    this.runtimes.clear();\n    this.contexts.clear();\n    allDisposables.forEach(d => {\n      if (d.alive) {\n        d.dispose();\n      }\n    });\n  }\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck();\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new errors_1.QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\");\n    }\n    if (this.contexts.size > 0) {\n      throw new errors_1.QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`);\n    }\n    if (this.runtimes.size > 0) {\n      throw new errors_1.QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`);\n    }\n  }\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI();\n  }\n}\nexports.TestQuickJSWASMModule = TestQuickJSWASMModule;","map":{"version":3,"mappings":";;;;;;AAIA;AACA;AAEA;;;;;;;;;;AAUA,MAAaA,qBAAqB;EAGhCC,YAAoBC,MAAyB;IAAzB,WAAM,GAANA,MAAM;IAF1B,aAAQ,GAAG,IAAIC,GAAG,EAAkB;IACpC,aAAQ,GAAG,IAAIA,GAAG,EAAkB;EACY;EAEhDC,UAAU,CAACC,OAAwB;IACjC,MAAMC,OAAO,GAAG,IAAI,CAACJ,MAAM,CAACE,UAAU,CAAC;MACrC,GAAGC,OAAO;MACVE,cAAc,EAAE,CACd,IAAIC,mBAAQ,CAACC,SAAS,EAAEA,SAAS,EAAE,MAAM,IAAI,CAACC,QAAQ,CAACC,MAAM,CAACL,OAAO,CAAC,CAAC,EACvE,IAAID,OAAO,EAAEE,cAAc,IAAI,EAAE,CAAC;KAErC,CAAC;IACF,IAAI,CAACG,QAAQ,CAACE,GAAG,CAACN,OAAO,CAAC;IAC1B,OAAOA,OAAO;EAChB;EAEAO,UAAU,CAACR,OAAwB;IACjC,MAAMS,OAAO,GAAG,IAAI,CAACZ,MAAM,CAACW,UAAU,CAAC;MACrC,GAAGR,OAAO;MACVE,cAAc,EAAE,CACd,IAAIC,mBAAQ,CAACC,SAAS,EAAEA,SAAS,EAAE,MAAM,IAAI,CAACM,QAAQ,CAACJ,MAAM,CAACG,OAAO,CAAC,CAAC,EACvE,IAAIT,OAAO,EAAEE,cAAc,IAAI,EAAE,CAAC;KAErC,CAAC;IACF,IAAI,CAACQ,QAAQ,CAACH,GAAG,CAACE,OAAO,CAAC;IAC1B,OAAOA,OAAO;EAChB;EAEAE,QAAQ,CAACC,IAAY,EAAEZ,OAA2B;IAChD,OAAO,IAAI,CAACH,MAAM,CAACc,QAAQ,CAACC,IAAI,EAAEZ,OAAO,CAAC;EAC5C;EAEAa,UAAU;IACR,MAAMC,cAAc,GAAG,CAAC,GAAG,IAAI,CAACJ,QAAQ,EAAE,GAAG,IAAI,CAACL,QAAQ,CAAC;IAC3D,IAAI,CAACA,QAAQ,CAACU,KAAK,EAAE;IACrB,IAAI,CAACL,QAAQ,CAACK,KAAK,EAAE;IACrBD,cAAc,CAACE,OAAO,CAAEC,CAAC,IAAI;MAC3B,IAAIA,CAAC,CAACC,KAAK,EAAE;QACXD,CAAC,CAACE,OAAO,EAAE;;IAEf,CAAC,CAAC;EACJ;EAEAC,uBAAuB;IACrB,MAAMC,aAAa,GAAG,IAAI,CAACC,MAAM,EAAE,CAACC,wBAAwB,EAAE;IAC9D,IAAIF,aAAa,EAAE;MACjB;MACA;MACA,MAAM,IAAIG,kCAAyB,CAAC,yCAAyC,CAAC;;IAGhF,IAAI,IAAI,CAACd,QAAQ,CAACe,IAAI,GAAG,CAAC,EAAE;MAC1B,MAAM,IAAID,kCAAyB,CAAC,GAAG,IAAI,CAACd,QAAQ,CAACe,IAAI,kBAAkB,CAAC;;IAG9E,IAAI,IAAI,CAACpB,QAAQ,CAACoB,IAAI,GAAG,CAAC,EAAE;MAC1B,MAAM,IAAID,kCAAyB,CAAC,GAAG,IAAI,CAACnB,QAAQ,CAACoB,IAAI,kBAAkB,CAAC;;EAEhF;EAEA;EACAH,MAAM;IACJ,OAAO,IAAI,CAACzB,MAAM,CAACyB,MAAM,EAAE;EAC7B;;AAhEFI","names":["TestQuickJSWASMModule","constructor","parent","Set","newRuntime","options","runtime","ownedLifetimes","lifetime_1","undefined","runtimes","delete","add","newContext","context","contexts","evalCode","code","disposeAll","allDisposables","clear","forEach","d","alive","dispose","assertNoMemoryAllocated","leaksDetected","getFFI","QTS_RecoverableLeakCheck","errors_1","size","exports"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\module-test.ts"],"sourcesContent":["import type { QuickJSContext } from \"./context\"\nimport type { ModuleEvalOptions, QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime } from \"./runtime\"\nimport type { ContextOptions, RuntimeOptions } from \"./types\"\nimport { QuickJSMemoryLeakDetected } from \"./errors\"\nimport { Lifetime } from \"./lifetime\"\n\n/**\n * A test wrapper of [[QuickJSWASMModule]] that keeps a reference to each\n * context or runtime created.\n *\n * Call [[disposeAll]] to reset these sets and calls `dispose` on any left alive\n * (which may throw an error).\n *\n * Call [[assertNoMemoryAllocated]] at the end of a test, when you expect that you've\n * freed all the memory you've ever allocated.\n */\nexport class TestQuickJSWASMModule implements Pick<QuickJSWASMModule, keyof QuickJSWASMModule> {\n  contexts = new Set<QuickJSContext>()\n  runtimes = new Set<QuickJSRuntime>()\n  constructor(private parent: QuickJSWASMModule) {}\n\n  newRuntime(options?: RuntimeOptions): QuickJSRuntime {\n    const runtime = this.parent.newRuntime({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.runtimes.delete(runtime)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.runtimes.add(runtime)\n    return runtime\n  }\n\n  newContext(options?: ContextOptions): QuickJSContext {\n    const context = this.parent.newContext({\n      ...options,\n      ownedLifetimes: [\n        new Lifetime(undefined, undefined, () => this.contexts.delete(context)),\n        ...(options?.ownedLifetimes ?? []),\n      ],\n    })\n    this.contexts.add(context)\n    return context\n  }\n\n  evalCode(code: string, options?: ModuleEvalOptions): unknown {\n    return this.parent.evalCode(code, options)\n  }\n\n  disposeAll() {\n    const allDisposables = [...this.contexts, ...this.runtimes]\n    this.runtimes.clear()\n    this.contexts.clear()\n    allDisposables.forEach((d) => {\n      if (d.alive) {\n        d.dispose()\n      }\n    })\n  }\n\n  assertNoMemoryAllocated() {\n    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck()\n    if (leaksDetected) {\n      // Note: this is currently only available when building from source\n      // with debug builds.\n      throw new QuickJSMemoryLeakDetected(\"Leak sanitizer detected un-freed memory\")\n    }\n\n    if (this.contexts.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`)\n    }\n\n    if (this.runtimes.size > 0) {\n      throw new QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`)\n    }\n  }\n\n  /** @private */\n  getFFI() {\n    return this.parent.getFFI()\n  }\n}\n"]},"metadata":{},"sourceType":"script"}