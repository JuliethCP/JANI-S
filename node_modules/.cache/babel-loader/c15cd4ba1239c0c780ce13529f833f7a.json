{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __setFunctionName = this && this.__setFunctionName || function (f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", {\n    configurable: true,\n    value: prefix ? \"\".concat(prefix, \" \", name) : name\n  });\n};\nimport { spawn, spawnSync } from 'child_process';\nimport { PassThrough } from 'stream';\nimport debug from 'debug';\nimport { bufferCount, concatMap, filter, from, fromEvent, lastValueFrom, map, takeUntil, tap } from '../../third_party/rxjs/rxjs.js';\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { debugError } from '../common/util.js';\nimport { guarded } from '../util/decorators.js';\nimport { asyncDisposeSymbol } from '../util/disposable.js';\nconst CRF_VALUE = 30;\nconst DEFAULT_FPS = 30;\nconst debugFfmpeg = debug('puppeteer:ffmpeg');\n/**\n * @public\n */\nlet ScreenRecorder = (() => {\n  let _classSuper = PassThrough;\n  let _instanceExtraInitializers = [];\n  let _private_writeFrame_decorators;\n  let _private_writeFrame_descriptor;\n  let _stop_decorators;\n  return class ScreenRecorder extends _classSuper {\n    static #_ = (() => {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      __esDecorate(this, _private_writeFrame_descriptor = {\n        value: __setFunctionName(async function (buffer) {\n          const error = await new Promise(resolve => {\n            this.#process.stdin.write(buffer, resolve);\n          });\n          if (error) {\n            console.log(`ffmpeg failed to write: ${error.message}.`);\n          }\n        }, \"#writeFrame\")\n      }, _private_writeFrame_decorators, {\n        kind: \"method\",\n        name: \"#writeFrame\",\n        static: false,\n        private: true,\n        access: {\n          has: obj => #writeFrame in obj,\n          get: obj => obj.#writeFrame\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _stop_decorators, {\n        kind: \"method\",\n        name: \"stop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"stop\" in obj,\n          get: obj => obj.stop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    })();\n    #page = (__runInitializers(this, _instanceExtraInitializers), void 0);\n    #process;\n    #controller = new AbortController();\n    #lastFrame;\n    /**\n     * @internal\n     */\n    constructor(page, width, height) {\n      let {\n        speed,\n        scale,\n        crop,\n        format,\n        path\n      } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      super({\n        allowHalfOpen: false\n      });\n      path ??= 'ffmpeg';\n      // Tests if `ffmpeg` exists.\n      const {\n        error\n      } = spawnSync(path);\n      if (error) {\n        throw error;\n      }\n      this.#process = spawn(path,\n      // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.\n      [['-loglevel', 'error'],\n      // Reduces general buffering.\n      ['-avioflags', 'direct'],\n      // Reduces initial buffering while analyzing input fps and other stats.\n      ['-fpsprobesize', `${0}`, '-probesize', `${32}`, '-analyzeduration', `${0}`, '-fflags', 'nobuffer'],\n      // Forces input to be read from standard input, and forces png input\n      // image format.\n      ['-f', 'image2pipe', '-c:v', 'png', '-i', 'pipe:0'],\n      // Overwrite output and no audio.\n      ['-y', '-an'],\n      // This drastically reduces stalling when cpu is overbooked. By default\n      // VP9 tries to use all available threads?\n      ['-threads', '1'],\n      // Specifies the frame rate we are giving ffmpeg.\n      ['-framerate', `${DEFAULT_FPS}`],\n      // Specifies the encoding and format we are using.\n      this.#getFormatArgs(format ?? 'webm'),\n      // Disable bitrate.\n      ['-b:v', `${0}`],\n      // Filters to ensure the images are piped correctly.\n      ['-vf', `${speed ? `setpts=${1 / speed}*PTS,` : ''}crop='min(${width},iw):min(${height},ih):${0}:${0}',pad=${width}:${height}:${0}:${0}${crop ? `,crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}` : ''}${scale ? `,scale=iw*${scale}:-1` : ''}`], 'pipe:1'].flat(), {\n        stdio: ['pipe', 'pipe', 'pipe']\n      });\n      this.#process.stdout.pipe(this);\n      this.#process.stderr.on('data', data => {\n        debugFfmpeg(data.toString('utf8'));\n      });\n      this.#page = page;\n      const {\n        client\n      } = this.#page.mainFrame();\n      client.once(CDPSessionEvent.Disconnected, () => {\n        void this.stop().catch(debugError);\n      });\n      this.#lastFrame = lastValueFrom(fromEvent(client, 'Page.screencastFrame').pipe(tap(event => {\n        void client.send('Page.screencastFrameAck', {\n          sessionId: event.sessionId\n        });\n      }), filter(event => {\n        return event.metadata.timestamp !== undefined;\n      }), map(event => {\n        return {\n          buffer: Buffer.from(event.data, 'base64'),\n          timestamp: event.metadata.timestamp\n        };\n      }), bufferCount(2, 1), concatMap(_ref => {\n        let [{\n          timestamp: previousTimestamp,\n          buffer\n        }, {\n          timestamp\n        }] = _ref;\n        return from(Array(Math.round(DEFAULT_FPS * Math.max(timestamp - previousTimestamp, 0))).fill(buffer));\n      }), map(buffer => {\n        void this.#writeFrame(buffer);\n        return [buffer, performance.now()];\n      }), takeUntil(fromEvent(this.#controller.signal, 'abort'))), {\n        defaultValue: [Buffer.from([]), performance.now()]\n      });\n    }\n    #getFormatArgs(format) {\n      switch (format) {\n        case 'webm':\n          return [\n          // Sets the codec to use.\n          ['-c:v', 'vp9'],\n          // Sets the format\n          ['-f', 'webm'],\n          // Sets the quality. Lower the better.\n          ['-crf', `${CRF_VALUE}`],\n          // Sets the quality and how efficient the compression will be.\n          ['-deadline', 'realtime', '-cpu-used', `${8}`]].flat();\n        case 'gif':\n          return [\n          // Sets the frame rate and uses a custom palette generated from the\n          // input.\n          ['-vf', 'fps=5,split[s0][s1];[s0]palettegen=stats_mode=diff[p];[s1][p]paletteuse'],\n          // Sets the format\n          ['-f', 'gif']].flat();\n      }\n    }\n    get #writeFrame() {\n      return _private_writeFrame_descriptor.value;\n    }\n    /**\n     * Stops the recorder.\n     *\n     * @public\n     */\n    async stop() {\n      if (this.#controller.signal.aborted) {\n        return;\n      }\n      // Stopping the screencast will flush the frames.\n      await this.#page._stopScreencast().catch(debugError);\n      this.#controller.abort();\n      // Repeat the last frame for the remaining frames.\n      const [buffer, timestamp] = await this.#lastFrame;\n      await Promise.all(Array(Math.max(1, Math.round(DEFAULT_FPS * (performance.now() - timestamp) / 1000))).fill(buffer).map(this.#writeFrame.bind(this)));\n      // Close stdin to notify FFmpeg we are done.\n      this.#process.stdin.end();\n      await new Promise(resolve => {\n        this.#process.once('close', resolve);\n      });\n    }\n    /**\n     * @internal\n     */\n    async [(_private_writeFrame_decorators = [guarded()], _stop_decorators = [guarded()], asyncDisposeSymbol)]() {\n      await this.stop();\n    }\n  };\n})();\nexport { ScreenRecorder };","map":{"version":3,"mappings":"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","names":["spawn","spawnSync","PassThrough","debug","bufferCount","concatMap","filter","from","fromEvent","lastValueFrom","map","takeUntil","tap","CDPSessionEvent","debugError","guarded","asyncDisposeSymbol","CRF_VALUE","DEFAULT_FPS","debugFfmpeg","ScreenRecorder","_classSuper","__esDecorate","value","buffer","error","Promise","resolve","stdin","write","console","log","message","kind","name","static","private","access","has","get","metadata","stop","AbortController","constructor","page","width","height","speed","scale","crop","format","path","allowHalfOpen","x","y","flat","stdio","stdout","pipe","stderr","on","data","toString","client","mainFrame","once","Disconnected","catch","event","send","sessionId","timestamp","undefined","Buffer","previousTimestamp","Array","Math","round","max","fill","performance","now","signal","defaultValue","aborted","_stopScreencast","abort","all","bind","end","_private_writeFrame_decorators"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\node\\ScreenRecorder.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {ChildProcessWithoutNullStreams} from 'child_process';\nimport {spawn, spawnSync} from 'child_process';\nimport {PassThrough} from 'stream';\n\nimport debug from 'debug';\nimport type Protocol from 'devtools-protocol';\n\nimport type {\n  Observable,\n  OperatorFunction,\n} from '../../third_party/rxjs/rxjs.js';\nimport {\n  bufferCount,\n  concatMap,\n  filter,\n  from,\n  fromEvent,\n  lastValueFrom,\n  map,\n  takeUntil,\n  tap,\n} from '../../third_party/rxjs/rxjs.js';\nimport {CDPSessionEvent} from '../api/CDPSession.js';\nimport type {BoundingBox} from '../api/ElementHandle.js';\nimport type {Page} from '../api/Page.js';\nimport {debugError} from '../common/util.js';\nimport {guarded} from '../util/decorators.js';\nimport {asyncDisposeSymbol} from '../util/disposable.js';\n\nconst CRF_VALUE = 30;\nconst DEFAULT_FPS = 30;\n\nconst debugFfmpeg = debug('puppeteer:ffmpeg');\n\n/**\n * @internal\n */\nexport interface ScreenRecorderOptions {\n  speed?: number;\n  crop?: BoundingBox;\n  format?: 'gif' | 'webm';\n  scale?: number;\n  path?: string;\n}\n\n/**\n * @public\n */\nexport class ScreenRecorder extends PassThrough {\n  #page: Page;\n\n  #process: ChildProcessWithoutNullStreams;\n\n  #controller = new AbortController();\n  #lastFrame: Promise<readonly [Buffer, number]>;\n\n  /**\n   * @internal\n   */\n  constructor(\n    page: Page,\n    width: number,\n    height: number,\n    {speed, scale, crop, format, path}: ScreenRecorderOptions = {}\n  ) {\n    super({allowHalfOpen: false});\n\n    path ??= 'ffmpeg';\n\n    // Tests if `ffmpeg` exists.\n    const {error} = spawnSync(path);\n    if (error) {\n      throw error;\n    }\n\n    this.#process = spawn(\n      path,\n      // See https://trac.ffmpeg.org/wiki/Encode/VP9 for more information on flags.\n      [\n        ['-loglevel', 'error'],\n        // Reduces general buffering.\n        ['-avioflags', 'direct'],\n        // Reduces initial buffering while analyzing input fps and other stats.\n        [\n          '-fpsprobesize',\n          `${0}`,\n          '-probesize',\n          `${32}`,\n          '-analyzeduration',\n          `${0}`,\n          '-fflags',\n          'nobuffer',\n        ],\n        // Forces input to be read from standard input, and forces png input\n        // image format.\n        ['-f', 'image2pipe', '-c:v', 'png', '-i', 'pipe:0'],\n        // Overwrite output and no audio.\n        ['-y', '-an'],\n        // This drastically reduces stalling when cpu is overbooked. By default\n        // VP9 tries to use all available threads?\n        ['-threads', '1'],\n        // Specifies the frame rate we are giving ffmpeg.\n        ['-framerate', `${DEFAULT_FPS}`],\n        // Specifies the encoding and format we are using.\n        this.#getFormatArgs(format ?? 'webm'),\n        // Disable bitrate.\n        ['-b:v', `${0}`],\n        // Filters to ensure the images are piped correctly.\n        [\n          '-vf',\n          `${\n            speed ? `setpts=${1 / speed}*PTS,` : ''\n          }crop='min(${width},iw):min(${height},ih):${0}:${0}',pad=${width}:${height}:${0}:${0}${\n            crop ? `,crop=${crop.width}:${crop.height}:${crop.x}:${crop.y}` : ''\n          }${scale ? `,scale=iw*${scale}:-1` : ''}`,\n        ],\n        'pipe:1',\n      ].flat(),\n      {stdio: ['pipe', 'pipe', 'pipe']}\n    );\n    this.#process.stdout.pipe(this);\n    this.#process.stderr.on('data', (data: Buffer) => {\n      debugFfmpeg(data.toString('utf8'));\n    });\n\n    this.#page = page;\n\n    const {client} = this.#page.mainFrame();\n    client.once(CDPSessionEvent.Disconnected, () => {\n      void this.stop().catch(debugError);\n    });\n\n    this.#lastFrame = lastValueFrom(\n      (\n        fromEvent(\n          client,\n          'Page.screencastFrame'\n        ) as Observable<Protocol.Page.ScreencastFrameEvent>\n      ).pipe(\n        tap(event => {\n          void client.send('Page.screencastFrameAck', {\n            sessionId: event.sessionId,\n          });\n        }),\n        filter(event => {\n          return event.metadata.timestamp !== undefined;\n        }),\n        map(event => {\n          return {\n            buffer: Buffer.from(event.data, 'base64'),\n            timestamp: event.metadata.timestamp!,\n          };\n        }),\n        bufferCount(2, 1) as OperatorFunction<\n          {buffer: Buffer; timestamp: number},\n          [\n            {buffer: Buffer; timestamp: number},\n            {buffer: Buffer; timestamp: number},\n          ]\n        >,\n        concatMap(([{timestamp: previousTimestamp, buffer}, {timestamp}]) => {\n          return from(\n            Array<Buffer>(\n              Math.round(\n                DEFAULT_FPS * Math.max(timestamp - previousTimestamp, 0)\n              )\n            ).fill(buffer)\n          );\n        }),\n        map(buffer => {\n          void this.#writeFrame(buffer);\n          return [buffer, performance.now()] as const;\n        }),\n        takeUntil(fromEvent(this.#controller.signal, 'abort'))\n      ),\n      {defaultValue: [Buffer.from([]), performance.now()] as const}\n    );\n  }\n\n  #getFormatArgs(format: 'webm' | 'gif') {\n    switch (format) {\n      case 'webm':\n        return [\n          // Sets the codec to use.\n          ['-c:v', 'vp9'],\n          // Sets the format\n          ['-f', 'webm'],\n          // Sets the quality. Lower the better.\n          ['-crf', `${CRF_VALUE}`],\n          // Sets the quality and how efficient the compression will be.\n          ['-deadline', 'realtime', '-cpu-used', `${8}`],\n        ].flat();\n      case 'gif':\n        return [\n          // Sets the frame rate and uses a custom palette generated from the\n          // input.\n          [\n            '-vf',\n            'fps=5,split[s0][s1];[s0]palettegen=stats_mode=diff[p];[s1][p]paletteuse',\n          ],\n          // Sets the format\n          ['-f', 'gif'],\n        ].flat();\n    }\n  }\n\n  @guarded()\n  async #writeFrame(buffer: Buffer) {\n    const error = await new Promise<Error | null | undefined>(resolve => {\n      this.#process.stdin.write(buffer, resolve);\n    });\n    if (error) {\n      console.log(`ffmpeg failed to write: ${error.message}.`);\n    }\n  }\n\n  /**\n   * Stops the recorder.\n   *\n   * @public\n   */\n  @guarded()\n  async stop(): Promise<void> {\n    if (this.#controller.signal.aborted) {\n      return;\n    }\n    // Stopping the screencast will flush the frames.\n    await this.#page._stopScreencast().catch(debugError);\n\n    this.#controller.abort();\n\n    // Repeat the last frame for the remaining frames.\n    const [buffer, timestamp] = await this.#lastFrame;\n    await Promise.all(\n      Array<Buffer>(\n        Math.max(\n          1,\n          Math.round((DEFAULT_FPS * (performance.now() - timestamp)) / 1000)\n        )\n      )\n        .fill(buffer)\n        .map(this.#writeFrame.bind(this))\n    );\n\n    // Close stdin to notify FFmpeg we are done.\n    this.#process.stdin.end();\n    await new Promise(resolve => {\n      this.#process.once('close', resolve);\n    });\n  }\n\n  /**\n   * @internal\n   */\n  async [asyncDisposeSymbol](): Promise<void> {\n    await this.stop();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}