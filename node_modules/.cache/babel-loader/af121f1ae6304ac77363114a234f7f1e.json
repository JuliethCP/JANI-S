{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\nimport { Browser, executablePathByBrowser } from './browser-data/browser-data.js';\nimport { detectBrowserPlatform } from './detectPlatform.js';\n/**\n * @public\n */\nexport class InstalledBrowser {\n  browser;\n  buildId;\n  platform;\n  executablePath;\n  #cache;\n  /**\n   * @internal\n   */\n  constructor(cache, browser, buildId, platform) {\n    this.#cache = cache;\n    this.browser = browser;\n    this.buildId = buildId;\n    this.platform = platform;\n    this.executablePath = cache.computeExecutablePath({\n      browser,\n      buildId,\n      platform\n    });\n  }\n  /**\n   * Path to the root of the installation folder. Use\n   * {@link computeExecutablePath} to get the path to the executable binary.\n   */\n  get path() {\n    return this.#cache.installationDir(this.browser, this.platform, this.buildId);\n  }\n}\n/**\n * The cache used by Puppeteer relies on the following structure:\n *\n * - rootDir\n *   -- <browser1> | browserRoot(browser1)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   -- <browser2> | browserRoot(browser2)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   @internal\n */\nexport class Cache {\n  #rootDir;\n  constructor(rootDir) {\n    this.#rootDir = rootDir;\n  }\n  /**\n   * @internal\n   */\n  get rootDir() {\n    return this.#rootDir;\n  }\n  browserRoot(browser) {\n    return path.join(this.#rootDir, browser);\n  }\n  installationDir(browser, platform, buildId) {\n    return path.join(this.browserRoot(browser), `${platform}-${buildId}`);\n  }\n  clear() {\n    fs.rmSync(this.#rootDir, {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500\n    });\n  }\n  uninstall(browser, platform, buildId) {\n    fs.rmSync(this.installationDir(browser, platform, buildId), {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500\n    });\n  }\n  getInstalledBrowsers() {\n    if (!fs.existsSync(this.#rootDir)) {\n      return [];\n    }\n    const types = fs.readdirSync(this.#rootDir);\n    const browsers = types.filter(t => {\n      return Object.values(Browser).includes(t);\n    });\n    return browsers.flatMap(browser => {\n      const files = fs.readdirSync(this.browserRoot(browser));\n      return files.map(file => {\n        const result = parseFolderPath(path.join(this.browserRoot(browser), file));\n        if (!result) {\n          return null;\n        }\n        return new InstalledBrowser(this, browser, result.buildId, result.platform);\n      }).filter(item => {\n        return item !== null;\n      });\n    });\n  }\n  computeExecutablePath(options) {\n    options.platform ??= detectBrowserPlatform();\n    if (!options.platform) {\n      throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);\n    }\n    const installationDir = this.installationDir(options.browser, options.platform, options.buildId);\n    return path.join(installationDir, executablePathByBrowser[options.browser](options.platform, options.buildId));\n  }\n}\nfunction parseFolderPath(folderPath) {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) {\n    return;\n  }\n  const [platform, buildId] = splits;\n  if (!buildId || !platform) {\n    return;\n  }\n  return {\n    platform,\n    buildId\n  };\n}","map":{"version":3,"mappings":"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","names":["fs","os","path","Browser","executablePathByBrowser","detectBrowserPlatform","InstalledBrowser","browser","buildId","platform","executablePath","constructor","cache","computeExecutablePath","installationDir","Cache","rootDir","browserRoot","join","clear","rmSync","force","recursive","maxRetries","retryDelay","uninstall","getInstalledBrowsers","existsSync","types","readdirSync","browsers","filter","t","Object","values","includes","flatMap","files","map","file","result","parseFolderPath","item","options","Error","arch","folderPath","name","basename","splits","split","length"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@puppeteer\\browsers\\src\\Cache.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport fs from 'fs';\nimport os from 'os';\nimport path from 'path';\n\nimport {\n  Browser,\n  type BrowserPlatform,\n  executablePathByBrowser,\n} from './browser-data/browser-data.js';\nimport {detectBrowserPlatform} from './detectPlatform.js';\n\n/**\n * @public\n */\nexport class InstalledBrowser {\n  browser: Browser;\n  buildId: string;\n  platform: BrowserPlatform;\n  readonly executablePath: string;\n\n  #cache: Cache;\n\n  /**\n   * @internal\n   */\n  constructor(\n    cache: Cache,\n    browser: Browser,\n    buildId: string,\n    platform: BrowserPlatform\n  ) {\n    this.#cache = cache;\n    this.browser = browser;\n    this.buildId = buildId;\n    this.platform = platform;\n    this.executablePath = cache.computeExecutablePath({\n      browser,\n      buildId,\n      platform,\n    });\n  }\n\n  /**\n   * Path to the root of the installation folder. Use\n   * {@link computeExecutablePath} to get the path to the executable binary.\n   */\n  get path(): string {\n    return this.#cache.installationDir(\n      this.browser,\n      this.platform,\n      this.buildId\n    );\n  }\n}\n\n/**\n * @internal\n */\nexport interface ComputeExecutablePathOptions {\n  /**\n   * Determines which platform the browser will be suited for.\n   *\n   * @defaultValue **Auto-detected.**\n   */\n  platform?: BrowserPlatform;\n  /**\n   * Determines which browser to launch.\n   */\n  browser: Browser;\n  /**\n   * Determines which buildId to download. BuildId should uniquely identify\n   * binaries and they are used for caching.\n   */\n  buildId: string;\n}\n\n/**\n * The cache used by Puppeteer relies on the following structure:\n *\n * - rootDir\n *   -- <browser1> | browserRoot(browser1)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   -- <browser2> | browserRoot(browser2)\n *   ---- <platform>-<buildId> | installationDir()\n *   ------ the browser-platform-buildId\n *   ------ specific structure.\n *   @internal\n */\nexport class Cache {\n  #rootDir: string;\n\n  constructor(rootDir: string) {\n    this.#rootDir = rootDir;\n  }\n\n  /**\n   * @internal\n   */\n  get rootDir(): string {\n    return this.#rootDir;\n  }\n\n  browserRoot(browser: Browser): string {\n    return path.join(this.#rootDir, browser);\n  }\n\n  installationDir(\n    browser: Browser,\n    platform: BrowserPlatform,\n    buildId: string\n  ): string {\n    return path.join(this.browserRoot(browser), `${platform}-${buildId}`);\n  }\n\n  clear(): void {\n    fs.rmSync(this.#rootDir, {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500,\n    });\n  }\n\n  uninstall(\n    browser: Browser,\n    platform: BrowserPlatform,\n    buildId: string\n  ): void {\n    fs.rmSync(this.installationDir(browser, platform, buildId), {\n      force: true,\n      recursive: true,\n      maxRetries: 10,\n      retryDelay: 500,\n    });\n  }\n\n  getInstalledBrowsers(): InstalledBrowser[] {\n    if (!fs.existsSync(this.#rootDir)) {\n      return [];\n    }\n    const types = fs.readdirSync(this.#rootDir);\n    const browsers = types.filter((t): t is Browser => {\n      return (Object.values(Browser) as string[]).includes(t);\n    });\n    return browsers.flatMap(browser => {\n      const files = fs.readdirSync(this.browserRoot(browser));\n      return files\n        .map(file => {\n          const result = parseFolderPath(\n            path.join(this.browserRoot(browser), file)\n          );\n          if (!result) {\n            return null;\n          }\n          return new InstalledBrowser(\n            this,\n            browser,\n            result.buildId,\n            result.platform as BrowserPlatform\n          );\n        })\n        .filter((item: InstalledBrowser | null): item is InstalledBrowser => {\n          return item !== null;\n        });\n    });\n  }\n\n  computeExecutablePath(options: ComputeExecutablePathOptions): string {\n    options.platform ??= detectBrowserPlatform();\n    if (!options.platform) {\n      throw new Error(\n        `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n      );\n    }\n    const installationDir = this.installationDir(\n      options.browser,\n      options.platform,\n      options.buildId\n    );\n    return path.join(\n      installationDir,\n      executablePathByBrowser[options.browser](\n        options.platform,\n        options.buildId\n      )\n    );\n  }\n}\n\nfunction parseFolderPath(\n  folderPath: string\n): {platform: string; buildId: string} | undefined {\n  const name = path.basename(folderPath);\n  const splits = name.split('-');\n  if (splits.length !== 2) {\n    return;\n  }\n  const [platform, buildId] = splits;\n  if (!buildId || !platform) {\n    return;\n  }\n  return {platform, buildId};\n}\n"]},"metadata":{},"sourceType":"module"}