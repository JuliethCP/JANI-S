{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FTPContext = exports.FTPError = void 0;\nconst net_1 = require(\"net\");\nconst parseControlResponse_1 = require(\"./parseControlResponse\");\n/**\n * Describes an FTP server error response including the FTP response code.\n */\nclass FTPError extends Error {\n  constructor(res) {\n    super(res.message);\n    this.name = this.constructor.name;\n    this.code = res.code;\n  }\n}\nexports.FTPError = FTPError;\nfunction doNothing() {\n  /** Do nothing */\n}\n/**\n * FTPContext holds the control and data sockets of an FTP connection and provides a\n * simplified way to interact with an FTP server, handle responses, errors and timeouts.\n *\n * It doesn't implement or use any FTP commands. It's only a foundation to make writing an FTP\n * client as easy as possible. You won't usually instantiate this, but use `Client`.\n */\nclass FTPContext {\n  /**\n   * Instantiate an FTP context.\n   *\n   * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.\n   * @param encoding - Encoding to use for control connection. UTF-8 by default. Use \"latin1\" for older servers.\n   */\n  constructor() {\n    let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let encoding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"utf8\";\n    this.timeout = timeout;\n    /** Debug-level logging of all socket communication. */\n    this.verbose = false;\n    /** IP version to prefer (4: IPv4, 6: IPv6, undefined: automatic). */\n    this.ipFamily = undefined;\n    /** Options for TLS connections. */\n    this.tlsOptions = {};\n    /** A multiline response might be received as multiple chunks. */\n    this._partialResponse = \"\";\n    this._encoding = encoding;\n    // Help Typescript understand that we do indeed set _socket in the constructor but use the setter method to do so.\n    this._socket = this.socket = this._newSocket();\n    this._dataSocket = undefined;\n  }\n  /**\n   * Close the context.\n   */\n  close() {\n    // Internally, closing a context is always described with an error. If there is still a task running, it will\n    // abort with an exception that the user closed the client during a task. If no task is running, no exception is\n    // thrown but all newly submitted tasks after that will abort the exception that the client has been closed.\n    // In addition the user will get a stack trace pointing to where exactly the client has been closed. So in any\n    // case use _closingError to determine whether a context is closed. This also allows us to have a single code-path\n    // for closing a context making the implementation easier.\n    const message = this._task ? \"User closed client during task\" : \"User closed client\";\n    const err = new Error(message);\n    this.closeWithError(err);\n  }\n  /**\n   * Close the context with an error.\n   */\n  closeWithError(err) {\n    // If this context already has been closed, don't overwrite the reason.\n    if (this._closingError) {\n      return;\n    }\n    this._closingError = err;\n    // Close the sockets but don't fully reset this context to preserve `this._closingError`.\n    this._closeControlSocket();\n    this._closeSocket(this._dataSocket);\n    // Give the user's task a chance to react, maybe cleanup resources.\n    this._passToHandler(err);\n    // The task might not have been rejected by the user after receiving the error.\n    this._stopTrackingTask();\n  }\n  /**\n   * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.\n   */\n  get closed() {\n    return this.socket.remoteAddress === undefined || this._closingError !== undefined;\n  }\n  /**\n   * Reset this contex and all of its state.\n   */\n  reset() {\n    this.socket = this._newSocket();\n  }\n  /**\n   * Get the FTP control socket.\n   */\n  get socket() {\n    return this._socket;\n  }\n  /**\n   * Set the socket for the control connection. This will only close the current control socket\n   * if the new one is not an upgrade to the current one.\n   */\n  set socket(socket) {\n    // No data socket should be open in any case where the control socket is set or upgraded.\n    this.dataSocket = undefined;\n    // This being a reset, reset any other state apart from the socket.\n    this.tlsOptions = {};\n    this._partialResponse = \"\";\n    if (this._socket) {\n      const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;\n      if (newSocketUpgradesExisting) {\n        this._removeSocketListeners(this.socket);\n      } else {\n        this._closeControlSocket();\n      }\n    }\n    if (socket) {\n      // Setting a completely new control socket is in essence something like a reset. That's\n      // why we also close any open data connection above. We can go one step further and reset\n      // a possible closing error. That means that a closed FTPContext can be \"reopened\" by\n      // setting a new control socket.\n      this._closingError = undefined;\n      // Don't set a timeout yet. Timeout for control sockets is only active during a task, see handle() below.\n      socket.setTimeout(0);\n      socket.setEncoding(this._encoding);\n      socket.setKeepAlive(true);\n      socket.on(\"data\", data => this._onControlSocketData(data));\n      // Server sending a FIN packet is treated as an error.\n      socket.on(\"end\", () => this.closeWithError(new Error(\"Server sent FIN packet unexpectedly, closing connection.\")));\n      // Control being closed without error by server is treated as an error.\n      socket.on(\"close\", hadError => {\n        if (!hadError) this.closeWithError(new Error(\"Server closed connection unexpectedly.\"));\n      });\n      this._setupDefaultErrorHandlers(socket, \"control socket\");\n    }\n    this._socket = socket;\n  }\n  /**\n   * Get the current FTP data connection if present.\n   */\n  get dataSocket() {\n    return this._dataSocket;\n  }\n  /**\n   * Set the socket for the data connection. This will automatically close the former data socket.\n   */\n  set dataSocket(socket) {\n    this._closeSocket(this._dataSocket);\n    if (socket) {\n      // Don't set a timeout yet. Timeout data socket should be activated when data transmission starts\n      // and timeout on control socket is deactivated.\n      socket.setTimeout(0);\n      this._setupDefaultErrorHandlers(socket, \"data socket\");\n    }\n    this._dataSocket = socket;\n  }\n  /**\n   * Get the currently used encoding.\n   */\n  get encoding() {\n    return this._encoding;\n  }\n  /**\n   * Set the encoding used for the control socket.\n   *\n   * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings\n   * are supported by Node.\n   */\n  set encoding(encoding) {\n    this._encoding = encoding;\n    if (this.socket) {\n      this.socket.setEncoding(encoding);\n    }\n  }\n  /**\n   * Send an FTP command without waiting for or handling the result.\n   */\n  send(command) {\n    const containsPassword = command.startsWith(\"PASS\");\n    const message = containsPassword ? \"> PASS ###\" : `> ${command}`;\n    this.log(message);\n    this._socket.write(command + \"\\r\\n\", this.encoding);\n  }\n  /**\n   * Send an FTP command and handle the first response. Use this if you have a simple\n   * request-response situation.\n   */\n  request(command) {\n    return this.handle(command, (res, task) => {\n      if (res instanceof Error) {\n        task.reject(res);\n      } else {\n        task.resolve(res);\n      }\n    });\n  }\n  /**\n   * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses\n   * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.\n   */\n  handle(command, responseHandler) {\n    if (this._task) {\n      const err = new Error(\"User launched a task while another one is still running. Forgot to use 'await' or '.then()'?\");\n      err.stack += `\\nRunning task launched at: ${this._task.stack}`;\n      this.closeWithError(err);\n      // Don't return here, continue with returning the Promise that will then be rejected\n      // because the context closed already. That way, users will receive an exception where\n      // they called this method by mistake.\n    }\n\n    return new Promise((resolveTask, rejectTask) => {\n      this._task = {\n        stack: new Error().stack || \"Unknown call stack\",\n        responseHandler,\n        resolver: {\n          resolve: arg => {\n            this._stopTrackingTask();\n            resolveTask(arg);\n          },\n          reject: err => {\n            this._stopTrackingTask();\n            rejectTask(err);\n          }\n        }\n      };\n      if (this._closingError) {\n        // This client has been closed. Provide an error that describes this one as being caused\n        // by `_closingError`, include stack traces for both.\n        const err = new Error(`Client is closed because ${this._closingError.message}`); // Type 'Error' is not correctly defined, doesn't have 'code'.\n        err.stack += `\\nClosing reason: ${this._closingError.stack}`;\n        err.code = this._closingError.code !== undefined ? this._closingError.code : \"0\";\n        this._passToHandler(err);\n        return;\n      }\n      // Only track control socket timeout during the lifecycle of a task. This avoids timeouts on idle sockets,\n      // the default socket behaviour which is not expected by most users.\n      this.socket.setTimeout(this.timeout);\n      if (command) {\n        this.send(command);\n      }\n    });\n  }\n  /**\n   * Log message if set to be verbose.\n   */\n  log(message) {\n    if (this.verbose) {\n      // tslint:disable-next-line no-console\n      console.log(message);\n    }\n  }\n  /**\n   * Return true if the control socket is using TLS. This does not mean that a session\n   * has already been negotiated.\n   */\n  get hasTLS() {\n    return \"encrypted\" in this._socket;\n  }\n  /**\n   * Removes reference to current task and handler. This won't resolve or reject the task.\n   * @protected\n   */\n  _stopTrackingTask() {\n    // Disable timeout on control socket if there is no task active.\n    this.socket.setTimeout(0);\n    this._task = undefined;\n  }\n  /**\n   * Handle incoming data on the control socket. The chunk is going to be of type `string`\n   * because we let `socket` handle encoding with `setEncoding`.\n   * @protected\n   */\n  _onControlSocketData(chunk) {\n    this.log(`< ${chunk}`);\n    // This chunk might complete an earlier partial response.\n    const completeResponse = this._partialResponse + chunk;\n    const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);\n    // Remember any incomplete remainder.\n    this._partialResponse = parsed.rest;\n    // Each response group is passed along individually.\n    for (const message of parsed.messages) {\n      const code = parseInt(message.substr(0, 3), 10);\n      const response = {\n        code,\n        message\n      };\n      const err = code >= 400 ? new FTPError(response) : undefined;\n      this._passToHandler(err ? err : response);\n    }\n  }\n  /**\n   * Send the current handler a response. This is usually a control socket response\n   * or a socket event, like an error or timeout.\n   * @protected\n   */\n  _passToHandler(response) {\n    if (this._task) {\n      this._task.responseHandler(response, this._task.resolver);\n    }\n    // Errors other than FTPError always close the client. If there isn't an active task to handle the error,\n    // the next one submitted will receive it using `_closingError`.\n    // There is only one edge-case: If there is an FTPError while no task is active, the error will be dropped.\n    // But that means that the user sent an FTP command with no intention of handling the result. So why should the\n    // error be handled? Maybe log it at least? Debug logging will already do that and the client stays useable after\n    // FTPError. So maybe no need to do anything here.\n  }\n  /**\n   * Setup all error handlers for a socket.\n   * @protected\n   */\n  _setupDefaultErrorHandlers(socket, identifier) {\n    socket.once(\"error\", error => {\n      error.message += ` (${identifier})`;\n      this.closeWithError(error);\n    });\n    socket.once(\"close\", hadError => {\n      if (hadError) {\n        this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));\n      }\n    });\n    socket.once(\"timeout\", () => {\n      socket.destroy();\n      this.closeWithError(new Error(`Timeout (${identifier})`));\n    });\n  }\n  /**\n   * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.\n   */\n  _closeControlSocket() {\n    this._removeSocketListeners(this._socket);\n    this._socket.on(\"error\", doNothing);\n    this.send(\"QUIT\");\n    this._closeSocket(this._socket);\n  }\n  /**\n   * Close a socket. Sends FIN and ignores any error.\n   * @protected\n   */\n  _closeSocket(socket) {\n    if (socket) {\n      this._removeSocketListeners(socket);\n      socket.on(\"error\", doNothing);\n      socket.on(\"timeout\", () => socket.destroy());\n      socket.setTimeout(this.timeout);\n      socket.end();\n    }\n  }\n  /**\n   * Remove all default listeners for socket.\n   * @protected\n   */\n  _removeSocketListeners(socket) {\n    socket.removeAllListeners();\n    // Before Node.js 10.3.0, using `socket.removeAllListeners()` without any name did not work: https://github.com/nodejs/node/issues/20923.\n    socket.removeAllListeners(\"timeout\");\n    socket.removeAllListeners(\"data\");\n    socket.removeAllListeners(\"end\");\n    socket.removeAllListeners(\"error\");\n    socket.removeAllListeners(\"close\");\n    socket.removeAllListeners(\"connect\");\n  }\n  /**\n   * Provide a new socket instance.\n   *\n   * Internal use only, replaced for unit tests.\n   */\n  _newSocket() {\n    return new net_1.Socket();\n  }\n}\nexports.FTPContext = FTPContext;","map":{"version":3,"names":["Object","defineProperty","exports","value","FTPContext","FTPError","net_1","require","parseControlResponse_1","Error","constructor","res","message","name","code","doNothing","timeout","encoding","verbose","ipFamily","undefined","tlsOptions","_partialResponse","_encoding","_socket","socket","_newSocket","_dataSocket","close","_task","err","closeWithError","_closingError","_closeControlSocket","_closeSocket","_passToHandler","_stopTrackingTask","closed","remoteAddress","reset","dataSocket","newSocketUpgradesExisting","localPort","_removeSocketListeners","setTimeout","setEncoding","setKeepAlive","on","data","_onControlSocketData","hadError","_setupDefaultErrorHandlers","send","command","containsPassword","startsWith","log","write","request","handle","task","reject","resolve","responseHandler","stack","Promise","resolveTask","rejectTask","resolver","arg","console","hasTLS","chunk","completeResponse","parsed","parseControlResponse","rest","messages","parseInt","substr","response","identifier","once","error","destroy","end","removeAllListeners","Socket"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/FtpContext.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.FTPContext = exports.FTPError = void 0;\nconst net_1 = require(\"net\");\nconst parseControlResponse_1 = require(\"./parseControlResponse\");\n/**\n * Describes an FTP server error response including the FTP response code.\n */\nclass FTPError extends Error {\n    constructor(res) {\n        super(res.message);\n        this.name = this.constructor.name;\n        this.code = res.code;\n    }\n}\nexports.FTPError = FTPError;\nfunction doNothing() {\n    /** Do nothing */\n}\n/**\n * FTPContext holds the control and data sockets of an FTP connection and provides a\n * simplified way to interact with an FTP server, handle responses, errors and timeouts.\n *\n * It doesn't implement or use any FTP commands. It's only a foundation to make writing an FTP\n * client as easy as possible. You won't usually instantiate this, but use `Client`.\n */\nclass FTPContext {\n    /**\n     * Instantiate an FTP context.\n     *\n     * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.\n     * @param encoding - Encoding to use for control connection. UTF-8 by default. Use \"latin1\" for older servers.\n     */\n    constructor(timeout = 0, encoding = \"utf8\") {\n        this.timeout = timeout;\n        /** Debug-level logging of all socket communication. */\n        this.verbose = false;\n        /** IP version to prefer (4: IPv4, 6: IPv6, undefined: automatic). */\n        this.ipFamily = undefined;\n        /** Options for TLS connections. */\n        this.tlsOptions = {};\n        /** A multiline response might be received as multiple chunks. */\n        this._partialResponse = \"\";\n        this._encoding = encoding;\n        // Help Typescript understand that we do indeed set _socket in the constructor but use the setter method to do so.\n        this._socket = this.socket = this._newSocket();\n        this._dataSocket = undefined;\n    }\n    /**\n     * Close the context.\n     */\n    close() {\n        // Internally, closing a context is always described with an error. If there is still a task running, it will\n        // abort with an exception that the user closed the client during a task. If no task is running, no exception is\n        // thrown but all newly submitted tasks after that will abort the exception that the client has been closed.\n        // In addition the user will get a stack trace pointing to where exactly the client has been closed. So in any\n        // case use _closingError to determine whether a context is closed. This also allows us to have a single code-path\n        // for closing a context making the implementation easier.\n        const message = this._task ? \"User closed client during task\" : \"User closed client\";\n        const err = new Error(message);\n        this.closeWithError(err);\n    }\n    /**\n     * Close the context with an error.\n     */\n    closeWithError(err) {\n        // If this context already has been closed, don't overwrite the reason.\n        if (this._closingError) {\n            return;\n        }\n        this._closingError = err;\n        // Close the sockets but don't fully reset this context to preserve `this._closingError`.\n        this._closeControlSocket();\n        this._closeSocket(this._dataSocket);\n        // Give the user's task a chance to react, maybe cleanup resources.\n        this._passToHandler(err);\n        // The task might not have been rejected by the user after receiving the error.\n        this._stopTrackingTask();\n    }\n    /**\n     * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.\n     */\n    get closed() {\n        return this.socket.remoteAddress === undefined || this._closingError !== undefined;\n    }\n    /**\n     * Reset this contex and all of its state.\n     */\n    reset() {\n        this.socket = this._newSocket();\n    }\n    /**\n     * Get the FTP control socket.\n     */\n    get socket() {\n        return this._socket;\n    }\n    /**\n     * Set the socket for the control connection. This will only close the current control socket\n     * if the new one is not an upgrade to the current one.\n     */\n    set socket(socket) {\n        // No data socket should be open in any case where the control socket is set or upgraded.\n        this.dataSocket = undefined;\n        // This being a reset, reset any other state apart from the socket.\n        this.tlsOptions = {};\n        this._partialResponse = \"\";\n        if (this._socket) {\n            const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;\n            if (newSocketUpgradesExisting) {\n                this._removeSocketListeners(this.socket);\n            }\n            else {\n                this._closeControlSocket();\n            }\n        }\n        if (socket) {\n            // Setting a completely new control socket is in essence something like a reset. That's\n            // why we also close any open data connection above. We can go one step further and reset\n            // a possible closing error. That means that a closed FTPContext can be \"reopened\" by\n            // setting a new control socket.\n            this._closingError = undefined;\n            // Don't set a timeout yet. Timeout for control sockets is only active during a task, see handle() below.\n            socket.setTimeout(0);\n            socket.setEncoding(this._encoding);\n            socket.setKeepAlive(true);\n            socket.on(\"data\", data => this._onControlSocketData(data));\n            // Server sending a FIN packet is treated as an error.\n            socket.on(\"end\", () => this.closeWithError(new Error(\"Server sent FIN packet unexpectedly, closing connection.\")));\n            // Control being closed without error by server is treated as an error.\n            socket.on(\"close\", hadError => { if (!hadError)\n                this.closeWithError(new Error(\"Server closed connection unexpectedly.\")); });\n            this._setupDefaultErrorHandlers(socket, \"control socket\");\n        }\n        this._socket = socket;\n    }\n    /**\n     * Get the current FTP data connection if present.\n     */\n    get dataSocket() {\n        return this._dataSocket;\n    }\n    /**\n     * Set the socket for the data connection. This will automatically close the former data socket.\n     */\n    set dataSocket(socket) {\n        this._closeSocket(this._dataSocket);\n        if (socket) {\n            // Don't set a timeout yet. Timeout data socket should be activated when data transmission starts\n            // and timeout on control socket is deactivated.\n            socket.setTimeout(0);\n            this._setupDefaultErrorHandlers(socket, \"data socket\");\n        }\n        this._dataSocket = socket;\n    }\n    /**\n     * Get the currently used encoding.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Set the encoding used for the control socket.\n     *\n     * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings\n     * are supported by Node.\n     */\n    set encoding(encoding) {\n        this._encoding = encoding;\n        if (this.socket) {\n            this.socket.setEncoding(encoding);\n        }\n    }\n    /**\n     * Send an FTP command without waiting for or handling the result.\n     */\n    send(command) {\n        const containsPassword = command.startsWith(\"PASS\");\n        const message = containsPassword ? \"> PASS ###\" : `> ${command}`;\n        this.log(message);\n        this._socket.write(command + \"\\r\\n\", this.encoding);\n    }\n    /**\n     * Send an FTP command and handle the first response. Use this if you have a simple\n     * request-response situation.\n     */\n    request(command) {\n        return this.handle(command, (res, task) => {\n            if (res instanceof Error) {\n                task.reject(res);\n            }\n            else {\n                task.resolve(res);\n            }\n        });\n    }\n    /**\n     * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses\n     * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.\n     */\n    handle(command, responseHandler) {\n        if (this._task) {\n            const err = new Error(\"User launched a task while another one is still running. Forgot to use 'await' or '.then()'?\");\n            err.stack += `\\nRunning task launched at: ${this._task.stack}`;\n            this.closeWithError(err);\n            // Don't return here, continue with returning the Promise that will then be rejected\n            // because the context closed already. That way, users will receive an exception where\n            // they called this method by mistake.\n        }\n        return new Promise((resolveTask, rejectTask) => {\n            this._task = {\n                stack: new Error().stack || \"Unknown call stack\",\n                responseHandler,\n                resolver: {\n                    resolve: arg => {\n                        this._stopTrackingTask();\n                        resolveTask(arg);\n                    },\n                    reject: err => {\n                        this._stopTrackingTask();\n                        rejectTask(err);\n                    }\n                }\n            };\n            if (this._closingError) {\n                // This client has been closed. Provide an error that describes this one as being caused\n                // by `_closingError`, include stack traces for both.\n                const err = new Error(`Client is closed because ${this._closingError.message}`); // Type 'Error' is not correctly defined, doesn't have 'code'.\n                err.stack += `\\nClosing reason: ${this._closingError.stack}`;\n                err.code = this._closingError.code !== undefined ? this._closingError.code : \"0\";\n                this._passToHandler(err);\n                return;\n            }\n            // Only track control socket timeout during the lifecycle of a task. This avoids timeouts on idle sockets,\n            // the default socket behaviour which is not expected by most users.\n            this.socket.setTimeout(this.timeout);\n            if (command) {\n                this.send(command);\n            }\n        });\n    }\n    /**\n     * Log message if set to be verbose.\n     */\n    log(message) {\n        if (this.verbose) {\n            // tslint:disable-next-line no-console\n            console.log(message);\n        }\n    }\n    /**\n     * Return true if the control socket is using TLS. This does not mean that a session\n     * has already been negotiated.\n     */\n    get hasTLS() {\n        return \"encrypted\" in this._socket;\n    }\n    /**\n     * Removes reference to current task and handler. This won't resolve or reject the task.\n     * @protected\n     */\n    _stopTrackingTask() {\n        // Disable timeout on control socket if there is no task active.\n        this.socket.setTimeout(0);\n        this._task = undefined;\n    }\n    /**\n     * Handle incoming data on the control socket. The chunk is going to be of type `string`\n     * because we let `socket` handle encoding with `setEncoding`.\n     * @protected\n     */\n    _onControlSocketData(chunk) {\n        this.log(`< ${chunk}`);\n        // This chunk might complete an earlier partial response.\n        const completeResponse = this._partialResponse + chunk;\n        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);\n        // Remember any incomplete remainder.\n        this._partialResponse = parsed.rest;\n        // Each response group is passed along individually.\n        for (const message of parsed.messages) {\n            const code = parseInt(message.substr(0, 3), 10);\n            const response = { code, message };\n            const err = code >= 400 ? new FTPError(response) : undefined;\n            this._passToHandler(err ? err : response);\n        }\n    }\n    /**\n     * Send the current handler a response. This is usually a control socket response\n     * or a socket event, like an error or timeout.\n     * @protected\n     */\n    _passToHandler(response) {\n        if (this._task) {\n            this._task.responseHandler(response, this._task.resolver);\n        }\n        // Errors other than FTPError always close the client. If there isn't an active task to handle the error,\n        // the next one submitted will receive it using `_closingError`.\n        // There is only one edge-case: If there is an FTPError while no task is active, the error will be dropped.\n        // But that means that the user sent an FTP command with no intention of handling the result. So why should the\n        // error be handled? Maybe log it at least? Debug logging will already do that and the client stays useable after\n        // FTPError. So maybe no need to do anything here.\n    }\n    /**\n     * Setup all error handlers for a socket.\n     * @protected\n     */\n    _setupDefaultErrorHandlers(socket, identifier) {\n        socket.once(\"error\", error => {\n            error.message += ` (${identifier})`;\n            this.closeWithError(error);\n        });\n        socket.once(\"close\", hadError => {\n            if (hadError) {\n                this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));\n            }\n        });\n        socket.once(\"timeout\", () => {\n            socket.destroy();\n            this.closeWithError(new Error(`Timeout (${identifier})`));\n        });\n    }\n    /**\n     * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.\n     */\n    _closeControlSocket() {\n        this._removeSocketListeners(this._socket);\n        this._socket.on(\"error\", doNothing);\n        this.send(\"QUIT\");\n        this._closeSocket(this._socket);\n    }\n    /**\n     * Close a socket. Sends FIN and ignores any error.\n     * @protected\n     */\n    _closeSocket(socket) {\n        if (socket) {\n            this._removeSocketListeners(socket);\n            socket.on(\"error\", doNothing);\n            socket.on(\"timeout\", () => socket.destroy());\n            socket.setTimeout(this.timeout);\n            socket.end();\n        }\n    }\n    /**\n     * Remove all default listeners for socket.\n     * @protected\n     */\n    _removeSocketListeners(socket) {\n        socket.removeAllListeners();\n        // Before Node.js 10.3.0, using `socket.removeAllListeners()` without any name did not work: https://github.com/nodejs/node/issues/20923.\n        socket.removeAllListeners(\"timeout\");\n        socket.removeAllListeners(\"data\");\n        socket.removeAllListeners(\"end\");\n        socket.removeAllListeners(\"error\");\n        socket.removeAllListeners(\"close\");\n        socket.removeAllListeners(\"connect\");\n    }\n    /**\n     * Provide a new socket instance.\n     *\n     * Internal use only, replaced for unit tests.\n     */\n    _newSocket() {\n        return new net_1.Socket();\n    }\n}\nexports.FTPContext = FTPContext;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}