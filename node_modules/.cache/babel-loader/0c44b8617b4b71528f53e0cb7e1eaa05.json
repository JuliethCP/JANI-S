{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction scopePlugin(fork) {\n  var types = fork.use(types_1.default);\n  var Type = types.Type;\n  var namedTypes = types.namedTypes;\n  var Node = namedTypes.Node;\n  var Expression = namedTypes.Expression;\n  var isArray = types.builtInTypes.array;\n  var b = types.builders;\n  var Scope = function Scope(path, parentScope) {\n    if (!(this instanceof Scope)) {\n      throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n    }\n    ScopeType.assert(path.value);\n    var depth;\n    if (parentScope) {\n      if (!(parentScope instanceof Scope)) {\n        throw new Error(\"\");\n      }\n      depth = parentScope.depth + 1;\n    } else {\n      parentScope = null;\n      depth = 0;\n    }\n    Object.defineProperties(this, {\n      path: {\n        value: path\n      },\n      node: {\n        value: path.value\n      },\n      isGlobal: {\n        value: !parentScope,\n        enumerable: true\n      },\n      depth: {\n        value: depth\n      },\n      parent: {\n        value: parentScope\n      },\n      bindings: {\n        value: {}\n      },\n      types: {\n        value: {}\n      }\n    });\n  };\n  var scopeTypes = [\n  // Program nodes introduce global scopes.\n  namedTypes.Program,\n  // Function is the supertype of FunctionExpression,\n  // FunctionDeclaration, ArrowExpression, etc.\n  namedTypes.Function,\n  // In case you didn't know, the caught parameter shadows any variable\n  // of the same name in an outer scope.\n  namedTypes.CatchClause];\n  var ScopeType = Type.or.apply(Type, scopeTypes);\n  Scope.isEstablishedBy = function (node) {\n    return ScopeType.check(node);\n  };\n  var Sp = Scope.prototype;\n  // Will be overridden after an instance lazily calls scanScope.\n  Sp.didScan = false;\n  Sp.declares = function (name) {\n    this.scan();\n    return hasOwn.call(this.bindings, name);\n  };\n  Sp.declaresType = function (name) {\n    this.scan();\n    return hasOwn.call(this.types, name);\n  };\n  Sp.declareTemporary = function (prefix) {\n    if (prefix) {\n      if (!/^[a-z$_]/i.test(prefix)) {\n        throw new Error(\"\");\n      }\n    } else {\n      prefix = \"t$\";\n    }\n    // Include this.depth in the name to make sure the name does not\n    // collide with any variables in nested/enclosing scopes.\n    prefix += this.depth.toString(36) + \"$\";\n    this.scan();\n    var index = 0;\n    while (this.declares(prefix + index)) {\n      ++index;\n    }\n    var name = prefix + index;\n    return this.bindings[name] = types.builders.identifier(name);\n  };\n  Sp.injectTemporary = function (identifier, init) {\n    identifier || (identifier = this.declareTemporary());\n    var bodyPath = this.path.get(\"body\");\n    if (namedTypes.BlockStatement.check(bodyPath.value)) {\n      bodyPath = bodyPath.get(\"body\");\n    }\n    bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n    return identifier;\n  };\n  Sp.scan = function (force) {\n    if (force || !this.didScan) {\n      for (var name in this.bindings) {\n        // Empty out this.bindings, just in cases.\n        delete this.bindings[name];\n      }\n      scanScope(this.path, this.bindings, this.types);\n      this.didScan = true;\n    }\n  };\n  Sp.getBindings = function () {\n    this.scan();\n    return this.bindings;\n  };\n  Sp.getTypes = function () {\n    this.scan();\n    return this.types;\n  };\n  function scanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    ScopeType.assert(node);\n    if (namedTypes.CatchClause.check(node)) {\n      // A catch clause establishes a new scope but the only variable\n      // bound in that scope is the catch parameter. Any other\n      // declarations create bindings in the outer scope.\n      var param = path.get(\"param\");\n      if (param.value) {\n        addPattern(param, bindings);\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n  function recursiveScanScope(path, bindings, scopeTypes) {\n    var node = path.value;\n    if (path.parent && namedTypes.FunctionExpression.check(path.parent.node) && path.parent.node.id) {\n      addPattern(path.parent.get(\"id\"), bindings);\n    }\n    if (!node) {\n      // None of the remaining cases matter if node is falsy.\n    } else if (isArray.check(node)) {\n      path.each(function (childPath) {\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    } else if (namedTypes.Function.check(node)) {\n      path.get(\"params\").each(function (paramPath) {\n        addPattern(paramPath, bindings);\n      });\n      recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n    } else if (namedTypes.TypeAlias && namedTypes.TypeAlias.check(node) || namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node) || namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node) || namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node)) {\n      addTypePattern(path.get(\"id\"), scopeTypes);\n    } else if (namedTypes.VariableDeclarator.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n      recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n    } else if (node.type === \"ImportSpecifier\" || node.type === \"ImportNamespaceSpecifier\" || node.type === \"ImportDefaultSpecifier\") {\n      addPattern(\n      // Esprima used to use the .name field to refer to the local\n      // binding identifier for ImportSpecifier nodes, but .id for\n      // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n      // ESTree/Acorn/ESpree use .local for all three node types.\n      path.get(node.local ? \"local\" : node.name ? \"name\" : \"id\"), bindings);\n    } else if (Node.check(node) && !Expression.check(node)) {\n      types.eachField(node, function (name, child) {\n        var childPath = path.get(name);\n        if (!pathHasValue(childPath, child)) {\n          throw new Error(\"\");\n        }\n        recursiveScanChild(childPath, bindings, scopeTypes);\n      });\n    }\n  }\n  function pathHasValue(path, value) {\n    if (path.value === value) {\n      return true;\n    }\n    // Empty arrays are probably produced by defaults.emptyArray, in which\n    // case is makes sense to regard them as equivalent, if not ===.\n    if (Array.isArray(path.value) && path.value.length === 0 && Array.isArray(value) && value.length === 0) {\n      return true;\n    }\n    return false;\n  }\n  function recursiveScanChild(path, bindings, scopeTypes) {\n    var node = path.value;\n    if (!node || Expression.check(node)) {\n      // Ignore falsy values and Expressions.\n    } else if (namedTypes.FunctionDeclaration.check(node) && node.id !== null) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (namedTypes.ClassDeclaration && namedTypes.ClassDeclaration.check(node)) {\n      addPattern(path.get(\"id\"), bindings);\n    } else if (ScopeType.check(node)) {\n      if (namedTypes.CatchClause.check(node) &&\n      // TODO Broaden this to accept any pattern.\n      namedTypes.Identifier.check(node.param)) {\n        var catchParamName = node.param.name;\n        var hadBinding = hasOwn.call(bindings, catchParamName);\n        // Any declarations that occur inside the catch body that do\n        // not have the same name as the catch parameter should count\n        // as bindings in the outer scope.\n        recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n        // If a new binding matching the catch parameter name was\n        // created while scanning the catch body, ignore it because it\n        // actually refers to the catch parameter and not the outer\n        // scope that we're currently scanning.\n        if (!hadBinding) {\n          delete bindings[catchParamName];\n        }\n      }\n    } else {\n      recursiveScanScope(path, bindings, scopeTypes);\n    }\n  }\n  function addPattern(patternPath, bindings) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(bindings, pattern.name)) {\n        bindings[pattern.name].push(patternPath);\n      } else {\n        bindings[pattern.name] = [patternPath];\n      }\n    } else if (namedTypes.AssignmentPattern && namedTypes.AssignmentPattern.check(pattern)) {\n      addPattern(patternPath.get('left'), bindings);\n    } else if (namedTypes.ObjectPattern && namedTypes.ObjectPattern.check(pattern)) {\n      patternPath.get('properties').each(function (propertyPath) {\n        var property = propertyPath.value;\n        if (namedTypes.Pattern.check(property)) {\n          addPattern(propertyPath, bindings);\n        } else if (namedTypes.Property.check(property)) {\n          addPattern(propertyPath.get('value'), bindings);\n        } else if (namedTypes.SpreadProperty && namedTypes.SpreadProperty.check(property)) {\n          addPattern(propertyPath.get('argument'), bindings);\n        }\n      });\n    } else if (namedTypes.ArrayPattern && namedTypes.ArrayPattern.check(pattern)) {\n      patternPath.get('elements').each(function (elementPath) {\n        var element = elementPath.value;\n        if (namedTypes.Pattern.check(element)) {\n          addPattern(elementPath, bindings);\n        } else if (namedTypes.SpreadElement && namedTypes.SpreadElement.check(element)) {\n          addPattern(elementPath.get(\"argument\"), bindings);\n        }\n      });\n    } else if (namedTypes.PropertyPattern && namedTypes.PropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('pattern'), bindings);\n    } else if (namedTypes.SpreadElementPattern && namedTypes.SpreadElementPattern.check(pattern) || namedTypes.SpreadPropertyPattern && namedTypes.SpreadPropertyPattern.check(pattern)) {\n      addPattern(patternPath.get('argument'), bindings);\n    }\n  }\n  function addTypePattern(patternPath, types) {\n    var pattern = patternPath.value;\n    namedTypes.Pattern.assert(pattern);\n    if (namedTypes.Identifier.check(pattern)) {\n      if (hasOwn.call(types, pattern.name)) {\n        types[pattern.name].push(patternPath);\n      } else {\n        types[pattern.name] = [patternPath];\n      }\n    }\n  }\n  Sp.lookup = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declares(name)) break;\n    return scope;\n  };\n  Sp.lookupType = function (name) {\n    for (var scope = this; scope; scope = scope.parent) if (scope.declaresType(name)) break;\n    return scope;\n  };\n  Sp.getGlobalScope = function () {\n    var scope = this;\n    while (!scope.isGlobal) scope = scope.parent;\n    return scope;\n  };\n  return Scope;\n}\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","hasOwn","prototype","hasOwnProperty","scopePlugin","fork","types","use","default","Type","namedTypes","Node","Expression","isArray","builtInTypes","array","b","builders","Scope","path","parentScope","Error","ScopeType","assert","depth","defineProperties","node","isGlobal","enumerable","parent","bindings","scopeTypes","Program","Function","CatchClause","or","apply","isEstablishedBy","check","Sp","didScan","declares","name","scan","call","declaresType","declareTemporary","prefix","test","toString","index","identifier","injectTemporary","init","bodyPath","get","BlockStatement","unshift","variableDeclaration","variableDeclarator","force","scanScope","getBindings","getTypes","param","addPattern","recursiveScanScope","FunctionExpression","id","each","childPath","recursiveScanChild","paramPath","TypeAlias","InterfaceDeclaration","TSTypeAliasDeclaration","TSInterfaceDeclaration","addTypePattern","VariableDeclarator","type","local","eachField","child","pathHasValue","Array","length","FunctionDeclaration","ClassDeclaration","Identifier","catchParamName","hadBinding","patternPath","pattern","Pattern","push","AssignmentPattern","ObjectPattern","propertyPath","property","Property","SpreadProperty","ArrayPattern","elementPath","element","SpreadElement","PropertyPattern","SpreadElementPattern","SpreadPropertyPattern","lookup","scope","lookupType","getGlobalScope","module"],"sources":["D:/Julieth-Campos/PSO/node_modules/ast-types/lib/scope.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction scopePlugin(fork) {\n    var types = fork.use(types_1.default);\n    var Type = types.Type;\n    var namedTypes = types.namedTypes;\n    var Node = namedTypes.Node;\n    var Expression = namedTypes.Expression;\n    var isArray = types.builtInTypes.array;\n    var b = types.builders;\n    var Scope = function Scope(path, parentScope) {\n        if (!(this instanceof Scope)) {\n            throw new Error(\"Scope constructor cannot be invoked without 'new'\");\n        }\n        ScopeType.assert(path.value);\n        var depth;\n        if (parentScope) {\n            if (!(parentScope instanceof Scope)) {\n                throw new Error(\"\");\n            }\n            depth = parentScope.depth + 1;\n        }\n        else {\n            parentScope = null;\n            depth = 0;\n        }\n        Object.defineProperties(this, {\n            path: { value: path },\n            node: { value: path.value },\n            isGlobal: { value: !parentScope, enumerable: true },\n            depth: { value: depth },\n            parent: { value: parentScope },\n            bindings: { value: {} },\n            types: { value: {} },\n        });\n    };\n    var scopeTypes = [\n        // Program nodes introduce global scopes.\n        namedTypes.Program,\n        // Function is the supertype of FunctionExpression,\n        // FunctionDeclaration, ArrowExpression, etc.\n        namedTypes.Function,\n        // In case you didn't know, the caught parameter shadows any variable\n        // of the same name in an outer scope.\n        namedTypes.CatchClause\n    ];\n    var ScopeType = Type.or.apply(Type, scopeTypes);\n    Scope.isEstablishedBy = function (node) {\n        return ScopeType.check(node);\n    };\n    var Sp = Scope.prototype;\n    // Will be overridden after an instance lazily calls scanScope.\n    Sp.didScan = false;\n    Sp.declares = function (name) {\n        this.scan();\n        return hasOwn.call(this.bindings, name);\n    };\n    Sp.declaresType = function (name) {\n        this.scan();\n        return hasOwn.call(this.types, name);\n    };\n    Sp.declareTemporary = function (prefix) {\n        if (prefix) {\n            if (!/^[a-z$_]/i.test(prefix)) {\n                throw new Error(\"\");\n            }\n        }\n        else {\n            prefix = \"t$\";\n        }\n        // Include this.depth in the name to make sure the name does not\n        // collide with any variables in nested/enclosing scopes.\n        prefix += this.depth.toString(36) + \"$\";\n        this.scan();\n        var index = 0;\n        while (this.declares(prefix + index)) {\n            ++index;\n        }\n        var name = prefix + index;\n        return this.bindings[name] = types.builders.identifier(name);\n    };\n    Sp.injectTemporary = function (identifier, init) {\n        identifier || (identifier = this.declareTemporary());\n        var bodyPath = this.path.get(\"body\");\n        if (namedTypes.BlockStatement.check(bodyPath.value)) {\n            bodyPath = bodyPath.get(\"body\");\n        }\n        bodyPath.unshift(b.variableDeclaration(\"var\", [b.variableDeclarator(identifier, init || null)]));\n        return identifier;\n    };\n    Sp.scan = function (force) {\n        if (force || !this.didScan) {\n            for (var name in this.bindings) {\n                // Empty out this.bindings, just in cases.\n                delete this.bindings[name];\n            }\n            scanScope(this.path, this.bindings, this.types);\n            this.didScan = true;\n        }\n    };\n    Sp.getBindings = function () {\n        this.scan();\n        return this.bindings;\n    };\n    Sp.getTypes = function () {\n        this.scan();\n        return this.types;\n    };\n    function scanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        ScopeType.assert(node);\n        if (namedTypes.CatchClause.check(node)) {\n            // A catch clause establishes a new scope but the only variable\n            // bound in that scope is the catch parameter. Any other\n            // declarations create bindings in the outer scope.\n            var param = path.get(\"param\");\n            if (param.value) {\n                addPattern(param, bindings);\n            }\n        }\n        else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n    function recursiveScanScope(path, bindings, scopeTypes) {\n        var node = path.value;\n        if (path.parent &&\n            namedTypes.FunctionExpression.check(path.parent.node) &&\n            path.parent.node.id) {\n            addPattern(path.parent.get(\"id\"), bindings);\n        }\n        if (!node) {\n            // None of the remaining cases matter if node is falsy.\n        }\n        else if (isArray.check(node)) {\n            path.each(function (childPath) {\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n        else if (namedTypes.Function.check(node)) {\n            path.get(\"params\").each(function (paramPath) {\n                addPattern(paramPath, bindings);\n            });\n            recursiveScanChild(path.get(\"body\"), bindings, scopeTypes);\n        }\n        else if ((namedTypes.TypeAlias && namedTypes.TypeAlias.check(node)) ||\n            (namedTypes.InterfaceDeclaration && namedTypes.InterfaceDeclaration.check(node)) ||\n            (namedTypes.TSTypeAliasDeclaration && namedTypes.TSTypeAliasDeclaration.check(node)) ||\n            (namedTypes.TSInterfaceDeclaration && namedTypes.TSInterfaceDeclaration.check(node))) {\n            addTypePattern(path.get(\"id\"), scopeTypes);\n        }\n        else if (namedTypes.VariableDeclarator.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n            recursiveScanChild(path.get(\"init\"), bindings, scopeTypes);\n        }\n        else if (node.type === \"ImportSpecifier\" ||\n            node.type === \"ImportNamespaceSpecifier\" ||\n            node.type === \"ImportDefaultSpecifier\") {\n            addPattern(\n            // Esprima used to use the .name field to refer to the local\n            // binding identifier for ImportSpecifier nodes, but .id for\n            // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.\n            // ESTree/Acorn/ESpree use .local for all three node types.\n            path.get(node.local ? \"local\" :\n                node.name ? \"name\" : \"id\"), bindings);\n        }\n        else if (Node.check(node) && !Expression.check(node)) {\n            types.eachField(node, function (name, child) {\n                var childPath = path.get(name);\n                if (!pathHasValue(childPath, child)) {\n                    throw new Error(\"\");\n                }\n                recursiveScanChild(childPath, bindings, scopeTypes);\n            });\n        }\n    }\n    function pathHasValue(path, value) {\n        if (path.value === value) {\n            return true;\n        }\n        // Empty arrays are probably produced by defaults.emptyArray, in which\n        // case is makes sense to regard them as equivalent, if not ===.\n        if (Array.isArray(path.value) &&\n            path.value.length === 0 &&\n            Array.isArray(value) &&\n            value.length === 0) {\n            return true;\n        }\n        return false;\n    }\n    function recursiveScanChild(path, bindings, scopeTypes) {\n        var node = path.value;\n        if (!node || Expression.check(node)) {\n            // Ignore falsy values and Expressions.\n        }\n        else if (namedTypes.FunctionDeclaration.check(node) &&\n            node.id !== null) {\n            addPattern(path.get(\"id\"), bindings);\n        }\n        else if (namedTypes.ClassDeclaration &&\n            namedTypes.ClassDeclaration.check(node)) {\n            addPattern(path.get(\"id\"), bindings);\n        }\n        else if (ScopeType.check(node)) {\n            if (namedTypes.CatchClause.check(node) &&\n                // TODO Broaden this to accept any pattern.\n                namedTypes.Identifier.check(node.param)) {\n                var catchParamName = node.param.name;\n                var hadBinding = hasOwn.call(bindings, catchParamName);\n                // Any declarations that occur inside the catch body that do\n                // not have the same name as the catch parameter should count\n                // as bindings in the outer scope.\n                recursiveScanScope(path.get(\"body\"), bindings, scopeTypes);\n                // If a new binding matching the catch parameter name was\n                // created while scanning the catch body, ignore it because it\n                // actually refers to the catch parameter and not the outer\n                // scope that we're currently scanning.\n                if (!hadBinding) {\n                    delete bindings[catchParamName];\n                }\n            }\n        }\n        else {\n            recursiveScanScope(path, bindings, scopeTypes);\n        }\n    }\n    function addPattern(patternPath, bindings) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(bindings, pattern.name)) {\n                bindings[pattern.name].push(patternPath);\n            }\n            else {\n                bindings[pattern.name] = [patternPath];\n            }\n        }\n        else if (namedTypes.AssignmentPattern &&\n            namedTypes.AssignmentPattern.check(pattern)) {\n            addPattern(patternPath.get('left'), bindings);\n        }\n        else if (namedTypes.ObjectPattern &&\n            namedTypes.ObjectPattern.check(pattern)) {\n            patternPath.get('properties').each(function (propertyPath) {\n                var property = propertyPath.value;\n                if (namedTypes.Pattern.check(property)) {\n                    addPattern(propertyPath, bindings);\n                }\n                else if (namedTypes.Property.check(property)) {\n                    addPattern(propertyPath.get('value'), bindings);\n                }\n                else if (namedTypes.SpreadProperty &&\n                    namedTypes.SpreadProperty.check(property)) {\n                    addPattern(propertyPath.get('argument'), bindings);\n                }\n            });\n        }\n        else if (namedTypes.ArrayPattern &&\n            namedTypes.ArrayPattern.check(pattern)) {\n            patternPath.get('elements').each(function (elementPath) {\n                var element = elementPath.value;\n                if (namedTypes.Pattern.check(element)) {\n                    addPattern(elementPath, bindings);\n                }\n                else if (namedTypes.SpreadElement &&\n                    namedTypes.SpreadElement.check(element)) {\n                    addPattern(elementPath.get(\"argument\"), bindings);\n                }\n            });\n        }\n        else if (namedTypes.PropertyPattern &&\n            namedTypes.PropertyPattern.check(pattern)) {\n            addPattern(patternPath.get('pattern'), bindings);\n        }\n        else if ((namedTypes.SpreadElementPattern &&\n            namedTypes.SpreadElementPattern.check(pattern)) ||\n            (namedTypes.SpreadPropertyPattern &&\n                namedTypes.SpreadPropertyPattern.check(pattern))) {\n            addPattern(patternPath.get('argument'), bindings);\n        }\n    }\n    function addTypePattern(patternPath, types) {\n        var pattern = patternPath.value;\n        namedTypes.Pattern.assert(pattern);\n        if (namedTypes.Identifier.check(pattern)) {\n            if (hasOwn.call(types, pattern.name)) {\n                types[pattern.name].push(patternPath);\n            }\n            else {\n                types[pattern.name] = [patternPath];\n            }\n        }\n    }\n    Sp.lookup = function (name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declares(name))\n                break;\n        return scope;\n    };\n    Sp.lookupType = function (name) {\n        for (var scope = this; scope; scope = scope.parent)\n            if (scope.declaresType(name))\n                break;\n        return scope;\n    };\n    Sp.getGlobalScope = function () {\n        var scope = this;\n        while (!scope.isGlobal)\n            scope = scope.parent;\n        return scope;\n    };\n    return Scope;\n}\nexports.default = scopePlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}