{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { transposeIterableHandle } from '../common/HandleIterator.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { getPageContent, importFSPromises, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { FunctionLocator, NodeLocator } from './locators/locators.js';\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport var FrameEvent;\n(function (FrameEvent) {\n  FrameEvent.FrameNavigated = Symbol('Frame.FrameNavigated');\n  FrameEvent.FrameSwapped = Symbol('Frame.FrameSwapped');\n  FrameEvent.LifecycleEvent = Symbol('Frame.LifecycleEvent');\n  FrameEvent.FrameNavigatedWithinDocument = Symbol('Frame.FrameNavigatedWithinDocument');\n  FrameEvent.FrameDetached = Symbol('Frame.FrameDetached');\n  FrameEvent.FrameSwappedByActivation = Symbol('Frame.FrameSwappedByActivation');\n})(FrameEvent || (FrameEvent = {}));\n/**\n * @internal\n */\nexport const throwIfDetached = throwIfDisposed(frame => {\n  return `Attempted to use detached Frame '${frame._id}'.`;\n});\n/**\n * Represents a DOM frame.\n *\n * To understand frames, you can think of frames as `<iframe>` elements. Just\n * like iframes, frames can be nested, and when JavaScript is executed in a\n * frame, the JavaScript does not effect frames inside the ambient frame the\n * JavaScript executes in.\n *\n * @example\n * At any point in time, {@link Page | pages} expose their current frame\n * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.\n *\n * @example\n * An example of dumping frame tree:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *       dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @example\n * An example of getting text from an iframe element:\n *\n * ```ts\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @remarks\n * Frame lifecycles are controlled by three events that are all dispatched on\n * the parent {@link Frame.page | page}:\n *\n * - {@link PageEvent.FrameAttached}\n * - {@link PageEvent.FrameNavigated}\n * - {@link PageEvent.FrameDetached}\n *\n * @public\n */\nlet Frame = (() => {\n  let _classSuper = EventEmitter;\n  let _instanceExtraInitializers = [];\n  let _frameElement_decorators;\n  let _evaluateHandle_decorators;\n  let _evaluate_decorators;\n  let _locator_decorators;\n  let _$_decorators;\n  let _$$_decorators;\n  let _$eval_decorators;\n  let _$$eval_decorators;\n  let _$x_decorators;\n  let _waitForSelector_decorators;\n  let _waitForXPath_decorators;\n  let _waitForFunction_decorators;\n  let _content_decorators;\n  let _addScriptTag_decorators;\n  let _addStyleTag_decorators;\n  let _click_decorators;\n  let _focus_decorators;\n  let _hover_decorators;\n  let _select_decorators;\n  let _tap_decorators;\n  let _type_decorators;\n  let _title_decorators;\n  return class Frame extends _classSuper {\n    static #_ = (() => {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _frameElement_decorators = [throwIfDetached];\n      _evaluateHandle_decorators = [throwIfDetached];\n      _evaluate_decorators = [throwIfDetached];\n      _locator_decorators = [throwIfDetached];\n      _$_decorators = [throwIfDetached];\n      _$$_decorators = [throwIfDetached];\n      _$eval_decorators = [throwIfDetached];\n      _$$eval_decorators = [throwIfDetached];\n      _$x_decorators = [throwIfDetached];\n      _waitForSelector_decorators = [throwIfDetached];\n      _waitForXPath_decorators = [throwIfDetached];\n      _waitForFunction_decorators = [throwIfDetached];\n      _content_decorators = [throwIfDetached];\n      _addScriptTag_decorators = [throwIfDetached];\n      _addStyleTag_decorators = [throwIfDetached];\n      _click_decorators = [throwIfDetached];\n      _focus_decorators = [throwIfDetached];\n      _hover_decorators = [throwIfDetached];\n      _select_decorators = [throwIfDetached];\n      _tap_decorators = [throwIfDetached];\n      _type_decorators = [throwIfDetached];\n      _title_decorators = [throwIfDetached];\n      __esDecorate(this, null, _frameElement_decorators, {\n        kind: \"method\",\n        name: \"frameElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"frameElement\" in obj,\n          get: obj => obj.frameElement\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _evaluateHandle_decorators, {\n        kind: \"method\",\n        name: \"evaluateHandle\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"evaluateHandle\" in obj,\n          get: obj => obj.evaluateHandle\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _evaluate_decorators, {\n        kind: \"method\",\n        name: \"evaluate\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"evaluate\" in obj,\n          get: obj => obj.evaluate\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _locator_decorators, {\n        kind: \"method\",\n        name: \"locator\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"locator\" in obj,\n          get: obj => obj.locator\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$_decorators, {\n        kind: \"method\",\n        name: \"$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$\" in obj,\n          get: obj => obj.$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$_decorators, {\n        kind: \"method\",\n        name: \"$$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$\" in obj,\n          get: obj => obj.$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$eval_decorators, {\n        kind: \"method\",\n        name: \"$eval\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$eval\" in obj,\n          get: obj => obj.$eval\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$eval_decorators, {\n        kind: \"method\",\n        name: \"$$eval\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$eval\" in obj,\n          get: obj => obj.$$eval\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$x_decorators, {\n        kind: \"method\",\n        name: \"$x\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$x\" in obj,\n          get: obj => obj.$x\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForSelector_decorators, {\n        kind: \"method\",\n        name: \"waitForSelector\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForSelector\" in obj,\n          get: obj => obj.waitForSelector\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForXPath_decorators, {\n        kind: \"method\",\n        name: \"waitForXPath\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForXPath\" in obj,\n          get: obj => obj.waitForXPath\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForFunction_decorators, {\n        kind: \"method\",\n        name: \"waitForFunction\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForFunction\" in obj,\n          get: obj => obj.waitForFunction\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _content_decorators, {\n        kind: \"method\",\n        name: \"content\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"content\" in obj,\n          get: obj => obj.content\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _addScriptTag_decorators, {\n        kind: \"method\",\n        name: \"addScriptTag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"addScriptTag\" in obj,\n          get: obj => obj.addScriptTag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _addStyleTag_decorators, {\n        kind: \"method\",\n        name: \"addStyleTag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"addStyleTag\" in obj,\n          get: obj => obj.addStyleTag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _click_decorators, {\n        kind: \"method\",\n        name: \"click\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"click\" in obj,\n          get: obj => obj.click\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _focus_decorators, {\n        kind: \"method\",\n        name: \"focus\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"focus\" in obj,\n          get: obj => obj.focus\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _hover_decorators, {\n        kind: \"method\",\n        name: \"hover\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"hover\" in obj,\n          get: obj => obj.hover\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _select_decorators, {\n        kind: \"method\",\n        name: \"select\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"select\" in obj,\n          get: obj => obj.select\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _tap_decorators, {\n        kind: \"method\",\n        name: \"tap\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"tap\" in obj,\n          get: obj => obj.tap\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _type_decorators, {\n        kind: \"method\",\n        name: \"type\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"type\" in obj,\n          get: obj => obj.type\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _title_decorators, {\n        kind: \"method\",\n        name: \"title\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"title\" in obj,\n          get: obj => obj.title\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    })();\n    /**\n     * @internal\n     */\n    _id = (__runInitializers(this, _instanceExtraInitializers), void 0);\n    /**\n     * @internal\n     */\n    _parentId;\n    /**\n     * @internal\n     */\n    worlds;\n    /**\n     * @internal\n     */\n    _name;\n    /**\n     * @internal\n     */\n    _hasStartedLoading = false;\n    /**\n     * @internal\n     */\n    constructor() {\n      super();\n    }\n    /**\n     * Is `true` if the frame is an out-of-process (OOP) frame. Otherwise,\n     * `false`.\n     */\n    isOOPFrame() {\n      throw new Error('Not implemented');\n    }\n    #_document;\n    /**\n     * @internal\n     */\n    #document() {\n      if (!this.#_document) {\n        this.#_document = this.isolatedRealm().evaluateHandle(() => {\n          return document;\n        }).then(handle => {\n          return this.mainRealm().transferHandle(handle);\n        });\n      }\n      return this.#_document;\n    }\n    /**\n     * Used to clear the document handle that has been destroyed.\n     *\n     * @internal\n     */\n    clearDocumentHandle() {\n      this.#_document = undefined;\n    }\n    /**\n     * @internal\n     */\n    async frameElement() {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const parentFrame = this.parentFrame();\n        if (!parentFrame) {\n          return null;\n        }\n        const list = __addDisposableResource(env_1, await parentFrame.isolatedRealm().evaluateHandle(() => {\n          return document.querySelectorAll('iframe');\n        }), false);\n        for await (const iframe_1 of transposeIterableHandle(list)) {\n          const env_2 = {\n            stack: [],\n            error: void 0,\n            hasError: false\n          };\n          try {\n            const iframe = __addDisposableResource(env_2, iframe_1, false);\n            const frame = await iframe.contentFrame();\n            if (frame._id === this._id) {\n              return iframe.move();\n            }\n          } catch (e_1) {\n            env_2.error = e_1;\n            env_2.hasError = true;\n          } finally {\n            __disposeResources(env_2);\n          }\n        }\n        return null;\n      } catch (e_2) {\n        env_1.error = e_2;\n        env_1.hasError = true;\n      } finally {\n        __disposeResources(env_1);\n      }\n    }\n    /**\n     * Behaves identically to {@link Page.evaluateHandle} except it's run within\n     * the context of this frame.\n     *\n     * @see {@link Page.evaluateHandle} for details.\n     */\n    async evaluateHandle(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return await this.mainRealm().evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * Behaves identically to {@link Page.evaluate} except it's run within the\n     * the context of this frame.\n     *\n     * @see {@link Page.evaluate} for details.\n     */\n    async evaluate(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      return await this.mainRealm().evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    locator(selectorOrFunc) {\n      if (typeof selectorOrFunc === 'string') {\n        return NodeLocator.create(this, selectorOrFunc);\n      } else {\n        return FunctionLocator.create(this, selectorOrFunc);\n      }\n    }\n    /**\n     * Queries the frame for an element matching the given selector.\n     *\n     * @param selector - The selector to query for.\n     * @returns A {@link ElementHandle | element handle} to the first element\n     * matching the given selector. Otherwise, `null`.\n     */\n    async $(selector) {\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$(selector);\n    }\n    /**\n     * Queries the frame for all elements matching the given selector.\n     *\n     * @param selector - The selector to query for.\n     * @returns An array of {@link ElementHandle | element handles} that point to\n     * elements matching the given selector.\n     */\n    async $$(selector) {\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$$(selector);\n    }\n    /**\n     * Runs the given function on the first element matching the given selector in\n     * the frame.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const searchValue = await frame.$eval('#search', el => el.value);\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param pageFunction - The function to be evaluated in the frame's context.\n     * The first element matching the selector will be passed to the function as\n     * its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $eval(selector, pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n        args[_key3 - 2] = arguments[_key3];\n      }\n      return await document.$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * Runs the given function on an array of elements matching the given selector\n     * in the frame.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```js\n     * const divsCounts = await frame.$$eval('div', divs => divs.length);\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param pageFunction - The function to be evaluated in the frame's context.\n     * An array of elements matching the given selector will be passed to the\n     * function as its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $$eval(selector, pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n        args[_key4 - 2] = arguments[_key4];\n      }\n      return await document.$$eval(selector, pageFunction, ...args);\n    }\n    /**\n     * @deprecated Use {@link Frame.$$} with the `xpath` prefix.\n     *\n     * Example: `await frame.$$('xpath/' + xpathExpression)`\n     *\n     * This method evaluates the given XPath expression and returns the results.\n     * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n     * automatically.\n     * @param expression - the XPath expression to evaluate.\n     */\n    async $x(expression) {\n      // eslint-disable-next-line rulesdir/use-using -- This is cached.\n      const document = await this.#document();\n      return await document.$x(expression);\n    }\n    /**\n     * Waits for an element matching the given selector to appear in the frame.\n     *\n     * This method works across navigations.\n     *\n     * @example\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .mainFrame()\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - The selector to query and wait for.\n     * @param options - Options for customizing waiting behavior.\n     * @returns An element matching the given selector.\n     * @throws Throws if an element matching the given selector doesn't appear.\n     */\n    async waitForSelector(selector) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.waitFor(this, updatedSelector, options);\n    }\n    /**\n     * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.\n     *\n     * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`\n     *\n     * The method evaluates the XPath expression relative to the Frame.\n     * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n     * automatically.\n     *\n     * Wait for the `xpath` to appear in page. If at the moment of calling the\n     * method the `xpath` already exists, the method will return immediately. If\n     * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * For a code example, see the example for {@link Frame.waitForSelector}. That\n     * function behaves identically other than taking a CSS selector rather than\n     * an XPath.\n     *\n     * @param xpath - the XPath expression to wait for.\n     * @param options - options to configure the visibility of the element and how\n     * long to wait before timing out.\n     */\n    async waitForXPath(xpath) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (xpath.startsWith('//')) {\n        xpath = `.${xpath}`;\n      }\n      return await this.waitForSelector(`xpath/${xpath}`, options);\n    }\n    /**\n     * @example\n     * The `waitForFunction` can be used to observe viewport size change:\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     * .  const browser = await puppeteer.launch();\n     * .  const page = await browser.newPage();\n     * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n     * .  page.setViewport({width: 50, height: 50});\n     * .  await watchDog;\n     * .  await browser.close();\n     * })();\n     * ```\n     *\n     * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n     *\n     * ```ts\n     * const selector = '.foo';\n     * await frame.waitForFunction(\n     *   selector => !!document.querySelector(selector),\n     *   {}, // empty options object\n     *   selector\n     * );\n     * ```\n     *\n     * @param pageFunction - the function to evaluate in the frame context.\n     * @param options - options to configure the polling method and timeout.\n     * @param args - arguments to pass to the `pageFunction`.\n     * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n     */\n    async waitForFunction(pageFunction) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n        args[_key5 - 2] = arguments[_key5];\n      }\n      return await this.mainRealm().waitForFunction(pageFunction, options, ...args);\n    }\n    /**\n     * The full HTML contents of the frame, including the DOCTYPE.\n     */\n    async content() {\n      return await this.evaluate(getPageContent);\n    }\n    /**\n     * The frame's `name` attribute as specified in the tag.\n     *\n     * @remarks\n     * If the name is empty, it returns the `id` attribute instead.\n     *\n     * @remarks\n     * This value is calculated once when the frame is created, and will not\n     * update if the attribute is changed later.\n     */\n    name() {\n      return this._name || '';\n    }\n    /**\n     * Is`true` if the frame has been detached. Otherwise, `false`.\n     *\n     * @deprecated Use the `detached` getter.\n     */\n    isDetached() {\n      return this.detached;\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      return this.detached;\n    }\n    /**\n     * Adds a `<script>` tag into the page with the desired url or content.\n     *\n     * @param options - Options for the script.\n     * @returns An {@link ElementHandle | element handle} to the injected\n     * `<script>` element.\n     */\n    async addScriptTag(options) {\n      let {\n        content = '',\n        type\n      } = options;\n      const {\n        path\n      } = options;\n      if (+!!options.url + +!!path + +!!content !== 1) {\n        throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');\n      }\n      if (path) {\n        const fs = await importFSPromises();\n        content = await fs.readFile(path, 'utf8');\n        content += `//# sourceURL=${path.replace(/\\n/g, '')}`;\n      }\n      type = type ?? 'text/javascript';\n      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async (_ref, _ref2) => {\n        let {\n          Deferred\n        } = _ref;\n        let {\n          url,\n          id,\n          type,\n          content\n        } = _ref2;\n        const deferred = Deferred.create();\n        const script = document.createElement('script');\n        script.type = type;\n        script.text = content;\n        if (url) {\n          script.src = url;\n          script.addEventListener('load', () => {\n            return deferred.resolve();\n          }, {\n            once: true\n          });\n          script.addEventListener('error', event => {\n            deferred.reject(new Error(event.message ?? 'Could not load script'));\n          }, {\n            once: true\n          });\n        } else {\n          deferred.resolve();\n        }\n        if (id) {\n          script.id = id;\n        }\n        document.head.appendChild(script);\n        await deferred.valueOrThrow();\n        return script;\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), {\n        ...options,\n        type,\n        content\n      }));\n    }\n    /**\n     * @internal\n     */\n    async addStyleTag(options) {\n      let {\n        content = ''\n      } = options;\n      const {\n        path\n      } = options;\n      if (+!!options.url + +!!path + +!!content !== 1) {\n        throw new Error('Exactly one of `url`, `path`, or `content` must be specified.');\n      }\n      if (path) {\n        const fs = await importFSPromises();\n        content = await fs.readFile(path, 'utf8');\n        content += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n        options.content = content;\n      }\n      return await this.mainRealm().transferHandle(await this.isolatedRealm().evaluateHandle(async (_ref3, _ref4) => {\n        let {\n          Deferred\n        } = _ref3;\n        let {\n          url,\n          content\n        } = _ref4;\n        const deferred = Deferred.create();\n        let element;\n        if (!url) {\n          element = document.createElement('style');\n          element.appendChild(document.createTextNode(content));\n        } else {\n          const link = document.createElement('link');\n          link.rel = 'stylesheet';\n          link.href = url;\n          element = link;\n        }\n        element.addEventListener('load', () => {\n          deferred.resolve();\n        }, {\n          once: true\n        });\n        element.addEventListener('error', event => {\n          deferred.reject(new Error(event.message ?? 'Could not load style'));\n        }, {\n          once: true\n        });\n        document.head.appendChild(element);\n        await deferred.valueOrThrow();\n        return element;\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), options));\n    }\n    /**\n     * Clicks the first element found that matches `selector`.\n     *\n     * @remarks\n     * If `click()` triggers a navigation event and there's a separate\n     * `page.waitForNavigation()` promise to be resolved, you may end up with a\n     * race condition that yields unexpected results. The correct pattern for\n     * click and wait for navigation is the following:\n     *\n     * ```ts\n     * const [response] = await Promise.all([\n     *   page.waitForNavigation(waitOptions),\n     *   frame.click(selector, clickOptions),\n     * ]);\n     * ```\n     *\n     * @param selector - The selector to query for.\n     */\n    async click(selector) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const env_3 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_3, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.click(options);\n        await handle.dispose();\n      } catch (e_3) {\n        env_3.error = e_3;\n        env_3.hasError = true;\n      } finally {\n        __disposeResources(env_3);\n      }\n    }\n    /**\n     * Focuses the first element that matches the `selector`.\n     *\n     * @param selector - The selector to query for.\n     * @throws Throws if there's no element matching `selector`.\n     */\n    async focus(selector) {\n      const env_4 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_4, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.focus();\n      } catch (e_4) {\n        env_4.error = e_4;\n        env_4.hasError = true;\n      } finally {\n        __disposeResources(env_4);\n      }\n    }\n    /**\n     * Hovers the pointer over the center of the first element that matches the\n     * `selector`.\n     *\n     * @param selector - The selector to query for.\n     * @throws Throws if there's no element matching `selector`.\n     */\n    async hover(selector) {\n      const env_5 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_5, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.hover();\n      } catch (e_5) {\n        env_5.error = e_5;\n        env_5.hasError = true;\n      } finally {\n        __disposeResources(env_5);\n      }\n    }\n    /**\n     * Selects a set of value on the first `<select>` element that matches the\n     * `selector`.\n     *\n     * @example\n     *\n     * ```ts\n     * frame.select('select#colors', 'blue'); // single selection\n     * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param values - The array of values to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     * @returns the list of values that were successfully selected.\n     * @throws Throws if there's no `<select>` matching `selector`.\n     */\n    async select(selector) {\n      const env_6 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_6, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        for (var _len6 = arguments.length, values = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n          values[_key6 - 1] = arguments[_key6];\n        }\n        return await handle.select(...values);\n      } catch (e_6) {\n        env_6.error = e_6;\n        env_6.hasError = true;\n      } finally {\n        __disposeResources(env_6);\n      }\n    }\n    /**\n     * Taps the first element that matches the `selector`.\n     *\n     * @param selector - The selector to query for.\n     * @throws Throws if there's no element matching `selector`.\n     */\n    async tap(selector) {\n      const env_7 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_7, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.tap();\n      } catch (e_7) {\n        env_7.error = e_7;\n        env_7.hasError = true;\n      } finally {\n        __disposeResources(env_7);\n      }\n    }\n    /**\n     * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n     * in the text.\n     *\n     * @remarks\n     * To press a special key, like `Control` or `ArrowDown`, use\n     * {@link Keyboard.press}.\n     *\n     * @example\n     *\n     * ```ts\n     * await frame.type('#mytextarea', 'Hello'); // Types instantly\n     * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @param selector - the selector for the element to type into. If there are\n     * multiple the first will be used.\n     * @param text - text to type into the element\n     * @param options - takes one option, `delay`, which sets the time to wait\n     * between key presses in milliseconds. Defaults to `0`.\n     */\n    async type(selector, text, options) {\n      const env_8 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const handle = __addDisposableResource(env_8, await this.$(selector), false);\n        assert(handle, `No element found for selector: ${selector}`);\n        await handle.type(text, options);\n      } catch (e_8) {\n        env_8.error = e_8;\n        env_8.hasError = true;\n      } finally {\n        __disposeResources(env_8);\n      }\n    }\n    /**\n     * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n     *\n     * Causes your script to wait for the given number of milliseconds.\n     *\n     * @remarks\n     * It's generally recommended to not wait for a number of seconds, but instead\n     * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n     * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n     *\n     * @example\n     *\n     * Wait for 1 second:\n     *\n     * ```ts\n     * await frame.waitForTimeout(1000);\n     * ```\n     *\n     * @param milliseconds - the number of milliseconds to wait.\n     */\n    async waitForTimeout(milliseconds) {\n      return await new Promise(resolve => {\n        setTimeout(resolve, milliseconds);\n      });\n    }\n    /**\n     * The frame's title.\n     */\n    async title() {\n      return await this.isolatedRealm().evaluate(() => {\n        return document.title;\n      });\n    }\n    /**\n     * @internal\n     */\n    waitForDevicePrompt() {\n      throw new Error('Not implemented');\n    }\n    exposeFunction() {\n      throw new Error('Not implemented');\n    }\n  };\n})();\nexport { Frame };","map":{"version":3,"mappings":"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","names":["EventEmitter","getQueryHandlerAndSelector","transposeIterableHandle","LazyArg","getPageContent","importFSPromises","withSourcePuppeteerURLIfNone","assert","throwIfDisposed","FunctionLocator","NodeLocator","FrameEvent","Symbol","throwIfDetached","frame","_id","Frame","_classSuper","__esDecorate","kind","name","static","private","access","has","get","frameElement","metadata","evaluateHandle","evaluate","$","$$","$eval","$$eval","$x","waitForSelector","waitForXPath","waitForFunction","content","addScriptTag","addStyleTag","click","focus","hover","select","tap","type","title","_parentId","worlds","_name","_hasStartedLoading","constructor","isOOPFrame","Error","isolatedRealm","document","then","handle","mainRealm","transferHandle","clearDocumentHandle","undefined","parentFrame","list","querySelectorAll","iframe","contentFrame","move","pageFunction","args","locator","selectorOrFunc","create","selector","expression","options","updatedSelector","QueryHandler","waitFor","xpath","startsWith","isDetached","detached","disposed","path","url","fs","readFile","replace","Deferred","id","deferred","script","createElement","text","src","addEventListener","resolve","once","event","reject","message","head","appendChild","valueOrThrow","context","puppeteerUtil","element","createTextNode","link","rel","href","dispose","values","waitForTimeout","milliseconds","Promise","setTimeout","waitForDevicePrompt","exposeFunction"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\api\\Frame.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {ClickOptions, ElementHandle} from '../api/ElementHandle.js';\nimport type {HTTPResponse} from '../api/HTTPResponse.js';\nimport type {\n  Page,\n  WaitForSelectorOptions,\n  WaitTimeoutOptions,\n} from '../api/Page.js';\nimport type {DeviceRequestPrompt} from '../cdp/DeviceRequestPrompt.js';\nimport type {IsolatedWorldChart} from '../cdp/IsolatedWorld.js';\nimport type {PuppeteerLifeCycleEvent} from '../cdp/LifecycleWatcher.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {transposeIterableHandle} from '../common/HandleIterator.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport type {\n  Awaitable,\n  EvaluateFunc,\n  EvaluateFuncWith,\n  HandleFor,\n  NodeFor,\n} from '../common/types.js';\nimport {\n  getPageContent,\n  importFSPromises,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport type {CDPSession} from './CDPSession.js';\nimport type {KeyboardTypeOptions} from './Input.js';\nimport {\n  FunctionLocator,\n  type Locator,\n  NodeLocator,\n} from './locators/locators.js';\nimport type {Realm} from './Realm.js';\n\n/**\n * @public\n */\nexport interface WaitForOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass 0 to disable the timeout.\n   *\n   * The default value can be changed by using the\n   * {@link Page.setDefaultTimeout} or {@link Page.setDefaultNavigationTimeout}\n   * methods.\n   *\n   * @defaultValue `30000`\n   */\n  timeout?: number;\n  /**\n   * When to consider waiting succeeds. Given an array of event strings, waiting\n   * is considered to be successful after all events have been fired.\n   *\n   * @defaultValue `'load'`\n   */\n  waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n}\n\n/**\n * @public\n */\nexport interface GoToOptions extends WaitForOptions {\n  /**\n   * If provided, it will take preference over the referer header value set by\n   * {@link Page.setExtraHTTPHeaders | page.setExtraHTTPHeaders()}.\n   */\n  referer?: string;\n  /**\n   * If provided, it will take preference over the referer-policy header value\n   * set by {@link Page.setExtraHTTPHeaders | page.setExtraHTTPHeaders()}.\n   */\n  referrerPolicy?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameWaitForFunctionOptions {\n  /**\n   * An interval at which the `pageFunction` is executed, defaults to `raf`. If\n   * `polling` is a number, then it is treated as an interval in milliseconds at\n   * which the function would be executed. If `polling` is a string, then it can\n   * be one of the following values:\n   *\n   * - `raf` - to constantly execute `pageFunction` in `requestAnimationFrame`\n   *   callback. This is the tightest polling mode which is suitable to observe\n   *   styling changes.\n   *\n   * - `mutation` - to execute `pageFunction` on every DOM mutation.\n   */\n  polling?: 'raf' | 'mutation' | number;\n  /**\n   * Maximum time to wait in milliseconds. Defaults to `30000` (30 seconds).\n   * Pass `0` to disable the timeout. Puppeteer's default timeout can be changed\n   * using {@link Page.setDefaultTimeout}.\n   */\n  timeout?: number;\n  /**\n   * A signal object that allows you to cancel a waitForFunction call.\n   */\n  signal?: AbortSignal;\n}\n\n/**\n * @public\n */\nexport interface FrameAddScriptTagOptions {\n  /**\n   * URL of the script to be added.\n   */\n  url?: string;\n  /**\n   * Path to a JavaScript file to be injected into the frame.\n   *\n   * @remarks\n   * If `path` is a relative path, it is resolved relative to the current\n   * working directory (`process.cwd()` in Node.js).\n   */\n  path?: string;\n  /**\n   * JavaScript to be injected into the frame.\n   */\n  content?: string;\n  /**\n   * Sets the `type` of the script. Use `module` in order to load an ES2015 module.\n   */\n  type?: string;\n  /**\n   * Sets the `id` of the script.\n   */\n  id?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameAddStyleTagOptions {\n  /**\n   * the URL of the CSS file to be added.\n   */\n  url?: string;\n  /**\n   * The path to a CSS file to be injected into the frame.\n   * @remarks\n   * If `path` is a relative path, it is resolved relative to the current\n   * working directory (`process.cwd()` in Node.js).\n   */\n  path?: string;\n  /**\n   * Raw CSS content to be injected into the frame.\n   */\n  content?: string;\n}\n\n/**\n * @public\n */\nexport interface FrameEvents extends Record<EventType, unknown> {\n  /** @internal */\n  [FrameEvent.FrameNavigated]: Protocol.Page.NavigationType;\n  /** @internal */\n  [FrameEvent.FrameSwapped]: undefined;\n  /** @internal */\n  [FrameEvent.LifecycleEvent]: undefined;\n  /** @internal */\n  [FrameEvent.FrameNavigatedWithinDocument]: undefined;\n  /** @internal */\n  [FrameEvent.FrameDetached]: Frame;\n  /** @internal */\n  [FrameEvent.FrameSwappedByActivation]: undefined;\n}\n\n/**\n * We use symbols to prevent external parties listening to these events.\n * They are internal to Puppeteer.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport namespace FrameEvent {\n  export const FrameNavigated = Symbol('Frame.FrameNavigated');\n  export const FrameSwapped = Symbol('Frame.FrameSwapped');\n  export const LifecycleEvent = Symbol('Frame.LifecycleEvent');\n  export const FrameNavigatedWithinDocument = Symbol(\n    'Frame.FrameNavigatedWithinDocument'\n  );\n  export const FrameDetached = Symbol('Frame.FrameDetached');\n  export const FrameSwappedByActivation = Symbol(\n    'Frame.FrameSwappedByActivation'\n  );\n}\n\n/**\n * @internal\n */\nexport const throwIfDetached = throwIfDisposed<Frame>(frame => {\n  return `Attempted to use detached Frame '${frame._id}'.`;\n});\n\n/**\n * Represents a DOM frame.\n *\n * To understand frames, you can think of frames as `<iframe>` elements. Just\n * like iframes, frames can be nested, and when JavaScript is executed in a\n * frame, the JavaScript does not effect frames inside the ambient frame the\n * JavaScript executes in.\n *\n * @example\n * At any point in time, {@link Page | pages} expose their current frame\n * tree via the {@link Page.mainFrame} and {@link Frame.childFrames} methods.\n *\n * @example\n * An example of dumping frame tree:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://www.google.com/chrome/browser/canary.html');\n *   dumpFrameTree(page.mainFrame(), '');\n *   await browser.close();\n *\n *   function dumpFrameTree(frame, indent) {\n *     console.log(indent + frame.url());\n *     for (const child of frame.childFrames()) {\n *       dumpFrameTree(child, indent + '  ');\n *     }\n *   }\n * })();\n * ```\n *\n * @example\n * An example of getting text from an iframe element:\n *\n * ```ts\n * const frame = page.frames().find(frame => frame.name() === 'myframe');\n * const text = await frame.$eval('.selector', element => element.textContent);\n * console.log(text);\n * ```\n *\n * @remarks\n * Frame lifecycles are controlled by three events that are all dispatched on\n * the parent {@link Frame.page | page}:\n *\n * - {@link PageEvent.FrameAttached}\n * - {@link PageEvent.FrameNavigated}\n * - {@link PageEvent.FrameDetached}\n *\n * @public\n */\nexport abstract class Frame extends EventEmitter<FrameEvents> {\n  /**\n   * @internal\n   */\n  _id!: string;\n  /**\n   * @internal\n   */\n  _parentId?: string;\n\n  /**\n   * @internal\n   */\n  worlds!: IsolatedWorldChart;\n\n  /**\n   * @internal\n   */\n  _name?: string;\n\n  /**\n   * @internal\n   */\n  _hasStartedLoading = false;\n\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * The page associated with the frame.\n   */\n  abstract page(): Page;\n\n  /**\n   * Is `true` if the frame is an out-of-process (OOP) frame. Otherwise,\n   * `false`.\n   */\n  isOOPFrame(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Navigates the frame to the given `url`.\n   *\n   * @remarks\n   * Navigation to `about:blank` or navigation to the same URL with a different\n   * hash will succeed and return `null`.\n   *\n   * :::warning\n   *\n   * Headless mode doesn't support navigation to a PDF document. See the {@link\n   * https://bugs.chromium.org/p/chromium/issues/detail?id=761295 | upstream\n   * issue}.\n   *\n   * :::\n   *\n   * @param url - URL to navigate the frame to. The URL should include scheme,\n   * e.g. `https://`\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response. In case of\n   * multiple redirects, the navigation will resolve with the response of the\n   * last redirect.\n   * @throws If:\n   *\n   * - there's an SSL error (e.g. in case of self-signed certificates).\n   * - target URL is invalid.\n   * - the timeout is exceeded during navigation.\n   * - the remote server does not respond or is unreachable.\n   * - the main resource failed to load.\n   *\n   * This method will not throw an error when any valid HTTP status code is\n   * returned by the remote server, including 404 \"Not Found\" and 500 \"Internal\n   * Server Error\". The status code for such responses can be retrieved by\n   * calling {@link HTTPResponse.status}.\n   */\n  abstract goto(\n    url: string,\n    options?: {\n      referer?: string;\n      referrerPolicy?: string;\n      timeout?: number;\n      waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n    }\n  ): Promise<HTTPResponse | null>;\n\n  /**\n   * Waits for the frame to navigate. It is useful for when you run code which\n   * will indirectly cause the frame to navigate.\n   *\n   * Usage of the\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/History_API | History API}\n   * to change the URL is considered a navigation.\n   *\n   * @example\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   // The navigation promise resolves after navigation has finished\n   *   frame.waitForNavigation(),\n   *   // Clicking the link will indirectly cause a navigation\n   *   frame.click('a.my-link'),\n   * ]);\n   * ```\n   *\n   * @param options - Options to configure waiting behavior.\n   * @returns A promise which resolves to the main resource response.\n   */\n  abstract waitForNavigation(\n    options?: WaitForOptions\n  ): Promise<HTTPResponse | null>;\n\n  /**\n   * @internal\n   */\n  abstract get client(): CDPSession;\n\n  /**\n   * @internal\n   */\n  abstract mainRealm(): Realm;\n\n  /**\n   * @internal\n   */\n  abstract isolatedRealm(): Realm;\n\n  #_document: Promise<ElementHandle<Document>> | undefined;\n\n  /**\n   * @internal\n   */\n  #document(): Promise<ElementHandle<Document>> {\n    if (!this.#_document) {\n      this.#_document = this.isolatedRealm()\n        .evaluateHandle(() => {\n          return document;\n        })\n        .then(handle => {\n          return this.mainRealm().transferHandle(handle);\n        });\n    }\n    return this.#_document;\n  }\n\n  /**\n   * Used to clear the document handle that has been destroyed.\n   *\n   * @internal\n   */\n  clearDocumentHandle(): void {\n    this.#_document = undefined;\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDetached\n  async frameElement(): Promise<HandleFor<HTMLIFrameElement> | null> {\n    const parentFrame = this.parentFrame();\n    if (!parentFrame) {\n      return null;\n    }\n    using list = await parentFrame.isolatedRealm().evaluateHandle(() => {\n      return document.querySelectorAll('iframe');\n    });\n    for await (using iframe of transposeIterableHandle(list)) {\n      const frame = await iframe.contentFrame();\n      if (frame._id === this._id) {\n        return iframe.move();\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Behaves identically to {@link Page.evaluateHandle} except it's run within\n   * the context of this frame.\n   *\n   * @see {@link Page.evaluateHandle} for details.\n   */\n  @throwIfDetached\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainRealm().evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * Behaves identically to {@link Page.evaluate} except it's run within the\n   * the context of this frame.\n   *\n   * @see {@link Page.evaluate} for details.\n   */\n  @throwIfDetached\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainRealm().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Creates a locator for the provided selector. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Selector extends string>(\n    selector: Selector\n  ): Locator<NodeFor<Selector>>;\n\n  /**\n   * Creates a locator for the provided function. See {@link Locator} for\n   * details and supported actions.\n   *\n   * @remarks\n   * Locators API is experimental and we will not follow semver for breaking\n   * change in the Locators API.\n   */\n  locator<Ret>(func: () => Awaitable<Ret>): Locator<Ret>;\n\n  /**\n   * @internal\n   */\n  @throwIfDetached\n  locator<Selector extends string, Ret>(\n    selectorOrFunc: Selector | (() => Awaitable<Ret>)\n  ): Locator<NodeFor<Selector>> | Locator<Ret> {\n    if (typeof selectorOrFunc === 'string') {\n      return NodeLocator.create(this, selectorOrFunc);\n    } else {\n      return FunctionLocator.create(this, selectorOrFunc);\n    }\n  }\n  /**\n   * Queries the frame for an element matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  @throwIfDetached\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$(selector);\n  }\n\n  /**\n   * Queries the frame for all elements matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  @throwIfDetached\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$$(selector);\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the frame.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const searchValue = await frame.$eval('#search', el => el.value);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the frame's context.\n   * The first element matching the selector will be passed to the function as\n   * its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  @throwIfDetached\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: string | Func,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the frame.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```js\n   * const divsCounts = await frame.$$eval('div', divs => divs.length);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the frame's context.\n   * An array of elements matching the given selector will be passed to the\n   * function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  @throwIfDetached\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: string | Func,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$$eval(selector, pageFunction, ...args);\n  }\n\n  /**\n   * @deprecated Use {@link Frame.$$} with the `xpath` prefix.\n   *\n   * Example: `await frame.$$('xpath/' + xpathExpression)`\n   *\n   * This method evaluates the given XPath expression and returns the results.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   * @param expression - the XPath expression to evaluate.\n   */\n  @throwIfDetached\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>> {\n    // eslint-disable-next-line rulesdir/use-using -- This is cached.\n    const document = await this.#document();\n    return await document.$x(expression);\n  }\n\n  /**\n   * Waits for an element matching the given selector to appear in the frame.\n   *\n   * This method works across navigations.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  @throwIfDetached\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(\n      this,\n      updatedSelector,\n      options\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * @deprecated Use {@link Frame.waitForSelector} with the `xpath` prefix.\n   *\n   * Example: `await frame.waitForSelector('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the Frame.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * Wait for the `xpath` to appear in page. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the xpath doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * For a code example, see the example for {@link Frame.waitForSelector}. That\n   * function behaves identically other than taking a CSS selector rather than\n   * an XPath.\n   *\n   * @param xpath - the XPath expression to wait for.\n   * @param options - options to configure the visibility of the element and how\n   * long to wait before timing out.\n   */\n  @throwIfDetached\n  async waitForXPath(\n    xpath: string,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<Node> | null> {\n    if (xpath.startsWith('//')) {\n      xpath = `.${xpath}`;\n    }\n    return await this.waitForSelector(`xpath/${xpath}`, options);\n  }\n\n  /**\n   * @example\n   * The `waitForFunction` can be used to observe viewport size change:\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   * .  const browser = await puppeteer.launch();\n   * .  const page = await browser.newPage();\n   * .  const watchDog = page.mainFrame().waitForFunction('window.innerWidth < 100');\n   * .  page.setViewport({width: 50, height: 50});\n   * .  await watchDog;\n   * .  await browser.close();\n   * })();\n   * ```\n   *\n   * To pass arguments from Node.js to the predicate of `page.waitForFunction` function:\n   *\n   * ```ts\n   * const selector = '.foo';\n   * await frame.waitForFunction(\n   *   selector => !!document.querySelector(selector),\n   *   {}, // empty options object\n   *   selector\n   * );\n   * ```\n   *\n   * @param pageFunction - the function to evaluate in the frame context.\n   * @param options - options to configure the polling method and timeout.\n   * @param args - arguments to pass to the `pageFunction`.\n   * @returns the promise which resolve when the `pageFunction` returns a truthy value.\n   */\n  @throwIfDetached\n  async waitForFunction<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    options: FrameWaitForFunctionOptions = {},\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    return await (this.mainRealm().waitForFunction(\n      pageFunction,\n      options,\n      ...args\n    ) as Promise<HandleFor<Awaited<ReturnType<Func>>>>);\n  }\n  /**\n   * The full HTML contents of the frame, including the DOCTYPE.\n   */\n  @throwIfDetached\n  async content(): Promise<string> {\n    return await this.evaluate(getPageContent);\n  }\n\n  /**\n   * Set the content of the frame.\n   *\n   * @param html - HTML markup to assign to the page.\n   * @param options - Options to configure how long before timing out and at\n   * what point to consider the content setting successful.\n   */\n  abstract setContent(\n    html: string,\n    options?: {\n      timeout?: number;\n      waitUntil?: PuppeteerLifeCycleEvent | PuppeteerLifeCycleEvent[];\n    }\n  ): Promise<void>;\n\n  /**\n   * The frame's `name` attribute as specified in the tag.\n   *\n   * @remarks\n   * If the name is empty, it returns the `id` attribute instead.\n   *\n   * @remarks\n   * This value is calculated once when the frame is created, and will not\n   * update if the attribute is changed later.\n   */\n  name(): string {\n    return this._name || '';\n  }\n\n  /**\n   * The frame's URL.\n   */\n  abstract url(): string;\n\n  /**\n   * The parent frame, if any. Detached and main frames return `null`.\n   */\n  abstract parentFrame(): Frame | null;\n\n  /**\n   * An array of child frames.\n   */\n  abstract childFrames(): Frame[];\n\n  /**\n   * @returns `true` if the frame has detached. `false` otherwise.\n   */\n  abstract get detached(): boolean;\n\n  /**\n   * Is`true` if the frame has been detached. Otherwise, `false`.\n   *\n   * @deprecated Use the `detached` getter.\n   */\n  isDetached(): boolean {\n    return this.detached;\n  }\n\n  /**\n   * @internal\n   */\n  get disposed(): boolean {\n    return this.detached;\n  }\n\n  /**\n   * Adds a `<script>` tag into the page with the desired url or content.\n   *\n   * @param options - Options for the script.\n   * @returns An {@link ElementHandle | element handle} to the injected\n   * `<script>` element.\n   */\n  @throwIfDetached\n  async addScriptTag(\n    options: FrameAddScriptTagOptions\n  ): Promise<ElementHandle<HTMLScriptElement>> {\n    let {content = '', type} = options;\n    const {path} = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    }\n\n    if (path) {\n      const fs = await importFSPromises();\n      content = await fs.readFile(path, 'utf8');\n      content += `//# sourceURL=${path.replace(/\\n/g, '')}`;\n    }\n\n    type = type ?? 'text/javascript';\n\n    return await this.mainRealm().transferHandle(\n      await this.isolatedRealm().evaluateHandle(\n        async ({Deferred}, {url, id, type, content}) => {\n          const deferred = Deferred.create<void>();\n          const script = document.createElement('script');\n          script.type = type;\n          script.text = content;\n          if (url) {\n            script.src = url;\n            script.addEventListener(\n              'load',\n              () => {\n                return deferred.resolve();\n              },\n              {once: true}\n            );\n            script.addEventListener(\n              'error',\n              event => {\n                deferred.reject(\n                  new Error(event.message ?? 'Could not load script')\n                );\n              },\n              {once: true}\n            );\n          } else {\n            deferred.resolve();\n          }\n          if (id) {\n            script.id = id;\n          }\n          document.head.appendChild(script);\n          await deferred.valueOrThrow();\n          return script;\n        },\n        LazyArg.create(context => {\n          return context.puppeteerUtil;\n        }),\n        {...options, type, content}\n      )\n    );\n  }\n\n  /**\n   * Adds a `HTMLStyleElement` into the frame with the desired URL\n   *\n   * @returns An {@link ElementHandle | element handle} to the loaded `<style>`\n   * element.\n   */\n  async addStyleTag(\n    options: Omit<FrameAddStyleTagOptions, 'url'>\n  ): Promise<ElementHandle<HTMLStyleElement>>;\n\n  /**\n   * Adds a `HTMLLinkElement` into the frame with the desired URL\n   *\n   * @returns An {@link ElementHandle | element handle} to the loaded `<link>`\n   * element.\n   */\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLLinkElement>>;\n\n  /**\n   * @internal\n   */\n  @throwIfDetached\n  async addStyleTag(\n    options: FrameAddStyleTagOptions\n  ): Promise<ElementHandle<HTMLStyleElement | HTMLLinkElement>> {\n    let {content = ''} = options;\n    const {path} = options;\n    if (+!!options.url + +!!path + +!!content !== 1) {\n      throw new Error(\n        'Exactly one of `url`, `path`, or `content` must be specified.'\n      );\n    }\n\n    if (path) {\n      const fs = await importFSPromises();\n\n      content = await fs.readFile(path, 'utf8');\n      content += '/*# sourceURL=' + path.replace(/\\n/g, '') + '*/';\n      options.content = content;\n    }\n\n    return await this.mainRealm().transferHandle(\n      await this.isolatedRealm().evaluateHandle(\n        async ({Deferred}, {url, content}) => {\n          const deferred = Deferred.create<void>();\n          let element: HTMLStyleElement | HTMLLinkElement;\n          if (!url) {\n            element = document.createElement('style');\n            element.appendChild(document.createTextNode(content!));\n          } else {\n            const link = document.createElement('link');\n            link.rel = 'stylesheet';\n            link.href = url;\n            element = link;\n          }\n          element.addEventListener(\n            'load',\n            () => {\n              deferred.resolve();\n            },\n            {once: true}\n          );\n          element.addEventListener(\n            'error',\n            event => {\n              deferred.reject(\n                new Error(\n                  (event as ErrorEvent).message ?? 'Could not load style'\n                )\n              );\n            },\n            {once: true}\n          );\n          document.head.appendChild(element);\n          await deferred.valueOrThrow();\n          return element;\n        },\n        LazyArg.create(context => {\n          return context.puppeteerUtil;\n        }),\n        options\n      )\n    );\n  }\n\n  /**\n   * Clicks the first element found that matches `selector`.\n   *\n   * @remarks\n   * If `click()` triggers a navigation event and there's a separate\n   * `page.waitForNavigation()` promise to be resolved, you may end up with a\n   * race condition that yields unexpected results. The correct pattern for\n   * click and wait for navigation is the following:\n   *\n   * ```ts\n   * const [response] = await Promise.all([\n   *   page.waitForNavigation(waitOptions),\n   *   frame.click(selector, clickOptions),\n   * ]);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   */\n  @throwIfDetached\n  async click(\n    selector: string,\n    options: Readonly<ClickOptions> = {}\n  ): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.click(options);\n    await handle.dispose();\n  }\n\n  /**\n   * Focuses the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  @throwIfDetached\n  async focus(selector: string): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.focus();\n  }\n\n  /**\n   * Hovers the pointer over the center of the first element that matches the\n   * `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  @throwIfDetached\n  async hover(selector: string): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.hover();\n  }\n\n  /**\n   * Selects a set of value on the first `<select>` element that matches the\n   * `selector`.\n   *\n   * @example\n   *\n   * ```ts\n   * frame.select('select#colors', 'blue'); // single selection\n   * frame.select('select#colors', 'red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param values - The array of values to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   * @returns the list of values that were successfully selected.\n   * @throws Throws if there's no `<select>` matching `selector`.\n   */\n  @throwIfDetached\n  async select(selector: string, ...values: string[]): Promise<string[]> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    return await handle.select(...values);\n  }\n\n  /**\n   * Taps the first element that matches the `selector`.\n   *\n   * @param selector - The selector to query for.\n   * @throws Throws if there's no element matching `selector`.\n   */\n  @throwIfDetached\n  async tap(selector: string): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.tap();\n  }\n\n  /**\n   * Sends a `keydown`, `keypress`/`input`, and `keyup` event for each character\n   * in the text.\n   *\n   * @remarks\n   * To press a special key, like `Control` or `ArrowDown`, use\n   * {@link Keyboard.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await frame.type('#mytextarea', 'Hello'); // Types instantly\n   * await frame.type('#mytextarea', 'World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @param selector - the selector for the element to type into. If there are\n   * multiple the first will be used.\n   * @param text - text to type into the element\n   * @param options - takes one option, `delay`, which sets the time to wait\n   * between key presses in milliseconds. Defaults to `0`.\n   */\n  @throwIfDetached\n  async type(\n    selector: string,\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    using handle = await this.$(selector);\n    assert(handle, `No element found for selector: ${selector}`);\n    await handle.type(text, options);\n  }\n\n  /**\n   * @deprecated Replace with `new Promise(r => setTimeout(r, milliseconds));`.\n   *\n   * Causes your script to wait for the given number of milliseconds.\n   *\n   * @remarks\n   * It's generally recommended to not wait for a number of seconds, but instead\n   * use {@link Frame.waitForSelector}, {@link Frame.waitForXPath} or\n   * {@link Frame.waitForFunction} to wait for exactly the conditions you want.\n   *\n   * @example\n   *\n   * Wait for 1 second:\n   *\n   * ```ts\n   * await frame.waitForTimeout(1000);\n   * ```\n   *\n   * @param milliseconds - the number of milliseconds to wait.\n   */\n  async waitForTimeout(milliseconds: number): Promise<void> {\n    return await new Promise(resolve => {\n      setTimeout(resolve, milliseconds);\n    });\n  }\n\n  /**\n   * The frame's title.\n   */\n  @throwIfDetached\n  async title(): Promise<string> {\n    return await this.isolatedRealm().evaluate(() => {\n      return document.title;\n    });\n  }\n\n  /**\n   * This method is typically coupled with an action that triggers a device\n   * request from an api such as WebBluetooth.\n   *\n   * :::caution\n   *\n   * This must be called before the device request is made. It will not return a\n   * currently active device prompt.\n   *\n   * :::\n   *\n   * @example\n   *\n   * ```ts\n   * const [devicePrompt] = Promise.all([\n   *   frame.waitForDevicePrompt(),\n   *   frame.click('#connect-bluetooth'),\n   * ]);\n   * await devicePrompt.select(\n   *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n   * );\n   * ```\n   */\n  waitForDevicePrompt(\n    options?: WaitTimeoutOptions\n  ): Promise<DeviceRequestPrompt>;\n\n  /**\n   * @internal\n   */\n  waitForDevicePrompt(): Promise<DeviceRequestPrompt> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  exposeFunction<Args extends unknown[], Ret>(\n    name: string,\n    fn: (...args: Args) => Awaitable<Ret>\n  ): Promise<void>;\n  exposeFunction(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}