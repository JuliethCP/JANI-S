{"ast":null,"code":"const debug = require('debug')('extract-zip');\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst {\n  createWriteStream,\n  promises: fs\n} = require('fs');\nconst getStream = require('get-stream');\nconst path = require('path');\nconst {\n  promisify\n} = require('util');\nconst stream = require('stream');\nconst yauzl = require('yauzl');\nconst openZip = promisify(yauzl.open);\nconst pipeline = promisify(stream.pipeline);\nclass Extractor {\n  constructor(zipPath, opts) {\n    this.zipPath = zipPath;\n    this.opts = opts;\n  }\n  async extract() {\n    debug('opening', this.zipPath, 'with opts', this.opts);\n    this.zipfile = await openZip(this.zipPath, {\n      lazyEntries: true\n    });\n    this.canceled = false;\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true;\n        reject(err);\n      });\n      this.zipfile.readEntry();\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete');\n          resolve();\n        }\n      });\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, {\n            cancelled: this.canceled\n          });\n          return;\n        }\n        debug('zipfile entry', entry.fileName);\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry();\n          return;\n        }\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName));\n        try {\n          await fs.mkdir(destDir, {\n            recursive: true\n          });\n          const canonicalDestDir = await fs.realpath(destDir);\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir);\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`);\n          }\n          await this.extractEntry(entry);\n          debug('finished processing', entry.fileName);\n          this.zipfile.readEntry();\n        } catch (err) {\n          this.canceled = true;\n          this.zipfile.close();\n          reject(err);\n        }\n      });\n    });\n  }\n  async extractEntry(entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, {\n        cancelled: this.canceled\n      });\n      return;\n    }\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile);\n    }\n    const dest = path.join(this.opts.dir, entry.fileName);\n\n    // convert external file attr int into a fs stat mode int\n    const mode = entry.externalFileAttributes >> 16 & 0xFFFF;\n    // check if it's a symlink or dir (using stat mode constants)\n    const IFMT = 61440;\n    const IFDIR = 16384;\n    const IFLNK = 40960;\n    const symlink = (mode & IFMT) === IFLNK;\n    let isDir = (mode & IFMT) === IFDIR;\n\n    // Failsafe, borrowed from jsZip\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true;\n    }\n\n    // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n    const madeBy = entry.versionMadeBy >> 8;\n    if (!isDir) isDir = madeBy === 0 && entry.externalFileAttributes === 16;\n    debug('extracting entry', {\n      filename: entry.fileName,\n      isDir: isDir,\n      isSymlink: symlink\n    });\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777;\n\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest);\n    const mkdirOptions = {\n      recursive: true\n    };\n    if (isDir) {\n      mkdirOptions.mode = procMode;\n    }\n    debug('mkdir', {\n      dir: destDir,\n      ...mkdirOptions\n    });\n    await fs.mkdir(destDir, mkdirOptions);\n    if (isDir) return;\n    debug('opening read stream', dest);\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry);\n    if (symlink) {\n      const link = await getStream(readStream);\n      debug('creating symlink', link, dest);\n      await fs.symlink(link, dest);\n    } else {\n      await pipeline(readStream, createWriteStream(dest, {\n        mode: procMode\n      }));\n    }\n  }\n  getExtractedMode(entryMode, isDir) {\n    let mode = entryMode;\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10);\n        }\n        if (!mode) {\n          mode = 0o755;\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10);\n        }\n        if (!mode) {\n          mode = 0o644;\n        }\n      }\n    }\n    return mode;\n  }\n}\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir);\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute');\n  }\n  await fs.mkdir(opts.dir, {\n    recursive: true\n  });\n  opts.dir = await fs.realpath(opts.dir);\n  return new Extractor(zipPath, opts).extract();\n};","map":{"version":3,"names":["debug","require","createWriteStream","promises","fs","getStream","path","promisify","stream","yauzl","openZip","open","pipeline","Extractor","constructor","zipPath","opts","extract","zipfile","lazyEntries","canceled","Promise","resolve","reject","on","err","readEntry","entry","fileName","cancelled","startsWith","destDir","dirname","join","dir","mkdir","recursive","canonicalDestDir","realpath","relativeDestDir","relative","split","sep","includes","Error","extractEntry","close","onEntry","dest","mode","externalFileAttributes","IFMT","IFDIR","IFLNK","symlink","isDir","endsWith","madeBy","versionMadeBy","filename","isSymlink","procMode","getExtractedMode","mkdirOptions","readStream","openReadStream","bind","link","entryMode","defaultDirMode","parseInt","defaultFileMode","module","exports","isAbsolute"],"sources":["D:/Julieth-Campos/PSO/node_modules/extract-zip/index.js"],"sourcesContent":["const debug = require('debug')('extract-zip')\n// eslint-disable-next-line node/no-unsupported-features/node-builtins\nconst { createWriteStream, promises: fs } = require('fs')\nconst getStream = require('get-stream')\nconst path = require('path')\nconst { promisify } = require('util')\nconst stream = require('stream')\nconst yauzl = require('yauzl')\n\nconst openZip = promisify(yauzl.open)\nconst pipeline = promisify(stream.pipeline)\n\nclass Extractor {\n  constructor (zipPath, opts) {\n    this.zipPath = zipPath\n    this.opts = opts\n  }\n\n  async extract () {\n    debug('opening', this.zipPath, 'with opts', this.opts)\n\n    this.zipfile = await openZip(this.zipPath, { lazyEntries: true })\n    this.canceled = false\n\n    return new Promise((resolve, reject) => {\n      this.zipfile.on('error', err => {\n        this.canceled = true\n        reject(err)\n      })\n      this.zipfile.readEntry()\n\n      this.zipfile.on('close', () => {\n        if (!this.canceled) {\n          debug('zip extraction complete')\n          resolve()\n        }\n      })\n\n      this.zipfile.on('entry', async entry => {\n        /* istanbul ignore if */\n        if (this.canceled) {\n          debug('skipping entry', entry.fileName, { cancelled: this.canceled })\n          return\n        }\n\n        debug('zipfile entry', entry.fileName)\n\n        if (entry.fileName.startsWith('__MACOSX/')) {\n          this.zipfile.readEntry()\n          return\n        }\n\n        const destDir = path.dirname(path.join(this.opts.dir, entry.fileName))\n\n        try {\n          await fs.mkdir(destDir, { recursive: true })\n\n          const canonicalDestDir = await fs.realpath(destDir)\n          const relativeDestDir = path.relative(this.opts.dir, canonicalDestDir)\n\n          if (relativeDestDir.split(path.sep).includes('..')) {\n            throw new Error(`Out of bound path \"${canonicalDestDir}\" found while processing file ${entry.fileName}`)\n          }\n\n          await this.extractEntry(entry)\n          debug('finished processing', entry.fileName)\n          this.zipfile.readEntry()\n        } catch (err) {\n          this.canceled = true\n          this.zipfile.close()\n          reject(err)\n        }\n      })\n    })\n  }\n\n  async extractEntry (entry) {\n    /* istanbul ignore if */\n    if (this.canceled) {\n      debug('skipping entry extraction', entry.fileName, { cancelled: this.canceled })\n      return\n    }\n\n    if (this.opts.onEntry) {\n      this.opts.onEntry(entry, this.zipfile)\n    }\n\n    const dest = path.join(this.opts.dir, entry.fileName)\n\n    // convert external file attr int into a fs stat mode int\n    const mode = (entry.externalFileAttributes >> 16) & 0xFFFF\n    // check if it's a symlink or dir (using stat mode constants)\n    const IFMT = 61440\n    const IFDIR = 16384\n    const IFLNK = 40960\n    const symlink = (mode & IFMT) === IFLNK\n    let isDir = (mode & IFMT) === IFDIR\n\n    // Failsafe, borrowed from jsZip\n    if (!isDir && entry.fileName.endsWith('/')) {\n      isDir = true\n    }\n\n    // check for windows weird way of specifying a directory\n    // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n    const madeBy = entry.versionMadeBy >> 8\n    if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)\n\n    debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })\n\n    const procMode = this.getExtractedMode(mode, isDir) & 0o777\n\n    // always ensure folders are created\n    const destDir = isDir ? dest : path.dirname(dest)\n\n    const mkdirOptions = { recursive: true }\n    if (isDir) {\n      mkdirOptions.mode = procMode\n    }\n    debug('mkdir', { dir: destDir, ...mkdirOptions })\n    await fs.mkdir(destDir, mkdirOptions)\n    if (isDir) return\n\n    debug('opening read stream', dest)\n    const readStream = await promisify(this.zipfile.openReadStream.bind(this.zipfile))(entry)\n\n    if (symlink) {\n      const link = await getStream(readStream)\n      debug('creating symlink', link, dest)\n      await fs.symlink(link, dest)\n    } else {\n      await pipeline(readStream, createWriteStream(dest, { mode: procMode }))\n    }\n  }\n\n  getExtractedMode (entryMode, isDir) {\n    let mode = entryMode\n    // Set defaults, if necessary\n    if (mode === 0) {\n      if (isDir) {\n        if (this.opts.defaultDirMode) {\n          mode = parseInt(this.opts.defaultDirMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o755\n        }\n      } else {\n        if (this.opts.defaultFileMode) {\n          mode = parseInt(this.opts.defaultFileMode, 10)\n        }\n\n        if (!mode) {\n          mode = 0o644\n        }\n      }\n    }\n\n    return mode\n  }\n}\n\nmodule.exports = async function (zipPath, opts) {\n  debug('creating target directory', opts.dir)\n\n  if (!path.isAbsolute(opts.dir)) {\n    throw new Error('Target directory is expected to be absolute')\n  }\n\n  await fs.mkdir(opts.dir, { recursive: true })\n  opts.dir = await fs.realpath(opts.dir)\n  return new Extractor(zipPath, opts).extract()\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}