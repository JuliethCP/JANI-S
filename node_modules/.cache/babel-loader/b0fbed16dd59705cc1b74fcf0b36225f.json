{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport assert from 'assert';\nimport { existsSync } from 'fs';\nimport { mkdir, unlink } from 'fs/promises';\nimport os from 'os';\nimport path from 'path';\nimport { downloadUrls } from './browser-data/browser-data.js';\nimport { Cache, InstalledBrowser } from './Cache.js';\nimport { debug } from './debug.js';\nimport { detectBrowserPlatform } from './detectPlatform.js';\nimport { unpackArchive } from './fileUtil.js';\nimport { downloadFile, headHttpRequest } from './httpUtil.js';\nconst debugInstall = debug('puppeteer:browsers:install');\nconst times = new Map();\nfunction debugTime(label) {\n  times.set(label, process.hrtime());\n}\nfunction debugTimeEnd(label) {\n  const end = process.hrtime();\n  const start = times.get(label);\n  if (!start) {\n    return;\n  }\n  const duration = end[0] * 1000 + end[1] / 1e6 - (start[0] * 1000 + start[1] / 1e6); // calculate duration in milliseconds\n  debugInstall(`Duration for ${label}: ${duration}ms`);\n}\nexport async function install(options) {\n  options.platform ??= detectBrowserPlatform();\n  options.unpack ??= true;\n  if (!options.platform) {\n    throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);\n  }\n  const url = getDownloadUrl(options.browser, options.platform, options.buildId, options.baseUrl);\n  const fileName = url.toString().split('/').pop();\n  assert(fileName, `A malformed download URL was found: ${url}.`);\n  const cache = new Cache(options.cacheDir);\n  const browserRoot = cache.browserRoot(options.browser);\n  const archivePath = path.join(browserRoot, `${options.buildId}-${fileName}`);\n  if (!existsSync(browserRoot)) {\n    await mkdir(browserRoot, {\n      recursive: true\n    });\n  }\n  if (!options.unpack) {\n    if (existsSync(archivePath)) {\n      return archivePath;\n    }\n    debugInstall(`Downloading binary from ${url}`);\n    debugTime('download');\n    await downloadFile(url, archivePath, options.downloadProgressCallback);\n    debugTimeEnd('download');\n    return archivePath;\n  }\n  const outputPath = cache.installationDir(options.browser, options.platform, options.buildId);\n  if (existsSync(outputPath)) {\n    return new InstalledBrowser(cache, options.browser, options.buildId, options.platform);\n  }\n  try {\n    debugInstall(`Downloading binary from ${url}`);\n    try {\n      debugTime('download');\n      await downloadFile(url, archivePath, options.downloadProgressCallback);\n    } finally {\n      debugTimeEnd('download');\n    }\n    debugInstall(`Installing ${archivePath} to ${outputPath}`);\n    try {\n      debugTime('extract');\n      await unpackArchive(archivePath, outputPath);\n    } finally {\n      debugTimeEnd('extract');\n    }\n  } finally {\n    if (existsSync(archivePath)) {\n      await unlink(archivePath);\n    }\n  }\n  return new InstalledBrowser(cache, options.browser, options.buildId, options.platform);\n}\n/**\n *\n * @public\n */\nexport async function uninstall(options) {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(`Cannot detect the browser platform for: ${os.platform()} (${os.arch()})`);\n  }\n  new Cache(options.cacheDir).uninstall(options.browser, options.platform, options.buildId);\n}\n/**\n * Returns metadata about browsers installed in the cache directory.\n *\n * @public\n */\nexport async function getInstalledBrowsers(options) {\n  return new Cache(options.cacheDir).getInstalledBrowsers();\n}\n/**\n * @public\n */\nexport async function canDownload(options) {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(`Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`);\n  }\n  return await headHttpRequest(getDownloadUrl(options.browser, options.platform, options.buildId, options.baseUrl));\n}\nfunction getDownloadUrl(browser, platform, buildId, baseUrl) {\n  return new URL(downloadUrls[browser](platform, buildId, baseUrl));\n}","map":{"version":3,"mappings":"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","names":["assert","existsSync","mkdir","unlink","os","path","downloadUrls","Cache","InstalledBrowser","debug","detectBrowserPlatform","unpackArchive","downloadFile","headHttpRequest","debugInstall","times","Map","debugTime","label","set","process","hrtime","debugTimeEnd","end","start","get","duration","install","options","platform","unpack","Error","arch","url","getDownloadUrl","browser","buildId","baseUrl","fileName","toString","split","pop","cache","cacheDir","browserRoot","archivePath","join","recursive","downloadProgressCallback","outputPath","installationDir","uninstall","getInstalledBrowsers","canDownload","URL"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@puppeteer\\browsers\\src\\install.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport assert from 'assert';\nimport {existsSync} from 'fs';\nimport {mkdir, unlink} from 'fs/promises';\nimport os from 'os';\nimport path from 'path';\n\nimport {\n  type Browser,\n  type BrowserPlatform,\n  downloadUrls,\n} from './browser-data/browser-data.js';\nimport {Cache, InstalledBrowser} from './Cache.js';\nimport {debug} from './debug.js';\nimport {detectBrowserPlatform} from './detectPlatform.js';\nimport {unpackArchive} from './fileUtil.js';\nimport {downloadFile, headHttpRequest} from './httpUtil.js';\n\nconst debugInstall = debug('puppeteer:browsers:install');\n\nconst times = new Map<string, [number, number]>();\nfunction debugTime(label: string) {\n  times.set(label, process.hrtime());\n}\n\nfunction debugTimeEnd(label: string) {\n  const end = process.hrtime();\n  const start = times.get(label);\n  if (!start) {\n    return;\n  }\n  const duration =\n    end[0] * 1000 + end[1] / 1e6 - (start[0] * 1000 + start[1] / 1e6); // calculate duration in milliseconds\n  debugInstall(`Duration for ${label}: ${duration}ms`);\n}\n\n/**\n * @public\n */\nexport interface InstallOptions {\n  /**\n   * Determines the path to download browsers to.\n   */\n  cacheDir: string;\n  /**\n   * Determines which platform the browser will be suited for.\n   *\n   * @defaultValue **Auto-detected.**\n   */\n  platform?: BrowserPlatform;\n  /**\n   * Determines which browser to install.\n   */\n  browser: Browser;\n  /**\n   * Determines which buildId to download. BuildId should uniquely identify\n   * binaries and they are used for caching.\n   */\n  buildId: string;\n  /**\n   * Provides information about the progress of the download.\n   */\n  downloadProgressCallback?: (\n    downloadedBytes: number,\n    totalBytes: number\n  ) => void;\n  /**\n   * Determines the host that will be used for downloading.\n   *\n   * @defaultValue Either\n   *\n   * - https://edgedl.me.gvt1.com/edgedl/chrome/chrome-for-testing or\n   * - https://archive.mozilla.org/pub/firefox/nightly/latest-mozilla-central\n   *\n   */\n  baseUrl?: string;\n  /**\n   * Whether to unpack and install browser archives.\n   *\n   * @defaultValue `true`\n   */\n  unpack?: boolean;\n}\n\n/**\n * @public\n */\nexport function install(\n  options: InstallOptions & {unpack?: true}\n): Promise<InstalledBrowser>;\n/**\n * @public\n */\nexport function install(\n  options: InstallOptions & {unpack: false}\n): Promise<string>;\nexport async function install(\n  options: InstallOptions\n): Promise<InstalledBrowser | string> {\n  options.platform ??= detectBrowserPlatform();\n  options.unpack ??= true;\n  if (!options.platform) {\n    throw new Error(\n      `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n    );\n  }\n  const url = getDownloadUrl(\n    options.browser,\n    options.platform,\n    options.buildId,\n    options.baseUrl\n  );\n  const fileName = url.toString().split('/').pop();\n  assert(fileName, `A malformed download URL was found: ${url}.`);\n  const cache = new Cache(options.cacheDir);\n  const browserRoot = cache.browserRoot(options.browser);\n  const archivePath = path.join(browserRoot, `${options.buildId}-${fileName}`);\n  if (!existsSync(browserRoot)) {\n    await mkdir(browserRoot, {recursive: true});\n  }\n\n  if (!options.unpack) {\n    if (existsSync(archivePath)) {\n      return archivePath;\n    }\n    debugInstall(`Downloading binary from ${url}`);\n    debugTime('download');\n    await downloadFile(url, archivePath, options.downloadProgressCallback);\n    debugTimeEnd('download');\n    return archivePath;\n  }\n\n  const outputPath = cache.installationDir(\n    options.browser,\n    options.platform,\n    options.buildId\n  );\n  if (existsSync(outputPath)) {\n    return new InstalledBrowser(\n      cache,\n      options.browser,\n      options.buildId,\n      options.platform\n    );\n  }\n  try {\n    debugInstall(`Downloading binary from ${url}`);\n    try {\n      debugTime('download');\n      await downloadFile(url, archivePath, options.downloadProgressCallback);\n    } finally {\n      debugTimeEnd('download');\n    }\n\n    debugInstall(`Installing ${archivePath} to ${outputPath}`);\n    try {\n      debugTime('extract');\n      await unpackArchive(archivePath, outputPath);\n    } finally {\n      debugTimeEnd('extract');\n    }\n  } finally {\n    if (existsSync(archivePath)) {\n      await unlink(archivePath);\n    }\n  }\n  return new InstalledBrowser(\n    cache,\n    options.browser,\n    options.buildId,\n    options.platform\n  );\n}\n\n/**\n * @public\n */\nexport interface UninstallOptions {\n  /**\n   * Determines the platform for the browser binary.\n   *\n   * @defaultValue **Auto-detected.**\n   */\n  platform?: BrowserPlatform;\n  /**\n   * The path to the root of the cache directory.\n   */\n  cacheDir: string;\n  /**\n   * Determines which browser to uninstall.\n   */\n  browser: Browser;\n  /**\n   * The browser build to uninstall\n   */\n  buildId: string;\n}\n\n/**\n *\n * @public\n */\nexport async function uninstall(options: UninstallOptions): Promise<void> {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(\n      `Cannot detect the browser platform for: ${os.platform()} (${os.arch()})`\n    );\n  }\n\n  new Cache(options.cacheDir).uninstall(\n    options.browser,\n    options.platform,\n    options.buildId\n  );\n}\n\n/**\n * @public\n */\nexport interface GetInstalledBrowsersOptions {\n  /**\n   * The path to the root of the cache directory.\n   */\n  cacheDir: string;\n}\n\n/**\n * Returns metadata about browsers installed in the cache directory.\n *\n * @public\n */\nexport async function getInstalledBrowsers(\n  options: GetInstalledBrowsersOptions\n): Promise<InstalledBrowser[]> {\n  return new Cache(options.cacheDir).getInstalledBrowsers();\n}\n\n/**\n * @public\n */\nexport async function canDownload(options: InstallOptions): Promise<boolean> {\n  options.platform ??= detectBrowserPlatform();\n  if (!options.platform) {\n    throw new Error(\n      `Cannot download a binary for the provided platform: ${os.platform()} (${os.arch()})`\n    );\n  }\n  return await headHttpRequest(\n    getDownloadUrl(\n      options.browser,\n      options.platform,\n      options.buildId,\n      options.baseUrl\n    )\n  );\n}\n\nfunction getDownloadUrl(\n  browser: Browser,\n  platform: BrowserPlatform,\n  buildId: string,\n  baseUrl?: string\n): URL {\n  return new URL(downloadUrls[browser](platform, buildId, baseUrl));\n}\n"]},"metadata":{},"sourceType":"module"}