{"ast":null,"code":"'use strict';\n\nconst fs = require('graceful-fs');\nconst path = require('path');\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10;\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5;\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0;\nconst nodeVersion = process.versions.node.split('.');\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10);\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10);\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10);\nfunction nodeSupportsBigInt() {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true;\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true;\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\nfunction getStats(src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, {\n      bigint: true\n    }, (err, srcStat) => {\n      if (err) return cb(err);\n      fs.stat(dest, {\n        bigint: true\n      }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, {\n            srcStat,\n            destStat: null\n          });\n          return cb(err);\n        }\n        return cb(null, {\n          srcStat,\n          destStat\n        });\n      });\n    });\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err);\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, {\n            srcStat,\n            destStat: null\n          });\n          return cb(err);\n        }\n        return cb(null, {\n          srcStat,\n          destStat\n        });\n      });\n    });\n  }\n}\nfunction getStatsSync(src, dest) {\n  let srcStat, destStat;\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, {\n      bigint: true\n    });\n  } else {\n    srcStat = fs.statSync(src);\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, {\n        bigint: true\n      });\n    } else {\n      destStat = fs.statSync(dest);\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return {\n      srcStat,\n      destStat: null\n    };\n    throw err;\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\nfunction checkPaths(src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'));\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)));\n    }\n    return cb(null, {\n      srcStat,\n      destStat\n    });\n  });\n}\nfunction checkPathsSync(src, dest, funcName) {\n  const {\n    srcStat,\n    destStat\n  } = getStatsSync(src, dest);\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.');\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return {\n    srcStat,\n    destStat\n  };\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths(src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb();\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, {\n      bigint: true\n    }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb();\n        return cb(err);\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)));\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb);\n    });\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb();\n        return cb(err);\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)));\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb);\n    });\n  }\n}\nfunction checkParentPathsSync(src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src));\n  const destParent = path.resolve(path.dirname(dest));\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return;\n  let destStat;\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, {\n        bigint: true\n      });\n    } else {\n      destStat = fs.statSync(destParent);\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return;\n    throw err;\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName));\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName);\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir(src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i);\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i);\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true);\n}\nfunction errMsg(src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`;\n}\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n};","map":{"version":3,"names":["fs","require","path","NODE_VERSION_MAJOR_WITH_BIGINT","NODE_VERSION_MINOR_WITH_BIGINT","NODE_VERSION_PATCH_WITH_BIGINT","nodeVersion","process","versions","node","split","nodeVersionMajor","Number","parseInt","nodeVersionMinor","nodeVersionPatch","nodeSupportsBigInt","getStats","src","dest","cb","stat","bigint","err","srcStat","destStat","code","getStatsSync","statSync","checkPaths","funcName","stats","ino","dev","Error","isDirectory","isSrcSubdir","errMsg","checkPathsSync","checkParentPaths","srcParent","resolve","dirname","destParent","parse","root","checkParentPathsSync","srcArr","sep","filter","i","destArr","reduce","acc","cur","module","exports"],"sources":["D:/Julieth-Campos/PSO/node_modules/get-uri/node_modules/fs-extra/lib/util/stat.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst path = require('path')\n\nconst NODE_VERSION_MAJOR_WITH_BIGINT = 10\nconst NODE_VERSION_MINOR_WITH_BIGINT = 5\nconst NODE_VERSION_PATCH_WITH_BIGINT = 0\nconst nodeVersion = process.versions.node.split('.')\nconst nodeVersionMajor = Number.parseInt(nodeVersion[0], 10)\nconst nodeVersionMinor = Number.parseInt(nodeVersion[1], 10)\nconst nodeVersionPatch = Number.parseInt(nodeVersion[2], 10)\n\nfunction nodeSupportsBigInt () {\n  if (nodeVersionMajor > NODE_VERSION_MAJOR_WITH_BIGINT) {\n    return true\n  } else if (nodeVersionMajor === NODE_VERSION_MAJOR_WITH_BIGINT) {\n    if (nodeVersionMinor > NODE_VERSION_MINOR_WITH_BIGINT) {\n      return true\n    } else if (nodeVersionMinor === NODE_VERSION_MINOR_WITH_BIGINT) {\n      if (nodeVersionPatch >= NODE_VERSION_PATCH_WITH_BIGINT) {\n        return true\n      }\n    }\n  }\n  return false\n}\n\nfunction getStats (src, dest, cb) {\n  if (nodeSupportsBigInt()) {\n    fs.stat(src, { bigint: true }, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, { bigint: true }, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  } else {\n    fs.stat(src, (err, srcStat) => {\n      if (err) return cb(err)\n      fs.stat(dest, (err, destStat) => {\n        if (err) {\n          if (err.code === 'ENOENT') return cb(null, { srcStat, destStat: null })\n          return cb(err)\n        }\n        return cb(null, { srcStat, destStat })\n      })\n    })\n  }\n}\n\nfunction getStatsSync (src, dest) {\n  let srcStat, destStat\n  if (nodeSupportsBigInt()) {\n    srcStat = fs.statSync(src, { bigint: true })\n  } else {\n    srcStat = fs.statSync(src)\n  }\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(dest, { bigint: true })\n    } else {\n      destStat = fs.statSync(dest)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return { srcStat, destStat: null }\n    throw err\n  }\n  return { srcStat, destStat }\n}\n\nfunction checkPaths (src, dest, funcName, cb) {\n  getStats(src, dest, (err, stats) => {\n    if (err) return cb(err)\n    const { srcStat, destStat } = stats\n    if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n      return cb(new Error('Source and destination must not be the same.'))\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      return cb(new Error(errMsg(src, dest, funcName)))\n    }\n    return cb(null, { srcStat, destStat })\n  })\n}\n\nfunction checkPathsSync (src, dest, funcName) {\n  const { srcStat, destStat } = getStatsSync(src, dest)\n  if (destStat && destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error('Source and destination must not be the same.')\n  }\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return { srcStat, destStat }\n}\n\n// recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths (src, srcStat, dest, funcName, cb) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return cb()\n  if (nodeSupportsBigInt()) {\n    fs.stat(destParent, { bigint: true }, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  } else {\n    fs.stat(destParent, (err, destStat) => {\n      if (err) {\n        if (err.code === 'ENOENT') return cb()\n        return cb(err)\n      }\n      if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n        return cb(new Error(errMsg(src, dest, funcName)))\n      }\n      return checkParentPaths(src, srcStat, destParent, funcName, cb)\n    })\n  }\n}\n\nfunction checkParentPathsSync (src, srcStat, dest, funcName) {\n  const srcParent = path.resolve(path.dirname(src))\n  const destParent = path.resolve(path.dirname(dest))\n  if (destParent === srcParent || destParent === path.parse(destParent).root) return\n  let destStat\n  try {\n    if (nodeSupportsBigInt()) {\n      destStat = fs.statSync(destParent, { bigint: true })\n    } else {\n      destStat = fs.statSync(destParent)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') return\n    throw err\n  }\n  if (destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev) {\n    throw new Error(errMsg(src, dest, funcName))\n  }\n  return checkParentPathsSync(src, srcStat, destParent, funcName)\n}\n\n// return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = path.resolve(src).split(path.sep).filter(i => i)\n  const destArr = path.resolve(dest).split(path.sep).filter(i => i)\n  return srcArr.reduce((acc, cur, i) => acc && destArr[i] === cur, true)\n}\n\nfunction errMsg (src, dest, funcName) {\n  return `Cannot ${funcName} '${src}' to a subdirectory of itself, '${dest}'.`\n}\n\nmodule.exports = {\n  checkPaths,\n  checkPathsSync,\n  checkParentPaths,\n  checkParentPathsSync,\n  isSrcSubdir\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}