{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nSymbol.dispose ??= Symbol('dispose');\nSymbol.asyncDispose ??= Symbol('asyncDispose');\n/**\n * @internal\n */\nexport const disposeSymbol = Symbol.dispose;\n/**\n * @internal\n */\nexport const asyncDisposeSymbol = Symbol.asyncDispose;\n/**\n * @internal\n */\nexport class DisposableStack {\n  #disposed = false;\n  #stack = [];\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed() {\n    return this.#disposed;\n  }\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  dispose() {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      resource[disposeSymbol]();\n    }\n  }\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided `value`.\n   */\n  use(value) {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt(value, onDispose) {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose(value);\n      }\n    });\n    return value;\n  }\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose) {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose();\n      }\n    });\n  }\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move() {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n\n    const stack = new DisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n  [disposeSymbol] = this.dispose;\n  [Symbol.toStringTag] = 'DisposableStack';\n}\n/**\n * @internal\n */\nexport class AsyncDisposableStack {\n  #disposed = false;\n  #stack = [];\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed() {\n    return this.#disposed;\n  }\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  async dispose() {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      await resource[asyncDisposeSymbol]();\n    }\n  }\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided {@link value}.\n   */\n  use(value) {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided {@link value}.\n   */\n  adopt(value, onDispose) {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose(value);\n      }\n    });\n    return value;\n  }\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose) {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose();\n      }\n    });\n  }\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move() {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n\n    const stack = new AsyncDisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n  [asyncDisposeSymbol] = this.dispose;\n  [Symbol.toStringTag] = 'AsyncDisposableStack';\n}","map":{"version":3,"mappings":"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","names":["Symbol","dispose","asyncDispose","disposeSymbol","asyncDisposeSymbol","DisposableStack","disposed","resource","reverse","use","value","push","adopt","onDispose","defer","move","ReferenceError","stack","toStringTag","AsyncDisposableStack"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\util\\disposable.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndeclare global {\n  interface SymbolConstructor {\n    /**\n     * A method that is used to release resources held by an object. Called by\n     * the semantics of the `using` statement.\n     */\n    readonly dispose: unique symbol;\n\n    /**\n     * A method that is used to asynchronously release resources held by an\n     * object. Called by the semantics of the `await using` statement.\n     */\n    readonly asyncDispose: unique symbol;\n  }\n\n  interface Disposable {\n    [Symbol.dispose](): void;\n  }\n\n  interface AsyncDisposable {\n    [Symbol.asyncDispose](): PromiseLike<void>;\n  }\n}\n\n(Symbol as any).dispose ??= Symbol('dispose');\n(Symbol as any).asyncDispose ??= Symbol('asyncDispose');\n\n/**\n * @internal\n */\nexport const disposeSymbol: typeof Symbol.dispose = Symbol.dispose;\n\n/**\n * @internal\n */\nexport const asyncDisposeSymbol: typeof Symbol.asyncDispose =\n  Symbol.asyncDispose;\n\n/**\n * @internal\n */\nexport class DisposableStack {\n  #disposed = false;\n  #stack: Disposable[] = [];\n\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  dispose(): void {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      resource[disposeSymbol]();\n    }\n  }\n\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided `value`.\n   */\n  use<T extends Disposable | null | undefined>(value: T): T {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided `value`.\n   */\n  adopt<T>(value: T, onDispose: (value: T) => void): T {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose(value);\n      },\n    });\n    return value;\n  }\n\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose: () => void): void {\n    this.#stack.push({\n      [disposeSymbol]() {\n        onDispose();\n      },\n    });\n  }\n\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move(): DisposableStack {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n    const stack = new DisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n\n  [disposeSymbol] = this.dispose;\n\n  readonly [Symbol.toStringTag] = 'DisposableStack';\n}\n\n/**\n * @internal\n */\nexport class AsyncDisposableStack {\n  #disposed = false;\n  #stack: AsyncDisposable[] = [];\n\n  /**\n   * Returns a value indicating whether this stack has been disposed.\n   */\n  get disposed(): boolean {\n    return this.#disposed;\n  }\n\n  /**\n   * Disposes each resource in the stack in the reverse order that they were added.\n   */\n  async dispose(): Promise<void> {\n    if (this.#disposed) {\n      return;\n    }\n    this.#disposed = true;\n    for (const resource of this.#stack.reverse()) {\n      await resource[asyncDisposeSymbol]();\n    }\n  }\n\n  /**\n   * Adds a disposable resource to the stack, returning the resource.\n   *\n   * @param value - The resource to add. `null` and `undefined` will not be added,\n   * but will be returned.\n   * @returns The provided {@link value}.\n   */\n  use<T extends AsyncDisposable | null | undefined>(value: T): T {\n    if (value) {\n      this.#stack.push(value);\n    }\n    return value;\n  }\n\n  /**\n   * Adds a value and associated disposal callback as a resource to the stack.\n   *\n   * @param value - The value to add.\n   * @param onDispose - The callback to use in place of a `[disposeSymbol]()`\n   * method. Will be invoked with `value` as the first parameter.\n   * @returns The provided {@link value}.\n   */\n  adopt<T>(value: T, onDispose: (value: T) => Promise<void>): T {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose(value);\n      },\n    });\n    return value;\n  }\n\n  /**\n   * Adds a callback to be invoked when the stack is disposed.\n   */\n  defer(onDispose: () => Promise<void>): void {\n    this.#stack.push({\n      [asyncDisposeSymbol]() {\n        return onDispose();\n      },\n    });\n  }\n\n  /**\n   * Move all resources out of this stack and into a new `DisposableStack`, and\n   * marks this stack as disposed.\n   *\n   * @example\n   *\n   * ```ts\n   * class C {\n   *   #res1: Disposable;\n   *   #res2: Disposable;\n   *   #disposables: DisposableStack;\n   *   constructor() {\n   *     // stack will be disposed when exiting constructor for any reason\n   *     using stack = new DisposableStack();\n   *\n   *     // get first resource\n   *     this.#res1 = stack.use(getResource1());\n   *\n   *     // get second resource. If this fails, both `stack` and `#res1` will be disposed.\n   *     this.#res2 = stack.use(getResource2());\n   *\n   *     // all operations succeeded, move resources out of `stack` so that\n   *     // they aren't disposed when constructor exits\n   *     this.#disposables = stack.move();\n   *   }\n   *\n   *   [disposeSymbol]() {\n   *     this.#disposables.dispose();\n   *   }\n   * }\n   * ```\n   */\n  move(): AsyncDisposableStack {\n    if (this.#disposed) {\n      throw new ReferenceError('a disposed stack can not use anything new'); // step 3\n    }\n    const stack = new AsyncDisposableStack(); // step 4-5\n    stack.#stack = this.#stack;\n    this.#disposed = true;\n    return stack;\n  }\n\n  [asyncDisposeSymbol] = this.dispose;\n\n  readonly [Symbol.toStringTag] = 'AsyncDisposableStack';\n}\n"]},"metadata":{},"sourceType":"module"}