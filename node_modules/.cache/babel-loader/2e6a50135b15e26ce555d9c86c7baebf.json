{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { createWriteStream } from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport { URL, urlToHttpOptions } from 'url';\nimport { ProxyAgent } from 'proxy-agent';\nexport function headHttpRequest(url) {\n  return new Promise(resolve => {\n    const request = httpRequest(url, 'HEAD', response => {\n      // consume response data free node process\n      response.resume();\n      resolve(response.statusCode === 200);\n    }, false);\n    request.on('error', () => {\n      resolve(false);\n    });\n  });\n}\nexport function httpRequest(url, method, response) {\n  let keepAlive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  const options = {\n    protocol: url.protocol,\n    hostname: url.hostname,\n    port: url.port,\n    path: url.pathname + url.search,\n    method,\n    headers: keepAlive ? {\n      Connection: 'keep-alive'\n    } : undefined,\n    auth: urlToHttpOptions(url).auth,\n    agent: new ProxyAgent()\n  };\n  const requestCallback = res => {\n    if (res.statusCode && res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {\n      httpRequest(new URL(res.headers.location), method, response);\n    } else {\n      response(res);\n    }\n  };\n  const request = options.protocol === 'https:' ? https.request(options, requestCallback) : http.request(options, requestCallback);\n  request.end();\n  return request;\n}\n/**\n * @internal\n */\nexport function downloadFile(url, destinationPath, progressCallback) {\n  return new Promise((resolve, reject) => {\n    let downloadedBytes = 0;\n    let totalBytes = 0;\n    function onData(chunk) {\n      downloadedBytes += chunk.length;\n      progressCallback(downloadedBytes, totalBytes);\n    }\n    const request = httpRequest(url, 'GET', response => {\n      if (response.statusCode !== 200) {\n        const error = new Error(`Download failed: server returned code ${response.statusCode}. URL: ${url}`);\n        // consume response data to free up memory\n        response.resume();\n        reject(error);\n        return;\n      }\n      const file = createWriteStream(destinationPath);\n      file.on('finish', () => {\n        return resolve();\n      });\n      file.on('error', error => {\n        return reject(error);\n      });\n      response.pipe(file);\n      totalBytes = parseInt(response.headers['content-length'], 10);\n      if (progressCallback) {\n        response.on('data', onData);\n      }\n    });\n    request.on('error', error => {\n      return reject(error);\n    });\n  });\n}\nexport async function getJSON(url) {\n  const text = await getText(url);\n  try {\n    return JSON.parse(text);\n  } catch {\n    throw new Error('Could not parse JSON from ' + url.toString());\n  }\n}\nexport function getText(url) {\n  return new Promise((resolve, reject) => {\n    const request = httpRequest(url, 'GET', response => {\n      let data = '';\n      if (response.statusCode && response.statusCode >= 400) {\n        return reject(new Error(`Got status code ${response.statusCode}`));\n      }\n      response.on('data', chunk => {\n        data += chunk;\n      });\n      response.on('end', () => {\n        try {\n          return resolve(String(data));\n        } catch {\n          return reject(new Error('Chrome version not found'));\n        }\n      });\n    }, false);\n    request.on('error', err => {\n      reject(err);\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["createWriteStream","http","https","URL","urlToHttpOptions","ProxyAgent","headHttpRequest","url","Promise","resolve","request","httpRequest","response","resume","statusCode","on","method","keepAlive","options","protocol","hostname","port","path","pathname","search","headers","Connection","undefined","auth","agent","requestCallback","res","location","end","downloadFile","destinationPath","progressCallback","reject","downloadedBytes","totalBytes","onData","chunk","length","error","Error","file","pipe","parseInt","getJSON","text","getText","JSON","parse","toString","data","String","err"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@puppeteer\\browsers\\src\\httpUtil.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {createWriteStream} from 'fs';\nimport * as http from 'http';\nimport * as https from 'https';\nimport {URL, urlToHttpOptions} from 'url';\n\nimport {ProxyAgent} from 'proxy-agent';\n\nexport function headHttpRequest(url: URL): Promise<boolean> {\n  return new Promise(resolve => {\n    const request = httpRequest(\n      url,\n      'HEAD',\n      response => {\n        // consume response data free node process\n        response.resume();\n        resolve(response.statusCode === 200);\n      },\n      false\n    );\n    request.on('error', () => {\n      resolve(false);\n    });\n  });\n}\n\nexport function httpRequest(\n  url: URL,\n  method: string,\n  response: (x: http.IncomingMessage) => void,\n  keepAlive = true\n): http.ClientRequest {\n  const options: http.RequestOptions = {\n    protocol: url.protocol,\n    hostname: url.hostname,\n    port: url.port,\n    path: url.pathname + url.search,\n    method,\n    headers: keepAlive ? {Connection: 'keep-alive'} : undefined,\n    auth: urlToHttpOptions(url).auth,\n    agent: new ProxyAgent(),\n  };\n\n  const requestCallback = (res: http.IncomingMessage): void => {\n    if (\n      res.statusCode &&\n      res.statusCode >= 300 &&\n      res.statusCode < 400 &&\n      res.headers.location\n    ) {\n      httpRequest(new URL(res.headers.location), method, response);\n    } else {\n      response(res);\n    }\n  };\n  const request =\n    options.protocol === 'https:'\n      ? https.request(options, requestCallback)\n      : http.request(options, requestCallback);\n  request.end();\n  return request;\n}\n\n/**\n * @internal\n */\nexport function downloadFile(\n  url: URL,\n  destinationPath: string,\n  progressCallback?: (downloadedBytes: number, totalBytes: number) => void\n): Promise<void> {\n  return new Promise<void>((resolve, reject) => {\n    let downloadedBytes = 0;\n    let totalBytes = 0;\n\n    function onData(chunk: string): void {\n      downloadedBytes += chunk.length;\n      progressCallback!(downloadedBytes, totalBytes);\n    }\n\n    const request = httpRequest(url, 'GET', response => {\n      if (response.statusCode !== 200) {\n        const error = new Error(\n          `Download failed: server returned code ${response.statusCode}. URL: ${url}`\n        );\n        // consume response data to free up memory\n        response.resume();\n        reject(error);\n        return;\n      }\n      const file = createWriteStream(destinationPath);\n      file.on('finish', () => {\n        return resolve();\n      });\n      file.on('error', error => {\n        return reject(error);\n      });\n      response.pipe(file);\n      totalBytes = parseInt(response.headers['content-length']!, 10);\n      if (progressCallback) {\n        response.on('data', onData);\n      }\n    });\n    request.on('error', error => {\n      return reject(error);\n    });\n  });\n}\n\nexport async function getJSON(url: URL): Promise<unknown> {\n  const text = await getText(url);\n  try {\n    return JSON.parse(text);\n  } catch {\n    throw new Error('Could not parse JSON from ' + url.toString());\n  }\n}\n\nexport function getText(url: URL): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const request = httpRequest(\n      url,\n      'GET',\n      response => {\n        let data = '';\n        if (response.statusCode && response.statusCode >= 400) {\n          return reject(new Error(`Got status code ${response.statusCode}`));\n        }\n        response.on('data', chunk => {\n          data += chunk;\n        });\n        response.on('end', () => {\n          try {\n            return resolve(String(data));\n          } catch {\n            return reject(new Error('Chrome version not found'));\n          }\n        });\n      },\n      false\n    );\n    request.on('error', err => {\n      reject(err);\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}