{"ast":null,"code":"const {\n  Readable,\n  Writable,\n  getStreamError\n} = require('streamx');\nconst b4a = require('b4a');\nconst constants = require('./constants');\nconst headers = require('./headers');\nconst DMODE = 0o755;\nconst FMODE = 0o644;\nconst END_OF_TAR = b4a.alloc(1024);\nclass Sink extends Writable {\n  constructor(pack, header, callback) {\n    super({\n      mapWritable,\n      eagerOpen: true\n    });\n    this.written = 0;\n    this.header = header;\n    this._callback = callback;\n    this._linkname = null;\n    this._isLinkname = header.type === 'symlink' && !header.linkname;\n    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file';\n    this._finished = false;\n    this._pack = pack;\n    this._openCallback = null;\n    if (this._pack._stream === null) this._pack._stream = this;else this._pack._pending.push(this);\n  }\n  _open(cb) {\n    this._openCallback = cb;\n    if (this._pack._stream === this) this._continueOpen();\n  }\n  _continuePack(err) {\n    if (this._callback === null) return;\n    const callback = this._callback;\n    this._callback = null;\n    callback(err);\n  }\n  _continueOpen() {\n    if (this._pack._stream === null) this._pack._stream = this;\n    const cb = this._openCallback;\n    this._openCallback = null;\n    if (cb === null) return;\n    if (this._pack.destroying) return cb(new Error('pack stream destroyed'));\n    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'));\n    this._pack._stream = this;\n    if (!this._isLinkname) {\n      this._pack._encode(this.header);\n    }\n    if (this._isVoid) {\n      this._finish();\n      this._continuePack(null);\n    }\n    cb(null);\n  }\n  _write(data, cb) {\n    if (this._isLinkname) {\n      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data;\n      return cb(null);\n    }\n    if (this._isVoid) {\n      if (data.byteLength > 0) {\n        return cb(new Error('No body allowed for this entry'));\n      }\n      return cb();\n    }\n    this.written += data.byteLength;\n    if (this._pack.push(data)) return cb();\n    this._pack._drain = cb;\n  }\n  _finish() {\n    if (this._finished) return;\n    this._finished = true;\n    if (this._isLinkname) {\n      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : '';\n      this._pack._encode(this.header);\n    }\n    overflow(this._pack, this.header.size);\n    this._pack._done(this);\n  }\n  _final(cb) {\n    if (this.written !== this.header.size) {\n      // corrupting tar\n      return cb(new Error('Size mismatch'));\n    }\n    this._finish();\n    cb(null);\n  }\n  _getError() {\n    return getStreamError(this) || new Error('tar entry destroyed');\n  }\n  _predestroy() {\n    this._pack.destroy(this._getError());\n  }\n  _destroy(cb) {\n    this._pack._done(this);\n    this._continuePack(this._finished ? null : this._getError());\n    cb();\n  }\n}\nclass Pack extends Readable {\n  constructor(opts) {\n    super(opts);\n    this._drain = noop;\n    this._finalized = false;\n    this._finalizing = false;\n    this._pending = [];\n    this._stream = null;\n  }\n  entry(header, buffer, callback) {\n    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed');\n    if (typeof buffer === 'function') {\n      callback = buffer;\n      buffer = null;\n    }\n    if (!callback) callback = noop;\n    if (!header.size || header.type === 'symlink') header.size = 0;\n    if (!header.type) header.type = modeToType(header.mode);\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE;\n    if (!header.uid) header.uid = 0;\n    if (!header.gid) header.gid = 0;\n    if (!header.mtime) header.mtime = new Date();\n    if (typeof buffer === 'string') buffer = b4a.from(buffer);\n    const sink = new Sink(this, header, callback);\n    if (b4a.isBuffer(buffer)) {\n      header.size = buffer.byteLength;\n      sink.write(buffer);\n      sink.end();\n      return sink;\n    }\n    if (sink._isVoid) {\n      return sink;\n    }\n    return sink;\n  }\n  finalize() {\n    if (this._stream || this._pending.length > 0) {\n      this._finalizing = true;\n      return;\n    }\n    if (this._finalized) return;\n    this._finalized = true;\n    this.push(END_OF_TAR);\n    this.push(null);\n  }\n  _done(stream) {\n    if (stream !== this._stream) return;\n    this._stream = null;\n    if (this._finalizing) this.finalize();\n    if (this._pending.length) this._pending.shift()._continueOpen();\n  }\n  _encode(header) {\n    if (!header.pax) {\n      const buf = headers.encode(header);\n      if (buf) {\n        this.push(buf);\n        return;\n      }\n    }\n    this._encodePax(header);\n  }\n  _encodePax(header) {\n    const paxHeader = headers.encodePax({\n      name: header.name,\n      linkname: header.linkname,\n      pax: header.pax\n    });\n    const newHeader = {\n      name: 'PaxHeader',\n      mode: header.mode,\n      uid: header.uid,\n      gid: header.gid,\n      size: paxHeader.byteLength,\n      mtime: header.mtime,\n      type: 'pax-header',\n      linkname: header.linkname && 'PaxHeader',\n      uname: header.uname,\n      gname: header.gname,\n      devmajor: header.devmajor,\n      devminor: header.devminor\n    };\n    this.push(headers.encode(newHeader));\n    this.push(paxHeader);\n    overflow(this, paxHeader.byteLength);\n    newHeader.size = header.size;\n    newHeader.type = header.type;\n    this.push(headers.encode(newHeader));\n  }\n  _doDrain() {\n    const drain = this._drain;\n    this._drain = noop;\n    drain();\n  }\n  _predestroy() {\n    const err = getStreamError(this);\n    if (this._stream) this._stream.destroy(err);\n    while (this._pending.length) {\n      const stream = this._pending.shift();\n      stream.destroy(err);\n      stream._continueOpen();\n    }\n    this._doDrain();\n  }\n  _read(cb) {\n    this._doDrain();\n    cb();\n  }\n}\nmodule.exports = function pack(opts) {\n  return new Pack(opts);\n};\nfunction modeToType(mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK:\n      return 'block-device';\n    case constants.S_IFCHR:\n      return 'character-device';\n    case constants.S_IFDIR:\n      return 'directory';\n    case constants.S_IFIFO:\n      return 'fifo';\n    case constants.S_IFLNK:\n      return 'symlink';\n  }\n  return 'file';\n}\nfunction noop() {}\nfunction overflow(self, size) {\n  size &= 511;\n  if (size) self.push(END_OF_TAR.subarray(0, 512 - size));\n}\nfunction mapWritable(buf) {\n  return b4a.isBuffer(buf) ? buf : b4a.from(buf);\n}","map":{"version":3,"names":["Readable","Writable","getStreamError","require","b4a","constants","headers","DMODE","FMODE","END_OF_TAR","alloc","Sink","constructor","pack","header","callback","mapWritable","eagerOpen","written","_callback","_linkname","_isLinkname","type","linkname","_isVoid","_finished","_pack","_openCallback","_stream","_pending","push","_open","cb","_continueOpen","_continuePack","err","destroying","Error","_finalized","_encode","_finish","_write","data","concat","byteLength","_drain","toString","overflow","size","_done","_final","_getError","_predestroy","destroy","_destroy","Pack","opts","noop","_finalizing","entry","buffer","modeToType","mode","uid","gid","mtime","Date","from","sink","isBuffer","write","end","finalize","length","stream","shift","pax","buf","encode","_encodePax","paxHeader","encodePax","name","newHeader","uname","gname","devmajor","devminor","_doDrain","drain","_read","module","exports","S_IFMT","S_IFBLK","S_IFCHR","S_IFDIR","S_IFIFO","S_IFLNK","self","subarray"],"sources":["D:/Julieth-Campos/PSO/node_modules/tar-stream/pack.js"],"sourcesContent":["const { Readable, Writable, getStreamError } = require('streamx')\nconst b4a = require('b4a')\n\nconst constants = require('./constants')\nconst headers = require('./headers')\n\nconst DMODE = 0o755\nconst FMODE = 0o644\n\nconst END_OF_TAR = b4a.alloc(1024)\n\nclass Sink extends Writable {\n  constructor (pack, header, callback) {\n    super({ mapWritable, eagerOpen: true })\n\n    this.written = 0\n    this.header = header\n\n    this._callback = callback\n    this._linkname = null\n    this._isLinkname = header.type === 'symlink' && !header.linkname\n    this._isVoid = header.type !== 'file' && header.type !== 'contiguous-file'\n    this._finished = false\n    this._pack = pack\n    this._openCallback = null\n\n    if (this._pack._stream === null) this._pack._stream = this\n    else this._pack._pending.push(this)\n  }\n\n  _open (cb) {\n    this._openCallback = cb\n    if (this._pack._stream === this) this._continueOpen()\n  }\n\n  _continuePack (err) {\n    if (this._callback === null) return\n\n    const callback = this._callback\n    this._callback = null\n\n    callback(err)\n  }\n\n  _continueOpen () {\n    if (this._pack._stream === null) this._pack._stream = this\n\n    const cb = this._openCallback\n    this._openCallback = null\n    if (cb === null) return\n\n    if (this._pack.destroying) return cb(new Error('pack stream destroyed'))\n    if (this._pack._finalized) return cb(new Error('pack stream is already finalized'))\n\n    this._pack._stream = this\n\n    if (!this._isLinkname) {\n      this._pack._encode(this.header)\n    }\n\n    if (this._isVoid) {\n      this._finish()\n      this._continuePack(null)\n    }\n\n    cb(null)\n  }\n\n  _write (data, cb) {\n    if (this._isLinkname) {\n      this._linkname = this._linkname ? b4a.concat([this._linkname, data]) : data\n      return cb(null)\n    }\n\n    if (this._isVoid) {\n      if (data.byteLength > 0) {\n        return cb(new Error('No body allowed for this entry'))\n      }\n      return cb()\n    }\n\n    this.written += data.byteLength\n    if (this._pack.push(data)) return cb()\n    this._pack._drain = cb\n  }\n\n  _finish () {\n    if (this._finished) return\n    this._finished = true\n\n    if (this._isLinkname) {\n      this.header.linkname = this._linkname ? b4a.toString(this._linkname, 'utf-8') : ''\n      this._pack._encode(this.header)\n    }\n\n    overflow(this._pack, this.header.size)\n\n    this._pack._done(this)\n  }\n\n  _final (cb) {\n    if (this.written !== this.header.size) { // corrupting tar\n      return cb(new Error('Size mismatch'))\n    }\n\n    this._finish()\n    cb(null)\n  }\n\n  _getError () {\n    return getStreamError(this) || new Error('tar entry destroyed')\n  }\n\n  _predestroy () {\n    this._pack.destroy(this._getError())\n  }\n\n  _destroy (cb) {\n    this._pack._done(this)\n\n    this._continuePack(this._finished ? null : this._getError())\n\n    cb()\n  }\n}\n\nclass Pack extends Readable {\n  constructor (opts) {\n    super(opts)\n    this._drain = noop\n    this._finalized = false\n    this._finalizing = false\n    this._pending = []\n    this._stream = null\n  }\n\n  entry (header, buffer, callback) {\n    if (this._finalized || this.destroying) throw new Error('already finalized or destroyed')\n\n    if (typeof buffer === 'function') {\n      callback = buffer\n      buffer = null\n    }\n\n    if (!callback) callback = noop\n\n    if (!header.size || header.type === 'symlink') header.size = 0\n    if (!header.type) header.type = modeToType(header.mode)\n    if (!header.mode) header.mode = header.type === 'directory' ? DMODE : FMODE\n    if (!header.uid) header.uid = 0\n    if (!header.gid) header.gid = 0\n    if (!header.mtime) header.mtime = new Date()\n\n    if (typeof buffer === 'string') buffer = b4a.from(buffer)\n\n    const sink = new Sink(this, header, callback)\n\n    if (b4a.isBuffer(buffer)) {\n      header.size = buffer.byteLength\n      sink.write(buffer)\n      sink.end()\n      return sink\n    }\n\n    if (sink._isVoid) {\n      return sink\n    }\n\n    return sink\n  }\n\n  finalize () {\n    if (this._stream || this._pending.length > 0) {\n      this._finalizing = true\n      return\n    }\n\n    if (this._finalized) return\n    this._finalized = true\n\n    this.push(END_OF_TAR)\n    this.push(null)\n  }\n\n  _done (stream) {\n    if (stream !== this._stream) return\n\n    this._stream = null\n\n    if (this._finalizing) this.finalize()\n    if (this._pending.length) this._pending.shift()._continueOpen()\n  }\n\n  _encode (header) {\n    if (!header.pax) {\n      const buf = headers.encode(header)\n      if (buf) {\n        this.push(buf)\n        return\n      }\n    }\n    this._encodePax(header)\n  }\n\n  _encodePax (header) {\n    const paxHeader = headers.encodePax({\n      name: header.name,\n      linkname: header.linkname,\n      pax: header.pax\n    })\n\n    const newHeader = {\n      name: 'PaxHeader',\n      mode: header.mode,\n      uid: header.uid,\n      gid: header.gid,\n      size: paxHeader.byteLength,\n      mtime: header.mtime,\n      type: 'pax-header',\n      linkname: header.linkname && 'PaxHeader',\n      uname: header.uname,\n      gname: header.gname,\n      devmajor: header.devmajor,\n      devminor: header.devminor\n    }\n\n    this.push(headers.encode(newHeader))\n    this.push(paxHeader)\n    overflow(this, paxHeader.byteLength)\n\n    newHeader.size = header.size\n    newHeader.type = header.type\n    this.push(headers.encode(newHeader))\n  }\n\n  _doDrain () {\n    const drain = this._drain\n    this._drain = noop\n    drain()\n  }\n\n  _predestroy () {\n    const err = getStreamError(this)\n\n    if (this._stream) this._stream.destroy(err)\n\n    while (this._pending.length) {\n      const stream = this._pending.shift()\n      stream.destroy(err)\n      stream._continueOpen()\n    }\n\n    this._doDrain()\n  }\n\n  _read (cb) {\n    this._doDrain()\n    cb()\n  }\n}\n\nmodule.exports = function pack (opts) {\n  return new Pack(opts)\n}\n\nfunction modeToType (mode) {\n  switch (mode & constants.S_IFMT) {\n    case constants.S_IFBLK: return 'block-device'\n    case constants.S_IFCHR: return 'character-device'\n    case constants.S_IFDIR: return 'directory'\n    case constants.S_IFIFO: return 'fifo'\n    case constants.S_IFLNK: return 'symlink'\n  }\n\n  return 'file'\n}\n\nfunction noop () {}\n\nfunction overflow (self, size) {\n  size &= 511\n  if (size) self.push(END_OF_TAR.subarray(0, 512 - size))\n}\n\nfunction mapWritable (buf) {\n  return b4a.isBuffer(buf) ? buf : b4a.from(buf)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}