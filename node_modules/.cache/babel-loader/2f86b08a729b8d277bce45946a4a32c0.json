{"ast":null,"code":"var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n\n// returns a function that reads bits.\n// takes a buffer iterator as input\nmodule.exports = function bitIterator(nextBuffer) {\n  var bit = 0,\n    byte = 0;\n  var bytes = nextBuffer();\n  var f = function (n) {\n    if (n === null && bit != 0) {\n      // align to byte boundary\n      bit = 0;\n      byte++;\n      return;\n    }\n    var result = 0;\n    while (n > 0) {\n      if (byte >= bytes.length) {\n        byte = 0;\n        bytes = nextBuffer();\n      }\n      var left = 8 - bit;\n      if (bit === 0 && n > 0) f.bytesRead++;\n      if (n >= left) {\n        result <<= left;\n        result |= BITMASK[left] & bytes[byte++];\n        bit = 0;\n        n -= left;\n      } else {\n        result <<= n;\n        result |= (bytes[byte] & BITMASK[n] << 8 - n - bit) >> 8 - n - bit;\n        bit += n;\n        n = 0;\n      }\n    }\n    return result;\n  };\n  f.bytesRead = 0;\n  return f;\n};","map":{"version":3,"names":["BITMASK","module","exports","bitIterator","nextBuffer","bit","byte","bytes","f","n","result","length","left","bytesRead"],"sources":["D:/Julieth-Campos/PSO/node_modules/unbzip2-stream/lib/bit_iterator.js"],"sourcesContent":["var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n\n// returns a function that reads bits.\n// takes a buffer iterator as input\nmodule.exports = function bitIterator(nextBuffer) {\n    var bit = 0, byte = 0;\n    var bytes = nextBuffer();\n    var f = function(n) {\n        if (n === null && bit != 0) {  // align to byte boundary\n            bit = 0\n            byte++;\n            return;\n        }\n        var result = 0;\n        while(n > 0) {\n            if (byte >= bytes.length) {\n                byte = 0;\n                bytes = nextBuffer();\n            }\n            var left = 8 - bit;\n            if (bit === 0 && n > 0)\n                f.bytesRead++;\n            if (n >= left) {\n                result <<= left;\n                result |= (BITMASK[left] & bytes[byte++]);\n                bit = 0;\n                n -= left;\n            } else {\n                result <<= n;\n                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));\n                bit += n;\n                n = 0;\n            }\n        }\n        return result;\n    };\n    f.bytesRead = 0;\n    return f;\n};\n"],"mappings":"AAAA,IAAIA,OAAO,GAAG,CAAC,CAAC,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,CAAC;;AAEjE;AACA;AACAC,MAAM,CAACC,OAAO,GAAG,SAASC,WAAW,CAACC,UAAU,EAAE;EAC9C,IAAIC,GAAG,GAAG,CAAC;IAAEC,IAAI,GAAG,CAAC;EACrB,IAAIC,KAAK,GAAGH,UAAU,EAAE;EACxB,IAAII,CAAC,GAAG,UAASC,CAAC,EAAE;IAChB,IAAIA,CAAC,KAAK,IAAI,IAAIJ,GAAG,IAAI,CAAC,EAAE;MAAG;MAC3BA,GAAG,GAAG,CAAC;MACPC,IAAI,EAAE;MACN;IACJ;IACA,IAAII,MAAM,GAAG,CAAC;IACd,OAAMD,CAAC,GAAG,CAAC,EAAE;MACT,IAAIH,IAAI,IAAIC,KAAK,CAACI,MAAM,EAAE;QACtBL,IAAI,GAAG,CAAC;QACRC,KAAK,GAAGH,UAAU,EAAE;MACxB;MACA,IAAIQ,IAAI,GAAG,CAAC,GAAGP,GAAG;MAClB,IAAIA,GAAG,KAAK,CAAC,IAAII,CAAC,GAAG,CAAC,EAClBD,CAAC,CAACK,SAAS,EAAE;MACjB,IAAIJ,CAAC,IAAIG,IAAI,EAAE;QACXF,MAAM,KAAKE,IAAI;QACfF,MAAM,IAAKV,OAAO,CAACY,IAAI,CAAC,GAAGL,KAAK,CAACD,IAAI,EAAE,CAAE;QACzCD,GAAG,GAAG,CAAC;QACPI,CAAC,IAAIG,IAAI;MACb,CAAC,MAAM;QACHF,MAAM,KAAKD,CAAC;QACZC,MAAM,IAAK,CAACH,KAAK,CAACD,IAAI,CAAC,GAAIN,OAAO,CAACS,CAAC,CAAC,IAAK,CAAC,GAAGA,CAAC,GAAGJ,GAAK,KAAM,CAAC,GAAGI,CAAC,GAAGJ,GAAK;QAC1EA,GAAG,IAAII,CAAC;QACRA,CAAC,GAAG,CAAC;MACT;IACJ;IACA,OAAOC,MAAM;EACjB,CAAC;EACDF,CAAC,CAACK,SAAS,GAAG,CAAC;EACf,OAAOL,CAAC;AACZ,CAAC"},"metadata":{},"sourceType":"script"}