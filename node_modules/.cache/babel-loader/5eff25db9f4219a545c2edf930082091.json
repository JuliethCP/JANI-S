{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.awaitEachYieldedPromise = exports.maybeAsync = exports.maybeAsyncFn = void 0;\nfunction* awaitYield(value) {\n  return yield value;\n}\nfunction awaitYieldOf(generator) {\n  return awaitYield(awaitEachYieldedPromise(generator));\n}\nconst AwaitYield = awaitYield;\nAwaitYield.of = awaitYieldOf;\n/**\n * Create a function that may or may not be async, using a generator\n *\n * Within the generator, call `yield* awaited(maybePromise)` to await a value\n * that may or may not be a promise.\n *\n * If the inner function never yields a promise, it will return synchronously.\n */\nfunction maybeAsyncFn(that, fn) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    const generator = fn.call(that, AwaitYield, ...args);\n    return awaitEachYieldedPromise(generator);\n  };\n}\nexports.maybeAsyncFn = maybeAsyncFn;\nclass Example {\n  constructor() {\n    this.maybeAsyncMethod = maybeAsyncFn(this, function* (awaited, a) {\n      yield* awaited(new Promise(resolve => setTimeout(resolve, a)));\n      return 5;\n    });\n  }\n}\nfunction maybeAsync(that, startGenerator) {\n  const generator = startGenerator.call(that, AwaitYield);\n  return awaitEachYieldedPromise(generator);\n}\nexports.maybeAsync = maybeAsync;\nfunction awaitEachYieldedPromise(gen) {\n  function handleNextStep(step) {\n    if (step.done) {\n      return step.value;\n    }\n    if (step.value instanceof Promise) {\n      return step.value.then(value => handleNextStep(gen.next(value)), error => handleNextStep(gen.throw(error)));\n    }\n    return handleNextStep(gen.next(step.value));\n  }\n  return handleNextStep(gen.next());\n}\nexports.awaitEachYieldedPromise = awaitEachYieldedPromise;","map":{"version":3,"mappings":";;;;;;AAAA,UAAUA,UAAU,CAAIC,KAAqB;EAC3C,OAAQ,MAAMA,KAAK;AACrB;AAEA,SAASC,YAAY,CACnBC,SAA4D;EAE5D,OAAOH,UAAU,CAACI,uBAAuB,CAACD,SAAS,CAAC,CAAC;AACvD;AAMA,MAAME,UAAU,GAAeL,UAAwB;AACvDK,UAAU,CAACC,EAAE,GAAGJ,YAAY;AAE5B;;;;;;;;AAQA,SAAgBK,YAAY,CAS1BC,IAAU,EACVC,EAI2D;EAE3D,OAAO,YAAkB;IAAA,kCAAdC,IAAU;MAAVA,IAAU;IAAA;IACnB,MAAMP,SAAS,GAAGM,EAAE,CAACE,IAAI,CAACH,IAAI,EAAEH,UAAU,EAAE,GAAGK,IAAI,CAAC;IACpD,OAAON,uBAAuB,CAACD,SAAS,CAAC;EAC3C,CAAC;AACH;AApBAS;AAsBA,MAAMC,OAAO;EAAbC;IACU,qBAAgB,GAAGP,YAAY,CAAC,IAAI,EAAE,WAAWQ,OAAO,EAAEC,CAAS;MACzE,OAAOD,OAAO,CAAC,IAAIE,OAAO,CAAEC,OAAO,IAAKC,UAAU,CAACD,OAAO,EAAEF,CAAC,CAAC,CAAC,CAAC;MAChE,OAAO,CAAC;IACV,CAAC,CAAC;EACJ;;AAQA,SAAgBI,UAAU,CACxBZ,IAAU,EACVa,cAG2D;EAE3D,MAAMlB,SAAS,GAAGkB,cAAc,CAACV,IAAI,CAACH,IAAI,EAAEH,UAAU,CAAC;EACvD,OAAOD,uBAAuB,CAACD,SAAS,CAAC;AAC3C;AATAS;AAWA,SAAgBR,uBAAuB,CACrCkB,GAA6D;EAI7D,SAASC,cAAc,CAACC,IAAgB;IACtC,IAAIA,IAAI,CAACC,IAAI,EAAE;MACb,OAAOD,IAAI,CAACvB,KAAK;;IAGnB,IAAIuB,IAAI,CAACvB,KAAK,YAAYgB,OAAO,EAAE;MACjC,OAAOO,IAAI,CAACvB,KAAK,CAACyB,IAAI,CACnBzB,KAAK,IAAKsB,cAAc,CAACD,GAAG,CAACK,IAAI,CAAC1B,KAAK,CAAC,CAAC,EACzC2B,KAAK,IAAKL,cAAc,CAACD,GAAG,CAACO,KAAK,CAACD,KAAK,CAAC,CAAC,CAC5C;;IAGH,OAAOL,cAAc,CAACD,GAAG,CAACK,IAAI,CAACH,IAAI,CAACvB,KAAK,CAAC,CAAC;EAC7C;EAEA,OAAOsB,cAAc,CAACD,GAAG,CAACK,IAAI,EAAE,CAAC;AACnC;AArBAf","names":["awaitYield","value","awaitYieldOf","generator","awaitEachYieldedPromise","AwaitYield","of","maybeAsyncFn","that","fn","args","call","exports","Example","constructor","awaited","a","Promise","resolve","setTimeout","maybeAsync","startGenerator","gen","handleNextStep","step","done","then","next","error","throw"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\asyncify-helpers.ts"],"sourcesContent":["function* awaitYield<T>(value: T | Promise<T>) {\n  return (yield value) as T\n}\n\nfunction awaitYieldOf<T, Yielded>(\n  generator: Generator<Yielded | Promise<Yielded>, T, Yielded>\n): Generator<T | Promise<T>, T, T> {\n  return awaitYield(awaitEachYieldedPromise(generator))\n}\n\nexport type AwaitYield = typeof awaitYield & {\n  of: typeof awaitYieldOf\n}\n\nconst AwaitYield: AwaitYield = awaitYield as AwaitYield\nAwaitYield.of = awaitYieldOf\n\n/**\n * Create a function that may or may not be async, using a generator\n *\n * Within the generator, call `yield* awaited(maybePromise)` to await a value\n * that may or may not be a promise.\n *\n * If the inner function never yields a promise, it will return synchronously.\n */\nexport function maybeAsyncFn<\n  /** Function arguments */\n  Args extends any[],\n  This,\n  /** Function return type */\n  Return,\n  /** Yields to unwrap */\n  Yielded\n>(\n  that: This,\n  fn: (\n    this: This,\n    awaited: AwaitYield,\n    ...args: Args\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>\n): (...args: Args) => Return | Promise<Return> {\n  return (...args: Args) => {\n    const generator = fn.call(that, AwaitYield, ...args)\n    return awaitEachYieldedPromise(generator)\n  }\n}\n\nclass Example {\n  private maybeAsyncMethod = maybeAsyncFn(this, function* (awaited, a: number) {\n    yield* awaited(new Promise((resolve) => setTimeout(resolve, a)))\n    return 5\n  })\n}\n\nexport type MaybeAsyncBlock<Return, This, Yielded, Args extends any[] = []> = (\n  this: This,\n  awaited: AwaitYield,\n  ...args: Args\n) => Generator<Yielded | Promise<Yielded>, Return, Yielded>\n\nexport function maybeAsync<Return, This, Yielded>(\n  that: This,\n  startGenerator: (\n    this: This,\n    await: AwaitYield\n  ) => Generator<Yielded | Promise<Yielded>, Return, Yielded>\n): Return | Promise<Return> {\n  const generator = startGenerator.call(that, AwaitYield)\n  return awaitEachYieldedPromise(generator)\n}\n\nexport function awaitEachYieldedPromise<Yielded, Returned>(\n  gen: Generator<Yielded | Promise<Yielded>, Returned, Yielded>\n): Returned | Promise<Returned> {\n  type NextResult = ReturnType<typeof gen.next>\n\n  function handleNextStep(step: NextResult): Returned | Promise<Returned> {\n    if (step.done) {\n      return step.value\n    }\n\n    if (step.value instanceof Promise) {\n      return step.value.then(\n        (value) => handleNextStep(gen.next(value)),\n        (error) => handleNextStep(gen.throw(error))\n      )\n    }\n\n    return handleNextStep(gen.next(step.value))\n  }\n\n  return handleNextStep(gen.next())\n}\n"]},"metadata":{},"sourceType":"script"}