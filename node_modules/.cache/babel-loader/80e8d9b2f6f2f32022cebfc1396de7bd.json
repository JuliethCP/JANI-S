{"ast":null,"code":"/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { Realm } from '../api/Realm.js';\nimport { addPageBinding, debugError, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { disposeSymbol } from '../util/disposable.js';\nimport { Mutex } from '../util/Mutex.js';\nimport { createCdpHandle } from './ExecutionContext.js';\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context = Deferred.create();\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set();\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map();\n  get _bindings() {\n    return this.#bindings;\n  }\n  #frameOrWorker;\n  constructor(frameOrWorker, timeoutSettings) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n    this.frameUpdated();\n  }\n  get environment() {\n    return this.#frameOrWorker;\n  }\n  frameUpdated() {\n    this.client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n  get client() {\n    return this.#frameOrWorker.client;\n  }\n  clearContext() {\n    this.#context = Deferred.create();\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n  setContext(context) {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.taskManager.rerunAll();\n  }\n  hasContext() {\n    return this.#context.resolved();\n  }\n  #executionContext() {\n    if (this.disposed) {\n      throw new Error(`Execution context is not available in detached frame \"${this.environment.url()}\" (are you trying to evaluate?)`);\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n  async evaluateHandle(pageFunction) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n    const context = await this.#executionContext();\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n  async evaluate(pageFunction) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n    const context = await this.#executionContext();\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return await context.evaluate(pageFunction, ...args);\n  }\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(context, name) {\n    const env_1 = {\n      stack: [],\n      error: void 0,\n      hasError: false\n    };\n    try {\n      if (this.#contextBindings.has(name)) {\n        return;\n      }\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const _ = __addDisposableResource(env_1, await this.#mutex.acquire(), false);\n      try {\n        await context._client.send('Runtime.addBinding', context._contextName ? {\n          name,\n          executionContextName: context._contextName\n        } : {\n          name,\n          executionContextId: context._contextId\n        });\n        await context.evaluate(addPageBinding, 'internal', name);\n        this.#contextBindings.add(name);\n      } catch (error) {\n        // We could have tried to evaluate in a context which was already\n        // destroyed. This happens, for example, if the page is navigated while\n        // we are trying to add the binding\n        if (error instanceof Error) {\n          // Destroyed context.\n          if (error.message.includes('Execution context was destroyed')) {\n            return;\n          }\n          // Missing context.\n          if (error.message.includes('Cannot find context with specified id')) {\n            return;\n          }\n        }\n        debugError(error);\n      }\n    } catch (e_1) {\n      env_1.error = e_1;\n      env_1.hasError = true;\n    } finally {\n      __disposeResources(env_1);\n    }\n  }\n  #onBindingCalled = async event => {\n    let payload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {\n      type,\n      name,\n      seq,\n      args,\n      isTrivial\n    } = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n  async adoptBackendNode(backendNodeId) {\n    const executionContext = await this.#executionContext();\n    const {\n      object\n    } = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId\n    });\n    return createCdpHandle(this, object);\n  }\n  async adoptHandle(handle) {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return await handle.evaluateHandle(value => {\n        return value;\n      });\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id\n    });\n    return await this.adoptBackendNode(nodeInfo.node.backendNodeId);\n  }\n  async transferHandle(handle) {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId\n    });\n    const newHandle = await this.adoptBackendNode(info.node.backendNodeId);\n    await handle.dispose();\n    return newHandle;\n  }\n  [disposeSymbol]() {\n    super[disposeSymbol]();\n    this.client.off('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n}","map":{"version":3,"mappings":"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","names":["Realm","addPageBinding","debugError","withSourcePuppeteerURLIfNone","Deferred","disposeSymbol","Mutex","createCdpHandle","IsolatedWorld","create","Set","Map","_bindings","constructor","frameOrWorker","timeoutSettings","frameUpdated","environment","client","on","clearContext","clearDocumentHandle","setContext","context","clear","resolve","taskManager","rerunAll","hasContext","resolved","disposed","Error","url","valueOrThrow","evaluateHandle","pageFunction","name","args","evaluate","_addBindingToContext","has","_","acquire","_client","send","_contextName","executionContextName","executionContextId","_contextId","add","error","message","includes","event","payload","JSON","parse","type","seq","isTrivial","binding","get","run","err","adoptBackendNode","backendNodeId","executionContext","object","adoptHandle","handle","realm","value","nodeInfo","objectId","id","node","transferHandle","remoteObject","undefined","info","newHandle","dispose","off"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\IsolatedWorld.ts"],"sourcesContent":["/**\n * Copyright 2019 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {Realm} from '../api/Realm.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {BindingPayload, EvaluateFunc, HandleFor} from '../common/types.js';\nimport {\n  addPageBinding,\n  debugError,\n  withSourcePuppeteerURLIfNone,\n} from '../common/util.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {Mutex} from '../util/Mutex.js';\n\nimport type {Binding} from './Binding.js';\nimport {type ExecutionContext, createCdpHandle} from './ExecutionContext.js';\nimport type {CdpFrame} from './Frame.js';\nimport type {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport type {WebWorker} from './WebWorker.js';\n\n/**\n * @internal\n */\nexport interface PageBinding {\n  name: string;\n  pptrFunction: Function;\n}\n\n/**\n * @internal\n */\nexport interface IsolatedWorldChart {\n  [key: string]: IsolatedWorld;\n  [MAIN_WORLD]: IsolatedWorld;\n  [PUPPETEER_WORLD]: IsolatedWorld;\n}\n\n/**\n * @internal\n */\nexport class IsolatedWorld extends Realm {\n  #context = Deferred.create<ExecutionContext>();\n\n  // Set of bindings that have been registered in the current context.\n  #contextBindings = new Set<string>();\n\n  // Contains mapping from functions that should be bound to Puppeteer functions.\n  #bindings = new Map<string, Binding>();\n\n  get _bindings(): Map<string, Binding> {\n    return this.#bindings;\n  }\n\n  readonly #frameOrWorker: CdpFrame | WebWorker;\n\n  constructor(\n    frameOrWorker: CdpFrame | WebWorker,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super(timeoutSettings);\n    this.#frameOrWorker = frameOrWorker;\n    this.frameUpdated();\n  }\n\n  get environment(): CdpFrame | WebWorker {\n    return this.#frameOrWorker;\n  }\n\n  frameUpdated(): void {\n    this.client.on('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n\n  get client(): CDPSession {\n    return this.#frameOrWorker.client;\n  }\n\n  clearContext(): void {\n    this.#context = Deferred.create();\n    if ('clearDocumentHandle' in this.#frameOrWorker) {\n      this.#frameOrWorker.clearDocumentHandle();\n    }\n  }\n\n  setContext(context: ExecutionContext): void {\n    this.#contextBindings.clear();\n    this.#context.resolve(context);\n    void this.taskManager.rerunAll();\n  }\n\n  hasContext(): boolean {\n    return this.#context.resolved();\n  }\n\n  #executionContext(): Promise<ExecutionContext> {\n    if (this.disposed) {\n      throw new Error(\n        `Execution context is not available in detached frame \"${this.environment.url()}\" (are you trying to evaluate?)`\n      );\n    }\n    if (this.#context === null) {\n      throw new Error(`Execution content promise is missing`);\n    }\n    return this.#context.valueOrThrow();\n  }\n\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    const context = await this.#executionContext();\n    return await context.evaluateHandle(pageFunction, ...args);\n  }\n\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    const context = await this.#executionContext();\n    return await context.evaluate(pageFunction, ...args);\n  }\n\n  // If multiple waitFor are set up asynchronously, we need to wait for the\n  // first one to set up the binding in the page before running the others.\n  #mutex = new Mutex();\n  async _addBindingToContext(\n    context: ExecutionContext,\n    name: string\n  ): Promise<void> {\n    if (this.#contextBindings.has(name)) {\n      return;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    using _ = await this.#mutex.acquire();\n    try {\n      await context._client.send(\n        'Runtime.addBinding',\n        context._contextName\n          ? {\n              name,\n              executionContextName: context._contextName,\n            }\n          : {\n              name,\n              executionContextId: context._contextId,\n            }\n      );\n\n      await context.evaluate(addPageBinding, 'internal', name);\n\n      this.#contextBindings.add(name);\n    } catch (error) {\n      // We could have tried to evaluate in a context which was already\n      // destroyed. This happens, for example, if the page is navigated while\n      // we are trying to add the binding\n      if (error instanceof Error) {\n        // Destroyed context.\n        if (error.message.includes('Execution context was destroyed')) {\n          return;\n        }\n        // Missing context.\n        if (error.message.includes('Cannot find context with specified id')) {\n          return;\n        }\n      }\n\n      debugError(error);\n    }\n  }\n\n  #onBindingCalled = async (\n    event: Protocol.Runtime.BindingCalledEvent\n  ): Promise<void> => {\n    let payload: BindingPayload;\n    try {\n      payload = JSON.parse(event.payload);\n    } catch {\n      // The binding was either called by something in the page or it was\n      // called before our wrapper was initialized.\n      return;\n    }\n    const {type, name, seq, args, isTrivial} = payload;\n    if (type !== 'internal') {\n      return;\n    }\n    if (!this.#contextBindings.has(name)) {\n      return;\n    }\n\n    try {\n      const context = await this.#context.valueOrThrow();\n      if (event.executionContextId !== context._contextId) {\n        return;\n      }\n\n      const binding = this._bindings.get(name);\n      await binding?.run(context, seq, args, isTrivial);\n    } catch (err) {\n      debugError(err);\n    }\n  };\n\n  override async adoptBackendNode(\n    backendNodeId?: Protocol.DOM.BackendNodeId\n  ): Promise<JSHandle<Node>> {\n    const executionContext = await this.#executionContext();\n    const {object} = await this.client.send('DOM.resolveNode', {\n      backendNodeId: backendNodeId,\n      executionContextId: executionContext._contextId,\n    });\n    return createCdpHandle(this, object) as JSHandle<Node>;\n  }\n\n  async adoptHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      // If the context has already adopted this handle, clone it so downstream\n      // disposal doesn't become an issue.\n      return (await handle.evaluateHandle(value => {\n        return value;\n      })) as unknown as T;\n    }\n    const nodeInfo = await this.client.send('DOM.describeNode', {\n      objectId: handle.id,\n    });\n    return (await this.adoptBackendNode(nodeInfo.node.backendNodeId)) as T;\n  }\n\n  async transferHandle<T extends JSHandle<Node>>(handle: T): Promise<T> {\n    if (handle.realm === this) {\n      return handle;\n    }\n    // Implies it's a primitive value, probably.\n    if (handle.remoteObject().objectId === undefined) {\n      return handle;\n    }\n    const info = await this.client.send('DOM.describeNode', {\n      objectId: handle.remoteObject().objectId,\n    });\n    const newHandle = (await this.adoptBackendNode(\n      info.node.backendNodeId\n    )) as T;\n    await handle.dispose();\n    return newHandle;\n  }\n\n  [disposeSymbol](): void {\n    super[disposeSymbol]();\n    this.client.off('Runtime.bindingCalled', this.#onBindingCalled);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}