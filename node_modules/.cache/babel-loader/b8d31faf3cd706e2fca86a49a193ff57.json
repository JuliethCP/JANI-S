{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.HttpsProxyAgent = void 0;\nconst net = __importStar(require(\"net\"));\nconst tls = __importStar(require(\"tls\"));\nconst assert_1 = __importDefault(require(\"assert\"));\nconst debug_1 = __importDefault(require(\"debug\"));\nconst agent_base_1 = require(\"agent-base\");\nconst parse_proxy_response_1 = require(\"./parse-proxy-response\");\nconst debug = (0, debug_1.default)('https-proxy-agent');\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to\n * the specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * Outgoing HTTP requests are first tunneled through the proxy server using the\n * `CONNECT` HTTP request method to establish a connection to the proxy server,\n * and then the proxy server connects to the destination target and issues the\n * HTTP request from the proxy server.\n *\n * `https:` requests have their socket connection upgraded to TLS once\n * the connection to the proxy server has been established.\n */\nclass HttpsProxyAgent extends agent_base_1.Agent {\n  constructor(proxy, opts) {\n    super(opts);\n    this.options = {\n      path: undefined\n    };\n    this.proxy = typeof proxy === 'string' ? new URL(proxy) : proxy;\n    this.proxyHeaders = opts?.headers ?? {};\n    debug('Creating new HttpsProxyAgent instance: %o', this.proxy.href);\n    // Trim off the brackets from IPv6 addresses\n    const host = (this.proxy.hostname || this.proxy.host).replace(/^\\[|\\]$/g, '');\n    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === 'https:' ? 443 : 80;\n    this.connectOpts = {\n      // Attempt to negotiate http/1.1 for proxy servers that support http/2\n      ALPNProtocols: ['http/1.1'],\n      ...(opts ? omit(opts, 'headers') : null),\n      host,\n      port\n    };\n  }\n  /**\n   * Called when the node-core HTTP client library is creating a\n   * new HTTP request.\n   */\n  async connect(req, opts) {\n    const {\n      proxy\n    } = this;\n    if (!opts.host) {\n      throw new TypeError('No \"host\" provided');\n    }\n    // Create a socket connection to the proxy server.\n    let socket;\n    if (proxy.protocol === 'https:') {\n      debug('Creating `tls.Socket`: %o', this.connectOpts);\n      const servername = this.connectOpts.servername || this.connectOpts.host;\n      socket = tls.connect({\n        ...this.connectOpts,\n        servername: servername && net.isIP(servername) ? undefined : servername\n      });\n    } else {\n      debug('Creating `net.Socket`: %o', this.connectOpts);\n      socket = net.connect(this.connectOpts);\n    }\n    const headers = typeof this.proxyHeaders === 'function' ? this.proxyHeaders() : {\n      ...this.proxyHeaders\n    };\n    const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;\n    let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\\r\\n`;\n    // Inject the `Proxy-Authorization` header if necessary.\n    if (proxy.username || proxy.password) {\n      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;\n      headers['Proxy-Authorization'] = `Basic ${Buffer.from(auth).toString('base64')}`;\n    }\n    headers.Host = `${host}:${opts.port}`;\n    if (!headers['Proxy-Connection']) {\n      headers['Proxy-Connection'] = this.keepAlive ? 'Keep-Alive' : 'close';\n    }\n    for (const name of Object.keys(headers)) {\n      payload += `${name}: ${headers[name]}\\r\\n`;\n    }\n    const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);\n    socket.write(`${payload}\\r\\n`);\n    const {\n      connect,\n      buffered\n    } = await proxyResponsePromise;\n    req.emit('proxyConnect', connect);\n    this.emit('proxyConnect', connect, req);\n    if (connect.statusCode === 200) {\n      req.once('socket', resume);\n      if (opts.secureEndpoint) {\n        // The proxy is connecting to a TLS server, so upgrade\n        // this socket connection to a TLS connection.\n        debug('Upgrading socket connection to TLS');\n        const servername = opts.servername || opts.host;\n        return tls.connect({\n          ...omit(opts, 'host', 'path', 'port'),\n          socket,\n          servername: net.isIP(servername) ? undefined : servername\n        });\n      }\n      return socket;\n    }\n    // Some other status code that's not 200... need to re-play the HTTP\n    // header \"data\" events onto the socket once the HTTP machinery is\n    // attached so that the node core `http` can parse and handle the\n    // error status code.\n    // Close the original socket, and a new \"fake\" socket is returned\n    // instead, so that the proxy doesn't get the HTTP request\n    // written to it (which may contain `Authorization` headers or other\n    // sensitive data).\n    //\n    // See: https://hackerone.com/reports/541502\n    socket.destroy();\n    const fakeSocket = new net.Socket({\n      writable: false\n    });\n    fakeSocket.readable = true;\n    // Need to wait for the \"socket\" event to re-play the \"data\" events.\n    req.once('socket', s => {\n      debug('Replaying proxy buffer for failed request');\n      (0, assert_1.default)(s.listenerCount('data') > 0);\n      // Replay the \"buffered\" Buffer onto the fake `socket`, since at\n      // this point the HTTP module machinery has been hooked up for\n      // the user.\n      s.push(buffered);\n      s.push(null);\n    });\n    return fakeSocket;\n  }\n}\nHttpsProxyAgent.protocols = ['http', 'https'];\nexports.HttpsProxyAgent = HttpsProxyAgent;\nfunction resume(socket) {\n  socket.resume();\n}\nfunction omit(obj) {\n  const ret = {};\n  let key;\n  for (var _len = arguments.length, keys = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    keys[_key - 1] = arguments[_key];\n  }\n  for (key in obj) {\n    if (!keys.includes(key)) {\n      ret[key] = obj[key];\n    }\n  }\n  return ret;\n}","map":{"version":3,"mappings":"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","names":["debug","HttpsProxyAgent","agent_base_1","constructor","proxy","opts","options","path","undefined","URL","proxyHeaders","headers","href","host","hostname","replace","port","parseInt","protocol","connectOpts","ALPNProtocols","omit","connect","req","TypeError","socket","servername","tls","net","isIP","isIPv6","payload","username","password","auth","decodeURIComponent","Buffer","from","toString","Host","keepAlive","name","Object","keys","proxyResponsePromise","write","buffered","emit","statusCode","once","resume","secureEndpoint","destroy","fakeSocket","Socket","writable","readable","s","listenerCount","push","exports","obj","ret","key","includes"],"sources":["../src/index.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}