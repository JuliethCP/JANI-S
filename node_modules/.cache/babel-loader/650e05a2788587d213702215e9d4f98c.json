{"ast":null,"code":"/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport {};","map":{"version":3,"mappings":"AAAA","names":[],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\common\\types.ts"],"sourcesContent":["/**\n * Copyright 2020 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {ElementHandle} from '../api/ElementHandle.js';\nimport type {JSHandle} from '../api/JSHandle.js';\n\nimport type {LazyArg} from './LazyArg.js';\n\n/**\n * @public\n */\nexport interface Moveable {\n  /**\n   * Moves the resource when 'using'.\n   */\n  move(): this;\n}\n\n/**\n * @internal\n */\nexport interface Disposed {\n  get disposed(): boolean;\n}\n\n/**\n * @internal\n */\nexport interface BindingPayload {\n  type: string;\n  name: string;\n  seq: number;\n  args: unknown[];\n  /**\n   * Determines whether the arguments of the payload are trivial.\n   */\n  isTrivial: boolean;\n}\n\n/**\n * @internal\n */\nexport type AwaitableIterator<T> = Iterator<T> | AsyncIterator<T>;\n\n/**\n * @public\n */\nexport type AwaitableIterable<T> = Iterable<T> | AsyncIterable<T>;\n\n/**\n * @public\n */\nexport type Awaitable<T> = T | PromiseLike<T>;\n\n/**\n * @public\n */\nexport type HandleFor<T> = T extends Node ? ElementHandle<T> : JSHandle<T>;\n\n/**\n * @public\n */\nexport type HandleOr<T> = HandleFor<T> | JSHandle<T> | T;\n\n/**\n * @public\n */\nexport type FlattenHandle<T> = T extends HandleOr<infer U> ? U : never;\n\n/**\n * @internal\n */\nexport type FlattenLazyArg<T> = T extends LazyArg<infer U> ? U : T;\n\n/**\n * @internal\n */\nexport type InnerLazyParams<T extends unknown[]> = {\n  [K in keyof T]: FlattenLazyArg<T[K]>;\n};\n\n/**\n * @public\n */\nexport type InnerParams<T extends unknown[]> = {\n  [K in keyof T]: FlattenHandle<T[K]>;\n};\n\n/**\n * @public\n */\nexport type ElementFor<\n  TagName extends keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap,\n> = TagName extends keyof HTMLElementTagNameMap\n  ? HTMLElementTagNameMap[TagName]\n  : TagName extends keyof SVGElementTagNameMap\n  ? SVGElementTagNameMap[TagName]\n  : never;\n\n/**\n * @public\n */\nexport type EvaluateFunc<T extends unknown[]> = (\n  ...params: InnerParams<T>\n) => Awaitable<unknown>;\n\n/**\n * @public\n */\nexport type EvaluateFuncWith<V, T extends unknown[]> = (\n  ...params: [V, ...InnerParams<T>]\n) => Awaitable<unknown>;\n\n/**\n * @public\n */\nexport type NodeFor<ComplexSelector extends string> =\n  TypeSelectorOfComplexSelector<ComplexSelector> extends infer TypeSelector\n    ? TypeSelector extends\n        | keyof HTMLElementTagNameMap\n        | keyof SVGElementTagNameMap\n      ? ElementFor<TypeSelector>\n      : Element\n    : never;\n\ntype TypeSelectorOfComplexSelector<ComplexSelector extends string> =\n  CompoundSelectorsOfComplexSelector<ComplexSelector> extends infer CompoundSelectors\n    ? CompoundSelectors extends NonEmptyReadonlyArray<string>\n      ? Last<CompoundSelectors> extends infer LastCompoundSelector\n        ? LastCompoundSelector extends string\n          ? TypeSelectorOfCompoundSelector<LastCompoundSelector>\n          : never\n        : never\n      : unknown\n    : never;\n\ntype TypeSelectorOfCompoundSelector<CompoundSelector extends string> =\n  SplitWithDelemiters<\n    CompoundSelector,\n    BeginSubclassSelectorTokens\n  > extends infer CompoundSelectorTokens\n    ? CompoundSelectorTokens extends [infer TypeSelector, ...any[]]\n      ? TypeSelector extends ''\n        ? unknown\n        : TypeSelector\n      : never\n    : never;\n\ntype Last<Arr extends NonEmptyReadonlyArray<unknown>> = Arr extends [\n  infer Head,\n  ...infer Tail,\n]\n  ? Tail extends NonEmptyReadonlyArray<unknown>\n    ? Last<Tail>\n    : Head\n  : never;\n\ntype NonEmptyReadonlyArray<T> = [T, ...(readonly T[])];\n\ntype CompoundSelectorsOfComplexSelector<ComplexSelector extends string> =\n  SplitWithDelemiters<\n    ComplexSelector,\n    CombinatorTokens\n  > extends infer IntermediateTokens\n    ? IntermediateTokens extends readonly string[]\n      ? Drop<IntermediateTokens, ''>\n      : never\n    : never;\n\ntype SplitWithDelemiters<\n  Input extends string,\n  Delemiters extends readonly string[],\n> = Delemiters extends [infer FirstDelemiter, ...infer RestDelemiters]\n  ? FirstDelemiter extends string\n    ? RestDelemiters extends readonly string[]\n      ? FlatmapSplitWithDelemiters<Split<Input, FirstDelemiter>, RestDelemiters>\n      : never\n    : never\n  : [Input];\n\ntype BeginSubclassSelectorTokens = ['.', '#', '[', ':'];\n\ntype CombinatorTokens = [' ', '>', '+', '~', '|', '|'];\n\ntype Drop<\n  Arr extends readonly unknown[],\n  Remove,\n  Acc extends unknown[] = [],\n> = Arr extends [infer Head, ...infer Tail]\n  ? Head extends Remove\n    ? Drop<Tail, Remove>\n    : Drop<Tail, Remove, [...Acc, Head]>\n  : Acc;\n\ntype FlatmapSplitWithDelemiters<\n  Inputs extends readonly string[],\n  Delemiters extends readonly string[],\n  Acc extends string[] = [],\n> = Inputs extends [infer FirstInput, ...infer RestInputs]\n  ? FirstInput extends string\n    ? RestInputs extends readonly string[]\n      ? FlatmapSplitWithDelemiters<\n          RestInputs,\n          Delemiters,\n          [...Acc, ...SplitWithDelemiters<FirstInput, Delemiters>]\n        >\n      : Acc\n    : Acc\n  : Acc;\n\ntype Split<\n  Input extends string,\n  Delimiter extends string,\n  Acc extends string[] = [],\n> = Input extends `${infer Prefix}${Delimiter}${infer Suffix}`\n  ? Split<Suffix, Delimiter, [...Acc, Prefix]>\n  : [...Acc, Input];\n"]},"metadata":{},"sourceType":"module"}