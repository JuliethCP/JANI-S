{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.shouldInterruptAfterDeadline = exports.newAsyncContext = exports.newAsyncRuntime = exports.getQuickJSSync = exports.getQuickJS = exports.errors = exports.RELEASE_SYNC = exports.RELEASE_ASYNC = exports.DEBUG_SYNC = exports.DEBUG_ASYNC = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;\n// Build variants\nconst variants_1 = require(\"./variants\");\nObject.defineProperty(exports, \"newQuickJSWASMModule\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.newQuickJSWASMModule;\n  }\n});\nObject.defineProperty(exports, \"newQuickJSAsyncWASMModule\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.newQuickJSAsyncWASMModule;\n  }\n});\nObject.defineProperty(exports, \"DEBUG_ASYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.DEBUG_ASYNC;\n  }\n});\nObject.defineProperty(exports, \"DEBUG_SYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.DEBUG_SYNC;\n  }\n});\nObject.defineProperty(exports, \"RELEASE_ASYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.RELEASE_ASYNC;\n  }\n});\nObject.defineProperty(exports, \"RELEASE_SYNC\", {\n  enumerable: true,\n  get: function () {\n    return variants_1.RELEASE_SYNC;\n  }\n});\n// Export helpers\n__exportStar(require(\"./vm-interface\"), exports);\n__exportStar(require(\"./lifetime\"), exports);\n/** Collects the informative errors this library may throw. */\nexports.errors = __importStar(require(\"./errors\"));\n__exportStar(require(\"./deferred-promise\"), exports);\n__exportStar(require(\"./module-test\"), exports);\nlet singleton = undefined;\nlet singletonPromise = undefined;\n/**\n * Get a shared singleton {@link QuickJSWASMModule}. Use this to evaluate code\n * or create Javascript environments.\n *\n * This is the top-level entrypoint for the quickjs-emscripten library.\n *\n * If you need strictest possible isolation guarantees, you may create a\n * separate {@link QuickJSWASMModule} via {@link newQuickJSWASMModule}.\n *\n * To work with the asyncified version of this library, see these functions:\n *\n * - {@link newAsyncRuntime}.\n * - {@link newAsyncContext}.\n * - {@link newQuickJSAsyncWASMModule}.\n */\nasync function getQuickJS() {\n  singletonPromise ?? (singletonPromise = (0, variants_1.newQuickJSWASMModule)().then(instance => {\n    singleton = instance;\n    return instance;\n  }));\n  return await singletonPromise;\n}\nexports.getQuickJS = getQuickJS;\n/**\n * Provides synchronous access to the shared {@link QuickJSWASMModule} instance returned by {@link getQuickJS}, as long as\n * least once.\n * @throws If called before `getQuickJS` resolves.\n */\nfunction getQuickJSSync() {\n  if (!singleton) {\n    throw new Error(\"QuickJS not initialized. Await getQuickJS() at least once.\");\n  }\n  return singleton;\n}\nexports.getQuickJSSync = getQuickJSSync;\n/**\n * Create a new [[QuickJSAsyncRuntime]] in a separate WebAssembly module.\n *\n * Each runtime is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nasync function newAsyncRuntime(options) {\n  const module = await (0, variants_1.newQuickJSAsyncWASMModule)();\n  return module.newRuntime(options);\n}\nexports.newAsyncRuntime = newAsyncRuntime;\n/**\n * Create a new [[QuickJSAsyncContext]] (with an associated runtime) in an\n * separate WebAssembly module.\n *\n * Each context is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nasync function newAsyncContext(options) {\n  const module = await (0, variants_1.newQuickJSAsyncWASMModule)();\n  return module.newContext(options);\n}\nexports.newAsyncContext = newAsyncContext;\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nfunction shouldInterruptAfterDeadline(deadline) {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime();\n  return function () {\n    return Date.now() > deadlineAsNumber;\n  };\n}\nexports.shouldInterruptAfterDeadline = shouldInterruptAfterDeadline;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAWEA;EAAAC;EAAAC;IAAA,OAVAC,+BAAoB;EAAA;AAAA;AAWpBH;EAAAC;EAAAC;IAAA,OAVAC,oCAAyB;EAAA;AAAA;AAWzBH;EAAAC;EAAAC;IAAA,OAVAC,sBAAW;EAAA;AAAA;AAWXH;EAAAC;EAAAC;IAAA,OAVAC,qBAAU;EAAA;AAAA;AAWVH;EAAAC;EAAAC;IAAA,OAVAC,wBAAa;EAAA;AAAA;AAWbH;EAAAC;EAAAC;IAAA,OAVAC,uBAAY;EAAA;AAAA;AAed;AACAC;AACAA;AACA;AACAC;AACAD;AACAA;AA0BA,IAAIE,SAAS,GAAkCC,SAAS;AACxD,IAAIC,gBAAgB,GAA2CD,SAAS;AAExE;;;;;;;;;;;;;;;AAeO,eAAeE,UAAU;EAC9BD,gBAAgB,KAAhBA,gBAAgB,GAAK,mCAAoB,GAAE,CAACE,IAAI,CAAEC,QAAQ,IAAI;IAC5DL,SAAS,GAAGK,QAAQ;IACpB,OAAOA,QAAQ;EACjB,CAAC,CAAC;EACF,OAAO,MAAMH,gBAAgB;AAC/B;AANAH;AAQA;;;;;AAKA,SAAgBO,cAAc;EAC5B,IAAI,CAACN,SAAS,EAAE;IACd,MAAM,IAAIO,KAAK,CAAC,4DAA4D,CAAC;;EAE/E,OAAOP,SAAS;AAClB;AALAD;AAOA;;;;;;;;;;;AAWO,eAAeS,eAAe,CAACC,OAA6B;EACjE,MAAMC,MAAM,GAAG,MAAM,wCAAyB,GAAE;EAChD,OAAOA,MAAM,CAACC,UAAU,CAACF,OAAO,CAAC;AACnC;AAHAV;AAKA;;;;;;;;;;;;AAYO,eAAea,eAAe,CAACH,OAAwB;EAC5D,MAAMC,MAAM,GAAG,MAAM,wCAAyB,GAAE;EAChD,OAAOA,MAAM,CAACG,UAAU,CAACJ,OAAO,CAAC;AACnC;AAHAV;AAKA;;;;;;AAMA,SAAgBe,4BAA4B,CAACC,QAAuB;EAClE,MAAMC,gBAAgB,GAAG,OAAOD,QAAQ,KAAK,QAAQ,GAAGA,QAAQ,GAAGA,QAAQ,CAACE,OAAO,EAAE;EAErF,OAAO;IACL,OAAOC,IAAI,CAACC,GAAG,EAAE,GAAGH,gBAAgB;EACtC,CAAC;AACH;AANAjB","names":["Object","enumerable","get","variants_1","__exportStar","exports","singleton","undefined","singletonPromise","getQuickJS","then","instance","getQuickJSSync","Error","newAsyncRuntime","options","module","newRuntime","newAsyncContext","newContext","shouldInterruptAfterDeadline","deadline","deadlineAsNumber","getTime","Date","now"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\index.ts"],"sourcesContent":["// Sync classes\nimport type { QuickJSWASMModule } from \"./module\"\nimport type { QuickJSRuntime, InterruptHandler } from \"./runtime\"\nimport type { QuickJSContext } from \"./context\"\nexport type { QuickJSWASMModule, QuickJSContext, QuickJSRuntime }\n\n// Async classes\nimport type { QuickJSAsyncWASMModule } from \"./module-asyncify\"\nimport type { QuickJSAsyncRuntime } from \"./runtime-asyncify\"\nimport type { QuickJSAsyncContext, AsyncFunctionImplementation } from \"./context-asyncify\"\nimport { AsyncRuntimeOptions, ContextOptions } from \"./types\"\nexport type {\n  QuickJSAsyncContext,\n  QuickJSAsyncRuntime,\n  QuickJSAsyncWASMModule,\n  AsyncFunctionImplementation,\n}\n\n// Build variants\nimport {\n  newQuickJSWASMModule,\n  newQuickJSAsyncWASMModule,\n  DEBUG_ASYNC,\n  DEBUG_SYNC,\n  RELEASE_ASYNC,\n  RELEASE_SYNC,\n  SyncBuildVariant,\n  AsyncBuildVariant,\n} from \"./variants\"\nexport {\n  newQuickJSWASMModule,\n  newQuickJSAsyncWASMModule,\n  DEBUG_ASYNC,\n  DEBUG_SYNC,\n  RELEASE_ASYNC,\n  RELEASE_SYNC,\n  SyncBuildVariant,\n  AsyncBuildVariant,\n}\n\n// Export helpers\nexport * from \"./vm-interface\"\nexport * from \"./lifetime\"\n/** Collects the informative errors this library may throw. */\nexport * as errors from \"./errors\"\nexport * from \"./deferred-promise\"\nexport * from \"./module-test\"\nexport type {\n  StaticJSValue,\n  JSValueConst,\n  JSValue,\n  QuickJSHandle,\n  ContextOptions,\n  ContextEvalOptions,\n  RuntimeOptions,\n  AsyncRuntimeOptions,\n  RuntimeOptionsBase,\n  JSModuleLoader,\n  JSModuleLoadResult,\n  JSModuleLoaderAsync,\n  JSModuleLoadSuccess,\n  JSModuleLoadFailure,\n  JSModuleNormalizer,\n  JSModuleNormalizerAsync,\n  JSModuleNormalizeResult,\n  JSModuleNormalizeFailure,\n  JSModuleNormalizeSuccess,\n} from \"./types\"\nexport type { ModuleEvalOptions } from \"./module\"\nexport type { InterruptHandler, ExecutePendingJobsResult } from \"./runtime\"\nexport type { QuickJSPropertyKey } from \"./context\"\n\nlet singleton: QuickJSWASMModule | undefined = undefined\nlet singletonPromise: Promise<QuickJSWASMModule> | undefined = undefined\n\n/**\n * Get a shared singleton {@link QuickJSWASMModule}. Use this to evaluate code\n * or create Javascript environments.\n *\n * This is the top-level entrypoint for the quickjs-emscripten library.\n *\n * If you need strictest possible isolation guarantees, you may create a\n * separate {@link QuickJSWASMModule} via {@link newQuickJSWASMModule}.\n *\n * To work with the asyncified version of this library, see these functions:\n *\n * - {@link newAsyncRuntime}.\n * - {@link newAsyncContext}.\n * - {@link newQuickJSAsyncWASMModule}.\n */\nexport async function getQuickJS(): Promise<QuickJSWASMModule> {\n  singletonPromise ??= newQuickJSWASMModule().then((instance) => {\n    singleton = instance\n    return instance\n  })\n  return await singletonPromise\n}\n\n/**\n * Provides synchronous access to the shared {@link QuickJSWASMModule} instance returned by {@link getQuickJS}, as long as\n * least once.\n * @throws If called before `getQuickJS` resolves.\n */\nexport function getQuickJSSync(): QuickJSWASMModule {\n  if (!singleton) {\n    throw new Error(\"QuickJS not initialized. Await getQuickJS() at least once.\")\n  }\n  return singleton\n}\n\n/**\n * Create a new [[QuickJSAsyncRuntime]] in a separate WebAssembly module.\n *\n * Each runtime is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncRuntime(options?: AsyncRuntimeOptions): Promise<QuickJSAsyncRuntime> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newRuntime(options)\n}\n\n/**\n * Create a new [[QuickJSAsyncContext]] (with an associated runtime) in an\n * separate WebAssembly module.\n *\n * Each context is isolated in a separate WebAssembly module, so that errors in\n * one runtime cannot contaminate another runtime, and each runtime can execute\n * an asynchronous action without conflicts.\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newAsyncContext(options?: ContextOptions): Promise<QuickJSAsyncContext> {\n  const module = await newQuickJSAsyncWASMModule()\n  return module.newContext(options)\n}\n\n/**\n * Returns an interrupt handler that interrupts Javascript execution after a deadline time.\n *\n * @param deadline - Interrupt execution if it's still running after this time.\n *   Number values are compared against `Date.now()`\n */\nexport function shouldInterruptAfterDeadline(deadline: Date | number): InterruptHandler {\n  const deadlineAsNumber = typeof deadline === \"number\" ? deadline : deadline.getTime()\n\n  return function () {\n    return Date.now() > deadlineAsNumber\n  }\n}\n"]},"metadata":{},"sourceType":"script"}