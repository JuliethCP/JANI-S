{"ast":null,"code":"\"use strict\";\n\n;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar node_path_1 = tslib_1.__importDefault(require(\"./node-path\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction pathVisitorPlugin(fork) {\n  var types = fork.use(types_1.default);\n  var NodePath = fork.use(node_path_1.default);\n  var isArray = types.builtInTypes.array;\n  var isObject = types.builtInTypes.object;\n  var isFunction = types.builtInTypes.function;\n  var undefined;\n  var PathVisitor = function PathVisitor() {\n    if (!(this instanceof PathVisitor)) {\n      throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n    }\n    // Permanent state.\n    this._reusableContextStack = [];\n    this._methodNameTable = computeMethodNameTable(this);\n    this._shouldVisitComments = hasOwn.call(this._methodNameTable, \"Block\") || hasOwn.call(this._methodNameTable, \"Line\");\n    this.Context = makeContextConstructor(this);\n    // State reset every time PathVisitor.prototype.visit is called.\n    this._visiting = false;\n    this._changeReported = false;\n  };\n  function computeMethodNameTable(visitor) {\n    var typeNames = Object.create(null);\n    for (var methodName in visitor) {\n      if (/^visit[A-Z]/.test(methodName)) {\n        typeNames[methodName.slice(\"visit\".length)] = true;\n      }\n    }\n    var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n    var methodNameTable = Object.create(null);\n    var typeNameKeys = Object.keys(supertypeTable);\n    var typeNameCount = typeNameKeys.length;\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNameKeys[i];\n      methodName = \"visit\" + supertypeTable[typeName];\n      if (isFunction.check(visitor[methodName])) {\n        methodNameTable[typeName] = methodName;\n      }\n    }\n    return methodNameTable;\n  }\n  PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n    if (methods instanceof PathVisitor) {\n      return methods;\n    }\n    if (!isObject.check(methods)) {\n      // An empty visitor?\n      return new PathVisitor();\n    }\n    var Visitor = function Visitor() {\n      if (!(this instanceof Visitor)) {\n        throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n      }\n      PathVisitor.call(this);\n    };\n    var Vp = Visitor.prototype = Object.create(PVp);\n    Vp.constructor = Visitor;\n    extend(Vp, methods);\n    extend(Visitor, PathVisitor);\n    isFunction.assert(Visitor.fromMethodsObject);\n    isFunction.assert(Visitor.visit);\n    return new Visitor();\n  };\n  function extend(target, source) {\n    for (var property in source) {\n      if (hasOwn.call(source, property)) {\n        target[property] = source[property];\n      }\n    }\n    return target;\n  }\n  PathVisitor.visit = function visit(node, methods) {\n    return PathVisitor.fromMethodsObject(methods).visit(node);\n  };\n  var PVp = PathVisitor.prototype;\n  PVp.visit = function () {\n    if (this._visiting) {\n      throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" + \"Try this.visit(path) or this.traverse(path) instead.\");\n    }\n    // Private state that needs to be reset before every traversal.\n    this._visiting = true;\n    this._changeReported = false;\n    this._abortRequested = false;\n    var argc = arguments.length;\n    var args = new Array(argc);\n    for (var i = 0; i < argc; ++i) {\n      args[i] = arguments[i];\n    }\n    if (!(args[0] instanceof NodePath)) {\n      args[0] = new NodePath({\n        root: args[0]\n      }).get(\"root\");\n    }\n    // Called with the same arguments as .visit.\n    this.reset.apply(this, args);\n    var didNotThrow;\n    try {\n      var root = this.visitWithoutReset(args[0]);\n      didNotThrow = true;\n    } finally {\n      this._visiting = false;\n      if (!didNotThrow && this._abortRequested) {\n        // If this.visitWithoutReset threw an exception and\n        // this._abortRequested was set to true, return the root of\n        // the AST instead of letting the exception propagate, so that\n        // client code does not have to provide a try-catch block to\n        // intercept the AbortRequest exception.  Other kinds of\n        // exceptions will propagate without being intercepted and\n        // rethrown by a catch block, so their stacks will accurately\n        // reflect the original throwing context.\n        return args[0].value;\n      }\n    }\n    return root;\n  };\n  PVp.AbortRequest = function AbortRequest() {};\n  PVp.abort = function () {\n    var visitor = this;\n    visitor._abortRequested = true;\n    var request = new visitor.AbortRequest();\n    // If you decide to catch this exception and stop it from propagating,\n    // make sure to call its cancel method to avoid silencing other\n    // exceptions that might be thrown later in the traversal.\n    request.cancel = function () {\n      visitor._abortRequested = false;\n    };\n    throw request;\n  };\n  PVp.reset = function (_path /*, additional arguments */) {\n    // Empty stub; may be reassigned or overridden by subclasses.\n  };\n  PVp.visitWithoutReset = function (path) {\n    if (this instanceof this.Context) {\n      // Since this.Context.prototype === this, there's a chance we\n      // might accidentally call context.visitWithoutReset. If that\n      // happens, re-invoke the method against context.visitor.\n      return this.visitor.visitWithoutReset(path);\n    }\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    var value = path.value;\n    var methodName = value && typeof value === \"object\" && typeof value.type === \"string\" && this._methodNameTable[value.type];\n    if (methodName) {\n      var context = this.acquireContext(path);\n      try {\n        return context.invokeVisitorMethod(methodName);\n      } finally {\n        this.releaseContext(context);\n      }\n    } else {\n      // If there was no visitor method to call, visit the children of\n      // this node generically.\n      return visitChildren(path, this);\n    }\n  };\n  function visitChildren(path, visitor) {\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n    var value = path.value;\n    if (isArray.check(value)) {\n      path.each(visitor.visitWithoutReset, visitor);\n    } else if (!isObject.check(value)) {\n      // No children to visit.\n    } else {\n      var childNames = types.getFieldNames(value);\n      // The .comments field of the Node type is hidden, so we only\n      // visit it if the visitor defines visitBlock or visitLine, and\n      // value.comments is defined.\n      if (visitor._shouldVisitComments && value.comments && childNames.indexOf(\"comments\") < 0) {\n        childNames.push(\"comments\");\n      }\n      var childCount = childNames.length;\n      var childPaths = [];\n      for (var i = 0; i < childCount; ++i) {\n        var childName = childNames[i];\n        if (!hasOwn.call(value, childName)) {\n          value[childName] = types.getFieldValue(value, childName);\n        }\n        childPaths.push(path.get(childName));\n      }\n      for (var i = 0; i < childCount; ++i) {\n        visitor.visitWithoutReset(childPaths[i]);\n      }\n    }\n    return path.value;\n  }\n  PVp.acquireContext = function (path) {\n    if (this._reusableContextStack.length === 0) {\n      return new this.Context(path);\n    }\n    return this._reusableContextStack.pop().reset(path);\n  };\n  PVp.releaseContext = function (context) {\n    if (!(context instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    this._reusableContextStack.push(context);\n    context.currentPath = null;\n  };\n  PVp.reportChanged = function () {\n    this._changeReported = true;\n  };\n  PVp.wasChangeReported = function () {\n    return this._changeReported;\n  };\n  function makeContextConstructor(visitor) {\n    function Context(path) {\n      if (!(this instanceof Context)) {\n        throw new Error(\"\");\n      }\n      if (!(this instanceof PathVisitor)) {\n        throw new Error(\"\");\n      }\n      if (!(path instanceof NodePath)) {\n        throw new Error(\"\");\n      }\n      Object.defineProperty(this, \"visitor\", {\n        value: visitor,\n        writable: false,\n        enumerable: true,\n        configurable: false\n      });\n      this.currentPath = path;\n      this.needToCallTraverse = true;\n      Object.seal(this);\n    }\n    if (!(visitor instanceof PathVisitor)) {\n      throw new Error(\"\");\n    }\n    // Note that the visitor object is the prototype of Context.prototype,\n    // so all visitor methods are inherited by context objects.\n    var Cp = Context.prototype = Object.create(visitor);\n    Cp.constructor = Context;\n    extend(Cp, sharedContextProtoMethods);\n    return Context;\n  }\n  // Every PathVisitor has a different this.Context constructor and\n  // this.Context.prototype object, but those prototypes can all use the\n  // same reset, invokeVisitorMethod, and traverse function objects.\n  var sharedContextProtoMethods = Object.create(null);\n  sharedContextProtoMethods.reset = function reset(path) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    this.currentPath = path;\n    this.needToCallTraverse = true;\n    return this;\n  };\n  sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    var result = this.visitor[methodName].call(this, this.currentPath);\n    if (result === false) {\n      // Visitor methods return false to indicate that they have handled\n      // their own traversal needs, and we should not complain if\n      // this.needToCallTraverse is still true.\n      this.needToCallTraverse = false;\n    } else if (result !== undefined) {\n      // Any other non-undefined value returned from the visitor method\n      // is interpreted as a replacement value.\n      this.currentPath = this.currentPath.replace(result)[0];\n      if (this.needToCallTraverse) {\n        // If this.traverse still hasn't been called, visit the\n        // children of the replacement node.\n        this.traverse(this.currentPath);\n      }\n    }\n    if (this.needToCallTraverse !== false) {\n      throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n    }\n    var path = this.currentPath;\n    return path && path.value;\n  };\n  sharedContextProtoMethods.traverse = function traverse(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    this.needToCallTraverse = false;\n    return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n  };\n  sharedContextProtoMethods.visit = function visit(path, newVisitor) {\n    if (!(this instanceof this.Context)) {\n      throw new Error(\"\");\n    }\n    if (!(path instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    if (!(this.currentPath instanceof NodePath)) {\n      throw new Error(\"\");\n    }\n    this.needToCallTraverse = false;\n    return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n  };\n  sharedContextProtoMethods.reportChanged = function reportChanged() {\n    this.visitor.reportChanged();\n  };\n  sharedContextProtoMethods.abort = function abort() {\n    this.needToCallTraverse = false;\n    this.visitor.abort();\n  };\n  return PathVisitor;\n}\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];","map":{"version":3,"names":["Object","defineProperty","exports","value","tslib_1","require","types_1","__importDefault","node_path_1","hasOwn","prototype","hasOwnProperty","pathVisitorPlugin","fork","types","use","default","NodePath","isArray","builtInTypes","array","isObject","object","isFunction","function","undefined","PathVisitor","Error","_reusableContextStack","_methodNameTable","computeMethodNameTable","_shouldVisitComments","call","Context","makeContextConstructor","_visiting","_changeReported","visitor","typeNames","create","methodName","test","slice","length","supertypeTable","computeSupertypeLookupTable","methodNameTable","typeNameKeys","keys","typeNameCount","i","typeName","check","fromMethodsObject","methods","Visitor","Vp","PVp","constructor","extend","assert","visit","target","source","property","node","_abortRequested","argc","arguments","args","Array","root","get","reset","apply","didNotThrow","visitWithoutReset","AbortRequest","abort","request","cancel","_path","path","type","context","acquireContext","invokeVisitorMethod","releaseContext","visitChildren","each","childNames","getFieldNames","comments","indexOf","push","childCount","childPaths","childName","getFieldValue","pop","currentPath","reportChanged","wasChangeReported","writable","enumerable","configurable","needToCallTraverse","seal","Cp","sharedContextProtoMethods","result","replace","traverse","newVisitor","module"],"sources":["D:/Julieth-Campos/PSO/node_modules/ast-types/lib/path-visitor.js"],"sourcesContent":["\"use strict\";;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = require(\"tslib\");\nvar types_1 = tslib_1.__importDefault(require(\"./types\"));\nvar node_path_1 = tslib_1.__importDefault(require(\"./node-path\"));\nvar hasOwn = Object.prototype.hasOwnProperty;\nfunction pathVisitorPlugin(fork) {\n    var types = fork.use(types_1.default);\n    var NodePath = fork.use(node_path_1.default);\n    var isArray = types.builtInTypes.array;\n    var isObject = types.builtInTypes.object;\n    var isFunction = types.builtInTypes.function;\n    var undefined;\n    var PathVisitor = function PathVisitor() {\n        if (!(this instanceof PathVisitor)) {\n            throw new Error(\"PathVisitor constructor cannot be invoked without 'new'\");\n        }\n        // Permanent state.\n        this._reusableContextStack = [];\n        this._methodNameTable = computeMethodNameTable(this);\n        this._shouldVisitComments =\n            hasOwn.call(this._methodNameTable, \"Block\") ||\n                hasOwn.call(this._methodNameTable, \"Line\");\n        this.Context = makeContextConstructor(this);\n        // State reset every time PathVisitor.prototype.visit is called.\n        this._visiting = false;\n        this._changeReported = false;\n    };\n    function computeMethodNameTable(visitor) {\n        var typeNames = Object.create(null);\n        for (var methodName in visitor) {\n            if (/^visit[A-Z]/.test(methodName)) {\n                typeNames[methodName.slice(\"visit\".length)] = true;\n            }\n        }\n        var supertypeTable = types.computeSupertypeLookupTable(typeNames);\n        var methodNameTable = Object.create(null);\n        var typeNameKeys = Object.keys(supertypeTable);\n        var typeNameCount = typeNameKeys.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNameKeys[i];\n            methodName = \"visit\" + supertypeTable[typeName];\n            if (isFunction.check(visitor[methodName])) {\n                methodNameTable[typeName] = methodName;\n            }\n        }\n        return methodNameTable;\n    }\n    PathVisitor.fromMethodsObject = function fromMethodsObject(methods) {\n        if (methods instanceof PathVisitor) {\n            return methods;\n        }\n        if (!isObject.check(methods)) {\n            // An empty visitor?\n            return new PathVisitor;\n        }\n        var Visitor = function Visitor() {\n            if (!(this instanceof Visitor)) {\n                throw new Error(\"Visitor constructor cannot be invoked without 'new'\");\n            }\n            PathVisitor.call(this);\n        };\n        var Vp = Visitor.prototype = Object.create(PVp);\n        Vp.constructor = Visitor;\n        extend(Vp, methods);\n        extend(Visitor, PathVisitor);\n        isFunction.assert(Visitor.fromMethodsObject);\n        isFunction.assert(Visitor.visit);\n        return new Visitor;\n    };\n    function extend(target, source) {\n        for (var property in source) {\n            if (hasOwn.call(source, property)) {\n                target[property] = source[property];\n            }\n        }\n        return target;\n    }\n    PathVisitor.visit = function visit(node, methods) {\n        return PathVisitor.fromMethodsObject(methods).visit(node);\n    };\n    var PVp = PathVisitor.prototype;\n    PVp.visit = function () {\n        if (this._visiting) {\n            throw new Error(\"Recursively calling visitor.visit(path) resets visitor state. \" +\n                \"Try this.visit(path) or this.traverse(path) instead.\");\n        }\n        // Private state that needs to be reset before every traversal.\n        this._visiting = true;\n        this._changeReported = false;\n        this._abortRequested = false;\n        var argc = arguments.length;\n        var args = new Array(argc);\n        for (var i = 0; i < argc; ++i) {\n            args[i] = arguments[i];\n        }\n        if (!(args[0] instanceof NodePath)) {\n            args[0] = new NodePath({ root: args[0] }).get(\"root\");\n        }\n        // Called with the same arguments as .visit.\n        this.reset.apply(this, args);\n        var didNotThrow;\n        try {\n            var root = this.visitWithoutReset(args[0]);\n            didNotThrow = true;\n        }\n        finally {\n            this._visiting = false;\n            if (!didNotThrow && this._abortRequested) {\n                // If this.visitWithoutReset threw an exception and\n                // this._abortRequested was set to true, return the root of\n                // the AST instead of letting the exception propagate, so that\n                // client code does not have to provide a try-catch block to\n                // intercept the AbortRequest exception.  Other kinds of\n                // exceptions will propagate without being intercepted and\n                // rethrown by a catch block, so their stacks will accurately\n                // reflect the original throwing context.\n                return args[0].value;\n            }\n        }\n        return root;\n    };\n    PVp.AbortRequest = function AbortRequest() { };\n    PVp.abort = function () {\n        var visitor = this;\n        visitor._abortRequested = true;\n        var request = new visitor.AbortRequest();\n        // If you decide to catch this exception and stop it from propagating,\n        // make sure to call its cancel method to avoid silencing other\n        // exceptions that might be thrown later in the traversal.\n        request.cancel = function () {\n            visitor._abortRequested = false;\n        };\n        throw request;\n    };\n    PVp.reset = function (_path /*, additional arguments */) {\n        // Empty stub; may be reassigned or overridden by subclasses.\n    };\n    PVp.visitWithoutReset = function (path) {\n        if (this instanceof this.Context) {\n            // Since this.Context.prototype === this, there's a chance we\n            // might accidentally call context.visitWithoutReset. If that\n            // happens, re-invoke the method against context.visitor.\n            return this.visitor.visitWithoutReset(path);\n        }\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        var value = path.value;\n        var methodName = value &&\n            typeof value === \"object\" &&\n            typeof value.type === \"string\" &&\n            this._methodNameTable[value.type];\n        if (methodName) {\n            var context = this.acquireContext(path);\n            try {\n                return context.invokeVisitorMethod(methodName);\n            }\n            finally {\n                this.releaseContext(context);\n            }\n        }\n        else {\n            // If there was no visitor method to call, visit the children of\n            // this node generically.\n            return visitChildren(path, this);\n        }\n    };\n    function visitChildren(path, visitor) {\n        if (!(path instanceof NodePath)) {\n            throw new Error(\"\");\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n        var value = path.value;\n        if (isArray.check(value)) {\n            path.each(visitor.visitWithoutReset, visitor);\n        }\n        else if (!isObject.check(value)) {\n            // No children to visit.\n        }\n        else {\n            var childNames = types.getFieldNames(value);\n            // The .comments field of the Node type is hidden, so we only\n            // visit it if the visitor defines visitBlock or visitLine, and\n            // value.comments is defined.\n            if (visitor._shouldVisitComments &&\n                value.comments &&\n                childNames.indexOf(\"comments\") < 0) {\n                childNames.push(\"comments\");\n            }\n            var childCount = childNames.length;\n            var childPaths = [];\n            for (var i = 0; i < childCount; ++i) {\n                var childName = childNames[i];\n                if (!hasOwn.call(value, childName)) {\n                    value[childName] = types.getFieldValue(value, childName);\n                }\n                childPaths.push(path.get(childName));\n            }\n            for (var i = 0; i < childCount; ++i) {\n                visitor.visitWithoutReset(childPaths[i]);\n            }\n        }\n        return path.value;\n    }\n    PVp.acquireContext = function (path) {\n        if (this._reusableContextStack.length === 0) {\n            return new this.Context(path);\n        }\n        return this._reusableContextStack.pop().reset(path);\n    };\n    PVp.releaseContext = function (context) {\n        if (!(context instanceof this.Context)) {\n            throw new Error(\"\");\n        }\n        this._reusableContextStack.push(context);\n        context.currentPath = null;\n    };\n    PVp.reportChanged = function () {\n        this._changeReported = true;\n    };\n    PVp.wasChangeReported = function () {\n        return this._changeReported;\n    };\n    function makeContextConstructor(visitor) {\n        function Context(path) {\n            if (!(this instanceof Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this instanceof PathVisitor)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            Object.defineProperty(this, \"visitor\", {\n                value: visitor,\n                writable: false,\n                enumerable: true,\n                configurable: false\n            });\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            Object.seal(this);\n        }\n        if (!(visitor instanceof PathVisitor)) {\n            throw new Error(\"\");\n        }\n        // Note that the visitor object is the prototype of Context.prototype,\n        // so all visitor methods are inherited by context objects.\n        var Cp = Context.prototype = Object.create(visitor);\n        Cp.constructor = Context;\n        extend(Cp, sharedContextProtoMethods);\n        return Context;\n    }\n    // Every PathVisitor has a different this.Context constructor and\n    // this.Context.prototype object, but those prototypes can all use the\n    // same reset, invokeVisitorMethod, and traverse function objects.\n    var sharedContextProtoMethods = Object.create(null);\n    sharedContextProtoMethods.reset =\n        function reset(path) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.currentPath = path;\n            this.needToCallTraverse = true;\n            return this;\n        };\n    sharedContextProtoMethods.invokeVisitorMethod =\n        function invokeVisitorMethod(methodName) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            var result = this.visitor[methodName].call(this, this.currentPath);\n            if (result === false) {\n                // Visitor methods return false to indicate that they have handled\n                // their own traversal needs, and we should not complain if\n                // this.needToCallTraverse is still true.\n                this.needToCallTraverse = false;\n            }\n            else if (result !== undefined) {\n                // Any other non-undefined value returned from the visitor method\n                // is interpreted as a replacement value.\n                this.currentPath = this.currentPath.replace(result)[0];\n                if (this.needToCallTraverse) {\n                    // If this.traverse still hasn't been called, visit the\n                    // children of the replacement node.\n                    this.traverse(this.currentPath);\n                }\n            }\n            if (this.needToCallTraverse !== false) {\n                throw new Error(\"Must either call this.traverse or return false in \" + methodName);\n            }\n            var path = this.currentPath;\n            return path && path.value;\n        };\n    sharedContextProtoMethods.traverse =\n        function traverse(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.needToCallTraverse = false;\n            return visitChildren(path, PathVisitor.fromMethodsObject(newVisitor || this.visitor));\n        };\n    sharedContextProtoMethods.visit =\n        function visit(path, newVisitor) {\n            if (!(this instanceof this.Context)) {\n                throw new Error(\"\");\n            }\n            if (!(path instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            if (!(this.currentPath instanceof NodePath)) {\n                throw new Error(\"\");\n            }\n            this.needToCallTraverse = false;\n            return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path);\n        };\n    sharedContextProtoMethods.reportChanged = function reportChanged() {\n        this.visitor.reportChanged();\n    };\n    sharedContextProtoMethods.abort = function abort() {\n        this.needToCallTraverse = false;\n        this.visitor.abort();\n    };\n    return PathVisitor;\n}\nexports.default = pathVisitorPlugin;\nmodule.exports = exports[\"default\"];\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}