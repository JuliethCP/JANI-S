{"ast":null,"code":"import { EventEmitter } from '../common/EventEmitter.js';\nimport { TimeoutSettings } from '../common/TimeoutSettings.js';\nimport { debugError, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { ExecutionContext } from './ExecutionContext.js';\nimport { IsolatedWorld } from './IsolatedWorld.js';\nimport { CdpJSHandle } from './JSHandle.js';\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport class WebWorker extends EventEmitter {\n  /**\n   * @internal\n   */\n  timeoutSettings = new TimeoutSettings();\n  #world;\n  #client;\n  #url;\n  /**\n   * @internal\n   */\n  constructor(client, url, consoleAPICalled, exceptionThrown) {\n    super();\n    this.#client = client;\n    this.#url = url;\n    this.#world = new IsolatedWorld(this, new TimeoutSettings());\n    this.#client.once('Runtime.executionContextCreated', async event => {\n      this.#world.setContext(new ExecutionContext(client, event.context, this.#world));\n    });\n    this.#client.on('Runtime.consoleAPICalled', async event => {\n      try {\n        return consoleAPICalled(event.type, event.args.map(object => {\n          return new CdpJSHandle(this.#world, object);\n        }), event.stackTrace);\n      } catch (err) {\n        debugError(err);\n      }\n    });\n    this.#client.on('Runtime.exceptionThrown', exceptionThrown);\n    // This might fail if the target is closed before we receive all execution contexts.\n    this.#client.send('Runtime.enable').catch(debugError);\n  }\n  /**\n   * @internal\n   */\n  mainRealm() {\n    return this.#world;\n  }\n  /**\n   * The URL of this web worker.\n   */\n  url() {\n    return this.#url;\n  }\n  /**\n   * The CDP session client the WebWorker belongs to.\n   */\n  get client() {\n    return this.#client;\n  }\n  /**\n   * If the function passed to the `worker.evaluate` returns a Promise, then\n   * `worker.evaluate` would wait for the promise to resolve and return its\n   * value. If the function passed to the `worker.evaluate` returns a\n   * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n   * DevTools Protocol also supports transferring some additional values that\n   * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n   * bigint literals.\n   * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n   *\n   * @param pageFunction - Function to be evaluated in the worker context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluate(pageFunction) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n    return await this.mainRealm().evaluate(pageFunction, ...args);\n  }\n  /**\n   * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n   * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n   * function passed to the `worker.evaluateHandle` returns a `Promise`, then\n   * `worker.evaluateHandle` would wait for the promise to resolve and return\n   * its value. Shortcut for\n   * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n   *\n   * @param pageFunction - Function to be evaluated in the page context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluateHandle(pageFunction) {\n    pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n    return await this.mainRealm().evaluateHandle(pageFunction, ...args);\n  }\n}","map":{"version":3,"mappings":"AAoBA,SAAQA,YAAY,QAAuB,2BAA2B;AACtE,SAAQC,eAAe,QAAO,8BAA8B;AAE5D,SAAQC,UAAU,EAAEC,4BAA4B,QAAO,mBAAmB;AAE1E,SAAQC,gBAAgB,QAAO,uBAAuB;AACtD,SAAQC,aAAa,QAAO,oBAAoB;AAChD,SAAQC,WAAW,QAAO,eAAe;AAkBzC;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA,OAAM,MAAOC,SAAU,SAAQP,YAAwC;EACrE;;;EAGSQ,eAAe,GAAG,IAAIP,eAAe,EAAE;EAEhD,MAAM;EACN,OAAO;EACP,IAAI;EAEJ;;;EAGAQ,YACEC,MAAkB,EAClBC,GAAW,EACXC,gBAA0C,EAC1CC,eAAwC;IAExC,KAAK,EAAE;IACP,IAAI,CAAC,OAAO,GAAGH,MAAM;IACrB,IAAI,CAAC,IAAI,GAAGC,GAAG;IACf,IAAI,CAAC,MAAM,GAAG,IAAIN,aAAa,CAAC,IAAI,EAAE,IAAIJ,eAAe,EAAE,CAAC;IAE5D,IAAI,CAAC,OAAO,CAACa,IAAI,CAAC,iCAAiC,EAAE,MAAMC,KAAK,IAAG;MACjE,IAAI,CAAC,MAAM,CAACC,UAAU,CACpB,IAAIZ,gBAAgB,CAACM,MAAM,EAAEK,KAAK,CAACE,OAAO,EAAE,IAAI,CAAC,MAAM,CAAC,CACzD;IACH,CAAC,CAAC;IACF,IAAI,CAAC,OAAO,CAACC,EAAE,CAAC,0BAA0B,EAAE,MAAMH,KAAK,IAAG;MACxD,IAAI;QACF,OAAOH,gBAAgB,CACrBG,KAAK,CAACI,IAAI,EACVJ,KAAK,CAACK,IAAI,CAACC,GAAG,CAAEC,MAAqC,IAAI;UACvD,OAAO,IAAIhB,WAAW,CAAC,IAAI,CAAC,MAAM,EAAEgB,MAAM,CAAC;QAC7C,CAAC,CAAC,EACFP,KAAK,CAACQ,UAAU,CACjB;OACF,CAAC,OAAOC,GAAG,EAAE;QACZtB,UAAU,CAACsB,GAAG,CAAC;;IAEnB,CAAC,CAAC;IACF,IAAI,CAAC,OAAO,CAACN,EAAE,CAAC,yBAAyB,EAAEL,eAAe,CAAC;IAE3D;IACA,IAAI,CAAC,OAAO,CAACY,IAAI,CAAC,gBAAgB,CAAC,CAACC,KAAK,CAACxB,UAAU,CAAC;EACvD;EAEA;;;EAGAyB,SAAS;IACP,OAAO,IAAI,CAAC,MAAM;EACpB;EAEA;;;EAGAhB,GAAG;IACD,OAAO,IAAI,CAAC,IAAI;EAClB;EAEA;;;EAGA,IAAID,MAAM;IACR,OAAO,IAAI,CAAC,OAAO;EACrB;EAEA;;;;;;;;;;;;;;EAcA,MAAMkB,QAAQ,CAIZC,YAA2B,EACZ;IAEfA,YAAY,GAAG1B,4BAA4B,CACzC,IAAI,CAACyB,QAAQ,CAACE,IAAI,EAClBD,YAAY,CACb;IAAC,kCALCT,IAAY;MAAZA,IAAY;IAAA;IAMf,OAAO,MAAM,IAAI,CAACO,SAAS,EAAE,CAACC,QAAQ,CAACC,YAAY,EAAE,GAAGT,IAAI,CAAC;EAC/D;EAEA;;;;;;;;;;;;EAYA,MAAMW,cAAc,CAIlBF,YAA2B,EACZ;IAEfA,YAAY,GAAG1B,4BAA4B,CACzC,IAAI,CAAC4B,cAAc,CAACD,IAAI,EACxBD,YAAY,CACb;IAAC,mCALCT,IAAY;MAAZA,IAAY;IAAA;IAMf,OAAO,MAAM,IAAI,CAACO,SAAS,EAAE,CAACI,cAAc,CAACF,YAAY,EAAE,GAAGT,IAAI,CAAC;EACrE","names":["EventEmitter","TimeoutSettings","debugError","withSourcePuppeteerURLIfNone","ExecutionContext","IsolatedWorld","CdpJSHandle","WebWorker","timeoutSettings","constructor","client","url","consoleAPICalled","exceptionThrown","once","event","setContext","context","on","type","args","map","object","stackTrace","err","send","catch","mainRealm","evaluate","pageFunction","name","evaluateHandle"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\WebWorker.ts"],"sourcesContent":["/**\n * Copyright 2018 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Realm} from '../api/Realm.js';\nimport type {ConsoleMessageType} from '../common/ConsoleMessage.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport type {EvaluateFunc, HandleFor} from '../common/types.js';\nimport {debugError, withSourcePuppeteerURLIfNone} from '../common/util.js';\n\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {IsolatedWorld} from './IsolatedWorld.js';\nimport {CdpJSHandle} from './JSHandle.js';\n\n/**\n * @internal\n */\nexport type ConsoleAPICalledCallback = (\n  eventType: ConsoleMessageType,\n  handles: CdpJSHandle[],\n  trace?: Protocol.Runtime.StackTrace\n) => void;\n\n/**\n * @internal\n */\nexport type ExceptionThrownCallback = (\n  event: Protocol.Runtime.ExceptionThrownEvent\n) => void;\n\n/**\n * This class represents a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API | WebWorker}.\n *\n * @remarks\n * The events `workercreated` and `workerdestroyed` are emitted on the page\n * object to signal the worker lifecycle.\n *\n * @example\n *\n * ```ts\n * page.on('workercreated', worker =>\n *   console.log('Worker created: ' + worker.url())\n * );\n * page.on('workerdestroyed', worker =>\n *   console.log('Worker destroyed: ' + worker.url())\n * );\n *\n * console.log('Current workers:');\n * for (const worker of page.workers()) {\n *   console.log('  ' + worker.url());\n * }\n * ```\n *\n * @public\n */\nexport class WebWorker extends EventEmitter<Record<EventType, unknown>> {\n  /**\n   * @internal\n   */\n  readonly timeoutSettings = new TimeoutSettings();\n\n  #world: IsolatedWorld;\n  #client: CDPSession;\n  #url: string;\n\n  /**\n   * @internal\n   */\n  constructor(\n    client: CDPSession,\n    url: string,\n    consoleAPICalled: ConsoleAPICalledCallback,\n    exceptionThrown: ExceptionThrownCallback\n  ) {\n    super();\n    this.#client = client;\n    this.#url = url;\n    this.#world = new IsolatedWorld(this, new TimeoutSettings());\n\n    this.#client.once('Runtime.executionContextCreated', async event => {\n      this.#world.setContext(\n        new ExecutionContext(client, event.context, this.#world)\n      );\n    });\n    this.#client.on('Runtime.consoleAPICalled', async event => {\n      try {\n        return consoleAPICalled(\n          event.type,\n          event.args.map((object: Protocol.Runtime.RemoteObject) => {\n            return new CdpJSHandle(this.#world, object);\n          }),\n          event.stackTrace\n        );\n      } catch (err) {\n        debugError(err);\n      }\n    });\n    this.#client.on('Runtime.exceptionThrown', exceptionThrown);\n\n    // This might fail if the target is closed before we receive all execution contexts.\n    this.#client.send('Runtime.enable').catch(debugError);\n  }\n\n  /**\n   * @internal\n   */\n  mainRealm(): Realm {\n    return this.#world;\n  }\n\n  /**\n   * The URL of this web worker.\n   */\n  url(): string {\n    return this.#url;\n  }\n\n  /**\n   * The CDP session client the WebWorker belongs to.\n   */\n  get client(): CDPSession {\n    return this.#client;\n  }\n\n  /**\n   * If the function passed to the `worker.evaluate` returns a Promise, then\n   * `worker.evaluate` would wait for the promise to resolve and return its\n   * value. If the function passed to the `worker.evaluate` returns a\n   * non-serializable value, then `worker.evaluate` resolves to `undefined`.\n   * DevTools Protocol also supports transferring some additional values that\n   * are not serializable by `JSON`: `-0`, `NaN`, `Infinity`, `-Infinity`, and\n   * bigint literals.\n   * Shortcut for `await worker.executionContext()).evaluate(pageFunction, ...args)`.\n   *\n   * @param pageFunction - Function to be evaluated in the worker context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.mainRealm().evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * The only difference between `worker.evaluate` and `worker.evaluateHandle`\n   * is that `worker.evaluateHandle` returns in-page object (JSHandle). If the\n   * function passed to the `worker.evaluateHandle` returns a `Promise`, then\n   * `worker.evaluateHandle` would wait for the promise to resolve and return\n   * its value. Shortcut for\n   * `await worker.executionContext()).evaluateHandle(pageFunction, ...args)`\n   *\n   * @param pageFunction - Function to be evaluated in the page context.\n   * @param args - Arguments to pass to `pageFunction`.\n   * @returns Promise which resolves to the return value of `pageFunction`.\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFunc<Params> = EvaluateFunc<Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.mainRealm().evaluateHandle(pageFunction, ...args);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}