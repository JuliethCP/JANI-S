{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n    desc = {\n      enumerable: true,\n      get: function () {\n        return m[k];\n      }\n    };\n  }\n  Object.defineProperty(o, k2, desc);\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  __setModuleDefault(result, mod);\n  return result;\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RELEASE_ASYNC = exports.DEBUG_ASYNC = exports.RELEASE_SYNC = exports.DEBUG_SYNC = exports.memoizePromiseFactory = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;\nconst esmHelpers_1 = require(\"./esmHelpers\");\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on [[QuickJSWASMModule]].\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nasync function newQuickJSWASMModule() {\n  let variant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.RELEASE_SYNC;\n  const [wasmModuleLoader, QuickJSFFI, {\n    QuickJSWASMModule\n  }] = await Promise.all([variant.importModuleLoader(), variant.importFFI(), Promise.resolve().then(() => __importStar(require(\"./module.js\"))).then(esmHelpers_1.unwrapTypescript)]);\n  const wasmModule = await wasmModuleLoader();\n  wasmModule.type = \"sync\";\n  const ffi = new QuickJSFFI(wasmModule);\n  return new QuickJSWASMModule(wasmModule, ffi);\n}\nexports.newQuickJSWASMModule = newQuickJSWASMModule;\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on [[QuickJSAsyncWASMModule]], [[QuickJSAsyncRuntime]],\n * and [[QuickJSAsyncContext]].\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nasync function newQuickJSAsyncWASMModule() {\n  let variant = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : exports.RELEASE_ASYNC;\n  const [wasmModuleLoader, QuickJSAsyncFFI, {\n    QuickJSAsyncWASMModule\n  }] = await Promise.all([variant.importModuleLoader(), variant.importFFI(), Promise.resolve().then(() => __importStar(require(\"./module-asyncify.js\"))).then(esmHelpers_1.unwrapTypescript)]);\n  const wasmModule = await wasmModuleLoader();\n  wasmModule.type = \"async\";\n  const ffi = new QuickJSAsyncFFI(wasmModule);\n  return new QuickJSAsyncWASMModule(wasmModule, ffi);\n}\nexports.newQuickJSAsyncWASMModule = newQuickJSAsyncWASMModule;\n/**\n * Helper intended to memoize the creation of a WebAssembly module.\n * ```typescript\n * const getDebugModule = memoizePromiseFactory(() => newQuickJSWASMModule(DEBUG_SYNC))\n * ```\n */\nfunction memoizePromiseFactory(fn) {\n  let promise;\n  return () => {\n    return promise ?? (promise = fn());\n  };\n}\nexports.memoizePromiseFactory = memoizePromiseFactory;\n/**\n * This build variant is compiled with `-fsanitize=leak`. It instruments all\n * memory allocations and when combined with sourcemaps, can present stack trace\n * locations where memory leaks occur.\n *\n * See [[TestQuickJSWASMModule]] which provides access to the leak sanitizer via\n * {@link TestQuickJSWASMModule.assertNoMemoryAllocated}.\n *\n * The downside is that it's 100-1000x slower than the other variants.\n * Suggested use case: automated testing, regression testing, and interactive\n * debugging.\n */\nexports.DEBUG_SYNC = {\n  type: \"sync\",\n  async importFFI() {\n    throw new Error(\"not implemented\");\n    // const mod = await import(\"./generated/ffi.WASM_DEBUG_SYNC.js\")\n    // return unwrapTypescript(mod).QuickJSFFI\n  },\n\n  async importModuleLoader() {\n    throw new Error(\"not implemented\");\n    // const mod = await import(\"./generated/emscripten-module.WASM_DEBUG_SYNC.js\")\n    // return unwrapJavascript(mod).default\n  }\n};\n/**\n * This is the default (synchronous) build variant.\n * {@link getQuickJS} returns a memoized instance of this build variant.\n */\nexports.RELEASE_SYNC = {\n  type: \"sync\",\n  async importFFI() {\n    const mod = await Promise.resolve().then(() => __importStar(require(\"./generated/ffi.WASM_RELEASE_SYNC.js\")));\n    return (0, esmHelpers_1.unwrapTypescript)(mod).QuickJSFFI;\n  },\n  async importModuleLoader() {\n    const mod = await Promise.resolve().then(() => __importStar(require(\"./generated/emscripten-module.WASM_RELEASE_SYNC.js\")));\n    return (0, esmHelpers_1.unwrapJavascript)(mod);\n  }\n};\n/**\n * The async debug build variant may or may not have the sanitizer enabled.\n * It does print a lot of debug logs.\n *\n * Suggested use case: interactive debugging only.\n */\nexports.DEBUG_ASYNC = {\n  type: \"async\",\n  async importFFI() {\n    throw new Error(\"not implemented\");\n    // const mod = await import(\"./generated/ffi.WASM_DEBUG_ASYNCIFY.js\")\n    // return unwrapTypescript(mod).QuickJSAsyncFFI\n  },\n\n  async importModuleLoader() {\n    throw new Error(\"not implemented\");\n    // const mod = await import(\"./generated/emscripten-module.WASM_DEBUG_ASYNCIFY.js\")\n    // return unwrapJavascript(mod).default\n  }\n};\n/**\n * This is the default asyncified build variant.\n */\nexports.RELEASE_ASYNC = {\n  type: \"async\",\n  async importFFI() {\n    throw new Error(\"not implemented\");\n    // const mod = await import(\"./generated/ffi.WASM_RELEASE_ASYNCIFY.js\")\n    // return unwrapTypescript(mod).QuickJSAsyncFFI\n  },\n\n  async importModuleLoader() {\n    throw new Error(\"not implemented\");\n    // const mod = await import(\"./generated/emscripten-module.WASM_RELEASE_ASYNCIFY.js\")\n    // return unwrapJavascript(mod).default\n  }\n};","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAWA;AA+CA;;;;;;;;AAQO,eAAeA,oBAAoB,GAIA;EAAA,IAAxCC,8EAA4BC,oBAAY;EAExC,MAAM,CAACC,gBAAgB,EAAEC,UAAU,EAAE;IAAEC;EAAiB,CAAE,CAAC,GAAG,MAAMC,OAAO,CAACC,GAAG,CAAC,CAC9EN,OAAO,CAACO,kBAAkB,EAAE,EAC5BP,OAAO,CAACQ,SAAS,EAAE,EACnBH,kDAAO,aAAa,IAAEI,IAAI,CAACC,6BAAgB,CAAC,CAC7C,CAAC;EACF,MAAMC,UAAU,GAAG,MAAMT,gBAAgB,EAAE;EAC3CS,UAAU,CAACC,IAAI,GAAG,MAAM;EACxB,MAAMC,GAAG,GAAG,IAAIV,UAAU,CAACQ,UAAU,CAAC;EACtC,OAAO,IAAIP,iBAAiB,CAACO,UAAU,EAAEE,GAAG,CAAC;AAC/C;AAfAZ;AAiBA;;;;;;;;;;;;;AAaO,eAAea,yBAAyB,GAIH;EAAA,IAA1Cd,8EAA6BC,qBAAa;EAE1C,MAAM,CAACC,gBAAgB,EAAEa,eAAe,EAAE;IAAEC;EAAsB,CAAE,CAAC,GAAG,MAAMX,OAAO,CAACC,GAAG,CAAC,CACxFN,OAAO,CAACO,kBAAkB,EAAE,EAC5BP,OAAO,CAACQ,SAAS,EAAE,EACnBH,kDAAO,sBAAsB,IAAEI,IAAI,CAACC,6BAAgB,CAAC,CACtD,CAAC;EACF,MAAMC,UAAU,GAAG,MAAMT,gBAAgB,EAAE;EAC3CS,UAAU,CAACC,IAAI,GAAG,OAAO;EACzB,MAAMC,GAAG,GAAG,IAAIE,eAAe,CAACJ,UAAU,CAAC;EAC3C,OAAO,IAAIK,sBAAsB,CAACL,UAAU,EAAEE,GAAG,CAAC;AACpD;AAfAZ;AAiBA;;;;;;AAMA,SAAgBgB,qBAAqB,CAAIC,EAAoB;EAC3D,IAAIC,OAA+B;EACnC,OAAO,MAAK;IACV,OAAQA,OAAO,KAAPA,OAAO,GAAKD,EAAE,EAAE;EAC1B,CAAC;AACH;AALAjB;AAOA;;;;;;;;;;;;AAYaA,kBAAU,GAAqB;EAC1CW,IAAI,EAAE,MAAM;EACZ,MAAMJ,SAAS;IACb,MAAM,IAAIY,KAAK,CAAC,iBAAiB,CAAC;IAClC;IACA;EACF,CAAC;;EACD,MAAMb,kBAAkB;IACtB,MAAM,IAAIa,KAAK,CAAC,iBAAiB,CAAC;IAClC;IACA;EACF;CACD;AAED;;;;AAIanB,oBAAY,GAAqB;EAC5CW,IAAI,EAAE,MAAM;EACZ,MAAMJ,SAAS;IACb,MAAMa,GAAG,GAAG,wDAAa,sCAAsC,GAAC;IAChE,OAAO,iCAAgB,EAACA,GAAG,CAAC,CAAClB,UAAU;EACzC,CAAC;EACD,MAAMI,kBAAkB;IACtB,MAAMc,GAAG,GAAG,wDAAa,oDAAoD,GAAC;IAC9E,OAAO,iCAAgB,EAACA,GAAG,CAAC;EAC9B;CACD;AAED;;;;;;AAMapB,mBAAW,GAAsB;EAC5CW,IAAI,EAAE,OAAO;EACb,MAAMJ,SAAS;IACb,MAAM,IAAIY,KAAK,CAAC,iBAAiB,CAAC;IAClC;IACA;EACF,CAAC;;EACD,MAAMb,kBAAkB;IACtB,MAAM,IAAIa,KAAK,CAAC,iBAAiB,CAAC;IAClC;IACA;EACF;CACD;AAED;;;AAGanB,qBAAa,GAAsB;EAC9CW,IAAI,EAAE,OAAO;EACb,MAAMJ,SAAS;IACb,MAAM,IAAIY,KAAK,CAAC,iBAAiB,CAAC;IAClC;IACA;EACF,CAAC;;EACD,MAAMb,kBAAkB;IACtB,MAAM,IAAIa,KAAK,CAAC,iBAAiB,CAAC;IAClC;IACA;EACF;CACD","names":["newQuickJSWASMModule","variant","exports","wasmModuleLoader","QuickJSFFI","QuickJSWASMModule","Promise","all","importModuleLoader","importFFI","then","esmHelpers_1","wasmModule","type","ffi","newQuickJSAsyncWASMModule","QuickJSAsyncFFI","QuickJSAsyncWASMModule","memoizePromiseFactory","fn","promise","Error","mod"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\@tootallnate\\quickjs-emscripten\\ts\\variants.ts"],"sourcesContent":["//import type { QuickJSAsyncFFI as DebugAsyncifyFFI } from \"./generated/ffi.WASM_DEBUG_ASYNCIFY\"\n//import type { QuickJSAsyncFFI as ReleaseAsyncifyFFI } from \"./generated/ffi.WASM_RELEASE_ASYNCIFY\"\n//import type { QuickJSFFI as DebugSyncFFI } from \"./generated/ffi.WASM_DEBUG_SYNC\"\nimport type { QuickJSFFI as ReleaseSyncFFI } from \"./generated/ffi.WASM_RELEASE_SYNC\"\nimport type {\n  EmscriptenModuleLoader,\n  QuickJSEmscriptenModule,\n  QuickJSAsyncEmscriptenModule,\n} from \"./emscripten-types\"\nimport type { QuickJSWASMModule } from \"./module\"\nimport type { QuickJSAsyncWASMModule } from \"./module-asyncify\"\nimport { unwrapTypescript, unwrapJavascript } from \"./esmHelpers\"\n\n/** @private */\nexport type QuickJSFFI = ReleaseSyncFFI\n/** @private */\nexport type QuickJSFFIConstructor = typeof ReleaseSyncFFI\n/** @private */\nexport type QuickJSAsyncFFI = any\n/** @private */\nexport type QuickJSAsyncFFIConstructor = any\n\n/**\n * quickjs-emscripten provides multiple build variants of the core WebAssembly\n * module. These variants are each intended for a different use case.\n *\n * To create an instance of the library using a specific build variant, pass the\n * build variant to {@link newQuickJSWASMModule} or {@link newQuickJSAsyncWASMModule}.\n *\n * Synchronous build variants:\n *\n * - {@link RELEASE_SYNC} - This is the default synchronous variant, for general purpose use.\n * - {@link DEBUG_SYNC} - Synchronous build variant for debugging memory leaks.\n */\nexport interface SyncBuildVariant {\n  type: \"sync\"\n  importFFI: () => Promise<QuickJSFFIConstructor>\n  importModuleLoader: () => Promise<EmscriptenModuleLoader<QuickJSEmscriptenModule>>\n}\n\n/**\n * quickjs-emscripten provides multiple build variants of the core WebAssembly\n * module. These variants are each intended for a different use case.\n *\n * To create an instance of the library using a specific build variant, pass the\n * build variant to {@link newQuickJSWASMModule} or {@link newQuickJSAsyncWASMModule}.\n *\n * Asyncified build variants:\n *\n * - {@link RELEASE_ASYNC} - This is the default asyncified build variant, for general purpose use.\n * - {@link DEBUG_ASYNC} - Asyncified build variant with debug logging.\n */\nexport interface AsyncBuildVariant {\n  type: \"async\"\n  importFFI: () => Promise<QuickJSAsyncFFIConstructor>\n  importModuleLoader: () => Promise<EmscriptenModuleLoader<QuickJSAsyncEmscriptenModule>>\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing the QuickJS library.\n * See the documentation on [[QuickJSWASMModule]].\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newQuickJSWASMModule(\n  /**\n   * Optionally, pass a {@link SyncBuildVariant} to construct a different WebAssembly module.\n   */\n  variant: SyncBuildVariant = RELEASE_SYNC\n): Promise<QuickJSWASMModule> {\n  const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([\n    variant.importModuleLoader(),\n    variant.importFFI(),\n    import(\"./module.js\").then(unwrapTypescript),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"sync\"\n  const ffi = new QuickJSFFI(wasmModule)\n  return new QuickJSWASMModule(wasmModule, ffi)\n}\n\n/**\n * Create a new, completely isolated WebAssembly module containing a version of the QuickJS library\n * compiled with Emscripten's [ASYNCIFY](https://emscripten.org/docs/porting/asyncify.html) transform.\n *\n * This version of the library offers features that enable synchronous code\n * inside the VM to interact with asynchronous code in the host environment.\n * See the documentation on [[QuickJSAsyncWASMModule]], [[QuickJSAsyncRuntime]],\n * and [[QuickJSAsyncContext]].\n *\n * Note that there is a hard limit on the number of WebAssembly modules in older\n * versions of v8:\n * https://bugs.chromium.org/p/v8/issues/detail?id=12076\n */\nexport async function newQuickJSAsyncWASMModule(\n  /**\n   * Optionally, pass a {@link AsyncBuildVariant} to construct a different WebAssembly module.\n   */\n  variant: AsyncBuildVariant = RELEASE_ASYNC\n): Promise<QuickJSAsyncWASMModule> {\n  const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([\n    variant.importModuleLoader(),\n    variant.importFFI(),\n    import(\"./module-asyncify.js\").then(unwrapTypescript),\n  ])\n  const wasmModule = await wasmModuleLoader()\n  wasmModule.type = \"async\"\n  const ffi = new QuickJSAsyncFFI(wasmModule)\n  return new QuickJSAsyncWASMModule(wasmModule, ffi)\n}\n\n/**\n * Helper intended to memoize the creation of a WebAssembly module.\n * ```typescript\n * const getDebugModule = memoizePromiseFactory(() => newQuickJSWASMModule(DEBUG_SYNC))\n * ```\n */\nexport function memoizePromiseFactory<T>(fn: () => Promise<T>): () => Promise<T> {\n  let promise: Promise<T> | undefined\n  return () => {\n    return (promise ??= fn())\n  }\n}\n\n/**\n * This build variant is compiled with `-fsanitize=leak`. It instruments all\n * memory allocations and when combined with sourcemaps, can present stack trace\n * locations where memory leaks occur.\n *\n * See [[TestQuickJSWASMModule]] which provides access to the leak sanitizer via\n * {@link TestQuickJSWASMModule.assertNoMemoryAllocated}.\n *\n * The downside is that it's 100-1000x slower than the other variants.\n * Suggested use case: automated testing, regression testing, and interactive\n * debugging.\n */\nexport const DEBUG_SYNC: SyncBuildVariant = {\n  type: \"sync\",\n  async importFFI() {\n    throw new Error(\"not implemented\")\n    // const mod = await import(\"./generated/ffi.WASM_DEBUG_SYNC.js\")\n    // return unwrapTypescript(mod).QuickJSFFI\n  },\n  async importModuleLoader() {\n    throw new Error(\"not implemented\")\n    // const mod = await import(\"./generated/emscripten-module.WASM_DEBUG_SYNC.js\")\n    // return unwrapJavascript(mod).default\n  },\n}\n\n/**\n * This is the default (synchronous) build variant.\n * {@link getQuickJS} returns a memoized instance of this build variant.\n */\nexport const RELEASE_SYNC: SyncBuildVariant = {\n  type: \"sync\",\n  async importFFI() {\n    const mod = await import(\"./generated/ffi.WASM_RELEASE_SYNC.js\")\n    return unwrapTypescript(mod).QuickJSFFI\n  },\n  async importModuleLoader() {\n    const mod = await import(\"./generated/emscripten-module.WASM_RELEASE_SYNC.js\")\n    return unwrapJavascript(mod)\n  },\n}\n\n/**\n * The async debug build variant may or may not have the sanitizer enabled.\n * It does print a lot of debug logs.\n *\n * Suggested use case: interactive debugging only.\n */\nexport const DEBUG_ASYNC: AsyncBuildVariant = {\n  type: \"async\",\n  async importFFI() {\n    throw new Error(\"not implemented\")\n    // const mod = await import(\"./generated/ffi.WASM_DEBUG_ASYNCIFY.js\")\n    // return unwrapTypescript(mod).QuickJSAsyncFFI\n  },\n  async importModuleLoader() {\n    throw new Error(\"not implemented\")\n    // const mod = await import(\"./generated/emscripten-module.WASM_DEBUG_ASYNCIFY.js\")\n    // return unwrapJavascript(mod).default\n  },\n}\n\n/**\n * This is the default asyncified build variant.\n */\nexport const RELEASE_ASYNC: AsyncBuildVariant = {\n  type: \"async\",\n  async importFFI() {\n    throw new Error(\"not implemented\")\n    // const mod = await import(\"./generated/ffi.WASM_RELEASE_ASYNCIFY.js\")\n    // return unwrapTypescript(mod).QuickJSAsyncFFI\n  },\n  async importModuleLoader() {\n    throw new Error(\"not implemented\")\n    // const mod = await import(\"./generated/emscripten-module.WASM_RELEASE_ASYNCIFY.js\")\n    // return unwrapJavascript(mod).default\n  },\n}\n"]},"metadata":{},"sourceType":"script"}