{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { getQueryHandlerAndSelector } from '../common/GetQueryHandler.js';\nimport { LazyArg } from '../common/LazyArg.js';\nimport { isString, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { AsyncIterableUtil } from '../util/AsyncIterableUtil.js';\nimport { throwIfDisposed } from '../util/decorators.js';\nimport { _isElementHandle } from './ElementHandleSymbol.js';\nimport { JSHandle } from './JSHandle.js';\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nlet ElementHandle = (() => {\n  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4, _5, _6, _7;\n  let _classSuper = JSHandle;\n  let _instanceExtraInitializers = [];\n  let _getProperty_decorators;\n  let _getProperties_decorators;\n  let _jsonValue_decorators;\n  let _$_decorators;\n  let _$$_decorators;\n  let _$x_decorators;\n  let _waitForSelector_decorators;\n  let _isVisible_decorators;\n  let _isHidden_decorators;\n  let _waitForXPath_decorators;\n  let _toElement_decorators;\n  let _clickablePoint_decorators;\n  let _hover_decorators;\n  let _click_decorators;\n  let _drag_decorators;\n  let _dragEnter_decorators;\n  let _dragOver_decorators;\n  let _drop_decorators;\n  let _dragAndDrop_decorators;\n  let _select_decorators;\n  let _tap_decorators;\n  let _touchStart_decorators;\n  let _touchMove_decorators;\n  let _touchEnd_decorators;\n  let _focus_decorators;\n  let _type_decorators;\n  let _press_decorators;\n  let _boundingBox_decorators;\n  let _boxModel_decorators;\n  let _screenshot_decorators;\n  let _isIntersectingViewport_decorators;\n  let _scrollIntoView_decorators;\n  return class ElementHandle extends _classSuper {\n    static #_ = (() => {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(_classSuper[Symbol.metadata] ?? null) : void 0;\n      _getProperty_decorators = [throwIfDisposed(), (_a = ElementHandle).bindIsolatedHandle.bind(_a)];\n      _getProperties_decorators = [throwIfDisposed(), (_b = ElementHandle).bindIsolatedHandle.bind(_b)];\n      _jsonValue_decorators = [throwIfDisposed(), (_c = ElementHandle).bindIsolatedHandle.bind(_c)];\n      _$_decorators = [throwIfDisposed(), (_d = ElementHandle).bindIsolatedHandle.bind(_d)];\n      _$$_decorators = [throwIfDisposed(), (_e = ElementHandle).bindIsolatedHandle.bind(_e)];\n      _$x_decorators = [throwIfDisposed(), (_f = ElementHandle).bindIsolatedHandle.bind(_f)];\n      _waitForSelector_decorators = [throwIfDisposed(), (_g = ElementHandle).bindIsolatedHandle.bind(_g)];\n      _isVisible_decorators = [throwIfDisposed(), (_h = ElementHandle).bindIsolatedHandle.bind(_h)];\n      _isHidden_decorators = [throwIfDisposed(), (_j = ElementHandle).bindIsolatedHandle.bind(_j)];\n      _waitForXPath_decorators = [throwIfDisposed(), (_k = ElementHandle).bindIsolatedHandle.bind(_k)];\n      _toElement_decorators = [throwIfDisposed(), (_l = ElementHandle).bindIsolatedHandle.bind(_l)];\n      _clickablePoint_decorators = [throwIfDisposed(), (_m = ElementHandle).bindIsolatedHandle.bind(_m)];\n      _hover_decorators = [throwIfDisposed(), (_o = ElementHandle).bindIsolatedHandle.bind(_o)];\n      _click_decorators = [throwIfDisposed(), (_p = ElementHandle).bindIsolatedHandle.bind(_p)];\n      _drag_decorators = [throwIfDisposed(), (_q = ElementHandle).bindIsolatedHandle.bind(_q)];\n      _dragEnter_decorators = [throwIfDisposed(), (_r = ElementHandle).bindIsolatedHandle.bind(_r)];\n      _dragOver_decorators = [throwIfDisposed(), (_s = ElementHandle).bindIsolatedHandle.bind(_s)];\n      _drop_decorators = [throwIfDisposed(), (_t = ElementHandle).bindIsolatedHandle.bind(_t)];\n      _dragAndDrop_decorators = [throwIfDisposed(), (_u = ElementHandle).bindIsolatedHandle.bind(_u)];\n      _select_decorators = [throwIfDisposed(), (_v = ElementHandle).bindIsolatedHandle.bind(_v)];\n      _tap_decorators = [throwIfDisposed(), (_w = ElementHandle).bindIsolatedHandle.bind(_w)];\n      _touchStart_decorators = [throwIfDisposed(), (_x = ElementHandle).bindIsolatedHandle.bind(_x)];\n      _touchMove_decorators = [throwIfDisposed(), (_y = ElementHandle).bindIsolatedHandle.bind(_y)];\n      _touchEnd_decorators = [throwIfDisposed(), (_z = ElementHandle).bindIsolatedHandle.bind(_z)];\n      _focus_decorators = [throwIfDisposed(), (_0 = ElementHandle).bindIsolatedHandle.bind(_0)];\n      _type_decorators = [throwIfDisposed(), (_1 = ElementHandle).bindIsolatedHandle.bind(_1)];\n      _press_decorators = [throwIfDisposed(), (_2 = ElementHandle).bindIsolatedHandle.bind(_2)];\n      _boundingBox_decorators = [throwIfDisposed(), (_3 = ElementHandle).bindIsolatedHandle.bind(_3)];\n      _boxModel_decorators = [throwIfDisposed(), (_4 = ElementHandle).bindIsolatedHandle.bind(_4)];\n      _screenshot_decorators = [throwIfDisposed(), (_5 = ElementHandle).bindIsolatedHandle.bind(_5)];\n      _isIntersectingViewport_decorators = [throwIfDisposed(), (_6 = ElementHandle).bindIsolatedHandle.bind(_6)];\n      _scrollIntoView_decorators = [throwIfDisposed(), (_7 = ElementHandle).bindIsolatedHandle.bind(_7)];\n      __esDecorate(this, null, _getProperty_decorators, {\n        kind: \"method\",\n        name: \"getProperty\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperty\" in obj,\n          get: obj => obj.getProperty\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _getProperties_decorators, {\n        kind: \"method\",\n        name: \"getProperties\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperties\" in obj,\n          get: obj => obj.getProperties\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _jsonValue_decorators, {\n        kind: \"method\",\n        name: \"jsonValue\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"jsonValue\" in obj,\n          get: obj => obj.jsonValue\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$_decorators, {\n        kind: \"method\",\n        name: \"$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$\" in obj,\n          get: obj => obj.$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$$_decorators, {\n        kind: \"method\",\n        name: \"$$\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$$\" in obj,\n          get: obj => obj.$$\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _$x_decorators, {\n        kind: \"method\",\n        name: \"$x\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"$x\" in obj,\n          get: obj => obj.$x\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForSelector_decorators, {\n        kind: \"method\",\n        name: \"waitForSelector\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForSelector\" in obj,\n          get: obj => obj.waitForSelector\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isVisible_decorators, {\n        kind: \"method\",\n        name: \"isVisible\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isVisible\" in obj,\n          get: obj => obj.isVisible\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isHidden_decorators, {\n        kind: \"method\",\n        name: \"isHidden\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isHidden\" in obj,\n          get: obj => obj.isHidden\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _waitForXPath_decorators, {\n        kind: \"method\",\n        name: \"waitForXPath\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"waitForXPath\" in obj,\n          get: obj => obj.waitForXPath\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _toElement_decorators, {\n        kind: \"method\",\n        name: \"toElement\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"toElement\" in obj,\n          get: obj => obj.toElement\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _clickablePoint_decorators, {\n        kind: \"method\",\n        name: \"clickablePoint\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"clickablePoint\" in obj,\n          get: obj => obj.clickablePoint\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _hover_decorators, {\n        kind: \"method\",\n        name: \"hover\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"hover\" in obj,\n          get: obj => obj.hover\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _click_decorators, {\n        kind: \"method\",\n        name: \"click\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"click\" in obj,\n          get: obj => obj.click\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drag_decorators, {\n        kind: \"method\",\n        name: \"drag\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drag\" in obj,\n          get: obj => obj.drag\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragEnter_decorators, {\n        kind: \"method\",\n        name: \"dragEnter\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragEnter\" in obj,\n          get: obj => obj.dragEnter\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragOver_decorators, {\n        kind: \"method\",\n        name: \"dragOver\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragOver\" in obj,\n          get: obj => obj.dragOver\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _drop_decorators, {\n        kind: \"method\",\n        name: \"drop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"drop\" in obj,\n          get: obj => obj.drop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _dragAndDrop_decorators, {\n        kind: \"method\",\n        name: \"dragAndDrop\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"dragAndDrop\" in obj,\n          get: obj => obj.dragAndDrop\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _select_decorators, {\n        kind: \"method\",\n        name: \"select\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"select\" in obj,\n          get: obj => obj.select\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _tap_decorators, {\n        kind: \"method\",\n        name: \"tap\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"tap\" in obj,\n          get: obj => obj.tap\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchStart_decorators, {\n        kind: \"method\",\n        name: \"touchStart\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchStart\" in obj,\n          get: obj => obj.touchStart\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchMove_decorators, {\n        kind: \"method\",\n        name: \"touchMove\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchMove\" in obj,\n          get: obj => obj.touchMove\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _touchEnd_decorators, {\n        kind: \"method\",\n        name: \"touchEnd\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"touchEnd\" in obj,\n          get: obj => obj.touchEnd\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _focus_decorators, {\n        kind: \"method\",\n        name: \"focus\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"focus\" in obj,\n          get: obj => obj.focus\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _type_decorators, {\n        kind: \"method\",\n        name: \"type\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"type\" in obj,\n          get: obj => obj.type\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _press_decorators, {\n        kind: \"method\",\n        name: \"press\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"press\" in obj,\n          get: obj => obj.press\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boundingBox_decorators, {\n        kind: \"method\",\n        name: \"boundingBox\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boundingBox\" in obj,\n          get: obj => obj.boundingBox\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _boxModel_decorators, {\n        kind: \"method\",\n        name: \"boxModel\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"boxModel\" in obj,\n          get: obj => obj.boxModel\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _screenshot_decorators, {\n        kind: \"method\",\n        name: \"screenshot\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"screenshot\" in obj,\n          get: obj => obj.screenshot\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _isIntersectingViewport_decorators, {\n        kind: \"method\",\n        name: \"isIntersectingViewport\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"isIntersectingViewport\" in obj,\n          get: obj => obj.isIntersectingViewport\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _scrollIntoView_decorators, {\n        kind: \"method\",\n        name: \"scrollIntoView\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"scrollIntoView\" in obj,\n          get: obj => obj.scrollIntoView\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      if (_metadata) Object.defineProperty(this, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n    })();\n    /**\n     * A given method will have it's `this` replaced with an isolated version of\n     * `this` when decorated with this decorator.\n     *\n     * All changes of isolated `this` are reflected on the actual `this`.\n     *\n     * @internal\n     */\n    static bindIsolatedHandle(target, _) {\n      return async function () {\n        const env_1 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n          // If the handle is already isolated, then we don't need to adopt it\n          // again.\n          if (this.realm === this.frame.isolatedRealm()) {\n            return await target.call(this, ...args);\n          }\n          const adoptedThis = __addDisposableResource(env_1, await this.frame.isolatedRealm().adoptHandle(this), false);\n          const result = await target.call(adoptedThis, ...args);\n          // If the function returns `adoptedThis`, then we return `this`.\n          if (result === adoptedThis) {\n            return this;\n          }\n          // If the function returns a handle, transfer it into the current realm.\n          if (result instanceof JSHandle) {\n            return await this.realm.transferHandle(result);\n          }\n          // If the function returns an array of handlers, transfer them into the\n          // current realm.\n          if (Array.isArray(result)) {\n            await Promise.all(result.map(async (item, index, result) => {\n              if (item instanceof JSHandle) {\n                result[index] = await this.realm.transferHandle(item);\n              }\n            }));\n          }\n          if (result instanceof Map) {\n            await Promise.all([...result.entries()].map(async _ref => {\n              let [key, value] = _ref;\n              if (value instanceof JSHandle) {\n                result.set(key, await this.realm.transferHandle(value));\n              }\n            }));\n          }\n          return result;\n        } catch (e_1) {\n          env_1.error = e_1;\n          env_1.hasError = true;\n        } finally {\n          __disposeResources(env_1);\n        }\n      };\n    }\n    /**\n     * @internal\n     */\n    handle = (__runInitializers(this, _instanceExtraInitializers), void 0);\n    /**\n     * @internal\n     */\n    constructor(handle) {\n      super();\n      this.handle = handle;\n      this[_isElementHandle] = true;\n    }\n    /**\n     * @internal\n     */\n    get id() {\n      return this.handle.id;\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      return this.handle.disposed;\n    }\n    /**\n     * @internal\n     */\n    async getProperty(propertyName) {\n      return await this.handle.getProperty(propertyName);\n    }\n    /**\n     * @internal\n     */\n    async getProperties() {\n      return await this.handle.getProperties();\n    }\n    /**\n     * @internal\n     */\n    async evaluate(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      return await this.handle.evaluate(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async evaluateHandle(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n        args[_key3 - 1] = arguments[_key3];\n      }\n      return await this.handle.evaluateHandle(pageFunction, ...args);\n    }\n    /**\n     * @internal\n     */\n    async jsonValue() {\n      return await this.handle.jsonValue();\n    }\n    /**\n     * @internal\n     */\n    toString() {\n      return this.handle.toString();\n    }\n    /**\n     * @internal\n     */\n    remoteObject() {\n      return this.handle.remoteObject();\n    }\n    /**\n     * @internal\n     */\n    dispose() {\n      return this.handle.dispose();\n    }\n    /**\n     * @internal\n     */\n    asElement() {\n      return this;\n    }\n    /**\n     * Queries the current element for an element matching the given selector.\n     *\n     * @param selector - The selector to query for.\n     * @returns A {@link ElementHandle | element handle} to the first element\n     * matching the given selector. Otherwise, `null`.\n     */\n    async $(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.queryOne(this, updatedSelector);\n    }\n    /**\n     * Queries the current element for all elements matching the given selector.\n     *\n     * @param selector - The selector to query for.\n     * @returns An array of {@link ElementHandle | element handles} that point to\n     * elements matching the given selector.\n     */\n    async $$(selector) {\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await AsyncIterableUtil.collect(QueryHandler.queryAll(this, updatedSelector));\n    }\n    /**\n     * Runs the given function on the first element matching the given selector in\n     * the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     *\n     * ```ts\n     * const tweetHandle = await page.$('.tweet');\n     * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n     *   '100'\n     * );\n     * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n     *   '10'\n     * );\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param pageFunction - The function to be evaluated in this element's page's\n     * context. The first element matching the selector will be passed in as the\n     * first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $eval(selector, pageFunction) {\n      const env_2 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n        const elementHandle = __addDisposableResource(env_2, await this.$(selector), false);\n        if (!elementHandle) {\n          throw new Error(`Error: failed to find element matching selector \"${selector}\"`);\n        }\n        for (var _len4 = arguments.length, args = new Array(_len4 > 2 ? _len4 - 2 : 0), _key4 = 2; _key4 < _len4; _key4++) {\n          args[_key4 - 2] = arguments[_key4];\n        }\n        return await elementHandle.evaluate(pageFunction, ...args);\n      } catch (e_2) {\n        env_2.error = e_2;\n        env_2.hasError = true;\n      } finally {\n        __disposeResources(env_2);\n      }\n    }\n    /**\n     * Runs the given function on an array of elements matching the given selector\n     * in the current element.\n     *\n     * If the given function returns a promise, then this method will wait till\n     * the promise resolves.\n     *\n     * @example\n     * HTML:\n     *\n     * ```html\n     * <div class=\"feed\">\n     *   <div class=\"tweet\">Hello!</div>\n     *   <div class=\"tweet\">Hi!</div>\n     * </div>\n     * ```\n     *\n     * JavaScript:\n     *\n     * ```js\n     * const feedHandle = await page.$('.feed');\n     * expect(\n     *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n     * ).toEqual(['Hello!', 'Hi!']);\n     * ```\n     *\n     * @param selector - The selector to query for.\n     * @param pageFunction - The function to be evaluated in the element's page's\n     * context. An array of elements matching the given selector will be passed to\n     * the function as its first argument.\n     * @param args - Additional arguments to pass to `pageFunction`.\n     * @returns A promise to the result of the function.\n     */\n    async $$eval(selector, pageFunction) {\n      const env_3 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n        const results = await this.$$(selector);\n        const elements = __addDisposableResource(env_3, await this.evaluateHandle(function (_) {\n          for (var _len6 = arguments.length, elements = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n            elements[_key6 - 1] = arguments[_key6];\n          }\n          return elements;\n        }, ...results), false);\n        for (var _len5 = arguments.length, args = new Array(_len5 > 2 ? _len5 - 2 : 0), _key5 = 2; _key5 < _len5; _key5++) {\n          args[_key5 - 2] = arguments[_key5];\n        }\n        const [result] = await Promise.all([elements.evaluate(pageFunction, ...args), ...results.map(results => {\n          return results.dispose();\n        })]);\n        return result;\n      } catch (e_3) {\n        env_3.error = e_3;\n        env_3.hasError = true;\n      } finally {\n        __disposeResources(env_3);\n      }\n    }\n    /**\n     * @deprecated Use {@link ElementHandle.$$} with the `xpath` prefix.\n     *\n     * Example: `await elementHandle.$$('xpath/' + xpathExpression)`\n     *\n     * The method evaluates the XPath expression relative to the elementHandle.\n     * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n     * automatically.\n     *\n     * If there are no such elements, the method will resolve to an empty array.\n     * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}\n     */\n    async $x(expression) {\n      if (expression.startsWith('//')) {\n        expression = `.${expression}`;\n      }\n      return await this.$$(`xpath/${expression}`);\n    }\n    /**\n     * Wait for an element matching the given selector to appear in the current\n     * element.\n     *\n     * Unlike {@link Frame.waitForSelector}, this method does not work across\n     * navigations or if the element is detached from DOM.\n     *\n     * @example\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     *\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .mainFrame()\n     *     .waitForSelector('img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param selector - The selector to query and wait for.\n     * @param options - Options for customizing waiting behavior.\n     * @returns An element matching the given selector.\n     * @throws Throws if an element matching the given selector doesn't appear.\n     */\n    async waitForSelector(selector) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      const {\n        updatedSelector,\n        QueryHandler\n      } = getQueryHandlerAndSelector(selector);\n      return await QueryHandler.waitFor(this, updatedSelector, options);\n    }\n    async #checkVisibility(visibility) {\n      return await this.evaluate(async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      }, LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }), visibility);\n    }\n    /**\n     * Checks if an element is visible using the same mechanism as\n     * {@link ElementHandle.waitForSelector}.\n     */\n    async isVisible() {\n      return await this.#checkVisibility(true);\n    }\n    /**\n     * Checks if an element is hidden using the same mechanism as\n     * {@link ElementHandle.waitForSelector}.\n     */\n    async isHidden() {\n      return await this.#checkVisibility(false);\n    }\n    /**\n     * @deprecated Use {@link ElementHandle.waitForSelector} with the `xpath`\n     * prefix.\n     *\n     * Example: `await elementHandle.waitForSelector('xpath/' + xpathExpression)`\n     *\n     * The method evaluates the XPath expression relative to the elementHandle.\n     *\n     * Wait for the `xpath` within the element. If at the moment of calling the\n     * method the `xpath` already exists, the method will return immediately. If\n     * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n     * function will throw.\n     *\n     * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n     * automatically.\n     *\n     * @example\n     * This method works across navigation.\n     *\n     * ```ts\n     * import puppeteer from 'puppeteer';\n     * (async () => {\n     *   const browser = await puppeteer.launch();\n     *   const page = await browser.newPage();\n     *   let currentURL;\n     *   page\n     *     .waitForXPath('//img')\n     *     .then(() => console.log('First URL with image: ' + currentURL));\n     *   for (currentURL of [\n     *     'https://example.com',\n     *     'https://google.com',\n     *     'https://bbc.com',\n     *   ]) {\n     *     await page.goto(currentURL);\n     *   }\n     *   await browser.close();\n     * })();\n     * ```\n     *\n     * @param xpath - A\n     * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n     * element to wait for\n     * @param options - Optional waiting parameters\n     * @returns Promise which resolves when element specified by xpath string is\n     * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n     * not found in DOM, otherwise resolves to `ElementHandle`.\n     * @remarks\n     * The optional Argument `options` have properties:\n     *\n     * - `visible`: A boolean to wait for element to be present in DOM and to be\n     *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n     *   properties. Defaults to `false`.\n     *\n     * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n     *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n     *   Defaults to `false`.\n     *\n     * - `timeout`: A number which is maximum time to wait for in milliseconds.\n     *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n     *   default value can be changed by using the {@link Page.setDefaultTimeout}\n     *   method.\n     */\n    async waitForXPath(xpath) {\n      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (xpath.startsWith('//')) {\n        xpath = `.${xpath}`;\n      }\n      return await this.waitForSelector(`xpath/${xpath}`, options);\n    }\n    /**\n     * Converts the current handle to the given element type.\n     *\n     * @example\n     *\n     * ```ts\n     * const element: ElementHandle<Element> = await page.$(\n     *   '.class-name-of-anchor'\n     * );\n     * // DO NOT DISPOSE `element`, this will be always be the same handle.\n     * const anchor: ElementHandle<HTMLAnchorElement> =\n     *   await element.toElement('a');\n     * ```\n     *\n     * @param tagName - The tag name of the desired element type.\n     * @throws An error if the handle does not match. **The handle will not be\n     * automatically disposed.**\n     */\n    async toElement(tagName) {\n      const isMatchingTagName = await this.evaluate((node, tagName) => {\n        return node.nodeName === tagName.toUpperCase();\n      }, tagName);\n      if (!isMatchingTagName) {\n        throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n      }\n      return this;\n    }\n    /**\n     * Returns the middle point within an element unless a specific offset is provided.\n     */\n    async clickablePoint(offset) {\n      const box = await this.#clickableBox();\n      if (!box) {\n        throw new Error('Node is either not clickable or not an Element');\n      }\n      if (offset !== undefined) {\n        return {\n          x: box.x + offset.x,\n          y: box.y + offset.y\n        };\n      }\n      return {\n        x: box.x + box.width / 2,\n        y: box.y + box.height / 2\n      };\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page} to hover over the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async hover() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().mouse.move(x, y);\n    }\n    /**\n     * This method scrolls element into view if needed, and then\n     * uses {@link Page | Page.mouse} to click in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async click() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint(options.offset);\n      await this.frame.page().mouse.click(x, y, options);\n    }\n    /**\n     * Drags an element over the given element or point.\n     *\n     * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n     * returned.\n     */\n    async drag(target) {\n      await this.scrollIntoViewIfNeeded();\n      const page = this.frame.page();\n      if (page.isDragInterceptionEnabled()) {\n        const source = await this.clickablePoint();\n        if (target instanceof ElementHandle) {\n          target = await target.clickablePoint();\n        }\n        return await page.mouse.drag(source, target);\n      }\n      try {\n        if (!page._isDragging) {\n          page._isDragging = true;\n          await this.hover();\n          await page.mouse.down();\n        }\n        if (target instanceof ElementHandle) {\n          await target.hover();\n        } else {\n          await page.mouse.move(target.x, target.y);\n        }\n      } catch (error) {\n        page._isDragging = false;\n        throw error;\n      }\n    }\n    /**\n     * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n     */\n    async dragEnter() {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        items: [],\n        dragOperationsMask: 1\n      };\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragEnter(target, data);\n    }\n    /**\n     * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n     */\n    async dragOver() {\n      let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        items: [],\n        dragOperationsMask: 1\n      };\n      const page = this.frame.page();\n      await this.scrollIntoViewIfNeeded();\n      const target = await this.clickablePoint();\n      await page.mouse.dragOver(target, data);\n    }\n    /**\n     * @internal\n     */\n    async drop() {\n      let dataOrElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        items: [],\n        dragOperationsMask: 1\n      };\n      const page = this.frame.page();\n      if ('items' in dataOrElement) {\n        await this.scrollIntoViewIfNeeded();\n        const destination = await this.clickablePoint();\n        await page.mouse.drop(destination, dataOrElement);\n      } else {\n        // Note if the rest errors, we still want dragging off because the errors\n        // is most likely something implying the mouse is no longer dragging.\n        await dataOrElement.drag(this);\n        page._isDragging = false;\n        await page.mouse.up();\n      }\n    }\n    /**\n     * @deprecated Use `ElementHandle.drop` instead.\n     */\n    async dragAndDrop(target, options) {\n      const page = this.frame.page();\n      assert(page.isDragInterceptionEnabled(), 'Drag Interception is not enabled!');\n      await this.scrollIntoViewIfNeeded();\n      const startPoint = await this.clickablePoint();\n      const targetPoint = await target.clickablePoint();\n      await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n    }\n    /**\n     * Triggers a `change` and `input` event once all the provided options have been\n     * selected. If there's no `<select>` element matching `selector`, the method\n     * throws an error.\n     *\n     * @example\n     *\n     * ```ts\n     * handle.select('blue'); // single selection\n     * handle.select('red', 'green', 'blue'); // multiple selections\n     * ```\n     *\n     * @param values - Values of options to select. If the `<select>` has the\n     * `multiple` attribute, all values are considered, otherwise only the first\n     * one is taken into account.\n     */\n    async select() {\n      for (var _len7 = arguments.length, values = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n        values[_key7] = arguments[_key7];\n      }\n      for (const value of values) {\n        assert(isString(value), 'Values must be strings. Found value \"' + value + '\" of type \"' + typeof value + '\"');\n      }\n      return await this.evaluate((element, vals) => {\n        const values = new Set(vals);\n        if (!(element instanceof HTMLSelectElement)) {\n          throw new Error('Element is not a <select> element.');\n        }\n        const selectedValues = new Set();\n        if (!element.multiple) {\n          for (const option of element.options) {\n            option.selected = false;\n          }\n          for (const option of element.options) {\n            if (values.has(option.value)) {\n              option.selected = true;\n              selectedValues.add(option.value);\n              break;\n            }\n          }\n        } else {\n          for (const option of element.options) {\n            option.selected = values.has(option.value);\n            if (option.selected) {\n              selectedValues.add(option.value);\n            }\n          }\n        }\n        element.dispatchEvent(new Event('input', {\n          bubbles: true\n        }));\n        element.dispatchEvent(new Event('change', {\n          bubbles: true\n        }));\n        return [...selectedValues.values()];\n      }, values);\n    }\n    async uploadFile() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * This method scrolls element into view if needed, and then uses\n     * {@link Touchscreen.tap} to tap in the center of the element.\n     * If the element is detached from DOM, the method throws an error.\n     */\n    async tap() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.tap(x, y);\n    }\n    async touchStart() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.touchStart(x, y);\n    }\n    async touchMove() {\n      await this.scrollIntoViewIfNeeded();\n      const {\n        x,\n        y\n      } = await this.clickablePoint();\n      await this.frame.page().touchscreen.touchMove(x, y);\n    }\n    async touchEnd() {\n      await this.scrollIntoViewIfNeeded();\n      await this.frame.page().touchscreen.touchEnd();\n    }\n    /**\n     * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n     */\n    async focus() {\n      await this.evaluate(element => {\n        if (!(element instanceof HTMLElement)) {\n          throw new Error('Cannot focus non-HTMLElement');\n        }\n        return element.focus();\n      });\n    }\n    /**\n     * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n     * `keyup` event for each character in the text.\n     *\n     * To press a special key, like `Control` or `ArrowDown`,\n     * use {@link ElementHandle.press}.\n     *\n     * @example\n     *\n     * ```ts\n     * await elementHandle.type('Hello'); // Types instantly\n     * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n     * ```\n     *\n     * @example\n     * An example of typing into a text field and then submitting the form:\n     *\n     * ```ts\n     * const elementHandle = await page.$('input');\n     * await elementHandle.type('some text');\n     * await elementHandle.press('Enter');\n     * ```\n     *\n     * @param options - Delay in milliseconds. Defaults to 0.\n     */\n    async type(text, options) {\n      await this.focus();\n      await this.frame.page().keyboard.type(text, options);\n    }\n    /**\n     * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n     *\n     * @remarks\n     * If `key` is a single character and no modifier keys besides `Shift`\n     * are being held down, a `keypress`/`input` event will also be generated.\n     * The `text` option can be specified to force an input event to be generated.\n     *\n     * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n     * will type the text in upper case.\n     *\n     * @param key - Name of key to press, such as `ArrowLeft`.\n     * See {@link KeyInput} for a list of all key names.\n     */\n    async press(key, options) {\n      await this.focus();\n      await this.frame.page().keyboard.press(key, options);\n    }\n    async #clickableBox() {\n      const boxes = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        return [...element.getClientRects()].map(rect => {\n          return {\n            x: rect.x,\n            y: rect.y,\n            width: rect.width,\n            height: rect.height\n          };\n        });\n      });\n      if (!boxes?.length) {\n        return null;\n      }\n      await this.#intersectBoundingBoxesWithFrame(boxes);\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_4 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_4, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          for (const box of boxes) {\n            box.x += parentBox.left;\n            box.y += parentBox.top;\n          }\n          await handle.#intersectBoundingBoxesWithFrame(boxes);\n          frame = parentFrame;\n        } catch (e_4) {\n          env_4.error = e_4;\n          env_4.hasError = true;\n        } finally {\n          __disposeResources(env_4);\n        }\n      }\n      const box = boxes.find(box => {\n        return box.width >= 1 && box.height >= 1;\n      });\n      if (!box) {\n        return null;\n      }\n      return {\n        x: box.x,\n        y: box.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    async #intersectBoundingBoxesWithFrame(boxes) {\n      const {\n        documentWidth,\n        documentHeight\n      } = await this.frame.isolatedRealm().evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight\n        };\n      });\n      for (const box of boxes) {\n        intersectBoundingBox(box, documentWidth, documentHeight);\n      }\n    }\n    /**\n     * This method returns the bounding box of the element (relative to the main frame),\n     * or `null` if the element is not visible.\n     */\n    async boundingBox() {\n      const box = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        return {\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height\n        };\n      });\n      if (!box) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n        height: box.height,\n        width: box.width\n      };\n    }\n    /**\n     * This method returns boxes of the element, or `null` if the element is not visible.\n     *\n     * @remarks\n     *\n     * Boxes are represented as an array of points;\n     * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n     */\n    async boxModel() {\n      const model = await this.evaluate(element => {\n        if (!(element instanceof Element)) {\n          return null;\n        }\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        const offsets = {\n          padding: {\n            left: parseInt(style.paddingLeft, 10),\n            top: parseInt(style.paddingTop, 10),\n            right: parseInt(style.paddingRight, 10),\n            bottom: parseInt(style.paddingBottom, 10)\n          },\n          margin: {\n            left: -parseInt(style.marginLeft, 10),\n            top: -parseInt(style.marginTop, 10),\n            right: -parseInt(style.marginRight, 10),\n            bottom: -parseInt(style.marginBottom, 10)\n          },\n          border: {\n            left: parseInt(style.borderLeft, 10),\n            top: parseInt(style.borderTop, 10),\n            right: parseInt(style.borderRight, 10),\n            bottom: parseInt(style.borderBottom, 10)\n          }\n        };\n        const border = [{\n          x: rect.left,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top\n        }, {\n          x: rect.left + rect.width,\n          y: rect.top + rect.bottom\n        }, {\n          x: rect.left,\n          y: rect.top + rect.bottom\n        }];\n        const padding = transformQuadWithOffsets(border, offsets.border);\n        const content = transformQuadWithOffsets(padding, offsets.padding);\n        const margin = transformQuadWithOffsets(border, offsets.margin);\n        return {\n          content,\n          padding,\n          border,\n          margin,\n          width: rect.width,\n          height: rect.height\n        };\n        function transformQuadWithOffsets(quad, offsets) {\n          return [{\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top\n          }, {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top\n          }, {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom\n          }, {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom\n          }];\n        }\n      });\n      if (!model) {\n        return null;\n      }\n      const offset = await this.#getTopLeftCornerOfFrame();\n      if (!offset) {\n        return null;\n      }\n      for (const attribute of ['content', 'padding', 'border', 'margin']) {\n        for (const point of model[attribute]) {\n          point.x += offset.x;\n          point.y += offset.y;\n        }\n      }\n      return model;\n    }\n    async #getTopLeftCornerOfFrame() {\n      const point = {\n        x: 0,\n        y: 0\n      };\n      let frame = this.frame;\n      let parentFrame;\n      while (parentFrame = frame?.parentFrame()) {\n        const env_5 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_5, await frame.frameElement(), false);\n          if (!handle) {\n            throw new Error('Unsupported frame type');\n          }\n          const parentBox = await handle.evaluate(element => {\n            // Element is not visible.\n            if (element.getClientRects().length === 0) {\n              return null;\n            }\n            const rect = element.getBoundingClientRect();\n            const style = window.getComputedStyle(element);\n            return {\n              left: rect.left + parseInt(style.paddingLeft, 10) + parseInt(style.borderLeftWidth, 10),\n              top: rect.top + parseInt(style.paddingTop, 10) + parseInt(style.borderTopWidth, 10)\n            };\n          });\n          if (!parentBox) {\n            return null;\n          }\n          point.x += parentBox.left;\n          point.y += parentBox.top;\n          frame = parentFrame;\n        } catch (e_5) {\n          env_5.error = e_5;\n          env_5.hasError = true;\n        } finally {\n          __disposeResources(env_5);\n        }\n      }\n      return point;\n    }\n    async screenshot() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const env_6 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const {\n          scrollIntoView = true,\n          captureBeyondViewport = true,\n          allowViewportExpansion = captureBeyondViewport\n        } = options;\n        let clip = await this.#nonEmptyVisibleBoundingBox();\n        const page = this.frame.page();\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const _ = __addDisposableResource(env_6, allowViewportExpansion && clip ? await page._createTemporaryViewportContainingBox(clip) : null, true);\n        if (scrollIntoView) {\n          await this.scrollIntoViewIfNeeded();\n          // We measure again just in case.\n          clip = await this.#nonEmptyVisibleBoundingBox();\n        }\n        const [pageLeft, pageTop] = await this.evaluate(() => {\n          if (!window.visualViewport) {\n            throw new Error('window.visualViewport is not supported.');\n          }\n          return [window.visualViewport.pageLeft, window.visualViewport.pageTop];\n        });\n        clip.x += pageLeft;\n        clip.y += pageTop;\n        return await page.screenshot({\n          ...options,\n          captureBeyondViewport: false,\n          clip\n        });\n      } catch (e_6) {\n        env_6.error = e_6;\n        env_6.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_6);\n        if (result_1) await result_1;\n      }\n    }\n    async #nonEmptyVisibleBoundingBox() {\n      const box = await this.boundingBox();\n      assert(box, 'Node is either not visible or not an HTMLElement');\n      assert(box.width !== 0, 'Node has 0 width.');\n      assert(box.height !== 0, 'Node has 0 height.');\n      return box;\n    }\n    /**\n     * @internal\n     */\n    async assertConnectedElement() {\n      const error = await this.evaluate(async element => {\n        if (!element.isConnected) {\n          return 'Node is detached from document';\n        }\n        if (element.nodeType !== Node.ELEMENT_NODE) {\n          return 'Node is not of type HTMLElement';\n        }\n        return;\n      });\n      if (error) {\n        throw new Error(error);\n      }\n    }\n    /**\n     * @internal\n     */\n    async scrollIntoViewIfNeeded() {\n      if (await this.isIntersectingViewport({\n        threshold: 1\n      })) {\n        return;\n      }\n      await this.scrollIntoView();\n    }\n    /**\n     * Resolves to true if the element is visible in the current viewport. If an\n     * element is an SVG, we check if the svg owner element is in the viewport\n     * instead. See https://crbug.com/963246.\n     *\n     * @param options - Threshold for the intersection between 0 (no intersection) and 1\n     * (full intersection). Defaults to 1.\n     */\n    async isIntersectingViewport() {\n      let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      const env_7 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        await this.assertConnectedElement();\n        // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n        const handle = await this.#asSVGElementHandle();\n        const target = __addDisposableResource(env_7, handle && (await handle.#getOwnerSVGElement()), false);\n        return await (target ?? this).evaluate(async (element, threshold) => {\n          const visibleRatio = await new Promise(resolve => {\n            const observer = new IntersectionObserver(entries => {\n              resolve(entries[0].intersectionRatio);\n              observer.disconnect();\n            });\n            observer.observe(element);\n          });\n          return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n        }, options.threshold ?? 0);\n      } catch (e_7) {\n        env_7.error = e_7;\n        env_7.hasError = true;\n      } finally {\n        __disposeResources(env_7);\n      }\n    }\n    /**\n     * Scrolls the element into view using either the automation protocol client\n     * or by calling element.scrollIntoView.\n     */\n    async scrollIntoView() {\n      await this.assertConnectedElement();\n      await this.evaluate(async element => {\n        element.scrollIntoView({\n          block: 'center',\n          inline: 'center',\n          behavior: 'instant'\n        });\n      });\n    }\n    /**\n     * Returns true if an element is an SVGElement (included svg, path, rect\n     * etc.).\n     */\n    async #asSVGElementHandle() {\n      if (await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })) {\n        return this;\n      } else {\n        return null;\n      }\n    }\n    async #getOwnerSVGElement() {\n      // SVGSVGElement.ownerSVGElement === null.\n      return await this.evaluateHandle(element => {\n        if (element instanceof SVGSVGElement) {\n          return element;\n        }\n        return element.ownerSVGElement;\n      });\n    }\n  };\n})();\nexport { ElementHandle };\nfunction intersectBoundingBox(box, width, height) {\n  box.width = Math.max(box.x >= 0 ? Math.min(width - box.x, box.width) : Math.min(width, box.width + box.x), 0);\n  box.height = Math.max(box.y >= 0 ? Math.min(height - box.y, box.height) : Math.min(height, box.height + box.y), 0);\n}","map":{"version":3,"mappings":"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","names":["getQueryHandlerAndSelector","LazyArg","isString","withSourcePuppeteerURLIfNone","assert","AsyncIterableUtil","throwIfDisposed","_isElementHandle","JSHandle","ElementHandle","_classSuper","bindIsolatedHandle","__esDecorate","kind","name","static","private","access","has","get","getProperty","metadata","getProperties","jsonValue","$","$$","$x","waitForSelector","isVisible","isHidden","waitForXPath","toElement","clickablePoint","hover","click","drag","dragEnter","dragOver","drop","dragAndDrop","select","tap","touchStart","touchMove","touchEnd","focus","type","press","boundingBox","boxModel","screenshot","isIntersectingViewport","scrollIntoView","target","_","args","realm","frame","isolatedRealm","call","adoptedThis","adoptHandle","result","transferHandle","Array","isArray","Promise","all","map","item","index","Map","entries","key","value","set","handle","constructor","id","disposed","propertyName","evaluate","pageFunction","evaluateHandle","toString","remoteObject","dispose","asElement","selector","updatedSelector","QueryHandler","queryOne","collect","queryAll","$eval","elementHandle","Error","$$eval","results","elements","expression","startsWith","options","waitFor","visibility","element","PuppeteerUtil","Boolean","checkVisibility","create","context","puppeteerUtil","xpath","tagName","isMatchingTagName","node","nodeName","toUpperCase","offset","box","undefined","x","y","width","height","scrollIntoViewIfNeeded","page","mouse","move","isDragInterceptionEnabled","source","_isDragging","down","error","data","items","dragOperationsMask","dataOrElement","destination","up","startPoint","targetPoint","values","vals","Set","HTMLSelectElement","selectedValues","multiple","option","selected","add","dispatchEvent","Event","bubbles","uploadFile","touchscreen","HTMLElement","text","keyboard","boxes","Element","getClientRects","rect","length","parentFrame","frameElement","parentBox","getBoundingClientRect","style","window","getComputedStyle","left","parseInt","paddingLeft","borderLeftWidth","top","paddingTop","borderTopWidth","find","documentWidth","documentHeight","document","documentElement","clientWidth","clientHeight","intersectBoundingBox","model","offsets","padding","right","paddingRight","bottom","paddingBottom","margin","marginLeft","marginTop","marginRight","marginBottom","border","borderLeft","borderTop","borderRight","borderBottom","transformQuadWithOffsets","content","quad","attribute","point","captureBeyondViewport","allowViewportExpansion","clip","_createTemporaryViewportContainingBox","pageLeft","pageTop","visualViewport","assertConnectedElement","isConnected","nodeType","Node","ELEMENT_NODE","threshold","visibleRatio","resolve","observer","IntersectionObserver","intersectionRatio","disconnect","observe","block","inline","behavior","SVGElement","SVGSVGElement","ownerSVGElement","Math","max","min"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\api\\ElementHandle.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {Frame} from '../api/Frame.js';\nimport {getQueryHandlerAndSelector} from '../common/GetQueryHandler.js';\nimport {LazyArg} from '../common/LazyArg.js';\nimport type {\n  ElementFor,\n  EvaluateFuncWith,\n  HandleFor,\n  HandleOr,\n  NodeFor,\n} from '../common/types.js';\nimport type {KeyInput} from '../common/USKeyboardLayout.js';\nimport {isString, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {AsyncIterableUtil} from '../util/AsyncIterableUtil.js';\nimport {throwIfDisposed} from '../util/decorators.js';\n\nimport {_isElementHandle} from './ElementHandleSymbol.js';\nimport type {\n  KeyboardTypeOptions,\n  KeyPressOptions,\n  MouseClickOptions,\n} from './Input.js';\nimport {JSHandle} from './JSHandle.js';\nimport type {ScreenshotOptions, WaitForSelectorOptions} from './Page.js';\n\n/**\n * @public\n */\nexport type Quad = [Point, Point, Point, Point];\n\n/**\n * @public\n */\nexport interface BoxModel {\n  content: Quad;\n  padding: Quad;\n  border: Quad;\n  margin: Quad;\n  width: number;\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface BoundingBox extends Point {\n  /**\n   * the width of the element in pixels.\n   */\n  width: number;\n  /**\n   * the height of the element in pixels.\n   */\n  height: number;\n}\n\n/**\n * @public\n */\nexport interface Offset {\n  /**\n   * x-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  x: number;\n  /**\n   * y-offset for the clickable point relative to the top-left corner of the border box.\n   */\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ClickOptions extends MouseClickOptions {\n  /**\n   * Offset for the clickable point relative to the top-left corner of the border box.\n   */\n  offset?: Offset;\n}\n\n/**\n * @public\n */\nexport interface Point {\n  x: number;\n  y: number;\n}\n\n/**\n * @public\n */\nexport interface ElementScreenshotOptions extends ScreenshotOptions {\n  /**\n   * @defaultValue true\n   */\n  scrollIntoView?: boolean;\n}\n\n/**\n * ElementHandle represents an in-page DOM element.\n *\n * @remarks\n * ElementHandles can be created with the {@link Page.$} method.\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * (async () => {\n *   const browser = await puppeteer.launch();\n *   const page = await browser.newPage();\n *   await page.goto('https://example.com');\n *   const hrefElement = await page.$('a');\n *   await hrefElement.click();\n *   // ...\n * })();\n * ```\n *\n * ElementHandle prevents the DOM element from being garbage-collected unless the\n * handle is {@link JSHandle.dispose | disposed}. ElementHandles are auto-disposed\n * when their origin frame gets navigated.\n *\n * ElementHandle instances can be used as arguments in {@link Page.$eval} and\n * {@link Page.evaluate} methods.\n *\n * If you're using TypeScript, ElementHandle takes a generic argument that\n * denotes the type of element the handle is holding within. For example, if you\n * have a handle to a `<select>` element, you can type it as\n * `ElementHandle<HTMLSelectElement>` and you get some nicer type checks.\n *\n * @public\n */\nexport abstract class ElementHandle<\n  ElementType extends Node = Element,\n> extends JSHandle<ElementType> {\n  /**\n   * @internal\n   */\n  declare [_isElementHandle]: boolean;\n\n  /**\n   * A given method will have it's `this` replaced with an isolated version of\n   * `this` when decorated with this decorator.\n   *\n   * All changes of isolated `this` are reflected on the actual `this`.\n   *\n   * @internal\n   */\n  static bindIsolatedHandle<This extends ElementHandle<Node>>(\n    target: (this: This, ...args: any[]) => Promise<any>,\n    _: unknown\n  ): typeof target {\n    return async function (...args) {\n      // If the handle is already isolated, then we don't need to adopt it\n      // again.\n      if (this.realm === this.frame.isolatedRealm()) {\n        return await target.call(this, ...args);\n      }\n      using adoptedThis = await this.frame.isolatedRealm().adoptHandle(this);\n      const result = await target.call(adoptedThis, ...args);\n      // If the function returns `adoptedThis`, then we return `this`.\n      if (result === adoptedThis) {\n        return this;\n      }\n      // If the function returns a handle, transfer it into the current realm.\n      if (result instanceof JSHandle) {\n        return await this.realm.transferHandle(result);\n      }\n      // If the function returns an array of handlers, transfer them into the\n      // current realm.\n      if (Array.isArray(result)) {\n        await Promise.all(\n          result.map(async (item, index, result) => {\n            if (item instanceof JSHandle) {\n              result[index] = await this.realm.transferHandle(item);\n            }\n          })\n        );\n      }\n      if (result instanceof Map) {\n        await Promise.all(\n          [...result.entries()].map(async ([key, value]) => {\n            if (value instanceof JSHandle) {\n              result.set(key, await this.realm.transferHandle(value));\n            }\n          })\n        );\n      }\n      return result;\n    };\n  }\n\n  /**\n   * @internal\n   */\n  protected readonly handle;\n\n  /**\n   * @internal\n   */\n  constructor(handle: JSHandle<ElementType>) {\n    super();\n    this.handle = handle;\n    this[_isElementHandle] = true;\n  }\n\n  /**\n   * @internal\n   */\n  override get id(): string | undefined {\n    return this.handle.id;\n  }\n\n  /**\n   * @internal\n   */\n  override get disposed(): boolean {\n    return this.handle.disposed;\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async getProperty<K extends keyof ElementType>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<ElementType[K]>> {\n    return await this.handle.getProperty(propertyName);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async getProperties(): Promise<Map<string, JSHandle>> {\n    return await this.handle.getProperties();\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.handle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  override async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<ElementType, Params> = EvaluateFuncWith<\n      ElementType,\n      Params\n    >,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.handle.evaluateHandle(pageFunction, ...args);\n  }\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  override async jsonValue(): Promise<ElementType> {\n    return await this.handle.jsonValue();\n  }\n\n  /**\n   * @internal\n   */\n  override toString(): string {\n    return this.handle.toString();\n  }\n\n  /**\n   * @internal\n   */\n  override remoteObject(): Protocol.Runtime.RemoteObject {\n    return this.handle.remoteObject();\n  }\n\n  /**\n   * @internal\n   */\n  override dispose(): Promise<void> {\n    return this.handle.dispose();\n  }\n\n  /**\n   * @internal\n   */\n  override asElement(): ElementHandle<ElementType> {\n    return this;\n  }\n\n  /**\n   * Frame corresponding to the current handle.\n   */\n  abstract get frame(): Frame;\n\n  /**\n   * Queries the current element for an element matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns A {@link ElementHandle | element handle} to the first element\n   * matching the given selector. Otherwise, `null`.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async $<Selector extends string>(\n    selector: Selector\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.queryOne(\n      this,\n      updatedSelector\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  /**\n   * Queries the current element for all elements matching the given selector.\n   *\n   * @param selector - The selector to query for.\n   * @returns An array of {@link ElementHandle | element handles} that point to\n   * elements matching the given selector.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async $$<Selector extends string>(\n    selector: Selector\n  ): Promise<Array<ElementHandle<NodeFor<Selector>>>> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return await (AsyncIterableUtil.collect(\n      QueryHandler.queryAll(this, updatedSelector)\n    ) as Promise<Array<ElementHandle<NodeFor<Selector>>>>);\n  }\n\n  /**\n   * Runs the given function on the first element matching the given selector in\n   * the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   *\n   * ```ts\n   * const tweetHandle = await page.$('.tweet');\n   * expect(await tweetHandle.$eval('.like', node => node.innerText)).toBe(\n   *   '100'\n   * );\n   * expect(await tweetHandle.$eval('.retweets', node => node.innerText)).toBe(\n   *   '10'\n   * );\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in this element's page's\n   * context. The first element matching the selector will be passed in as the\n   * first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<NodeFor<Selector>, Params> = EvaluateFuncWith<\n      NodeFor<Selector>,\n      Params\n    >,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$eval.name, pageFunction);\n    using elementHandle = await this.$(selector);\n    if (!elementHandle) {\n      throw new Error(\n        `Error: failed to find element matching selector \"${selector}\"`\n      );\n    }\n    return await elementHandle.evaluate(pageFunction, ...args);\n  }\n\n  /**\n   * Runs the given function on an array of elements matching the given selector\n   * in the current element.\n   *\n   * If the given function returns a promise, then this method will wait till\n   * the promise resolves.\n   *\n   * @example\n   * HTML:\n   *\n   * ```html\n   * <div class=\"feed\">\n   *   <div class=\"tweet\">Hello!</div>\n   *   <div class=\"tweet\">Hi!</div>\n   * </div>\n   * ```\n   *\n   * JavaScript:\n   *\n   * ```js\n   * const feedHandle = await page.$('.feed');\n   * expect(\n   *   await feedHandle.$$eval('.tweet', nodes => nodes.map(n => n.innerText))\n   * ).toEqual(['Hello!', 'Hi!']);\n   * ```\n   *\n   * @param selector - The selector to query for.\n   * @param pageFunction - The function to be evaluated in the element's page's\n   * context. An array of elements matching the given selector will be passed to\n   * the function as its first argument.\n   * @param args - Additional arguments to pass to `pageFunction`.\n   * @returns A promise to the result of the function.\n   */\n  async $$eval<\n    Selector extends string,\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<\n      Array<NodeFor<Selector>>,\n      Params\n    > = EvaluateFuncWith<Array<NodeFor<Selector>>, Params>,\n  >(\n    selector: Selector,\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(this.$$eval.name, pageFunction);\n    const results = await this.$$(selector);\n    using elements = await this.evaluateHandle(\n      (_, ...elements) => {\n        return elements;\n      },\n      ...results\n    );\n    const [result] = await Promise.all([\n      elements.evaluate(pageFunction, ...args),\n      ...results.map(results => {\n        return results.dispose();\n      }),\n    ]);\n    return result;\n  }\n\n  /**\n   * @deprecated Use {@link ElementHandle.$$} with the `xpath` prefix.\n   *\n   * Example: `await elementHandle.$$('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the elementHandle.\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * If there are no such elements, the method will resolve to an empty array.\n   * @param expression - Expression to {@link https://developer.mozilla.org/en-US/docs/Web/API/Document/evaluate | evaluate}\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async $x(expression: string): Promise<Array<ElementHandle<Node>>> {\n    if (expression.startsWith('//')) {\n      expression = `.${expression}`;\n    }\n    return await this.$$(`xpath/${expression}`);\n  }\n\n  /**\n   * Wait for an element matching the given selector to appear in the current\n   * element.\n   *\n   * Unlike {@link Frame.waitForSelector}, this method does not work across\n   * navigations or if the element is detached from DOM.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .mainFrame()\n   *     .waitForSelector('img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param selector - The selector to query and wait for.\n   * @param options - Options for customizing waiting behavior.\n   * @returns An element matching the given selector.\n   * @throws Throws if an element matching the given selector doesn't appear.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async waitForSelector<Selector extends string>(\n    selector: Selector,\n    options: WaitForSelectorOptions = {}\n  ): Promise<ElementHandle<NodeFor<Selector>> | null> {\n    const {updatedSelector, QueryHandler} =\n      getQueryHandlerAndSelector(selector);\n    return (await QueryHandler.waitFor(\n      this,\n      updatedSelector,\n      options\n    )) as ElementHandle<NodeFor<Selector>> | null;\n  }\n\n  async #checkVisibility(visibility: boolean): Promise<boolean> {\n    return await this.evaluate(\n      async (element, PuppeteerUtil, visibility) => {\n        return Boolean(PuppeteerUtil.checkVisibility(element, visibility));\n      },\n      LazyArg.create(context => {\n        return context.puppeteerUtil;\n      }),\n      visibility\n    );\n  }\n\n  /**\n   * Checks if an element is visible using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isVisible(): Promise<boolean> {\n    return await this.#checkVisibility(true);\n  }\n\n  /**\n   * Checks if an element is hidden using the same mechanism as\n   * {@link ElementHandle.waitForSelector}.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isHidden(): Promise<boolean> {\n    return await this.#checkVisibility(false);\n  }\n\n  /**\n   * @deprecated Use {@link ElementHandle.waitForSelector} with the `xpath`\n   * prefix.\n   *\n   * Example: `await elementHandle.waitForSelector('xpath/' + xpathExpression)`\n   *\n   * The method evaluates the XPath expression relative to the elementHandle.\n   *\n   * Wait for the `xpath` within the element. If at the moment of calling the\n   * method the `xpath` already exists, the method will return immediately. If\n   * the `xpath` doesn't appear after the `timeout` milliseconds of waiting, the\n   * function will throw.\n   *\n   * If `xpath` starts with `//` instead of `.//`, the dot will be appended\n   * automatically.\n   *\n   * @example\n   * This method works across navigation.\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   * (async () => {\n   *   const browser = await puppeteer.launch();\n   *   const page = await browser.newPage();\n   *   let currentURL;\n   *   page\n   *     .waitForXPath('//img')\n   *     .then(() => console.log('First URL with image: ' + currentURL));\n   *   for (currentURL of [\n   *     'https://example.com',\n   *     'https://google.com',\n   *     'https://bbc.com',\n   *   ]) {\n   *     await page.goto(currentURL);\n   *   }\n   *   await browser.close();\n   * })();\n   * ```\n   *\n   * @param xpath - A\n   * {@link https://developer.mozilla.org/en-US/docs/Web/XPath | xpath} of an\n   * element to wait for\n   * @param options - Optional waiting parameters\n   * @returns Promise which resolves when element specified by xpath string is\n   * added to DOM. Resolves to `null` if waiting for `hidden: true` and xpath is\n   * not found in DOM, otherwise resolves to `ElementHandle`.\n   * @remarks\n   * The optional Argument `options` have properties:\n   *\n   * - `visible`: A boolean to wait for element to be present in DOM and to be\n   *   visible, i.e. to not have `display: none` or `visibility: hidden` CSS\n   *   properties. Defaults to `false`.\n   *\n   * - `hidden`: A boolean wait for element to not be found in the DOM or to be\n   *   hidden, i.e. have `display: none` or `visibility: hidden` CSS properties.\n   *   Defaults to `false`.\n   *\n   * - `timeout`: A number which is maximum time to wait for in milliseconds.\n   *   Defaults to `30000` (30 seconds). Pass `0` to disable timeout. The\n   *   default value can be changed by using the {@link Page.setDefaultTimeout}\n   *   method.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async waitForXPath(\n    xpath: string,\n    options: {\n      visible?: boolean;\n      hidden?: boolean;\n      timeout?: number;\n    } = {}\n  ): Promise<ElementHandle<Node> | null> {\n    if (xpath.startsWith('//')) {\n      xpath = `.${xpath}`;\n    }\n    return await this.waitForSelector(`xpath/${xpath}`, options);\n  }\n\n  /**\n   * Converts the current handle to the given element type.\n   *\n   * @example\n   *\n   * ```ts\n   * const element: ElementHandle<Element> = await page.$(\n   *   '.class-name-of-anchor'\n   * );\n   * // DO NOT DISPOSE `element`, this will be always be the same handle.\n   * const anchor: ElementHandle<HTMLAnchorElement> =\n   *   await element.toElement('a');\n   * ```\n   *\n   * @param tagName - The tag name of the desired element type.\n   * @throws An error if the handle does not match. **The handle will not be\n   * automatically disposed.**\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async toElement<\n    K extends keyof HTMLElementTagNameMap | keyof SVGElementTagNameMap,\n  >(tagName: K): Promise<HandleFor<ElementFor<K>>> {\n    const isMatchingTagName = await this.evaluate((node, tagName) => {\n      return node.nodeName === tagName.toUpperCase();\n    }, tagName);\n    if (!isMatchingTagName) {\n      throw new Error(`Element is not a(n) \\`${tagName}\\` element`);\n    }\n    return this as unknown as HandleFor<ElementFor<K>>;\n  }\n\n  /**\n   * Resolves the frame associated with the element, if any. Always exists for\n   * HTMLIFrameElements.\n   */\n  abstract contentFrame(this: ElementHandle<HTMLIFrameElement>): Promise<Frame>;\n  abstract contentFrame(): Promise<Frame | null>;\n\n  /**\n   * Returns the middle point within an element unless a specific offset is provided.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async clickablePoint(offset?: Offset): Promise<Point> {\n    const box = await this.#clickableBox();\n    if (!box) {\n      throw new Error('Node is either not clickable or not an Element');\n    }\n    if (offset !== undefined) {\n      return {\n        x: box.x + offset.x,\n        y: box.y + offset.y,\n      };\n    }\n    return {\n      x: box.x + box.width / 2,\n      y: box.y + box.height / 2,\n    };\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page} to hover over the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async hover(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().mouse.move(x, y);\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then\n   * uses {@link Page | Page.mouse} to click in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async click(\n    this: ElementHandle<Element>,\n    options: Readonly<ClickOptions> = {}\n  ): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint(options.offset);\n    await this.frame.page().mouse.click(x, y, options);\n  }\n\n  /**\n   * Drags an element over the given element or point.\n   *\n   * @returns DEPRECATED. When drag interception is enabled, the drag payload is\n   * returned.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async drag(\n    this: ElementHandle<Element>,\n    target: Point | ElementHandle<Element>\n  ): Promise<Protocol.Input.DragData | void> {\n    await this.scrollIntoViewIfNeeded();\n    const page = this.frame.page();\n    if (page.isDragInterceptionEnabled()) {\n      const source = await this.clickablePoint();\n      if (target instanceof ElementHandle) {\n        target = await target.clickablePoint();\n      }\n      return await page.mouse.drag(source, target);\n    }\n    try {\n      if (!page._isDragging) {\n        page._isDragging = true;\n        await this.hover();\n        await page.mouse.down();\n      }\n      if (target instanceof ElementHandle) {\n        await target.hover();\n      } else {\n        await page.mouse.move(target.x, target.y);\n      }\n    } catch (error) {\n      page._isDragging = false;\n      throw error;\n    }\n  }\n\n  /**\n   * @deprecated Do not use. `dragenter` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragEnter(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragEnter(target, data);\n  }\n\n  /**\n   * @deprecated Do not use. `dragover` will automatically be performed during dragging.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragOver(\n    this: ElementHandle<Element>,\n    data: Protocol.Input.DragData = {items: [], dragOperationsMask: 1}\n  ): Promise<void> {\n    const page = this.frame.page();\n    await this.scrollIntoViewIfNeeded();\n    const target = await this.clickablePoint();\n    await page.mouse.dragOver(target, data);\n  }\n\n  /**\n   * Drops the given element onto the current one.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    element: ElementHandle<Element>\n  ): Promise<void>;\n\n  /**\n   * @deprecated No longer supported.\n   */\n  async drop(\n    this: ElementHandle<Element>,\n    data?: Protocol.Input.DragData\n  ): Promise<void>;\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async drop(\n    this: ElementHandle<Element>,\n    dataOrElement: ElementHandle<Element> | Protocol.Input.DragData = {\n      items: [],\n      dragOperationsMask: 1,\n    }\n  ): Promise<void> {\n    const page = this.frame.page();\n    if ('items' in dataOrElement) {\n      await this.scrollIntoViewIfNeeded();\n      const destination = await this.clickablePoint();\n      await page.mouse.drop(destination, dataOrElement);\n    } else {\n      // Note if the rest errors, we still want dragging off because the errors\n      // is most likely something implying the mouse is no longer dragging.\n      await dataOrElement.drag(this);\n      page._isDragging = false;\n      await page.mouse.up();\n    }\n  }\n\n  /**\n   * @deprecated Use `ElementHandle.drop` instead.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async dragAndDrop(\n    this: ElementHandle<Element>,\n    target: ElementHandle<Node>,\n    options?: {delay: number}\n  ): Promise<void> {\n    const page = this.frame.page();\n    assert(\n      page.isDragInterceptionEnabled(),\n      'Drag Interception is not enabled!'\n    );\n    await this.scrollIntoViewIfNeeded();\n    const startPoint = await this.clickablePoint();\n    const targetPoint = await target.clickablePoint();\n    await page.mouse.dragAndDrop(startPoint, targetPoint, options);\n  }\n\n  /**\n   * Triggers a `change` and `input` event once all the provided options have been\n   * selected. If there's no `<select>` element matching `selector`, the method\n   * throws an error.\n   *\n   * @example\n   *\n   * ```ts\n   * handle.select('blue'); // single selection\n   * handle.select('red', 'green', 'blue'); // multiple selections\n   * ```\n   *\n   * @param values - Values of options to select. If the `<select>` has the\n   * `multiple` attribute, all values are considered, otherwise only the first\n   * one is taken into account.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async select(...values: string[]): Promise<string[]> {\n    for (const value of values) {\n      assert(\n        isString(value),\n        'Values must be strings. Found value \"' +\n          value +\n          '\" of type \"' +\n          typeof value +\n          '\"'\n      );\n    }\n\n    return await this.evaluate((element, vals): string[] => {\n      const values = new Set(vals);\n      if (!(element instanceof HTMLSelectElement)) {\n        throw new Error('Element is not a <select> element.');\n      }\n\n      const selectedValues = new Set<string>();\n      if (!element.multiple) {\n        for (const option of element.options) {\n          option.selected = false;\n        }\n        for (const option of element.options) {\n          if (values.has(option.value)) {\n            option.selected = true;\n            selectedValues.add(option.value);\n            break;\n          }\n        }\n      } else {\n        for (const option of element.options) {\n          option.selected = values.has(option.value);\n          if (option.selected) {\n            selectedValues.add(option.value);\n          }\n        }\n      }\n      element.dispatchEvent(new Event('input', {bubbles: true}));\n      element.dispatchEvent(new Event('change', {bubbles: true}));\n      return [...selectedValues.values()];\n    }, values);\n  }\n\n  /**\n   * Sets the value of an\n   * {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input | input element}\n   * to the given file paths.\n   *\n   * @remarks This will not validate whether the file paths exists. Also, if a\n   * path is relative, then it is resolved against the\n   * {@link https://nodejs.org/api/process.html#process_process_cwd | current working directory}.\n   * For locals script connecting to remote chrome environments, paths must be\n   * absolute.\n   */\n  async uploadFile(\n    this: ElementHandle<HTMLInputElement>,\n    ...paths: string[]\n  ): Promise<void>;\n  async uploadFile(this: ElementHandle<HTMLInputElement>): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Touchscreen.tap} to tap in the center of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async tap(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.tap(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchStart(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.touchStart(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchMove(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    const {x, y} = await this.clickablePoint();\n    await this.frame.page().touchscreen.touchMove(x, y);\n  }\n\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async touchEnd(this: ElementHandle<Element>): Promise<void> {\n    await this.scrollIntoViewIfNeeded();\n    await this.frame.page().touchscreen.touchEnd();\n  }\n\n  /**\n   * Calls {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/focus | focus} on the element.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async focus(): Promise<void> {\n    await this.evaluate(element => {\n      if (!(element instanceof HTMLElement)) {\n        throw new Error('Cannot focus non-HTMLElement');\n      }\n      return element.focus();\n    });\n  }\n\n  /**\n   * Focuses the element, and then sends a `keydown`, `keypress`/`input`, and\n   * `keyup` event for each character in the text.\n   *\n   * To press a special key, like `Control` or `ArrowDown`,\n   * use {@link ElementHandle.press}.\n   *\n   * @example\n   *\n   * ```ts\n   * await elementHandle.type('Hello'); // Types instantly\n   * await elementHandle.type('World', {delay: 100}); // Types slower, like a user\n   * ```\n   *\n   * @example\n   * An example of typing into a text field and then submitting the form:\n   *\n   * ```ts\n   * const elementHandle = await page.$('input');\n   * await elementHandle.type('some text');\n   * await elementHandle.press('Enter');\n   * ```\n   *\n   * @param options - Delay in milliseconds. Defaults to 0.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async type(\n    text: string,\n    options?: Readonly<KeyboardTypeOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.type(text, options);\n  }\n\n  /**\n   * Focuses the element, and then uses {@link Keyboard.down} and {@link Keyboard.up}.\n   *\n   * @remarks\n   * If `key` is a single character and no modifier keys besides `Shift`\n   * are being held down, a `keypress`/`input` event will also be generated.\n   * The `text` option can be specified to force an input event to be generated.\n   *\n   * **NOTE** Modifier keys DO affect `elementHandle.press`. Holding down `Shift`\n   * will type the text in upper case.\n   *\n   * @param key - Name of key to press, such as `ArrowLeft`.\n   * See {@link KeyInput} for a list of all key names.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async press(\n    key: KeyInput,\n    options?: Readonly<KeyPressOptions>\n  ): Promise<void> {\n    await this.focus();\n    await this.frame.page().keyboard.press(key, options);\n  }\n\n  async #clickableBox(): Promise<BoundingBox | null> {\n    const boxes = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      return [...element.getClientRects()].map(rect => {\n        return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n      });\n    });\n    if (!boxes?.length) {\n      return null;\n    }\n    await this.#intersectBoundingBoxesWithFrame(boxes);\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      for (const box of boxes) {\n        box.x += parentBox.left;\n        box.y += parentBox.top;\n      }\n      await handle.#intersectBoundingBoxesWithFrame(boxes);\n      frame = parentFrame;\n    }\n    const box = boxes.find(box => {\n      return box.width >= 1 && box.height >= 1;\n    });\n    if (!box) {\n      return null;\n    }\n    return {\n      x: box.x,\n      y: box.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  async #intersectBoundingBoxesWithFrame(boxes: BoundingBox[]) {\n    const {documentWidth, documentHeight} = await this.frame\n      .isolatedRealm()\n      .evaluate(() => {\n        return {\n          documentWidth: document.documentElement.clientWidth,\n          documentHeight: document.documentElement.clientHeight,\n        };\n      });\n    for (const box of boxes) {\n      intersectBoundingBox(box, documentWidth, documentHeight);\n    }\n  }\n\n  /**\n   * This method returns the bounding box of the element (relative to the main frame),\n   * or `null` if the element is not visible.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async boundingBox(): Promise<BoundingBox | null> {\n    const box = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      return {x: rect.x, y: rect.y, width: rect.width, height: rect.height};\n    });\n    if (!box) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    return {\n      x: box.x + offset.x,\n      y: box.y + offset.y,\n      height: box.height,\n      width: box.width,\n    };\n  }\n\n  /**\n   * This method returns boxes of the element, or `null` if the element is not visible.\n   *\n   * @remarks\n   *\n   * Boxes are represented as an array of points;\n   * Each Point is an object `{x, y}`. Box points are sorted clock-wise.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async boxModel(): Promise<BoxModel | null> {\n    const model = await this.evaluate(element => {\n      if (!(element instanceof Element)) {\n        return null;\n      }\n      // Element is not visible.\n      if (element.getClientRects().length === 0) {\n        return null;\n      }\n      const rect = element.getBoundingClientRect();\n      const style = window.getComputedStyle(element);\n      const offsets = {\n        padding: {\n          left: parseInt(style.paddingLeft, 10),\n          top: parseInt(style.paddingTop, 10),\n          right: parseInt(style.paddingRight, 10),\n          bottom: parseInt(style.paddingBottom, 10),\n        },\n        margin: {\n          left: -parseInt(style.marginLeft, 10),\n          top: -parseInt(style.marginTop, 10),\n          right: -parseInt(style.marginRight, 10),\n          bottom: -parseInt(style.marginBottom, 10),\n        },\n        border: {\n          left: parseInt(style.borderLeft, 10),\n          top: parseInt(style.borderTop, 10),\n          right: parseInt(style.borderRight, 10),\n          bottom: parseInt(style.borderBottom, 10),\n        },\n      };\n      const border: Quad = [\n        {x: rect.left, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top},\n        {x: rect.left + rect.width, y: rect.top + rect.bottom},\n        {x: rect.left, y: rect.top + rect.bottom},\n      ];\n      const padding = transformQuadWithOffsets(border, offsets.border);\n      const content = transformQuadWithOffsets(padding, offsets.padding);\n      const margin = transformQuadWithOffsets(border, offsets.margin);\n      return {\n        content,\n        padding,\n        border,\n        margin,\n        width: rect.width,\n        height: rect.height,\n      };\n\n      function transformQuadWithOffsets(\n        quad: Quad,\n        offsets: {top: number; left: number; right: number; bottom: number}\n      ): Quad {\n        return [\n          {\n            x: quad[0].x + offsets.left,\n            y: quad[0].y + offsets.top,\n          },\n          {\n            x: quad[1].x - offsets.right,\n            y: quad[1].y + offsets.top,\n          },\n          {\n            x: quad[2].x - offsets.right,\n            y: quad[2].y - offsets.bottom,\n          },\n          {\n            x: quad[3].x + offsets.left,\n            y: quad[3].y - offsets.bottom,\n          },\n        ];\n      }\n    });\n    if (!model) {\n      return null;\n    }\n    const offset = await this.#getTopLeftCornerOfFrame();\n    if (!offset) {\n      return null;\n    }\n    for (const attribute of [\n      'content',\n      'padding',\n      'border',\n      'margin',\n    ] as const) {\n      for (const point of model[attribute]) {\n        point.x += offset.x;\n        point.y += offset.y;\n      }\n    }\n    return model;\n  }\n\n  async #getTopLeftCornerOfFrame() {\n    const point = {x: 0, y: 0};\n    let frame = this.frame;\n    let parentFrame: Frame | null | undefined;\n    while ((parentFrame = frame?.parentFrame())) {\n      using handle = await frame.frameElement();\n      if (!handle) {\n        throw new Error('Unsupported frame type');\n      }\n      const parentBox = await handle.evaluate(element => {\n        // Element is not visible.\n        if (element.getClientRects().length === 0) {\n          return null;\n        }\n        const rect = element.getBoundingClientRect();\n        const style = window.getComputedStyle(element);\n        return {\n          left:\n            rect.left +\n            parseInt(style.paddingLeft, 10) +\n            parseInt(style.borderLeftWidth, 10),\n          top:\n            rect.top +\n            parseInt(style.paddingTop, 10) +\n            parseInt(style.borderTopWidth, 10),\n        };\n      });\n      if (!parentBox) {\n        return null;\n      }\n      point.x += parentBox.left;\n      point.y += parentBox.top;\n      frame = parentFrame;\n    }\n    return point;\n  }\n\n  /**\n   * This method scrolls element into view if needed, and then uses\n   * {@link Page.(screenshot:2) } to take a screenshot of the element.\n   * If the element is detached from DOM, the method throws an error.\n   */\n  async screenshot(\n    options: Readonly<ScreenshotOptions> & {encoding: 'base64'}\n  ): Promise<string>;\n  async screenshot(options?: Readonly<ScreenshotOptions>): Promise<Buffer>;\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async screenshot(\n    this: ElementHandle<Element>,\n    options: Readonly<ElementScreenshotOptions> = {}\n  ): Promise<string | Buffer> {\n    const {\n      scrollIntoView = true,\n      captureBeyondViewport = true,\n      allowViewportExpansion = captureBeyondViewport,\n    } = options;\n\n    let clip = await this.#nonEmptyVisibleBoundingBox();\n\n    const page = this.frame.page();\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    await using _ =\n      allowViewportExpansion && clip\n        ? await page._createTemporaryViewportContainingBox(clip)\n        : null;\n\n    if (scrollIntoView) {\n      await this.scrollIntoViewIfNeeded();\n\n      // We measure again just in case.\n      clip = await this.#nonEmptyVisibleBoundingBox();\n    }\n\n    const [pageLeft, pageTop] = await this.evaluate(() => {\n      if (!window.visualViewport) {\n        throw new Error('window.visualViewport is not supported.');\n      }\n      return [\n        window.visualViewport.pageLeft,\n        window.visualViewport.pageTop,\n      ] as const;\n    });\n    clip.x += pageLeft;\n    clip.y += pageTop;\n\n    return await page.screenshot({\n      ...options,\n      captureBeyondViewport: false,\n      clip,\n    });\n  }\n\n  async #nonEmptyVisibleBoundingBox() {\n    const box = await this.boundingBox();\n    assert(box, 'Node is either not visible or not an HTMLElement');\n    assert(box.width !== 0, 'Node has 0 width.');\n    assert(box.height !== 0, 'Node has 0 height.');\n    return box;\n  }\n\n  /**\n   * @internal\n   */\n  protected async assertConnectedElement(): Promise<void> {\n    const error = await this.evaluate(async element => {\n      if (!element.isConnected) {\n        return 'Node is detached from document';\n      }\n      if (element.nodeType !== Node.ELEMENT_NODE) {\n        return 'Node is not of type HTMLElement';\n      }\n      return;\n    });\n\n    if (error) {\n      throw new Error(error);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  protected async scrollIntoViewIfNeeded(\n    this: ElementHandle<Element>\n  ): Promise<void> {\n    if (\n      await this.isIntersectingViewport({\n        threshold: 1,\n      })\n    ) {\n      return;\n    }\n    await this.scrollIntoView();\n  }\n\n  /**\n   * Resolves to true if the element is visible in the current viewport. If an\n   * element is an SVG, we check if the svg owner element is in the viewport\n   * instead. See https://crbug.com/963246.\n   *\n   * @param options - Threshold for the intersection between 0 (no intersection) and 1\n   * (full intersection). Defaults to 1.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async isIntersectingViewport(\n    this: ElementHandle<Element>,\n    options: {\n      threshold?: number;\n    } = {}\n  ): Promise<boolean> {\n    await this.assertConnectedElement();\n    // eslint-disable-next-line rulesdir/use-using -- Returns `this`.\n    const handle = await this.#asSVGElementHandle();\n    using target = handle && (await handle.#getOwnerSVGElement());\n    return await ((target ?? this) as ElementHandle<Element>).evaluate(\n      async (element, threshold) => {\n        const visibleRatio = await new Promise<number>(resolve => {\n          const observer = new IntersectionObserver(entries => {\n            resolve(entries[0]!.intersectionRatio);\n            observer.disconnect();\n          });\n          observer.observe(element);\n        });\n        return threshold === 1 ? visibleRatio === 1 : visibleRatio > threshold;\n      },\n      options.threshold ?? 0\n    );\n  }\n\n  /**\n   * Scrolls the element into view using either the automation protocol client\n   * or by calling element.scrollIntoView.\n   */\n  @throwIfDisposed()\n  @ElementHandle.bindIsolatedHandle\n  async scrollIntoView(this: ElementHandle<Element>): Promise<void> {\n    await this.assertConnectedElement();\n    await this.evaluate(async (element): Promise<void> => {\n      element.scrollIntoView({\n        block: 'center',\n        inline: 'center',\n        behavior: 'instant',\n      });\n    });\n  }\n\n  /**\n   * Returns true if an element is an SVGElement (included svg, path, rect\n   * etc.).\n   */\n  async #asSVGElementHandle(\n    this: ElementHandle<Element>\n  ): Promise<ElementHandle<SVGElement> | null> {\n    if (\n      await this.evaluate(element => {\n        return element instanceof SVGElement;\n      })\n    ) {\n      return this as ElementHandle<SVGElement>;\n    } else {\n      return null;\n    }\n  }\n\n  async #getOwnerSVGElement(\n    this: ElementHandle<SVGElement>\n  ): Promise<ElementHandle<SVGSVGElement>> {\n    // SVGSVGElement.ownerSVGElement === null.\n    return await this.evaluateHandle(element => {\n      if (element instanceof SVGSVGElement) {\n        return element;\n      }\n      return element.ownerSVGElement!;\n    });\n  }\n\n  /**\n   * If the element is a form input, you can use {@link ElementHandle.autofill}\n   * to test if the form is compatible with the browser's autofill\n   * implementation. Throws an error if the form cannot be autofilled.\n   *\n   * @remarks\n   *\n   * Currently, Puppeteer supports auto-filling credit card information only and\n   * in Chrome in the new headless and headful modes only.\n   *\n   * ```ts\n   * // Select an input on the credit card form.\n   * const name = await page.waitForSelector('form #name');\n   * // Trigger autofill with the desired data.\n   * await name.autofill({\n   *   creditCard: {\n   *     number: '4444444444444444',\n   *     name: 'John Smith',\n   *     expiryMonth: '01',\n   *     expiryYear: '2030',\n   *     cvc: '123',\n   *   },\n   * });\n   * ```\n   */\n  abstract autofill(data: AutofillData): Promise<void>;\n}\n\n/**\n * @public\n */\nexport interface AutofillData {\n  creditCard: {\n    // See https://chromedevtools.github.io/devtools-protocol/tot/Autofill/#type-CreditCard.\n    number: string;\n    name: string;\n    expiryMonth: string;\n    expiryYear: string;\n    cvc: string;\n  };\n}\n\nfunction intersectBoundingBox(\n  box: BoundingBox,\n  width: number,\n  height: number\n): void {\n  box.width = Math.max(\n    box.x >= 0\n      ? Math.min(width - box.x, box.width)\n      : Math.min(width, box.width + box.x),\n    0\n  );\n  box.height = Math.max(\n    box.y >= 0\n      ? Math.min(height - box.y, box.height)\n      : Math.min(height, box.height + box.y),\n    0\n  );\n}\n"]},"metadata":{},"sourceType":"module"}