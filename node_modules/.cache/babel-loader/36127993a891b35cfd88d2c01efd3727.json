{"ast":null,"code":"/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\n/**\n * Device in a request prompt.\n *\n * @public\n */\nexport class DeviceRequestPromptDevice {\n  /**\n   * Device id during a prompt.\n   */\n  id;\n  /**\n   * Device name as it appears in a prompt.\n   */\n  name;\n  /**\n   * @internal\n   */\n  constructor(id, name) {\n    this.id = id;\n    this.name = name;\n  }\n}\n/**\n * Device request prompts let you respond to the page requesting for a device\n * through an API like WebBluetooth.\n *\n * @remarks\n * `DeviceRequestPrompt` instances are returned via the\n * {@link Page.waitForDevicePrompt} method.\n *\n * @example\n *\n * ```ts\n * const [deviceRequest] = Promise.all([\n *   page.waitForDevicePrompt(),\n *   page.click('#connect-bluetooth'),\n * ]);\n * await devicePrompt.select(\n *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n * );\n * ```\n *\n * @public\n */\nexport class DeviceRequestPrompt {\n  #client;\n  #timeoutSettings;\n  #id;\n  #handled = false;\n  #updateDevicesHandle = this.#updateDevices.bind(this);\n  #waitForDevicePromises = new Set();\n  /**\n   * Current list of selectable devices.\n   */\n  devices = [];\n  /**\n   * @internal\n   */\n  constructor(client, timeoutSettings, firstEvent) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n    this.#id = firstEvent.id;\n    this.#client.on('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n    this.#updateDevices(firstEvent);\n  }\n  #updateDevices(event) {\n    if (event.id !== this.#id) {\n      return;\n    }\n    for (const rawDevice of event.devices) {\n      if (this.devices.some(device => {\n        return device.id === rawDevice.id;\n      })) {\n        continue;\n      }\n      const newDevice = new DeviceRequestPromptDevice(rawDevice.id, rawDevice.name);\n      this.devices.push(newDevice);\n      for (const waitForDevicePromise of this.#waitForDevicePromises) {\n        if (waitForDevicePromise.filter(newDevice)) {\n          waitForDevicePromise.promise.resolve(newDevice);\n        }\n      }\n    }\n  }\n  /**\n   * Resolve to the first device in the prompt matching a filter.\n   */\n  async waitForDevice(filter) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    for (const device of this.devices) {\n      if (filter(device)) {\n        return device;\n      }\n    }\n    const {\n      timeout = this.#timeoutSettings.timeout()\n    } = options;\n    const deferred = Deferred.create({\n      message: `Waiting for \\`DeviceRequestPromptDevice\\` failed: ${timeout}ms exceeded`,\n      timeout\n    });\n    const handle = {\n      filter,\n      promise: deferred\n    };\n    this.#waitForDevicePromises.add(handle);\n    try {\n      return await deferred.valueOrThrow();\n    } finally {\n      this.#waitForDevicePromises.delete(handle);\n    }\n  }\n  /**\n   * Select a device in the prompt's list.\n   */\n  async select(device) {\n    assert(this.#client !== null, 'Cannot select device through detached session!');\n    assert(this.devices.includes(device), 'Cannot select unknown device!');\n    assert(!this.#handled, 'Cannot select DeviceRequestPrompt which is already handled!');\n    this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.selectPrompt', {\n      id: this.#id,\n      deviceId: device.id\n    });\n  }\n  /**\n   * Cancel the prompt.\n   */\n  async cancel() {\n    assert(this.#client !== null, 'Cannot cancel prompt through detached session!');\n    assert(!this.#handled, 'Cannot cancel DeviceRequestPrompt which is already handled!');\n    this.#client.off('DeviceAccess.deviceRequestPrompted', this.#updateDevicesHandle);\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.cancelPrompt', {\n      id: this.#id\n    });\n  }\n}\n/**\n * @internal\n */\nexport class DeviceRequestPromptManager {\n  #client;\n  #timeoutSettings;\n  #deviceRequestPrompDeferreds = new Set();\n  /**\n   * @internal\n   */\n  constructor(client, timeoutSettings) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n    this.#client.on('DeviceAccess.deviceRequestPrompted', event => {\n      this.#onDeviceRequestPrompted(event);\n    });\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n  }\n  /**\n   * Wait for device prompt created by an action like calling WebBluetooth's\n   * requestDevice.\n   */\n  async waitForDevicePrompt() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    assert(this.#client !== null, 'Cannot wait for device prompt through detached session!');\n    const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;\n    let enablePromise;\n    if (needsEnable) {\n      enablePromise = this.#client.send('DeviceAccess.enable');\n    }\n    const {\n      timeout = this.#timeoutSettings.timeout()\n    } = options;\n    const deferred = Deferred.create({\n      message: `Waiting for \\`DeviceRequestPrompt\\` failed: ${timeout}ms exceeded`,\n      timeout\n    });\n    this.#deviceRequestPrompDeferreds.add(deferred);\n    try {\n      const [result] = await Promise.all([deferred.valueOrThrow(), enablePromise]);\n      return result;\n    } finally {\n      this.#deviceRequestPrompDeferreds.delete(deferred);\n    }\n  }\n  /**\n   * @internal\n   */\n  #onDeviceRequestPrompted(event) {\n    if (!this.#deviceRequestPrompDeferreds.size) {\n      return;\n    }\n    assert(this.#client !== null);\n    const devicePrompt = new DeviceRequestPrompt(this.#client, this.#timeoutSettings, event);\n    for (const promise of this.#deviceRequestPrompDeferreds) {\n      promise.resolve(devicePrompt);\n    }\n    this.#deviceRequestPrompDeferreds.clear();\n  }\n}","map":{"version":3,"mappings":"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","names":["assert","Deferred","DeviceRequestPromptDevice","id","name","constructor","DeviceRequestPrompt","bind","Set","devices","client","timeoutSettings","firstEvent","on","event","rawDevice","some","device","newDevice","push","waitForDevicePromise","filter","promise","resolve","waitForDevice","options","timeout","deferred","create","message","handle","add","valueOrThrow","delete","select","includes","off","send","deviceId","cancel","DeviceRequestPromptManager","waitForDevicePrompt","needsEnable","size","enablePromise","result","Promise","all","devicePrompt","clear"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\DeviceRequestPrompt.ts"],"sourcesContent":["/**\n * Copyright 2022 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {WaitTimeoutOptions} from '../api/Page.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\n\n/**\n * Device in a request prompt.\n *\n * @public\n */\nexport class DeviceRequestPromptDevice {\n  /**\n   * Device id during a prompt.\n   */\n  id: string;\n\n  /**\n   * Device name as it appears in a prompt.\n   */\n  name: string;\n\n  /**\n   * @internal\n   */\n  constructor(id: string, name: string) {\n    this.id = id;\n    this.name = name;\n  }\n}\n\n/**\n * Device request prompts let you respond to the page requesting for a device\n * through an API like WebBluetooth.\n *\n * @remarks\n * `DeviceRequestPrompt` instances are returned via the\n * {@link Page.waitForDevicePrompt} method.\n *\n * @example\n *\n * ```ts\n * const [deviceRequest] = Promise.all([\n *   page.waitForDevicePrompt(),\n *   page.click('#connect-bluetooth'),\n * ]);\n * await devicePrompt.select(\n *   await devicePrompt.waitForDevice(({name}) => name.includes('My Device'))\n * );\n * ```\n *\n * @public\n */\nexport class DeviceRequestPrompt {\n  #client: CDPSession | null;\n  #timeoutSettings: TimeoutSettings;\n  #id: string;\n  #handled = false;\n  #updateDevicesHandle = this.#updateDevices.bind(this);\n  #waitForDevicePromises = new Set<{\n    filter: (device: DeviceRequestPromptDevice) => boolean;\n    promise: Deferred<DeviceRequestPromptDevice>;\n  }>();\n\n  /**\n   * Current list of selectable devices.\n   */\n  devices: DeviceRequestPromptDevice[] = [];\n\n  /**\n   * @internal\n   */\n  constructor(\n    client: CDPSession,\n    timeoutSettings: TimeoutSettings,\n    firstEvent: Protocol.DeviceAccess.DeviceRequestPromptedEvent\n  ) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n    this.#id = firstEvent.id;\n\n    this.#client.on(\n      'DeviceAccess.deviceRequestPrompted',\n      this.#updateDevicesHandle\n    );\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n\n    this.#updateDevices(firstEvent);\n  }\n\n  #updateDevices(event: Protocol.DeviceAccess.DeviceRequestPromptedEvent) {\n    if (event.id !== this.#id) {\n      return;\n    }\n\n    for (const rawDevice of event.devices) {\n      if (\n        this.devices.some(device => {\n          return device.id === rawDevice.id;\n        })\n      ) {\n        continue;\n      }\n\n      const newDevice = new DeviceRequestPromptDevice(\n        rawDevice.id,\n        rawDevice.name\n      );\n      this.devices.push(newDevice);\n\n      for (const waitForDevicePromise of this.#waitForDevicePromises) {\n        if (waitForDevicePromise.filter(newDevice)) {\n          waitForDevicePromise.promise.resolve(newDevice);\n        }\n      }\n    }\n  }\n\n  /**\n   * Resolve to the first device in the prompt matching a filter.\n   */\n  async waitForDevice(\n    filter: (device: DeviceRequestPromptDevice) => boolean,\n    options: WaitTimeoutOptions = {}\n  ): Promise<DeviceRequestPromptDevice> {\n    for (const device of this.devices) {\n      if (filter(device)) {\n        return device;\n      }\n    }\n\n    const {timeout = this.#timeoutSettings.timeout()} = options;\n    const deferred = Deferred.create<DeviceRequestPromptDevice>({\n      message: `Waiting for \\`DeviceRequestPromptDevice\\` failed: ${timeout}ms exceeded`,\n      timeout,\n    });\n    const handle = {filter, promise: deferred};\n    this.#waitForDevicePromises.add(handle);\n    try {\n      return await deferred.valueOrThrow();\n    } finally {\n      this.#waitForDevicePromises.delete(handle);\n    }\n  }\n\n  /**\n   * Select a device in the prompt's list.\n   */\n  async select(device: DeviceRequestPromptDevice): Promise<void> {\n    assert(\n      this.#client !== null,\n      'Cannot select device through detached session!'\n    );\n    assert(this.devices.includes(device), 'Cannot select unknown device!');\n    assert(\n      !this.#handled,\n      'Cannot select DeviceRequestPrompt which is already handled!'\n    );\n    this.#client.off(\n      'DeviceAccess.deviceRequestPrompted',\n      this.#updateDevicesHandle\n    );\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.selectPrompt', {\n      id: this.#id,\n      deviceId: device.id,\n    });\n  }\n\n  /**\n   * Cancel the prompt.\n   */\n  async cancel(): Promise<void> {\n    assert(\n      this.#client !== null,\n      'Cannot cancel prompt through detached session!'\n    );\n    assert(\n      !this.#handled,\n      'Cannot cancel DeviceRequestPrompt which is already handled!'\n    );\n    this.#client.off(\n      'DeviceAccess.deviceRequestPrompted',\n      this.#updateDevicesHandle\n    );\n    this.#handled = true;\n    return await this.#client.send('DeviceAccess.cancelPrompt', {id: this.#id});\n  }\n}\n\n/**\n * @internal\n */\nexport class DeviceRequestPromptManager {\n  #client: CDPSession | null;\n  #timeoutSettings: TimeoutSettings;\n  #deviceRequestPrompDeferreds = new Set<Deferred<DeviceRequestPrompt>>();\n\n  /**\n   * @internal\n   */\n  constructor(client: CDPSession, timeoutSettings: TimeoutSettings) {\n    this.#client = client;\n    this.#timeoutSettings = timeoutSettings;\n\n    this.#client.on('DeviceAccess.deviceRequestPrompted', event => {\n      this.#onDeviceRequestPrompted(event);\n    });\n    this.#client.on('Target.detachedFromTarget', () => {\n      this.#client = null;\n    });\n  }\n\n  /**\n   * Wait for device prompt created by an action like calling WebBluetooth's\n   * requestDevice.\n   */\n  async waitForDevicePrompt(\n    options: WaitTimeoutOptions = {}\n  ): Promise<DeviceRequestPrompt> {\n    assert(\n      this.#client !== null,\n      'Cannot wait for device prompt through detached session!'\n    );\n    const needsEnable = this.#deviceRequestPrompDeferreds.size === 0;\n    let enablePromise: Promise<void> | undefined;\n    if (needsEnable) {\n      enablePromise = this.#client.send('DeviceAccess.enable');\n    }\n\n    const {timeout = this.#timeoutSettings.timeout()} = options;\n    const deferred = Deferred.create<DeviceRequestPrompt>({\n      message: `Waiting for \\`DeviceRequestPrompt\\` failed: ${timeout}ms exceeded`,\n      timeout,\n    });\n    this.#deviceRequestPrompDeferreds.add(deferred);\n\n    try {\n      const [result] = await Promise.all([\n        deferred.valueOrThrow(),\n        enablePromise,\n      ]);\n      return result;\n    } finally {\n      this.#deviceRequestPrompDeferreds.delete(deferred);\n    }\n  }\n\n  /**\n   * @internal\n   */\n  #onDeviceRequestPrompted(\n    event: Protocol.DeviceAccess.DeviceRequestPromptedEvent\n  ) {\n    if (!this.#deviceRequestPrompDeferreds.size) {\n      return;\n    }\n\n    assert(this.#client !== null);\n    const devicePrompt = new DeviceRequestPrompt(\n      this.#client,\n      this.#timeoutSettings,\n      event\n    );\n    for (const promise of this.#deviceRequestPrompDeferreds) {\n      promise.resolve(devicePrompt);\n    }\n    this.#deviceRequestPrompDeferreds.clear();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}