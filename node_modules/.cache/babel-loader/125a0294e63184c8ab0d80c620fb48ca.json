{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ProgressTracker = void 0;\n/**\n * Tracks progress of one socket data transfer at a time.\n */\nclass ProgressTracker {\n  constructor() {\n    this.bytesOverall = 0;\n    this.intervalMs = 500;\n    this.onStop = noop;\n    this.onHandle = noop;\n  }\n  /**\n   * Register a new handler for progress info. Use `undefined` to disable reporting.\n   */\n  reportTo() {\n    let onHandle = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : noop;\n    this.onHandle = onHandle;\n  }\n  /**\n   * Start tracking transfer progress of a socket.\n   *\n   * @param socket  The socket to observe.\n   * @param name  A name associated with this progress tracking, e.g. a filename.\n   * @param type  The type of the transfer, typically \"upload\" or \"download\".\n   */\n  start(socket, name, type) {\n    let lastBytes = 0;\n    this.onStop = poll(this.intervalMs, () => {\n      const bytes = socket.bytesRead + socket.bytesWritten;\n      this.bytesOverall += bytes - lastBytes;\n      lastBytes = bytes;\n      this.onHandle({\n        name,\n        type,\n        bytes,\n        bytesOverall: this.bytesOverall\n      });\n    });\n  }\n  /**\n   * Stop tracking transfer progress.\n   */\n  stop() {\n    this.onStop(false);\n  }\n  /**\n   * Call the progress handler one more time, then stop tracking.\n   */\n  updateAndStop() {\n    this.onStop(true);\n  }\n}\nexports.ProgressTracker = ProgressTracker;\n/**\n * Starts calling a callback function at a regular interval. The first call will go out\n * immediately. The function returns a function to stop the polling.\n */\nfunction poll(intervalMs, updateFunc) {\n  const id = setInterval(updateFunc, intervalMs);\n  const stopFunc = stopWithUpdate => {\n    clearInterval(id);\n    if (stopWithUpdate) {\n      updateFunc();\n    }\n    // Prevent repeated calls to stop calling handler.\n    updateFunc = noop;\n  };\n  updateFunc();\n  return stopFunc;\n}\nfunction noop() {}","map":{"version":3,"names":["Object","defineProperty","exports","value","ProgressTracker","constructor","bytesOverall","intervalMs","onStop","noop","onHandle","reportTo","start","socket","name","type","lastBytes","poll","bytes","bytesRead","bytesWritten","stop","updateAndStop","updateFunc","id","setInterval","stopFunc","stopWithUpdate","clearInterval"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/ProgressTracker.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ProgressTracker = void 0;\n/**\n * Tracks progress of one socket data transfer at a time.\n */\nclass ProgressTracker {\n    constructor() {\n        this.bytesOverall = 0;\n        this.intervalMs = 500;\n        this.onStop = noop;\n        this.onHandle = noop;\n    }\n    /**\n     * Register a new handler for progress info. Use `undefined` to disable reporting.\n     */\n    reportTo(onHandle = noop) {\n        this.onHandle = onHandle;\n    }\n    /**\n     * Start tracking transfer progress of a socket.\n     *\n     * @param socket  The socket to observe.\n     * @param name  A name associated with this progress tracking, e.g. a filename.\n     * @param type  The type of the transfer, typically \"upload\" or \"download\".\n     */\n    start(socket, name, type) {\n        let lastBytes = 0;\n        this.onStop = poll(this.intervalMs, () => {\n            const bytes = socket.bytesRead + socket.bytesWritten;\n            this.bytesOverall += bytes - lastBytes;\n            lastBytes = bytes;\n            this.onHandle({\n                name,\n                type,\n                bytes,\n                bytesOverall: this.bytesOverall\n            });\n        });\n    }\n    /**\n     * Stop tracking transfer progress.\n     */\n    stop() {\n        this.onStop(false);\n    }\n    /**\n     * Call the progress handler one more time, then stop tracking.\n     */\n    updateAndStop() {\n        this.onStop(true);\n    }\n}\nexports.ProgressTracker = ProgressTracker;\n/**\n * Starts calling a callback function at a regular interval. The first call will go out\n * immediately. The function returns a function to stop the polling.\n */\nfunction poll(intervalMs, updateFunc) {\n    const id = setInterval(updateFunc, intervalMs);\n    const stopFunc = (stopWithUpdate) => {\n        clearInterval(id);\n        if (stopWithUpdate) {\n            updateFunc();\n        }\n        // Prevent repeated calls to stop calling handler.\n        updateFunc = noop;\n    };\n    updateFunc();\n    return stopFunc;\n}\nfunction noop() { }\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,eAAe,GAAG,KAAK,CAAC;AAChC;AACA;AACA;AACA,MAAMA,eAAe,CAAC;EAClBC,WAAW,GAAG;IACV,IAAI,CAACC,YAAY,GAAG,CAAC;IACrB,IAAI,CAACC,UAAU,GAAG,GAAG;IACrB,IAAI,CAACC,MAAM,GAAGC,IAAI;IAClB,IAAI,CAACC,QAAQ,GAAGD,IAAI;EACxB;EACA;AACJ;AACA;EACIE,QAAQ,GAAkB;IAAA,IAAjBD,QAAQ,uEAAGD,IAAI;IACpB,IAAI,CAACC,QAAQ,GAAGA,QAAQ;EAC5B;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACIE,KAAK,CAACC,MAAM,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACtB,IAAIC,SAAS,GAAG,CAAC;IACjB,IAAI,CAACR,MAAM,GAAGS,IAAI,CAAC,IAAI,CAACV,UAAU,EAAE,MAAM;MACtC,MAAMW,KAAK,GAAGL,MAAM,CAACM,SAAS,GAAGN,MAAM,CAACO,YAAY;MACpD,IAAI,CAACd,YAAY,IAAIY,KAAK,GAAGF,SAAS;MACtCA,SAAS,GAAGE,KAAK;MACjB,IAAI,CAACR,QAAQ,CAAC;QACVI,IAAI;QACJC,IAAI;QACJG,KAAK;QACLZ,YAAY,EAAE,IAAI,CAACA;MACvB,CAAC,CAAC;IACN,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACIe,IAAI,GAAG;IACH,IAAI,CAACb,MAAM,CAAC,KAAK,CAAC;EACtB;EACA;AACJ;AACA;EACIc,aAAa,GAAG;IACZ,IAAI,CAACd,MAAM,CAAC,IAAI,CAAC;EACrB;AACJ;AACAN,OAAO,CAACE,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA;AACA,SAASa,IAAI,CAACV,UAAU,EAAEgB,UAAU,EAAE;EAClC,MAAMC,EAAE,GAAGC,WAAW,CAACF,UAAU,EAAEhB,UAAU,CAAC;EAC9C,MAAMmB,QAAQ,GAAIC,cAAc,IAAK;IACjCC,aAAa,CAACJ,EAAE,CAAC;IACjB,IAAIG,cAAc,EAAE;MAChBJ,UAAU,EAAE;IAChB;IACA;IACAA,UAAU,GAAGd,IAAI;EACrB,CAAC;EACDc,UAAU,EAAE;EACZ,OAAOG,QAAQ;AACnB;AACA,SAASjB,IAAI,GAAG,CAAE"},"metadata":{},"sourceType":"script"}