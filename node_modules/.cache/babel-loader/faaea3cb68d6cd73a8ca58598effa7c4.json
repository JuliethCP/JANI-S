{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { CDPSessionEvent } from '../api/CDPSession.js';\nimport { FrameEvent } from '../api/Frame.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError, PuppeteerURL, UTILITY_WORLD_NAME } from '../common/util.js';\nimport { assert } from '../util/assert.js';\nimport { Deferred } from '../util/Deferred.js';\nimport { disposeSymbol } from '../util/disposable.js';\nimport { isErrorLike } from '../util/ErrorLike.js';\nimport { CdpCDPSession } from './CDPSession.js';\nimport { isTargetClosedError } from './Connection.js';\nimport { DeviceRequestPromptManager } from './DeviceRequestPrompt.js';\nimport { ExecutionContext } from './ExecutionContext.js';\nimport { CdpFrame } from './Frame.js';\nimport { FrameManagerEvent } from './FrameManagerEvents.js';\nimport { FrameTree } from './FrameTree.js';\nimport { MAIN_WORLD, PUPPETEER_WORLD } from './IsolatedWorlds.js';\nimport { NetworkManager } from './NetworkManager.js';\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter {\n  #page;\n  #networkManager;\n  #timeoutSettings;\n  #contextIdToContext = new Map();\n  #isolatedWorlds = new Set();\n  #client;\n  _frameTree = new FrameTree();\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set();\n  #deviceRequestPromptManagerMap = new WeakMap();\n  #frameTreeHandled;\n  get timeoutSettings() {\n    return this.#timeoutSettings;\n  }\n  get networkManager() {\n    return this.#networkManager;\n  }\n  get client() {\n    return this.#client;\n  }\n  constructor(client, page, ignoreHTTPSErrors, timeoutSettings) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped'\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch (err) {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client) {\n    this.#onExecutionContextsCleared(this.#client);\n    this.#client = client;\n    assert(this.#client instanceof CdpCDPSession, 'CDPSession is not an instance of CDPSessionImpl.');\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client._target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client._target()._targetId);\n      frame.mainRealm().clearContext();\n      frame.isolatedRealm().clearContext();\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client, true);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n  async registerSpeculativeSession(client) {\n    await this.#networkManager.addClient(client);\n  }\n  setupEventListeners(session) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on('Page.frameDetached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameDetached(event.frameId, event.reason);\n    });\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', async () => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n  async initialize(client) {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchroniously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([this.#networkManager.addClient(client), client.send('Page.enable'), client.send('Page.getFrameTree').then(_ref => {\n        let {\n          frameTree\n        } = _ref;\n        this.#handleFrameTree(client, frameTree);\n        this.#frameTreeHandled?.resolve();\n      }), client.send('Page.setLifecycleEventsEnabled', {\n        enabled: true\n      }), client.send('Runtime.enable').then(() => {\n        return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n      })]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n      throw error;\n    }\n  }\n  executionContextById(contextId) {\n    let session = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.#client;\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n  getExecutionContextById(contextId) {\n    let session = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.#client;\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n  page() {\n    return this.#page;\n  }\n  mainFrame() {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n  frames() {\n    return Array.from(this._frameTree.frames());\n  }\n  frame(frameId) {\n    return this._frameTree.getById(frameId) || null;\n  }\n  onAttachedToTarget(target) {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session());\n    }\n    this.setupEventListeners(target._session());\n    void this.initialize(target._session());\n  }\n  _deviceRequestPromptManager(client) {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n  #onLifecycleEvent(event) {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n  #onFrameStartedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n  #onFrameStoppedLoading(frameId) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n  #handleFrameTree(session, frameTree) {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(session, frameTree.frame.id, frameTree.frame.parentId);\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n    if (!frameTree.childFrames) {\n      return;\n    }\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n  #onFrameAttached(session, frameId, parentFrameId) {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n  async #onFrameNavigated(framePayload, navigationType) {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n    let frame = this._frameTree.getById(frameId);\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n  async #createIsolatedWorld(session, name) {\n    const key = `${session.id()}:${name}`;\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name\n    });\n    await Promise.all(this.frames().filter(frame => {\n      return frame.client === session;\n    }).map(frame => {\n      // Frames might be removed before we send this, so we don't want to\n      // throw an error.\n      return session.send('Page.createIsolatedWorld', {\n        frameId: frame._id,\n        worldName: name,\n        grantUniveralAccess: true\n      }).catch(debugError);\n    }));\n    this.#isolatedWorlds.add(key);\n  }\n  #onFrameNavigatedWithinDocument(frameId, url) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n  #onFrameDetached(frameId, reason) {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n  #onExecutionContextCreated(contextPayload, session) {\n    const auxData = contextPayload.auxData;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (contextPayload.name === UTILITY_WORLD_NAME && !frame.worlds[PUPPETEER_WORLD].hasContext()) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(frame?.client || this.#client, contextPayload, world);\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n  #onExecutionContextDestroyed(executionContextId, session) {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n  #onExecutionContextsCleared(session) {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n  #removeFramesRecursively(frame) {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;AAkBA,SAAyBA,eAAe,QAAO,sBAAsB;AACrE,SAAQC,UAAU,QAAO,iBAAiB;AAC1C,SAAQC,YAAY,QAAO,2BAA2B;AAEtD,SAAQC,UAAU,EAAEC,YAAY,EAAEC,kBAAkB,QAAO,mBAAmB;AAC9E,SAAQC,MAAM,QAAO,mBAAmB;AACxC,SAAQC,QAAQ,QAAO,qBAAqB;AAC5C,SAAQC,aAAa,QAAO,uBAAuB;AACnD,SAAQC,WAAW,QAAO,sBAAsB;AAEhD,SAAQC,aAAa,QAAO,iBAAiB;AAC7C,SAAQC,mBAAmB,QAAO,iBAAiB;AACnD,SAAQC,0BAA0B,QAAO,0BAA0B;AACnE,SAAQC,gBAAgB,QAAO,uBAAuB;AACtD,SAAQC,QAAQ,QAAO,YAAY;AAEnC,SAAQC,iBAAiB,QAAO,yBAAyB;AACzD,SAAQC,SAAS,QAAO,gBAAgB;AAExC,SAAQC,UAAU,EAAEC,eAAe,QAAO,qBAAqB;AAC/D,SAAQC,cAAc,QAAO,qBAAqB;AAIlD,MAAMC,yBAAyB,GAAG,GAAG,CAAC,CAAC;AAEvC;;;;;AAKA,OAAM,MAAOC,YAAa,SAAQnB,YAAgC;EAChE,KAAK;EACL,eAAe;EACf,gBAAgB;EAChB,mBAAmB,GAAG,IAAIoB,GAAG,EAA4B;EACzD,eAAe,GAAG,IAAIC,GAAG,EAAU;EACnC,OAAO;EAEPC,UAAU,GAAG,IAAIR,SAAS,EAAY;EAEtC;;;;;EAKA,uBAAuB,GAAG,IAAIO,GAAG,EAAU;EAE3C,8BAA8B,GAAG,IAAIE,OAAO,EAGzC;EAEH,iBAAiB;EAEjB,IAAIC,eAAe;IACjB,OAAO,IAAI,CAAC,gBAAgB;EAC9B;EAEA,IAAIC,cAAc;IAChB,OAAO,IAAI,CAAC,eAAe;EAC7B;EAEA,IAAIC,MAAM;IACR,OAAO,IAAI,CAAC,OAAO;EACrB;EAEAC,YACED,MAAkB,EAClBE,IAAa,EACbC,iBAA0B,EAC1BL,eAAgC;IAEhC,KAAK,EAAE;IACP,IAAI,CAAC,OAAO,GAAGE,MAAM;IACrB,IAAI,CAAC,KAAK,GAAGE,IAAI;IACjB,IAAI,CAAC,eAAe,GAAG,IAAIX,cAAc,CAACY,iBAAiB,EAAE,IAAI,CAAC;IAClE,IAAI,CAAC,gBAAgB,GAAGL,eAAe;IACvC,IAAI,CAACM,mBAAmB,CAAC,IAAI,CAAC,OAAO,CAAC;IACtCJ,MAAM,CAACK,IAAI,CAACjC,eAAe,CAACkC,YAAY,EAAE,MAAK;MAC7C,IAAI,CAAC,mBAAmB,EAAE,CAACC,KAAK,CAAChC,UAAU,CAAC;IAC9C,CAAC,CAAC;EACJ;EAEA;;;;;EAKA,MAAM,mBAAmB;IACvB,MAAMiC,SAAS,GAAG,IAAI,CAACZ,UAAU,CAACa,YAAY,EAAE;IAChD,IAAI,CAACD,SAAS,EAAE;MACd;;IAEF,KAAK,MAAME,KAAK,IAAIF,SAAS,CAACG,WAAW,EAAE,EAAE;MAC3C,IAAI,CAAC,wBAAwB,CAACD,KAAK,CAAC;;IAEtC,MAAME,OAAO,GAAGjC,QAAQ,CAACkC,MAAM,CAAO;MACpCC,OAAO,EAAEtB,yBAAyB;MAClCuB,OAAO,EAAE;KACV,CAAC;IACFP,SAAS,CAACH,IAAI,CAAChC,UAAU,CAAC2C,wBAAwB,EAAE,MAAK;MACvDJ,OAAO,CAACK,OAAO,EAAE;IACnB,CAAC,CAAC;IACF,IAAI;MACF,MAAML,OAAO,CAACM,YAAY,EAAE;KAC7B,CAAC,OAAOC,GAAG,EAAE;MACZ,IAAI,CAAC,wBAAwB,CAACX,SAAS,CAAC;;EAE5C;EAEA;;;;;EAKA,MAAMY,aAAa,CAACpB,MAAkB;IACpC,IAAI,CAAC,2BAA2B,CAAC,IAAI,CAAC,OAAO,CAAC;IAE9C,IAAI,CAAC,OAAO,GAAGA,MAAM;IACrBtB,MAAM,CACJ,IAAI,CAAC,OAAO,YAAYI,aAAa,EACrC,kDAAkD,CACnD;IACD,MAAMuC,KAAK,GAAG,IAAI,CAACzB,UAAU,CAACa,YAAY,EAAE;IAC5C,IAAIY,KAAK,EAAE;MACT,IAAI,CAAC,uBAAuB,CAACC,GAAG,CAAC,IAAI,CAAC,OAAO,CAACC,OAAO,EAAE,CAACC,SAAS,CAAC;MAClE,IAAI,CAAC5B,UAAU,CAAC6B,WAAW,CAACJ,KAAK,CAAC;MAClCA,KAAK,CAACK,QAAQ,CAAC,IAAI,CAAC,OAAO,CAACH,OAAO,EAAE,CAACC,SAAS,CAAC;MAChDH,KAAK,CAACM,SAAS,EAAE,CAACC,YAAY,EAAE;MAChCP,KAAK,CAACQ,aAAa,EAAE,CAACD,YAAY,EAAE;MACpC,IAAI,CAAChC,UAAU,CAACkC,QAAQ,CAACT,KAAK,CAAC;MAC/BA,KAAK,CAACU,YAAY,CAAC/B,MAAM,EAAE,IAAI,CAAC;;IAElC,IAAI,CAACI,mBAAmB,CAACJ,MAAM,CAAC;IAChCA,MAAM,CAACK,IAAI,CAACjC,eAAe,CAACkC,YAAY,EAAE,MAAK;MAC7C,IAAI,CAAC,mBAAmB,EAAE,CAACC,KAAK,CAAChC,UAAU,CAAC;IAC9C,CAAC,CAAC;IACF,MAAM,IAAI,CAACyD,UAAU,CAAChC,MAAM,CAAC;IAC7B,MAAM,IAAI,CAAC,eAAe,CAACiC,SAAS,CAACjC,MAAM,CAAC;IAC5C,IAAIqB,KAAK,EAAE;MACTA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAAC2C,wBAAwB,EAAEmB,SAAS,CAAC;;EAE9D;EAEA,MAAMC,0BAA0B,CAACpC,MAAqB;IACpD,MAAM,IAAI,CAAC,eAAe,CAACiC,SAAS,CAACjC,MAAM,CAAC;EAC9C;EAEQI,mBAAmB,CAACiC,OAAmB;IAC7CA,OAAO,CAACC,EAAE,CAAC,oBAAoB,EAAE,MAAMC,KAAK,IAAG;MAC7C,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,gBAAgB,CAACmB,OAAO,EAAEE,KAAK,CAACC,OAAO,EAAED,KAAK,CAACE,aAAa,CAAC;IACpE,CAAC,CAAC;IACFJ,OAAO,CAACC,EAAE,CAAC,qBAAqB,EAAE,MAAMC,KAAK,IAAG;MAC9C,IAAI,CAAC,uBAAuB,CAACjB,GAAG,CAACiB,KAAK,CAAClB,KAAK,CAACqB,EAAE,CAAC;MAChD,MAAM,IAAI,CAAC,iBAAiB,EAAExB,YAAY,EAAE;MAC5C,KAAK,IAAI,CAAC,iBAAiB,CAACqB,KAAK,CAAClB,KAAK,EAAEkB,KAAK,CAACI,IAAI,CAAC;IACtD,CAAC,CAAC;IACFN,OAAO,CAACC,EAAE,CAAC,8BAA8B,EAAE,MAAMC,KAAK,IAAG;MACvD,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,+BAA+B,CAACqB,KAAK,CAACC,OAAO,EAAED,KAAK,CAACK,GAAG,CAAC;IAChE,CAAC,CAAC;IACFP,OAAO,CAACC,EAAE,CACR,oBAAoB,EACpB,MAAOC,KAAuC,IAAI;MAChD,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,gBAAgB,CACnBqB,KAAK,CAACC,OAAO,EACbD,KAAK,CAACM,MAAgD,CACvD;IACH,CAAC,CACF;IACDR,OAAO,CAACC,EAAE,CAAC,0BAA0B,EAAE,MAAMC,KAAK,IAAG;MACnD,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,sBAAsB,CAACqB,KAAK,CAACC,OAAO,CAAC;IAC5C,CAAC,CAAC;IACFH,OAAO,CAACC,EAAE,CAAC,0BAA0B,EAAE,MAAMC,KAAK,IAAG;MACnD,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,sBAAsB,CAACqB,KAAK,CAACC,OAAO,CAAC;IAC5C,CAAC,CAAC;IACFH,OAAO,CAACC,EAAE,CAAC,iCAAiC,EAAE,MAAMC,KAAK,IAAG;MAC1D,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,0BAA0B,CAACqB,KAAK,CAACO,OAAO,EAAET,OAAO,CAAC;IACzD,CAAC,CAAC;IACFA,OAAO,CAACC,EAAE,CAAC,mCAAmC,EAAE,MAAMC,KAAK,IAAG;MAC5D,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,4BAA4B,CAACqB,KAAK,CAACQ,kBAAkB,EAAEV,OAAO,CAAC;IACtE,CAAC,CAAC;IACFA,OAAO,CAACC,EAAE,CAAC,kCAAkC,EAAE,YAAW;MACxD,MAAM,IAAI,CAAC,iBAAiB,EAAEpB,YAAY,EAAE;MAC5C,IAAI,CAAC,2BAA2B,CAACmB,OAAO,CAAC;IAC3C,CAAC,CAAC;IACFA,OAAO,CAACC,EAAE,CAAC,qBAAqB,EAAE,MAAMC,KAAK,IAAG;MAC9C,MAAM,IAAI,CAAC,iBAAiB,EAAErB,YAAY,EAAE;MAC5C,IAAI,CAAC,iBAAiB,CAACqB,KAAK,CAAC;IAC/B,CAAC,CAAC;EACJ;EAEA,MAAMP,UAAU,CAAChC,MAAkB;IACjC,IAAI;MACF,IAAI,CAAC,iBAAiB,EAAEiB,OAAO,EAAE;MACjC,IAAI,CAAC,iBAAiB,GAAGtC,QAAQ,CAACkC,MAAM,EAAE;MAC1C;MACA;MACA;MACA;MACA,MAAMmC,OAAO,CAACC,GAAG,CAAC,CAChB,IAAI,CAAC,eAAe,CAAChB,SAAS,CAACjC,MAAM,CAAC,EACtCA,MAAM,CAACkD,IAAI,CAAC,aAAa,CAAC,EAC1BlD,MAAM,CAACkD,IAAI,CAAC,mBAAmB,CAAC,CAACC,IAAI,CAAC,QAAgB;QAAA,IAAf;UAACC;QAAS,CAAC;QAChD,IAAI,CAAC,gBAAgB,CAACpD,MAAM,EAAEoD,SAAS,CAAC;QACxC,IAAI,CAAC,iBAAiB,EAAEnC,OAAO,EAAE;MACnC,CAAC,CAAC,EACFjB,MAAM,CAACkD,IAAI,CAAC,gCAAgC,EAAE;QAACG,OAAO,EAAE;MAAI,CAAC,CAAC,EAC9DrD,MAAM,CAACkD,IAAI,CAAC,gBAAgB,CAAC,CAACC,IAAI,CAAC,MAAK;QACtC,OAAO,IAAI,CAAC,oBAAoB,CAACnD,MAAM,EAAEvB,kBAAkB,CAAC;MAC9D,CAAC,CAAC,CACH,CAAC;KACH,CAAC,OAAO6E,KAAK,EAAE;MACd,IAAI,CAAC,iBAAiB,EAAErC,OAAO,EAAE;MACjC;MACA,IAAIpC,WAAW,CAACyE,KAAK,CAAC,IAAIvE,mBAAmB,CAACuE,KAAK,CAAC,EAAE;QACpD;;MAGF,MAAMA,KAAK;;EAEf;EAEAC,oBAAoB,CAClBC,SAAiB,EACiB;IAAA,IAAlCnB,8EAAsB,IAAI,CAAC,OAAO;IAElC,MAAMS,OAAO,GAAG,IAAI,CAACW,uBAAuB,CAACD,SAAS,EAAEnB,OAAO,CAAC;IAChE3D,MAAM,CAACoE,OAAO,EAAE,4CAA4C,GAAGU,SAAS,CAAC;IACzE,OAAOV,OAAO;EAChB;EAEAW,uBAAuB,CACrBD,SAAiB,EACiB;IAAA,IAAlCnB,8EAAsB,IAAI,CAAC,OAAO;IAElC,OAAO,IAAI,CAAC,mBAAmB,CAACqB,GAAG,CAAC,GAAGrB,OAAO,CAACK,EAAE,EAAE,IAAIc,SAAS,EAAE,CAAC;EACrE;EAEAtD,IAAI;IACF,OAAO,IAAI,CAAC,KAAK;EACnB;EAEAM,SAAS;IACP,MAAMA,SAAS,GAAG,IAAI,CAACZ,UAAU,CAACa,YAAY,EAAE;IAChD/B,MAAM,CAAC8B,SAAS,EAAE,kCAAkC,CAAC;IACrD,OAAOA,SAAS;EAClB;EAEAmD,MAAM;IACJ,OAAOC,KAAK,CAACC,IAAI,CAAC,IAAI,CAACjE,UAAU,CAAC+D,MAAM,EAAE,CAAC;EAC7C;EAEAtC,KAAK,CAACmB,OAAe;IACnB,OAAO,IAAI,CAAC5C,UAAU,CAACkE,OAAO,CAACtB,OAAO,CAAC,IAAI,IAAI;EACjD;EAEAuB,kBAAkB,CAACC,MAAiB;IAClC,IAAIA,MAAM,CAACC,cAAc,EAAE,CAACtB,IAAI,KAAK,QAAQ,EAAE;MAC7C;;IAGF,MAAMtB,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC2C,MAAM,CAACC,cAAc,EAAE,CAACC,QAAQ,CAAC;IAC1D,IAAI7C,KAAK,EAAE;MACTA,KAAK,CAACU,YAAY,CAACiC,MAAM,CAACG,QAAQ,EAAG,CAAC;;IAExC,IAAI,CAAC/D,mBAAmB,CAAC4D,MAAM,CAACG,QAAQ,EAAG,CAAC;IAC5C,KAAK,IAAI,CAACnC,UAAU,CAACgC,MAAM,CAACG,QAAQ,EAAG,CAAC;EAC1C;EAEAC,2BAA2B,CAACpE,MAAkB;IAC5C,IAAIqE,OAAO,GAAG,IAAI,CAAC,8BAA8B,CAACX,GAAG,CAAC1D,MAAM,CAAC;IAC7D,IAAIqE,OAAO,KAAKlC,SAAS,EAAE;MACzBkC,OAAO,GAAG,IAAIrF,0BAA0B,CAACgB,MAAM,EAAE,IAAI,CAAC,gBAAgB,CAAC;MACvE,IAAI,CAAC,8BAA8B,CAACsE,GAAG,CAACtE,MAAM,EAAEqE,OAAO,CAAC;;IAE1D,OAAOA,OAAO;EAChB;EAEA,iBAAiB,CAAC9B,KAAwC;IACxD,MAAMlB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACkB,KAAK,CAACC,OAAO,CAAC;IACvC,IAAI,CAACnB,KAAK,EAAE;MACV;;IAEFA,KAAK,CAACkD,iBAAiB,CAAChC,KAAK,CAACiC,QAAQ,EAAEjC,KAAK,CAACkC,IAAI,CAAC;IACnD,IAAI,CAACvC,IAAI,CAAC/C,iBAAiB,CAACuF,cAAc,EAAErD,KAAK,CAAC;IAClDA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAACqG,cAAc,EAAEvC,SAAS,CAAC;EAClD;EAEA,sBAAsB,CAACK,OAAe;IACpC,MAAMnB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACmB,OAAO,CAAC;IACjC,IAAI,CAACnB,KAAK,EAAE;MACV;;IAEFA,KAAK,CAACsD,iBAAiB,EAAE;EAC3B;EAEA,sBAAsB,CAACnC,OAAe;IACpC,MAAMnB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACmB,OAAO,CAAC;IACjC,IAAI,CAACnB,KAAK,EAAE;MACV;;IAEFA,KAAK,CAACuD,iBAAiB,EAAE;IACzB,IAAI,CAAC1C,IAAI,CAAC/C,iBAAiB,CAACuF,cAAc,EAAErD,KAAK,CAAC;IAClDA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAACqG,cAAc,EAAEvC,SAAS,CAAC;EAClD;EAEA,gBAAgB,CACdE,OAAmB,EACnBe,SAAkC;IAElC,IAAIA,SAAS,CAAC/B,KAAK,CAACwD,QAAQ,EAAE;MAC5B,IAAI,CAAC,gBAAgB,CACnBxC,OAAO,EACPe,SAAS,CAAC/B,KAAK,CAACqB,EAAE,EAClBU,SAAS,CAAC/B,KAAK,CAACwD,QAAQ,CACzB;;IAEH,IAAI,CAAC,IAAI,CAAC,uBAAuB,CAACC,GAAG,CAAC1B,SAAS,CAAC/B,KAAK,CAACqB,EAAE,CAAC,EAAE;MACzD,KAAK,IAAI,CAAC,iBAAiB,CAACU,SAAS,CAAC/B,KAAK,EAAE,YAAY,CAAC;KAC3D,MAAM;MACL,IAAI,CAAC,uBAAuB,CAAC0D,MAAM,CAAC3B,SAAS,CAAC/B,KAAK,CAACqB,EAAE,CAAC;;IAGzD,IAAI,CAACU,SAAS,CAACzC,WAAW,EAAE;MAC1B;;IAGF,KAAK,MAAMD,KAAK,IAAI0C,SAAS,CAACzC,WAAW,EAAE;MACzC,IAAI,CAAC,gBAAgB,CAAC0B,OAAO,EAAE3B,KAAK,CAAC;;EAEzC;EAEA,gBAAgB,CACd2B,OAAmB,EACnBG,OAAe,EACfC,aAAqB;IAErB,IAAIpB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACmB,OAAO,CAAC;IAC/B,IAAInB,KAAK,EAAE;MACT,IAAIgB,OAAO,IAAIhB,KAAK,CAAC2D,UAAU,EAAE,EAAE;QACjC;QACA;QACA;QACA3D,KAAK,CAACU,YAAY,CAACM,OAAO,CAAC;;MAE7B;;IAGFhB,KAAK,GAAG,IAAInC,QAAQ,CAAC,IAAI,EAAEsD,OAAO,EAAEC,aAAa,EAAEJ,OAAO,CAAC;IAC3D,IAAI,CAACzC,UAAU,CAACkC,QAAQ,CAACT,KAAK,CAAC;IAC/B,IAAI,CAACa,IAAI,CAAC/C,iBAAiB,CAAC8F,aAAa,EAAE5D,KAAK,CAAC;EACnD;EAEA,MAAM,iBAAiB,CACrB6D,YAAiC,EACjCC,cAA4C;IAE5C,MAAM3C,OAAO,GAAG0C,YAAY,CAACxC,EAAE;IAC/B,MAAM0C,WAAW,GAAG,CAACF,YAAY,CAACL,QAAQ;IAE1C,IAAIxD,KAAK,GAAG,IAAI,CAACzB,UAAU,CAACkE,OAAO,CAACtB,OAAO,CAAC;IAE5C;IACA,IAAInB,KAAK,EAAE;MACT,KAAK,MAAMX,KAAK,IAAIW,KAAK,CAACV,WAAW,EAAE,EAAE;QACvC,IAAI,CAAC,wBAAwB,CAACD,KAAK,CAAC;;;IAIxC;IACA,IAAI0E,WAAW,EAAE;MACf,IAAI/D,KAAK,EAAE;QACT;QACA,IAAI,CAACzB,UAAU,CAAC6B,WAAW,CAACJ,KAAK,CAAC;QAClCA,KAAK,CAACgE,GAAG,GAAG7C,OAAO;OACpB,MAAM;QACL;QACAnB,KAAK,GAAG,IAAInC,QAAQ,CAAC,IAAI,EAAEsD,OAAO,EAAEL,SAAS,EAAE,IAAI,CAAC,OAAO,CAAC;;MAE9D,IAAI,CAACvC,UAAU,CAACkC,QAAQ,CAACT,KAAK,CAAC;;IAGjCA,KAAK,GAAG,MAAM,IAAI,CAACzB,UAAU,CAAC0F,YAAY,CAAC9C,OAAO,CAAC;IACnDnB,KAAK,CAACkE,UAAU,CAACL,YAAY,CAAC;IAC9B,IAAI,CAAChD,IAAI,CAAC/C,iBAAiB,CAACqG,cAAc,EAAEnE,KAAK,CAAC;IAClDA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAACmH,cAAc,EAAEL,cAAc,CAAC;EACvD;EAEA,MAAM,oBAAoB,CAAC9C,OAAmB,EAAEoC,IAAY;IAC1D,MAAMgB,GAAG,GAAG,GAAGpD,OAAO,CAACK,EAAE,EAAE,IAAI+B,IAAI,EAAE;IAErC,IAAI,IAAI,CAAC,eAAe,CAACK,GAAG,CAACW,GAAG,CAAC,EAAE;MACjC;;IAGF,MAAMpD,OAAO,CAACa,IAAI,CAAC,uCAAuC,EAAE;MAC1DwC,MAAM,EAAE,iBAAiBlH,YAAY,CAACmH,YAAY,EAAE;MACpDC,SAAS,EAAEnB;KACZ,CAAC;IAEF,MAAMzB,OAAO,CAACC,GAAG,CACf,IAAI,CAACU,MAAM,EAAE,CACVkC,MAAM,CAACxE,KAAK,IAAG;MACd,OAAOA,KAAK,CAACrB,MAAM,KAAKqC,OAAO;IACjC,CAAC,CAAC,CACDyD,GAAG,CAACzE,KAAK,IAAG;MACX;MACA;MACA,OAAOgB,OAAO,CACXa,IAAI,CAAC,0BAA0B,EAAE;QAChCV,OAAO,EAAEnB,KAAK,CAACgE,GAAG;QAClBO,SAAS,EAAEnB,IAAI;QACfsB,mBAAmB,EAAE;OACtB,CAAC,CACDxF,KAAK,CAAChC,UAAU,CAAC;IACtB,CAAC,CAAC,CACL;IAED,IAAI,CAAC,eAAe,CAAC+C,GAAG,CAACmE,GAAG,CAAC;EAC/B;EAEA,+BAA+B,CAACjD,OAAe,EAAEI,GAAW;IAC1D,MAAMvB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACmB,OAAO,CAAC;IACjC,IAAI,CAACnB,KAAK,EAAE;MACV;;IAEFA,KAAK,CAAC2E,wBAAwB,CAACpD,GAAG,CAAC;IACnC,IAAI,CAACV,IAAI,CAAC/C,iBAAiB,CAAC8G,4BAA4B,EAAE5E,KAAK,CAAC;IAChEA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAAC4H,4BAA4B,EAAE9D,SAAS,CAAC;IAC9D,IAAI,CAACD,IAAI,CAAC/C,iBAAiB,CAACqG,cAAc,EAAEnE,KAAK,CAAC;IAClDA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAACmH,cAAc,EAAE,YAAY,CAAC;EACrD;EAEA,gBAAgB,CACdhD,OAAe,EACfK,MAA8C;IAE9C,MAAMxB,KAAK,GAAG,IAAI,CAACA,KAAK,CAACmB,OAAO,CAAC;IACjC,IAAI,CAACnB,KAAK,EAAE;MACV;;IAEF,QAAQwB,MAAM;MACZ,KAAK,QAAQ;QACX;QACA;QACA;QACA,IAAI,CAAC,wBAAwB,CAACxB,KAAK,CAAC;QACpC;MACF,KAAK,MAAM;QACT,IAAI,CAACa,IAAI,CAAC/C,iBAAiB,CAAC+G,YAAY,EAAE7E,KAAK,CAAC;QAChDA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAAC6H,YAAY,EAAE/D,SAAS,CAAC;QAC9C;IAAM;EAEZ;EAEA,0BAA0B,CACxBgE,cAA4D,EAC5D9D,OAAmB;IAEnB,MAAM+D,OAAO,GAAGD,cAAc,CAACC,OAAyC;IACxE,MAAM5D,OAAO,GAAG4D,OAAO,IAAIA,OAAO,CAAC5D,OAAO;IAC1C,MAAMnB,KAAK,GAAG,OAAOmB,OAAO,KAAK,QAAQ,GAAG,IAAI,CAACnB,KAAK,CAACmB,OAAO,CAAC,GAAGL,SAAS;IAC3E,IAAIkE,KAAgC;IACpC,IAAIhF,KAAK,EAAE;MACT;MACA,IAAIA,KAAK,CAACrB,MAAM,KAAKqC,OAAO,EAAE;QAC5B;;MAEF,IAAI8D,cAAc,CAACC,OAAO,IAAID,cAAc,CAACC,OAAO,CAAC,WAAW,CAAC,EAAE;QACjEC,KAAK,GAAGhF,KAAK,CAACiF,MAAM,CAACjH,UAAU,CAAC;OACjC,MAAM,IACL8G,cAAc,CAAC1B,IAAI,KAAKhG,kBAAkB,IAC1C,CAAC4C,KAAK,CAACiF,MAAM,CAAChH,eAAe,CAAC,CAACiH,UAAU,EAAE,EAC3C;QACA;QACA;QACA;QACAF,KAAK,GAAGhF,KAAK,CAACiF,MAAM,CAAChH,eAAe,CAAC;;;IAGzC;IACA,IAAI,CAAC+G,KAAK,EAAE;MACV;;IAEF,MAAMvD,OAAO,GAAG,IAAI7D,gBAAgB,CAClCoC,KAAK,EAAErB,MAAM,IAAI,IAAI,CAAC,OAAO,EAC7BmG,cAAc,EACdE,KAAK,CACN;IACD,IAAIA,KAAK,EAAE;MACTA,KAAK,CAACG,UAAU,CAAC1D,OAAO,CAAC;;IAE3B,MAAM2C,GAAG,GAAG,GAAGpD,OAAO,CAACK,EAAE,EAAE,IAAIyD,cAAc,CAACzD,EAAE,EAAE;IAClD,IAAI,CAAC,mBAAmB,CAAC4B,GAAG,CAACmB,GAAG,EAAE3C,OAAO,CAAC;EAC5C;EAEA,4BAA4B,CAC1BC,kBAA0B,EAC1BV,OAAmB;IAEnB,MAAMoD,GAAG,GAAG,GAAGpD,OAAO,CAACK,EAAE,EAAE,IAAIK,kBAAkB,EAAE;IACnD,MAAMD,OAAO,GAAG,IAAI,CAAC,mBAAmB,CAACY,GAAG,CAAC+B,GAAG,CAAC;IACjD,IAAI,CAAC3C,OAAO,EAAE;MACZ;;IAEF,IAAI,CAAC,mBAAmB,CAACiC,MAAM,CAACU,GAAG,CAAC;IACpC,IAAI3C,OAAO,CAAC2D,MAAM,EAAE;MAClB3D,OAAO,CAAC2D,MAAM,CAAC7E,YAAY,EAAE;;EAEjC;EAEA,2BAA2B,CAACS,OAAmB;IAC7C,KAAK,MAAM,CAACoD,GAAG,EAAE3C,OAAO,CAAC,IAAI,IAAI,CAAC,mBAAmB,CAAC4D,OAAO,EAAE,EAAE;MAC/D;MACA;MACA,IAAI5D,OAAO,CAAC6D,OAAO,KAAKtE,OAAO,EAAE;QAC/B;;MAEF,IAAIS,OAAO,CAAC2D,MAAM,EAAE;QAClB3D,OAAO,CAAC2D,MAAM,CAAC7E,YAAY,EAAE;;MAE/B,IAAI,CAAC,mBAAmB,CAACmD,MAAM,CAACU,GAAG,CAAC;;EAExC;EAEA,wBAAwB,CAACpE,KAAe;IACtC,KAAK,MAAMX,KAAK,IAAIW,KAAK,CAACV,WAAW,EAAE,EAAE;MACvC,IAAI,CAAC,wBAAwB,CAACD,KAAK,CAAC;;IAEtCW,KAAK,CAACzC,aAAa,CAAC,EAAE;IACtB,IAAI,CAACgB,UAAU,CAAC6B,WAAW,CAACJ,KAAK,CAAC;IAClC,IAAI,CAACa,IAAI,CAAC/C,iBAAiB,CAACyH,aAAa,EAAEvF,KAAK,CAAC;IACjDA,KAAK,CAACa,IAAI,CAAC7D,UAAU,CAACuI,aAAa,EAAEvF,KAAK,CAAC;EAC7C","names":["CDPSessionEvent","FrameEvent","EventEmitter","debugError","PuppeteerURL","UTILITY_WORLD_NAME","assert","Deferred","disposeSymbol","isErrorLike","CdpCDPSession","isTargetClosedError","DeviceRequestPromptManager","ExecutionContext","CdpFrame","FrameManagerEvent","FrameTree","MAIN_WORLD","PUPPETEER_WORLD","NetworkManager","TIME_FOR_WAITING_FOR_SWAP","FrameManager","Map","Set","_frameTree","WeakMap","timeoutSettings","networkManager","client","constructor","page","ignoreHTTPSErrors","setupEventListeners","once","Disconnected","catch","mainFrame","getMainFrame","child","childFrames","swapped","create","timeout","message","FrameSwappedByActivation","resolve","valueOrThrow","err","swapFrameTree","frame","add","_target","_targetId","removeFrame","updateId","mainRealm","clearContext","isolatedRealm","addFrame","updateClient","initialize","addClient","emit","undefined","registerSpeculativeSession","session","on","event","frameId","parentFrameId","id","type","url","reason","context","executionContextId","Promise","all","send","then","frameTree","enabled","error","executionContextById","contextId","getExecutionContextById","get","frames","Array","from","getById","onAttachedToTarget","target","_getTargetInfo","targetId","_session","_deviceRequestPromptManager","manager","set","_onLifecycleEvent","loaderId","name","LifecycleEvent","_onLoadingStarted","_onLoadingStopped","parentId","has","delete","isOOPFrame","FrameAttached","framePayload","navigationType","isMainFrame","_id","waitForFrame","_navigated","FrameNavigated","key","source","INTERNAL_URL","worldName","filter","map","grantUniveralAccess","_navigatedWithinDocument","FrameNavigatedWithinDocument","FrameSwapped","contextPayload","auxData","world","worlds","hasContext","setContext","_world","entries","_client","FrameDetached"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\FrameManager.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {type CDPSession, CDPSessionEvent} from '../api/CDPSession.js';\nimport {FrameEvent} from '../api/Frame.js';\nimport {EventEmitter} from '../common/EventEmitter.js';\nimport type {TimeoutSettings} from '../common/TimeoutSettings.js';\nimport {debugError, PuppeteerURL, UTILITY_WORLD_NAME} from '../common/util.js';\nimport {assert} from '../util/assert.js';\nimport {Deferred} from '../util/Deferred.js';\nimport {disposeSymbol} from '../util/disposable.js';\nimport {isErrorLike} from '../util/ErrorLike.js';\n\nimport {CdpCDPSession} from './CDPSession.js';\nimport {isTargetClosedError} from './Connection.js';\nimport {DeviceRequestPromptManager} from './DeviceRequestPrompt.js';\nimport {ExecutionContext} from './ExecutionContext.js';\nimport {CdpFrame} from './Frame.js';\nimport type {FrameManagerEvents} from './FrameManagerEvents.js';\nimport {FrameManagerEvent} from './FrameManagerEvents.js';\nimport {FrameTree} from './FrameTree.js';\nimport type {IsolatedWorld} from './IsolatedWorld.js';\nimport {MAIN_WORLD, PUPPETEER_WORLD} from './IsolatedWorlds.js';\nimport {NetworkManager} from './NetworkManager.js';\nimport type {CdpPage} from './Page.js';\nimport type {CdpTarget} from './Target.js';\n\nconst TIME_FOR_WAITING_FOR_SWAP = 100; // ms.\n\n/**\n * A frame manager manages the frames for a given {@link Page | page}.\n *\n * @internal\n */\nexport class FrameManager extends EventEmitter<FrameManagerEvents> {\n  #page: CdpPage;\n  #networkManager: NetworkManager;\n  #timeoutSettings: TimeoutSettings;\n  #contextIdToContext = new Map<string, ExecutionContext>();\n  #isolatedWorlds = new Set<string>();\n  #client: CDPSession;\n\n  _frameTree = new FrameTree<CdpFrame>();\n\n  /**\n   * Set of frame IDs stored to indicate if a frame has received a\n   * frameNavigated event so that frame tree responses could be ignored as the\n   * frameNavigated event usually contains the latest information.\n   */\n  #frameNavigatedReceived = new Set<string>();\n\n  #deviceRequestPromptManagerMap = new WeakMap<\n    CDPSession,\n    DeviceRequestPromptManager\n  >();\n\n  #frameTreeHandled?: Deferred<void>;\n\n  get timeoutSettings(): TimeoutSettings {\n    return this.#timeoutSettings;\n  }\n\n  get networkManager(): NetworkManager {\n    return this.#networkManager;\n  }\n\n  get client(): CDPSession {\n    return this.#client;\n  }\n\n  constructor(\n    client: CDPSession,\n    page: CdpPage,\n    ignoreHTTPSErrors: boolean,\n    timeoutSettings: TimeoutSettings\n  ) {\n    super();\n    this.#client = client;\n    this.#page = page;\n    this.#networkManager = new NetworkManager(ignoreHTTPSErrors, this);\n    this.#timeoutSettings = timeoutSettings;\n    this.setupEventListeners(this.#client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n  }\n\n  /**\n   * Called when the frame's client is disconnected. We don't know if the\n   * disconnect means that the frame is removed or if it will be replaced by a\n   * new frame. Therefore, we wait for a swap event.\n   */\n  async #onClientDisconnect() {\n    const mainFrame = this._frameTree.getMainFrame();\n    if (!mainFrame) {\n      return;\n    }\n    for (const child of mainFrame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    const swapped = Deferred.create<void>({\n      timeout: TIME_FOR_WAITING_FOR_SWAP,\n      message: 'Frame was not swapped',\n    });\n    mainFrame.once(FrameEvent.FrameSwappedByActivation, () => {\n      swapped.resolve();\n    });\n    try {\n      await swapped.valueOrThrow();\n    } catch (err) {\n      this.#removeFramesRecursively(mainFrame);\n    }\n  }\n\n  /**\n   * When the main frame is replaced by another main frame,\n   * we maintain the main frame object identity while updating\n   * its frame tree and ID.\n   */\n  async swapFrameTree(client: CDPSession): Promise<void> {\n    this.#onExecutionContextsCleared(this.#client);\n\n    this.#client = client;\n    assert(\n      this.#client instanceof CdpCDPSession,\n      'CDPSession is not an instance of CDPSessionImpl.'\n    );\n    const frame = this._frameTree.getMainFrame();\n    if (frame) {\n      this.#frameNavigatedReceived.add(this.#client._target()._targetId);\n      this._frameTree.removeFrame(frame);\n      frame.updateId(this.#client._target()._targetId);\n      frame.mainRealm().clearContext();\n      frame.isolatedRealm().clearContext();\n      this._frameTree.addFrame(frame);\n      frame.updateClient(client, true);\n    }\n    this.setupEventListeners(client);\n    client.once(CDPSessionEvent.Disconnected, () => {\n      this.#onClientDisconnect().catch(debugError);\n    });\n    await this.initialize(client);\n    await this.#networkManager.addClient(client);\n    if (frame) {\n      frame.emit(FrameEvent.FrameSwappedByActivation, undefined);\n    }\n  }\n\n  async registerSpeculativeSession(client: CdpCDPSession): Promise<void> {\n    await this.#networkManager.addClient(client);\n  }\n\n  private setupEventListeners(session: CDPSession) {\n    session.on('Page.frameAttached', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameAttached(session, event.frameId, event.parentFrameId);\n    });\n    session.on('Page.frameNavigated', async event => {\n      this.#frameNavigatedReceived.add(event.frame.id);\n      await this.#frameTreeHandled?.valueOrThrow();\n      void this.#onFrameNavigated(event.frame, event.type);\n    });\n    session.on('Page.navigatedWithinDocument', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameNavigatedWithinDocument(event.frameId, event.url);\n    });\n    session.on(\n      'Page.frameDetached',\n      async (event: Protocol.Page.FrameDetachedEvent) => {\n        await this.#frameTreeHandled?.valueOrThrow();\n        this.#onFrameDetached(\n          event.frameId,\n          event.reason as Protocol.Page.FrameDetachedEventReason\n        );\n      }\n    );\n    session.on('Page.frameStartedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStartedLoading(event.frameId);\n    });\n    session.on('Page.frameStoppedLoading', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onFrameStoppedLoading(event.frameId);\n    });\n    session.on('Runtime.executionContextCreated', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextCreated(event.context, session);\n    });\n    session.on('Runtime.executionContextDestroyed', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextDestroyed(event.executionContextId, session);\n    });\n    session.on('Runtime.executionContextsCleared', async () => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onExecutionContextsCleared(session);\n    });\n    session.on('Page.lifecycleEvent', async event => {\n      await this.#frameTreeHandled?.valueOrThrow();\n      this.#onLifecycleEvent(event);\n    });\n  }\n\n  async initialize(client: CDPSession): Promise<void> {\n    try {\n      this.#frameTreeHandled?.resolve();\n      this.#frameTreeHandled = Deferred.create();\n      // We need to schedule all these commands while the target is paused,\n      // therefore, it needs to happen synchroniously. At the same time we\n      // should not start processing execution context and frame events before\n      // we received the initial information about the frame tree.\n      await Promise.all([\n        this.#networkManager.addClient(client),\n        client.send('Page.enable'),\n        client.send('Page.getFrameTree').then(({frameTree}) => {\n          this.#handleFrameTree(client, frameTree);\n          this.#frameTreeHandled?.resolve();\n        }),\n        client.send('Page.setLifecycleEventsEnabled', {enabled: true}),\n        client.send('Runtime.enable').then(() => {\n          return this.#createIsolatedWorld(client, UTILITY_WORLD_NAME);\n        }),\n      ]);\n    } catch (error) {\n      this.#frameTreeHandled?.resolve();\n      // The target might have been closed before the initialization finished.\n      if (isErrorLike(error) && isTargetClosedError(error)) {\n        return;\n      }\n\n      throw error;\n    }\n  }\n\n  executionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext {\n    const context = this.getExecutionContextById(contextId, session);\n    assert(context, 'INTERNAL ERROR: missing context with id = ' + contextId);\n    return context;\n  }\n\n  getExecutionContextById(\n    contextId: number,\n    session: CDPSession = this.#client\n  ): ExecutionContext | undefined {\n    return this.#contextIdToContext.get(`${session.id()}:${contextId}`);\n  }\n\n  page(): CdpPage {\n    return this.#page;\n  }\n\n  mainFrame(): CdpFrame {\n    const mainFrame = this._frameTree.getMainFrame();\n    assert(mainFrame, 'Requesting main frame too early!');\n    return mainFrame;\n  }\n\n  frames(): CdpFrame[] {\n    return Array.from(this._frameTree.frames());\n  }\n\n  frame(frameId: string): CdpFrame | null {\n    return this._frameTree.getById(frameId) || null;\n  }\n\n  onAttachedToTarget(target: CdpTarget): void {\n    if (target._getTargetInfo().type !== 'iframe') {\n      return;\n    }\n\n    const frame = this.frame(target._getTargetInfo().targetId);\n    if (frame) {\n      frame.updateClient(target._session()!);\n    }\n    this.setupEventListeners(target._session()!);\n    void this.initialize(target._session()!);\n  }\n\n  _deviceRequestPromptManager(client: CDPSession): DeviceRequestPromptManager {\n    let manager = this.#deviceRequestPromptManagerMap.get(client);\n    if (manager === undefined) {\n      manager = new DeviceRequestPromptManager(client, this.#timeoutSettings);\n      this.#deviceRequestPromptManagerMap.set(client, manager);\n    }\n    return manager;\n  }\n\n  #onLifecycleEvent(event: Protocol.Page.LifecycleEventEvent): void {\n    const frame = this.frame(event.frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLifecycleEvent(event.loaderId, event.name);\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #onFrameStartedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStarted();\n  }\n\n  #onFrameStoppedLoading(frameId: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._onLoadingStopped();\n    this.emit(FrameManagerEvent.LifecycleEvent, frame);\n    frame.emit(FrameEvent.LifecycleEvent, undefined);\n  }\n\n  #handleFrameTree(\n    session: CDPSession,\n    frameTree: Protocol.Page.FrameTree\n  ): void {\n    if (frameTree.frame.parentId) {\n      this.#onFrameAttached(\n        session,\n        frameTree.frame.id,\n        frameTree.frame.parentId\n      );\n    }\n    if (!this.#frameNavigatedReceived.has(frameTree.frame.id)) {\n      void this.#onFrameNavigated(frameTree.frame, 'Navigation');\n    } else {\n      this.#frameNavigatedReceived.delete(frameTree.frame.id);\n    }\n\n    if (!frameTree.childFrames) {\n      return;\n    }\n\n    for (const child of frameTree.childFrames) {\n      this.#handleFrameTree(session, child);\n    }\n  }\n\n  #onFrameAttached(\n    session: CDPSession,\n    frameId: string,\n    parentFrameId: string\n  ): void {\n    let frame = this.frame(frameId);\n    if (frame) {\n      if (session && frame.isOOPFrame()) {\n        // If an OOP iframes becomes a normal iframe again\n        // it is first attached to the parent page before\n        // the target is removed.\n        frame.updateClient(session);\n      }\n      return;\n    }\n\n    frame = new CdpFrame(this, frameId, parentFrameId, session);\n    this._frameTree.addFrame(frame);\n    this.emit(FrameManagerEvent.FrameAttached, frame);\n  }\n\n  async #onFrameNavigated(\n    framePayload: Protocol.Page.Frame,\n    navigationType: Protocol.Page.NavigationType\n  ): Promise<void> {\n    const frameId = framePayload.id;\n    const isMainFrame = !framePayload.parentId;\n\n    let frame = this._frameTree.getById(frameId);\n\n    // Detach all child frames first.\n    if (frame) {\n      for (const child of frame.childFrames()) {\n        this.#removeFramesRecursively(child);\n      }\n    }\n\n    // Update or create main frame.\n    if (isMainFrame) {\n      if (frame) {\n        // Update frame id to retain frame identity on cross-process navigation.\n        this._frameTree.removeFrame(frame);\n        frame._id = frameId;\n      } else {\n        // Initial main frame navigation.\n        frame = new CdpFrame(this, frameId, undefined, this.#client);\n      }\n      this._frameTree.addFrame(frame);\n    }\n\n    frame = await this._frameTree.waitForFrame(frameId);\n    frame._navigated(framePayload);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, navigationType);\n  }\n\n  async #createIsolatedWorld(session: CDPSession, name: string): Promise<void> {\n    const key = `${session.id()}:${name}`;\n\n    if (this.#isolatedWorlds.has(key)) {\n      return;\n    }\n\n    await session.send('Page.addScriptToEvaluateOnNewDocument', {\n      source: `//# sourceURL=${PuppeteerURL.INTERNAL_URL}`,\n      worldName: name,\n    });\n\n    await Promise.all(\n      this.frames()\n        .filter(frame => {\n          return frame.client === session;\n        })\n        .map(frame => {\n          // Frames might be removed before we send this, so we don't want to\n          // throw an error.\n          return session\n            .send('Page.createIsolatedWorld', {\n              frameId: frame._id,\n              worldName: name,\n              grantUniveralAccess: true,\n            })\n            .catch(debugError);\n        })\n    );\n\n    this.#isolatedWorlds.add(key);\n  }\n\n  #onFrameNavigatedWithinDocument(frameId: string, url: string): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    frame._navigatedWithinDocument(url);\n    this.emit(FrameManagerEvent.FrameNavigatedWithinDocument, frame);\n    frame.emit(FrameEvent.FrameNavigatedWithinDocument, undefined);\n    this.emit(FrameManagerEvent.FrameNavigated, frame);\n    frame.emit(FrameEvent.FrameNavigated, 'Navigation');\n  }\n\n  #onFrameDetached(\n    frameId: string,\n    reason: Protocol.Page.FrameDetachedEventReason\n  ): void {\n    const frame = this.frame(frameId);\n    if (!frame) {\n      return;\n    }\n    switch (reason) {\n      case 'remove':\n        // Only remove the frame if the reason for the detached event is\n        // an actual removement of the frame.\n        // For frames that become OOP iframes, the reason would be 'swap'.\n        this.#removeFramesRecursively(frame);\n        break;\n      case 'swap':\n        this.emit(FrameManagerEvent.FrameSwapped, frame);\n        frame.emit(FrameEvent.FrameSwapped, undefined);\n        break;\n    }\n  }\n\n  #onExecutionContextCreated(\n    contextPayload: Protocol.Runtime.ExecutionContextDescription,\n    session: CDPSession\n  ): void {\n    const auxData = contextPayload.auxData as {frameId?: string} | undefined;\n    const frameId = auxData && auxData.frameId;\n    const frame = typeof frameId === 'string' ? this.frame(frameId) : undefined;\n    let world: IsolatedWorld | undefined;\n    if (frame) {\n      // Only care about execution contexts created for the current session.\n      if (frame.client !== session) {\n        return;\n      }\n      if (contextPayload.auxData && contextPayload.auxData['isDefault']) {\n        world = frame.worlds[MAIN_WORLD];\n      } else if (\n        contextPayload.name === UTILITY_WORLD_NAME &&\n        !frame.worlds[PUPPETEER_WORLD].hasContext()\n      ) {\n        // In case of multiple sessions to the same target, there's a race between\n        // connections so we might end up creating multiple isolated worlds.\n        // We can use either.\n        world = frame.worlds[PUPPETEER_WORLD];\n      }\n    }\n    // If there is no world, the context is not meant to be handled by us.\n    if (!world) {\n      return;\n    }\n    const context = new ExecutionContext(\n      frame?.client || this.#client,\n      contextPayload,\n      world\n    );\n    if (world) {\n      world.setContext(context);\n    }\n    const key = `${session.id()}:${contextPayload.id}`;\n    this.#contextIdToContext.set(key, context);\n  }\n\n  #onExecutionContextDestroyed(\n    executionContextId: number,\n    session: CDPSession\n  ): void {\n    const key = `${session.id()}:${executionContextId}`;\n    const context = this.#contextIdToContext.get(key);\n    if (!context) {\n      return;\n    }\n    this.#contextIdToContext.delete(key);\n    if (context._world) {\n      context._world.clearContext();\n    }\n  }\n\n  #onExecutionContextsCleared(session: CDPSession): void {\n    for (const [key, context] of this.#contextIdToContext.entries()) {\n      // Make sure to only clear execution contexts that belong\n      // to the current session.\n      if (context._client !== session) {\n        continue;\n      }\n      if (context._world) {\n        context._world.clearContext();\n      }\n      this.#contextIdToContext.delete(key);\n    }\n  }\n\n  #removeFramesRecursively(frame: CdpFrame): void {\n    for (const child of frame.childFrames()) {\n      this.#removeFramesRecursively(child);\n    }\n    frame[disposeSymbol]();\n    this._frameTree.removeFrame(frame);\n    this.emit(FrameManagerEvent.FrameDetached, frame);\n    frame.emit(FrameEvent.FrameDetached, frame);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}