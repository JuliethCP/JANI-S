{"ast":null,"code":"import { TimeoutError } from '../common/Errors.js';\n/**\n * Creates and returns a deferred object along with the resolve/reject functions.\n *\n * If the deferred has not been resolved/rejected within the `timeout` period,\n * the deferred gets resolves with a timeout error. `timeout` has to be greater than 0 or\n * it is ignored.\n *\n * @internal\n */\nexport class Deferred {\n  #isResolved = false;\n  #isRejected = false;\n  #value;\n  #resolver = () => {};\n  #taskPromise = new Promise(resolve => {\n    this.#resolver = resolve;\n  });\n  #timeoutId;\n  #timeoutError;\n  constructor(opts) {\n    if (opts && opts.timeout > 0) {\n      this.#timeoutError = new TimeoutError(opts.message);\n      this.#timeoutId = setTimeout(() => {\n        this.reject(this.#timeoutError);\n      }, opts.timeout);\n    }\n  }\n  #finish(value) {\n    clearTimeout(this.#timeoutId);\n    this.#value = value;\n    this.#resolver();\n  }\n  resolve(value) {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isResolved = true;\n    this.#finish(value);\n  }\n  reject(error) {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isRejected = true;\n    this.#finish(error);\n  }\n  resolved() {\n    return this.#isResolved;\n  }\n  finished() {\n    return this.#isResolved || this.#isRejected;\n  }\n  value() {\n    return this.#value;\n  }\n  async valueOrThrow() {\n    await this.#taskPromise;\n    if (this.#isRejected) {\n      throw this.#value;\n    }\n    return this.#value;\n  }\n  static create(opts) {\n    return new Deferred(opts);\n  }\n  static async race(awaitables) {\n    const deferredWithTimeout = new Set();\n    try {\n      const promises = awaitables.map(value => {\n        if (value instanceof Deferred) {\n          if (value.#timeoutId) {\n            deferredWithTimeout.add(value);\n          }\n          return value.valueOrThrow();\n        }\n        return value;\n      });\n      // eslint-disable-next-line no-restricted-syntax\n      return await Promise.race(promises);\n    } finally {\n      for (const deferred of deferredWithTimeout) {\n        // We need to stop the timeout else\n        // Node.JS will keep running the event loop till the\n        // timer executes\n        deferred.reject(new Error('Timeout cleared'));\n      }\n    }\n  }\n}","map":{"version":3,"mappings":"AAAA,SAAQA,YAAY,QAAO,qBAAqB;AAUhD;;;;;;;;;AASA,OAAM,MAAOC,QAAQ;EACnB,WAAW,GAAG,KAAK;EACnB,WAAW,GAAG,KAAK;EACnB,MAAM;EACN,SAAS,GAA0B,MAAK,CAAE,CAAC;EAC3C,YAAY,GAAG,IAAIC,OAAO,CAAOC,OAAO,IAAG;IACzC,IAAI,CAAC,SAAS,GAAGA,OAAO;EAC1B,CAAC,CAAC;EACF,UAAU;EACV,aAAa;EAEbC,YAAYC,IAAsB;IAChC,IAAIA,IAAI,IAAIA,IAAI,CAACC,OAAO,GAAG,CAAC,EAAE;MAC5B,IAAI,CAAC,aAAa,GAAG,IAAIN,YAAY,CAACK,IAAI,CAACE,OAAO,CAAC;MACnD,IAAI,CAAC,UAAU,GAAGC,UAAU,CAAC,MAAK;QAChC,IAAI,CAACC,MAAM,CAAC,IAAI,CAAC,aAAc,CAAC;MAClC,CAAC,EAAEJ,IAAI,CAACC,OAAO,CAAC;;EAEpB;EAEA,OAAO,CAACI,KAA2B;IACjCC,YAAY,CAAC,IAAI,CAAC,UAAU,CAAC;IAC7B,IAAI,CAAC,MAAM,GAAGD,KAAK;IACnB,IAAI,CAAC,SAAS,EAAE;EAClB;EAEAP,OAAO,CAACO,KAAQ;IACd,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,EAAE;MACxC;;IAEF,IAAI,CAAC,WAAW,GAAG,IAAI;IACvB,IAAI,CAAC,OAAO,CAACA,KAAK,CAAC;EACrB;EAEAD,MAAM,CAACG,KAAuB;IAC5B,IAAI,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW,EAAE;MACxC;;IAEF,IAAI,CAAC,WAAW,GAAG,IAAI;IACvB,IAAI,CAAC,OAAO,CAACA,KAAK,CAAC;EACrB;EAEAC,QAAQ;IACN,OAAO,IAAI,CAAC,WAAW;EACzB;EAEAC,QAAQ;IACN,OAAO,IAAI,CAAC,WAAW,IAAI,IAAI,CAAC,WAAW;EAC7C;EAEAJ,KAAK;IACH,OAAO,IAAI,CAAC,MAAM;EACpB;EAEA,MAAMK,YAAY;IAChB,MAAM,IAAI,CAAC,YAAY;IACvB,IAAI,IAAI,CAAC,WAAW,EAAE;MACpB,MAAM,IAAI,CAAC,MAAM;;IAEnB,OAAO,IAAI,CAAC,MAAW;EACzB;EAEA,OAAOC,MAAM,CACXX,IAAsB;IAEtB,OAAO,IAAIJ,QAAQ,CAAOI,IAAI,CAAC;EACjC;EAEA,aAAaY,IAAI,CACfC,UAA2C;IAE3C,MAAMC,mBAAmB,GAAG,IAAIC,GAAG,EAAe;IAClD,IAAI;MACF,MAAMC,QAAQ,GAAGH,UAAU,CAACI,GAAG,CAACZ,KAAK,IAAG;QACtC,IAAIA,KAAK,YAAYT,QAAQ,EAAE;UAC7B,IAAIS,KAAK,CAAC,UAAU,EAAE;YACpBS,mBAAmB,CAACI,GAAG,CAACb,KAAK,CAAC;;UAGhC,OAAOA,KAAK,CAACK,YAAY,EAAE;;QAG7B,OAAOL,KAAK;MACd,CAAC,CAAC;MACF;MACA,OAAO,MAAMR,OAAO,CAACe,IAAI,CAACI,QAAQ,CAAC;KACpC,SAAS;MACR,KAAK,MAAMG,QAAQ,IAAIL,mBAAmB,EAAE;QAC1C;QACA;QACA;QACAK,QAAQ,CAACf,MAAM,CAAC,IAAIgB,KAAK,CAAC,iBAAiB,CAAC,CAAC;;;EAGnD","names":["TimeoutError","Deferred","Promise","resolve","constructor","opts","timeout","message","setTimeout","reject","value","clearTimeout","error","resolved","finished","valueOrThrow","create","race","awaitables","deferredWithTimeout","Set","promises","map","add","deferred","Error"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\util\\Deferred.ts"],"sourcesContent":["import {TimeoutError} from '../common/Errors.js';\n\n/**\n * @internal\n */\nexport interface DeferredOptions {\n  message: string;\n  timeout: number;\n}\n\n/**\n * Creates and returns a deferred object along with the resolve/reject functions.\n *\n * If the deferred has not been resolved/rejected within the `timeout` period,\n * the deferred gets resolves with a timeout error. `timeout` has to be greater than 0 or\n * it is ignored.\n *\n * @internal\n */\nexport class Deferred<T, V extends Error = Error> {\n  #isResolved = false;\n  #isRejected = false;\n  #value: T | V | TimeoutError | undefined;\n  #resolver: (value: void) => void = () => {};\n  #taskPromise = new Promise<void>(resolve => {\n    this.#resolver = resolve;\n  });\n  #timeoutId: ReturnType<typeof setTimeout> | undefined;\n  #timeoutError: TimeoutError | undefined;\n\n  constructor(opts?: DeferredOptions) {\n    if (opts && opts.timeout > 0) {\n      this.#timeoutError = new TimeoutError(opts.message);\n      this.#timeoutId = setTimeout(() => {\n        this.reject(this.#timeoutError!);\n      }, opts.timeout);\n    }\n  }\n\n  #finish(value: T | V | TimeoutError) {\n    clearTimeout(this.#timeoutId);\n    this.#value = value;\n    this.#resolver();\n  }\n\n  resolve(value: T): void {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isResolved = true;\n    this.#finish(value);\n  }\n\n  reject(error: V | TimeoutError): void {\n    if (this.#isRejected || this.#isResolved) {\n      return;\n    }\n    this.#isRejected = true;\n    this.#finish(error);\n  }\n\n  resolved(): boolean {\n    return this.#isResolved;\n  }\n\n  finished(): boolean {\n    return this.#isResolved || this.#isRejected;\n  }\n\n  value(): T | V | TimeoutError | undefined {\n    return this.#value;\n  }\n\n  async valueOrThrow(): Promise<T> {\n    await this.#taskPromise;\n    if (this.#isRejected) {\n      throw this.#value;\n    }\n    return this.#value as T;\n  }\n\n  static create<R, X extends Error = Error>(\n    opts?: DeferredOptions\n  ): Deferred<R> {\n    return new Deferred<R, X>(opts);\n  }\n\n  static async race<R>(\n    awaitables: Array<Promise<R> | Deferred<R>>\n  ): Promise<R> {\n    const deferredWithTimeout = new Set<Deferred<R>>();\n    try {\n      const promises = awaitables.map(value => {\n        if (value instanceof Deferred) {\n          if (value.#timeoutId) {\n            deferredWithTimeout.add(value);\n          }\n\n          return value.valueOrThrow();\n        }\n\n        return value;\n      });\n      // eslint-disable-next-line no-restricted-syntax\n      return await Promise.race(promises);\n    } finally {\n      for (const deferred of deferredWithTimeout) {\n        // We need to stop the timeout else\n        // Node.JS will keep running the event loop till the\n        // timer executes\n        deferred.reject(new Error('Timeout cleared'));\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}