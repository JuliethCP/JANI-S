{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { asyncDisposeSymbol, disposeSymbol } from './disposable.js';\nimport { Mutex } from './Mutex.js';\nconst instances = new WeakSet();\nexport function moveable(Class, _) {\n  let hasDispose = false;\n  if (Class.prototype[disposeSymbol]) {\n    const dispose = Class.prototype[disposeSymbol];\n    Class.prototype[disposeSymbol] = function () {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return dispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (Class.prototype[asyncDisposeSymbol]) {\n    const asyncDispose = Class.prototype[asyncDisposeSymbol];\n    Class.prototype[asyncDisposeSymbol] = function () {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return asyncDispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (hasDispose) {\n    Class.prototype.move = function () {\n      instances.add(this);\n      return this;\n    };\n  }\n  return Class;\n}\nexport function throwIfDisposed() {\n  let message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : value => {\n    return `Attempted to use disposed ${value.constructor.name}.`;\n  };\n  return (target, _) => {\n    return function () {\n      if (this.disposed) {\n        throw new Error(message(this));\n      }\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      return target.call(this, ...args);\n    };\n  };\n}\n/**\n * The decorator only invokes the target if the target has not been invoked with\n * the same arguments before. The decorated method throws an error if it's\n * invoked with a different number of elements: if you decorate a method, it\n * should have the same number of arguments\n *\n * @internal\n */\nexport function invokeAtMostOnceForArguments(target, _) {\n  const cache = new WeakMap();\n  let cacheDepth = -1;\n  return function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    if (cacheDepth === -1) {\n      cacheDepth = args.length;\n    }\n    if (cacheDepth !== args.length) {\n      throw new Error('Memoized method was called with the wrong number of arguments');\n    }\n    let freshArguments = false;\n    let cacheIterator = cache;\n    for (const arg of args) {\n      if (cacheIterator.has(arg)) {\n        cacheIterator = cacheIterator.get(arg);\n      } else {\n        freshArguments = true;\n        cacheIterator.set(arg, new WeakMap());\n        cacheIterator = cacheIterator.get(arg);\n      }\n    }\n    if (!freshArguments) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\nexport function guarded() {\n  let getKey = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n    return this;\n  };\n  return (target, _) => {\n    const mutexes = new WeakMap();\n    return async function () {\n      const env_1 = {\n        stack: [],\n        error: void 0,\n        hasError: false\n      };\n      try {\n        const key = getKey.call(this);\n        let mutex = mutexes.get(key);\n        if (!mutex) {\n          mutex = new Mutex();\n          mutexes.set(key, mutex);\n        }\n        const _ = __addDisposableResource(env_1, await mutex.acquire(), true);\n        for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n        return await target.call(this, ...args);\n      } catch (e_1) {\n        env_1.error = e_1;\n        env_1.hasError = true;\n      } finally {\n        const result_1 = __disposeResources(env_1);\n        if (result_1) await result_1;\n      }\n    };\n  };\n}","map":{"version":3,"mappings":"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","names":["asyncDisposeSymbol","disposeSymbol","Mutex","instances","WeakSet","moveable","Class","_","hasDispose","prototype","dispose","has","delete","call","asyncDispose","move","add","throwIfDisposed","message","value","constructor","name","target","disposed","Error","args","invokeAtMostOnceForArguments","cache","WeakMap","cacheDepth","length","freshArguments","cacheIterator","arg","get","set","guarded","getKey","mutexes","key","mutex","acquire"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\util\\decorators.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Disposed, Moveable} from '../common/types.js';\n\nimport {asyncDisposeSymbol, disposeSymbol} from './disposable.js';\nimport {Mutex} from './Mutex.js';\n\nconst instances = new WeakSet<object>();\n\nexport function moveable<\n  Class extends abstract new (...args: never[]) => Moveable,\n>(Class: Class, _: ClassDecoratorContext<Class>): Class {\n  let hasDispose = false;\n  if (Class.prototype[disposeSymbol]) {\n    const dispose = Class.prototype[disposeSymbol];\n    Class.prototype[disposeSymbol] = function (this: InstanceType<Class>) {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return dispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (Class.prototype[asyncDisposeSymbol]) {\n    const asyncDispose = Class.prototype[asyncDisposeSymbol];\n    Class.prototype[asyncDisposeSymbol] = function (this: InstanceType<Class>) {\n      if (instances.has(this)) {\n        instances.delete(this);\n        return;\n      }\n      return asyncDispose.call(this);\n    };\n    hasDispose = true;\n  }\n  if (hasDispose) {\n    Class.prototype.move = function (\n      this: InstanceType<Class>\n    ): InstanceType<Class> {\n      instances.add(this);\n      return this;\n    };\n  }\n  return Class;\n}\n\nexport function throwIfDisposed<This extends Disposed>(\n  message: (value: This) => string = value => {\n    return `Attempted to use disposed ${value.constructor.name}.`;\n  }\n) {\n  return (target: (this: This, ...args: any[]) => any, _: unknown) => {\n    return function (this: This, ...args: any[]): any {\n      if (this.disposed) {\n        throw new Error(message(this));\n      }\n      return target.call(this, ...args);\n    };\n  };\n}\n\n/**\n * The decorator only invokes the target if the target has not been invoked with\n * the same arguments before. The decorated method throws an error if it's\n * invoked with a different number of elements: if you decorate a method, it\n * should have the same number of arguments\n *\n * @internal\n */\nexport function invokeAtMostOnceForArguments(\n  target: (this: unknown, ...args: any[]) => any,\n  _: unknown\n): typeof target {\n  const cache = new WeakMap();\n  let cacheDepth = -1;\n  return function (this: unknown, ...args: unknown[]) {\n    if (cacheDepth === -1) {\n      cacheDepth = args.length;\n    }\n    if (cacheDepth !== args.length) {\n      throw new Error(\n        'Memoized method was called with the wrong number of arguments'\n      );\n    }\n    let freshArguments = false;\n    let cacheIterator = cache;\n    for (const arg of args) {\n      if (cacheIterator.has(arg as object)) {\n        cacheIterator = cacheIterator.get(arg as object)!;\n      } else {\n        freshArguments = true;\n        cacheIterator.set(arg as object, new WeakMap());\n        cacheIterator = cacheIterator.get(arg as object)!;\n      }\n    }\n    if (!freshArguments) {\n      return;\n    }\n    return target.call(this, ...args);\n  };\n}\n\nexport function guarded<T extends object>(\n  getKey = function (this: T): object {\n    return this;\n  }\n) {\n  return (\n    target: (this: T, ...args: any[]) => Promise<any>,\n    _: ClassMethodDecoratorContext<T>\n  ): typeof target => {\n    const mutexes = new WeakMap<object, Mutex>();\n    return async function (...args) {\n      const key = getKey.call(this);\n      let mutex = mutexes.get(key);\n      if (!mutex) {\n        mutex = new Mutex();\n        mutexes.set(key, mutex);\n      }\n      await using _ = await mutex.acquire();\n      return await target.call(this, ...args);\n    };\n  };\n}\n"]},"metadata":{},"sourceType":"module"}