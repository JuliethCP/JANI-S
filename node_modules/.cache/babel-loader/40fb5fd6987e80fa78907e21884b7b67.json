{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { Keyboard, Mouse, MouseButton, Touchscreen } from '../api/Input.js';\nimport { _keyDefinitions } from '../common/USKeyboardLayout.js';\nimport { assert } from '../util/assert.js';\n/**\n * @internal\n */\nexport class CdpKeyboard extends Keyboard {\n  #client;\n  #pressedKeys = new Set();\n  _modifiers = 0;\n  constructor(client) {\n    super();\n    this.#client = client;\n  }\n  updateClient(client) {\n    this.#client = client;\n  }\n  async down(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      text: undefined,\n      commands: []\n    };\n    const description = this.#keyDescriptionForString(key);\n    const autoRepeat = this.#pressedKeys.has(description.code);\n    this.#pressedKeys.add(description.code);\n    this._modifiers |= this.#modifierBit(description.key);\n    const text = options.text === undefined ? description.text : options.text;\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: this._modifiers,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      key: description.key,\n      text: text,\n      unmodifiedText: text,\n      autoRepeat,\n      location: description.location,\n      isKeypad: description.location === 3,\n      commands: options.commands\n    });\n  }\n  #modifierBit(key) {\n    if (key === 'Alt') {\n      return 1;\n    }\n    if (key === 'Control') {\n      return 2;\n    }\n    if (key === 'Meta') {\n      return 4;\n    }\n    if (key === 'Shift') {\n      return 8;\n    }\n    return 0;\n  }\n  #keyDescriptionForString(keyString) {\n    const shift = this._modifiers & 8;\n    const description = {\n      key: '',\n      keyCode: 0,\n      code: '',\n      text: '',\n      location: 0\n    };\n    const definition = _keyDefinitions[keyString];\n    assert(definition, `Unknown key: \"${keyString}\"`);\n    if (definition.key) {\n      description.key = definition.key;\n    }\n    if (shift && definition.shiftKey) {\n      description.key = definition.shiftKey;\n    }\n    if (definition.keyCode) {\n      description.keyCode = definition.keyCode;\n    }\n    if (shift && definition.shiftKeyCode) {\n      description.keyCode = definition.shiftKeyCode;\n    }\n    if (definition.code) {\n      description.code = definition.code;\n    }\n    if (definition.location) {\n      description.location = definition.location;\n    }\n    if (description.key.length === 1) {\n      description.text = description.key;\n    }\n    if (definition.text) {\n      description.text = definition.text;\n    }\n    if (shift && definition.shiftText) {\n      description.text = definition.shiftText;\n    }\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._modifiers & ~8) {\n      description.text = '';\n    }\n    return description;\n  }\n  async up(key) {\n    const description = this.#keyDescriptionForString(key);\n    this._modifiers &= ~this.#modifierBit(description.key);\n    this.#pressedKeys.delete(description.code);\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: this._modifiers,\n      key: description.key,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      location: description.location\n    });\n  }\n  async sendCharacter(char) {\n    await this.#client.send('Input.insertText', {\n      text: char\n    });\n  }\n  charIsKey(char) {\n    return !!_keyDefinitions[char];\n  }\n  async type(text) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const delay = options.delay || undefined;\n    for (const char of text) {\n      if (this.charIsKey(char)) {\n        await this.press(char, {\n          delay\n        });\n      } else {\n        if (delay) {\n          await new Promise(f => {\n            return setTimeout(f, delay);\n          });\n        }\n        await this.sendCharacter(char);\n      }\n    }\n  }\n  async press(key) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      delay = null\n    } = options;\n    await this.down(key, options);\n    if (delay) {\n      await new Promise(f => {\n        return setTimeout(f, options.delay);\n      });\n    }\n    await this.up(key);\n  }\n}\nconst getFlag = button => {\n  switch (button) {\n    case MouseButton.Left:\n      return 1 /* MouseButtonFlag.Left */;\n    case MouseButton.Right:\n      return 2 /* MouseButtonFlag.Right */;\n    case MouseButton.Middle:\n      return 4 /* MouseButtonFlag.Middle */;\n    case MouseButton.Back:\n      return 8 /* MouseButtonFlag.Back */;\n    case MouseButton.Forward:\n      return 16 /* MouseButtonFlag.Forward */;\n  }\n};\n/**\n * This should match\n * https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:content/browser/renderer_host/input/web_input_event_builders_mac.mm;drc=a61b95c63b0b75c1cfe872d9c8cdf927c226046e;bpv=1;bpt=1;l=221.\n */\nconst getButtonFromPressedButtons = buttons => {\n  if (buttons & 1 /* MouseButtonFlag.Left */) {\n    return MouseButton.Left;\n  } else if (buttons & 2 /* MouseButtonFlag.Right */) {\n    return MouseButton.Right;\n  } else if (buttons & 4 /* MouseButtonFlag.Middle */) {\n    return MouseButton.Middle;\n  } else if (buttons & 8 /* MouseButtonFlag.Back */) {\n    return MouseButton.Back;\n  } else if (buttons & 16 /* MouseButtonFlag.Forward */) {\n    return MouseButton.Forward;\n  }\n  return 'none';\n};\n/**\n * @internal\n */\nexport class CdpMouse extends Mouse {\n  #client;\n  #keyboard;\n  constructor(client, keyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n  updateClient(client) {\n    this.#client = client;\n  }\n  #_state = {\n    position: {\n      x: 0,\n      y: 0\n    },\n    buttons: 0 /* MouseButtonFlag.None */\n  };\n\n  get #state() {\n    return Object.assign({\n      ...this.#_state\n    }, ...this.#transactions);\n  }\n  // Transactions can run in parallel, so we store each of thme in this array.\n  #transactions = [];\n  #createTransaction() {\n    const transaction = {};\n    this.#transactions.push(transaction);\n    const popTransaction = () => {\n      this.#transactions.splice(this.#transactions.indexOf(transaction), 1);\n    };\n    return {\n      update: updates => {\n        Object.assign(transaction, updates);\n      },\n      commit: () => {\n        this.#_state = {\n          ...this.#_state,\n          ...transaction\n        };\n        popTransaction();\n      },\n      rollback: popTransaction\n    };\n  }\n  /**\n   * This is a shortcut for a typical update, commit/rollback lifecycle based on\n   * the error of the action.\n   */\n  async #withTransaction(action) {\n    const {\n      update,\n      commit,\n      rollback\n    } = this.#createTransaction();\n    try {\n      await action(update);\n      commit();\n    } catch (error) {\n      rollback();\n      throw error;\n    }\n  }\n  async reset() {\n    const actions = [];\n    for (const [flag, button] of [[1 /* MouseButtonFlag.Left */, MouseButton.Left], [4 /* MouseButtonFlag.Middle */, MouseButton.Middle], [2 /* MouseButtonFlag.Right */, MouseButton.Right], [16 /* MouseButtonFlag.Forward */, MouseButton.Forward], [8 /* MouseButtonFlag.Back */, MouseButton.Back]]) {\n      if (this.#state.buttons & flag) {\n        actions.push(this.up({\n          button: button\n        }));\n      }\n    }\n    if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {\n      actions.push(this.move(0, 0));\n    }\n    await Promise.all(actions);\n  }\n  async move(x, y) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      steps = 1\n    } = options;\n    const from = this.#state.position;\n    const to = {\n      x,\n      y\n    };\n    for (let i = 1; i <= steps; i++) {\n      await this.#withTransaction(updateState => {\n        updateState({\n          position: {\n            x: from.x + (to.x - from.x) * (i / steps),\n            y: from.y + (to.y - from.y) * (i / steps)\n          }\n        });\n        const {\n          buttons,\n          position\n        } = this.#state;\n        return this.#client.send('Input.dispatchMouseEvent', {\n          type: 'mouseMoved',\n          modifiers: this.#keyboard._modifiers,\n          buttons,\n          button: getButtonFromPressedButtons(buttons),\n          ...position\n        });\n      });\n    }\n  }\n  async down() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      button = MouseButton.Left,\n      clickCount = 1\n    } = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (this.#state.buttons & flag) {\n      throw new Error(`'${button}' is already pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons | flag\n      });\n      const {\n        buttons,\n        position\n      } = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mousePressed',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position\n      });\n    });\n  }\n  async up() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      button = MouseButton.Left,\n      clickCount = 1\n    } = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (!(this.#state.buttons & flag)) {\n      throw new Error(`'${button}' is not pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons & ~flag\n      });\n      const {\n        buttons,\n        position\n      } = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mouseReleased',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position\n      });\n    });\n  }\n  async click(x, y) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      delay,\n      count = 1,\n      clickCount = count\n    } = options;\n    if (count < 1) {\n      throw new Error('Click must occur a positive number of times.');\n    }\n    const actions = [this.move(x, y)];\n    if (clickCount === count) {\n      for (let i = 1; i < count; ++i) {\n        actions.push(this.down({\n          ...options,\n          clickCount: i\n        }), this.up({\n          ...options,\n          clickCount: i\n        }));\n      }\n    }\n    actions.push(this.down({\n      ...options,\n      clickCount\n    }));\n    if (typeof delay === 'number') {\n      await Promise.all(actions);\n      actions.length = 0;\n      await new Promise(resolve => {\n        setTimeout(resolve, delay);\n      });\n    }\n    actions.push(this.up({\n      ...options,\n      clickCount\n    }));\n    await Promise.all(actions);\n  }\n  async wheel() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const {\n      deltaX = 0,\n      deltaY = 0\n    } = options;\n    const {\n      position,\n      buttons\n    } = this.#state;\n    await this.#client.send('Input.dispatchMouseEvent', {\n      type: 'mouseWheel',\n      pointerType: 'mouse',\n      modifiers: this.#keyboard._modifiers,\n      deltaY,\n      deltaX,\n      buttons,\n      ...position\n    });\n  }\n  async drag(start, target) {\n    const promise = new Promise(resolve => {\n      this.#client.once('Input.dragIntercepted', event => {\n        return resolve(event.data);\n      });\n    });\n    await this.move(start.x, start.y);\n    await this.down();\n    await this.move(target.x, target.y);\n    return await promise;\n  }\n  async dragEnter(target, data) {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragEnter',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data\n    });\n  }\n  async dragOver(target, data) {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragOver',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data\n    });\n  }\n  async drop(target, data) {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'drop',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data\n    });\n  }\n  async dragAndDrop(start, target) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const {\n      delay = null\n    } = options;\n    const data = await this.drag(start, target);\n    await this.dragEnter(target, data);\n    await this.dragOver(target, data);\n    if (delay) {\n      await new Promise(resolve => {\n        return setTimeout(resolve, delay);\n      });\n    }\n    await this.drop(target, data);\n    await this.up();\n  }\n}\n/**\n * @internal\n */\nexport class CdpTouchscreen extends Touchscreen {\n  #client;\n  #keyboard;\n  constructor(client, keyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n  updateClient(client) {\n    this.#client = client;\n  }\n  async touchStart(x, y) {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchStart',\n      touchPoints: [{\n        x: Math.round(x),\n        y: Math.round(y),\n        radiusX: 0.5,\n        radiusY: 0.5\n      }],\n      modifiers: this.#keyboard._modifiers\n    });\n  }\n  async touchMove(x, y) {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchMove',\n      touchPoints: [{\n        x: Math.round(x),\n        y: Math.round(y),\n        radiusX: 0.5,\n        radiusY: 0.5\n      }],\n      modifiers: this.#keyboard._modifiers\n    });\n  }\n  async touchEnd() {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchEnd',\n      touchPoints: [],\n      modifiers: this.#keyboard._modifiers\n    });\n  }\n}","map":{"version":3,"mappings":"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","names":["Keyboard","Mouse","MouseButton","Touchscreen","_keyDefinitions","assert","CdpKeyboard","Set","_modifiers","constructor","client","updateClient","down","key","options","text","undefined","commands","description","autoRepeat","has","code","add","send","type","modifiers","windowsVirtualKeyCode","keyCode","unmodifiedText","location","isKeypad","keyString","shift","definition","shiftKey","shiftKeyCode","length","shiftText","up","delete","sendCharacter","char","charIsKey","delay","press","Promise","f","setTimeout","getFlag","button","Left","Right","Middle","Back","Forward","getButtonFromPressedButtons","buttons","CdpMouse","keyboard","position","x","y","Object","assign","transaction","push","popTransaction","splice","indexOf","update","updates","commit","rollback","action","error","reset","actions","flag","move","all","steps","from","to","i","updateState","clickCount","Error","click","count","resolve","wheel","deltaX","deltaY","pointerType","drag","start","target","promise","once","event","data","dragEnter","dragOver","drop","dragAndDrop","CdpTouchscreen","touchStart","touchPoints","Math","round","radiusX","radiusY","touchMove","touchEnd"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\cdp\\Input.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport type {CDPSession} from '../api/CDPSession.js';\nimport type {Point} from '../api/ElementHandle.js';\nimport {\n  Keyboard,\n  type KeyDownOptions,\n  type KeyPressOptions,\n  Mouse,\n  MouseButton,\n  type MouseClickOptions,\n  type MouseMoveOptions,\n  type MouseOptions,\n  type MouseWheelOptions,\n  Touchscreen,\n  type KeyboardTypeOptions,\n} from '../api/Input.js';\nimport {\n  _keyDefinitions,\n  type KeyDefinition,\n  type KeyInput,\n} from '../common/USKeyboardLayout.js';\nimport {assert} from '../util/assert.js';\n\ntype KeyDescription = Required<\n  Pick<KeyDefinition, 'keyCode' | 'key' | 'text' | 'code' | 'location'>\n>;\n\n/**\n * @internal\n */\nexport class CdpKeyboard extends Keyboard {\n  #client: CDPSession;\n  #pressedKeys = new Set<string>();\n\n  _modifiers = 0;\n\n  constructor(client: CDPSession) {\n    super();\n    this.#client = client;\n  }\n\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  override async down(\n    key: KeyInput,\n    options: Readonly<KeyDownOptions> = {\n      text: undefined,\n      commands: [],\n    }\n  ): Promise<void> {\n    const description = this.#keyDescriptionForString(key);\n\n    const autoRepeat = this.#pressedKeys.has(description.code);\n    this.#pressedKeys.add(description.code);\n    this._modifiers |= this.#modifierBit(description.key);\n\n    const text = options.text === undefined ? description.text : options.text;\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: text ? 'keyDown' : 'rawKeyDown',\n      modifiers: this._modifiers,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      key: description.key,\n      text: text,\n      unmodifiedText: text,\n      autoRepeat,\n      location: description.location,\n      isKeypad: description.location === 3,\n      commands: options.commands,\n    });\n  }\n\n  #modifierBit(key: string): number {\n    if (key === 'Alt') {\n      return 1;\n    }\n    if (key === 'Control') {\n      return 2;\n    }\n    if (key === 'Meta') {\n      return 4;\n    }\n    if (key === 'Shift') {\n      return 8;\n    }\n    return 0;\n  }\n\n  #keyDescriptionForString(keyString: KeyInput): KeyDescription {\n    const shift = this._modifiers & 8;\n    const description = {\n      key: '',\n      keyCode: 0,\n      code: '',\n      text: '',\n      location: 0,\n    };\n\n    const definition = _keyDefinitions[keyString];\n    assert(definition, `Unknown key: \"${keyString}\"`);\n\n    if (definition.key) {\n      description.key = definition.key;\n    }\n    if (shift && definition.shiftKey) {\n      description.key = definition.shiftKey;\n    }\n\n    if (definition.keyCode) {\n      description.keyCode = definition.keyCode;\n    }\n    if (shift && definition.shiftKeyCode) {\n      description.keyCode = definition.shiftKeyCode;\n    }\n\n    if (definition.code) {\n      description.code = definition.code;\n    }\n\n    if (definition.location) {\n      description.location = definition.location;\n    }\n\n    if (description.key.length === 1) {\n      description.text = description.key;\n    }\n\n    if (definition.text) {\n      description.text = definition.text;\n    }\n    if (shift && definition.shiftText) {\n      description.text = definition.shiftText;\n    }\n\n    // if any modifiers besides shift are pressed, no text should be sent\n    if (this._modifiers & ~8) {\n      description.text = '';\n    }\n\n    return description;\n  }\n\n  override async up(key: KeyInput): Promise<void> {\n    const description = this.#keyDescriptionForString(key);\n\n    this._modifiers &= ~this.#modifierBit(description.key);\n    this.#pressedKeys.delete(description.code);\n    await this.#client.send('Input.dispatchKeyEvent', {\n      type: 'keyUp',\n      modifiers: this._modifiers,\n      key: description.key,\n      windowsVirtualKeyCode: description.keyCode,\n      code: description.code,\n      location: description.location,\n    });\n  }\n\n  override async sendCharacter(char: string): Promise<void> {\n    await this.#client.send('Input.insertText', {text: char});\n  }\n\n  private charIsKey(char: string): char is KeyInput {\n    return !!_keyDefinitions[char as KeyInput];\n  }\n\n  override async type(\n    text: string,\n    options: Readonly<KeyboardTypeOptions> = {}\n  ): Promise<void> {\n    const delay = options.delay || undefined;\n    for (const char of text) {\n      if (this.charIsKey(char)) {\n        await this.press(char, {delay});\n      } else {\n        if (delay) {\n          await new Promise(f => {\n            return setTimeout(f, delay);\n          });\n        }\n        await this.sendCharacter(char);\n      }\n    }\n  }\n\n  override async press(\n    key: KeyInput,\n    options: Readonly<KeyPressOptions> = {}\n  ): Promise<void> {\n    const {delay = null} = options;\n    await this.down(key, options);\n    if (delay) {\n      await new Promise(f => {\n        return setTimeout(f, options.delay);\n      });\n    }\n    await this.up(key);\n  }\n}\n\n/**\n * This must follow {@link Protocol.Input.DispatchMouseEventRequest.buttons}.\n */\nconst enum MouseButtonFlag {\n  None = 0,\n  Left = 1,\n  Right = 1 << 1,\n  Middle = 1 << 2,\n  Back = 1 << 3,\n  Forward = 1 << 4,\n}\n\nconst getFlag = (button: MouseButton): MouseButtonFlag => {\n  switch (button) {\n    case MouseButton.Left:\n      return MouseButtonFlag.Left;\n    case MouseButton.Right:\n      return MouseButtonFlag.Right;\n    case MouseButton.Middle:\n      return MouseButtonFlag.Middle;\n    case MouseButton.Back:\n      return MouseButtonFlag.Back;\n    case MouseButton.Forward:\n      return MouseButtonFlag.Forward;\n  }\n};\n\n/**\n * This should match\n * https://source.chromium.org/chromium/chromium/src/+/refs/heads/main:content/browser/renderer_host/input/web_input_event_builders_mac.mm;drc=a61b95c63b0b75c1cfe872d9c8cdf927c226046e;bpv=1;bpt=1;l=221.\n */\nconst getButtonFromPressedButtons = (\n  buttons: number\n): Protocol.Input.MouseButton => {\n  if (buttons & MouseButtonFlag.Left) {\n    return MouseButton.Left;\n  } else if (buttons & MouseButtonFlag.Right) {\n    return MouseButton.Right;\n  } else if (buttons & MouseButtonFlag.Middle) {\n    return MouseButton.Middle;\n  } else if (buttons & MouseButtonFlag.Back) {\n    return MouseButton.Back;\n  } else if (buttons & MouseButtonFlag.Forward) {\n    return MouseButton.Forward;\n  }\n  return 'none';\n};\n\ninterface MouseState {\n  /**\n   * The current position of the mouse.\n   */\n  position: Point;\n  /**\n   * The buttons that are currently being pressed.\n   */\n  buttons: number;\n}\n\n/**\n * @internal\n */\nexport class CdpMouse extends Mouse {\n  #client: CDPSession;\n  #keyboard: CdpKeyboard;\n\n  constructor(client: CDPSession, keyboard: CdpKeyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  #_state: Readonly<MouseState> = {\n    position: {x: 0, y: 0},\n    buttons: MouseButtonFlag.None,\n  };\n  get #state(): MouseState {\n    return Object.assign({...this.#_state}, ...this.#transactions);\n  }\n\n  // Transactions can run in parallel, so we store each of thme in this array.\n  #transactions: Array<Partial<MouseState>> = [];\n  #createTransaction(): {\n    update: (updates: Partial<MouseState>) => void;\n    commit: () => void;\n    rollback: () => void;\n  } {\n    const transaction: Partial<MouseState> = {};\n    this.#transactions.push(transaction);\n    const popTransaction = () => {\n      this.#transactions.splice(this.#transactions.indexOf(transaction), 1);\n    };\n    return {\n      update: (updates: Partial<MouseState>) => {\n        Object.assign(transaction, updates);\n      },\n      commit: () => {\n        this.#_state = {...this.#_state, ...transaction};\n        popTransaction();\n      },\n      rollback: popTransaction,\n    };\n  }\n\n  /**\n   * This is a shortcut for a typical update, commit/rollback lifecycle based on\n   * the error of the action.\n   */\n  async #withTransaction(\n    action: (update: (updates: Partial<MouseState>) => void) => Promise<unknown>\n  ): Promise<void> {\n    const {update, commit, rollback} = this.#createTransaction();\n    try {\n      await action(update);\n      commit();\n    } catch (error) {\n      rollback();\n      throw error;\n    }\n  }\n\n  override async reset(): Promise<void> {\n    const actions = [];\n    for (const [flag, button] of [\n      [MouseButtonFlag.Left, MouseButton.Left],\n      [MouseButtonFlag.Middle, MouseButton.Middle],\n      [MouseButtonFlag.Right, MouseButton.Right],\n      [MouseButtonFlag.Forward, MouseButton.Forward],\n      [MouseButtonFlag.Back, MouseButton.Back],\n    ] as const) {\n      if (this.#state.buttons & flag) {\n        actions.push(this.up({button: button}));\n      }\n    }\n    if (this.#state.position.x !== 0 || this.#state.position.y !== 0) {\n      actions.push(this.move(0, 0));\n    }\n    await Promise.all(actions);\n  }\n\n  override async move(\n    x: number,\n    y: number,\n    options: Readonly<MouseMoveOptions> = {}\n  ): Promise<void> {\n    const {steps = 1} = options;\n    const from = this.#state.position;\n    const to = {x, y};\n    for (let i = 1; i <= steps; i++) {\n      await this.#withTransaction(updateState => {\n        updateState({\n          position: {\n            x: from.x + (to.x - from.x) * (i / steps),\n            y: from.y + (to.y - from.y) * (i / steps),\n          },\n        });\n        const {buttons, position} = this.#state;\n        return this.#client.send('Input.dispatchMouseEvent', {\n          type: 'mouseMoved',\n          modifiers: this.#keyboard._modifiers,\n          buttons,\n          button: getButtonFromPressedButtons(buttons),\n          ...position,\n        });\n      });\n    }\n  }\n\n  override async down(options: Readonly<MouseOptions> = {}): Promise<void> {\n    const {button = MouseButton.Left, clickCount = 1} = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (this.#state.buttons & flag) {\n      throw new Error(`'${button}' is already pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons | flag,\n      });\n      const {buttons, position} = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mousePressed',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position,\n      });\n    });\n  }\n\n  override async up(options: Readonly<MouseOptions> = {}): Promise<void> {\n    const {button = MouseButton.Left, clickCount = 1} = options;\n    const flag = getFlag(button);\n    if (!flag) {\n      throw new Error(`Unsupported mouse button: ${button}`);\n    }\n    if (!(this.#state.buttons & flag)) {\n      throw new Error(`'${button}' is not pressed.`);\n    }\n    await this.#withTransaction(updateState => {\n      updateState({\n        buttons: this.#state.buttons & ~flag,\n      });\n      const {buttons, position} = this.#state;\n      return this.#client.send('Input.dispatchMouseEvent', {\n        type: 'mouseReleased',\n        modifiers: this.#keyboard._modifiers,\n        clickCount,\n        buttons,\n        button,\n        ...position,\n      });\n    });\n  }\n\n  override async click(\n    x: number,\n    y: number,\n    options: Readonly<MouseClickOptions> = {}\n  ): Promise<void> {\n    const {delay, count = 1, clickCount = count} = options;\n    if (count < 1) {\n      throw new Error('Click must occur a positive number of times.');\n    }\n    const actions: Array<Promise<void>> = [this.move(x, y)];\n    if (clickCount === count) {\n      for (let i = 1; i < count; ++i) {\n        actions.push(\n          this.down({...options, clickCount: i}),\n          this.up({...options, clickCount: i})\n        );\n      }\n    }\n    actions.push(this.down({...options, clickCount}));\n    if (typeof delay === 'number') {\n      await Promise.all(actions);\n      actions.length = 0;\n      await new Promise(resolve => {\n        setTimeout(resolve, delay);\n      });\n    }\n    actions.push(this.up({...options, clickCount}));\n    await Promise.all(actions);\n  }\n\n  override async wheel(\n    options: Readonly<MouseWheelOptions> = {}\n  ): Promise<void> {\n    const {deltaX = 0, deltaY = 0} = options;\n    const {position, buttons} = this.#state;\n    await this.#client.send('Input.dispatchMouseEvent', {\n      type: 'mouseWheel',\n      pointerType: 'mouse',\n      modifiers: this.#keyboard._modifiers,\n      deltaY,\n      deltaX,\n      buttons,\n      ...position,\n    });\n  }\n\n  override async drag(\n    start: Point,\n    target: Point\n  ): Promise<Protocol.Input.DragData> {\n    const promise = new Promise<Protocol.Input.DragData>(resolve => {\n      this.#client.once('Input.dragIntercepted', event => {\n        return resolve(event.data);\n      });\n    });\n    await this.move(start.x, start.y);\n    await this.down();\n    await this.move(target.x, target.y);\n    return await promise;\n  }\n\n  override async dragEnter(\n    target: Point,\n    data: Protocol.Input.DragData\n  ): Promise<void> {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragEnter',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data,\n    });\n  }\n\n  override async dragOver(\n    target: Point,\n    data: Protocol.Input.DragData\n  ): Promise<void> {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'dragOver',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data,\n    });\n  }\n\n  override async drop(\n    target: Point,\n    data: Protocol.Input.DragData\n  ): Promise<void> {\n    await this.#client.send('Input.dispatchDragEvent', {\n      type: 'drop',\n      x: target.x,\n      y: target.y,\n      modifiers: this.#keyboard._modifiers,\n      data,\n    });\n  }\n\n  override async dragAndDrop(\n    start: Point,\n    target: Point,\n    options: {delay?: number} = {}\n  ): Promise<void> {\n    const {delay = null} = options;\n    const data = await this.drag(start, target);\n    await this.dragEnter(target, data);\n    await this.dragOver(target, data);\n    if (delay) {\n      await new Promise(resolve => {\n        return setTimeout(resolve, delay);\n      });\n    }\n    await this.drop(target, data);\n    await this.up();\n  }\n}\n\n/**\n * @internal\n */\nexport class CdpTouchscreen extends Touchscreen {\n  #client: CDPSession;\n  #keyboard: CdpKeyboard;\n\n  constructor(client: CDPSession, keyboard: CdpKeyboard) {\n    super();\n    this.#client = client;\n    this.#keyboard = keyboard;\n  }\n\n  updateClient(client: CDPSession): void {\n    this.#client = client;\n  }\n\n  override async touchStart(x: number, y: number): Promise<void> {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchStart',\n      touchPoints: [\n        {\n          x: Math.round(x),\n          y: Math.round(y),\n          radiusX: 0.5,\n          radiusY: 0.5,\n        },\n      ],\n      modifiers: this.#keyboard._modifiers,\n    });\n  }\n\n  override async touchMove(x: number, y: number): Promise<void> {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchMove',\n      touchPoints: [\n        {\n          x: Math.round(x),\n          y: Math.round(y),\n          radiusX: 0.5,\n          radiusY: 0.5,\n        },\n      ],\n      modifiers: this.#keyboard._modifiers,\n    });\n  }\n\n  override async touchEnd(): Promise<void> {\n    await this.#client.send('Input.dispatchTouchEvent', {\n      type: 'touchEnd',\n      touchPoints: [],\n      modifiers: this.#keyboard._modifiers,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}