{"ast":null,"code":"/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { firstValueFrom, from, merge, raceWith, filterAsync, fromEvent } from '../../third_party/rxjs/rxjs.js';\nimport { EventEmitter } from '../common/EventEmitter.js';\nimport { debugError } from '../common/util.js';\nimport { timeout } from '../common/util.js';\nimport { asyncDisposeSymbol, disposeSymbol } from '../util/disposable.js';\n/**\n * @internal\n */\nexport const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map([['geolocation', 'geolocation'], ['midi', 'midi'], ['notifications', 'notifications'],\n// TODO: push isn't a valid type?\n// ['push', 'push'],\n['camera', 'videoCapture'], ['microphone', 'audioCapture'], ['background-sync', 'backgroundSync'], ['ambient-light-sensor', 'sensors'], ['accelerometer', 'sensors'], ['gyroscope', 'sensors'], ['magnetometer', 'sensors'], ['accessibility-events', 'accessibilityEvents'], ['clipboard-read', 'clipboardReadWrite'], ['clipboard-write', 'clipboardReadWrite'], ['clipboard-sanitized-write', 'clipboardSanitizedWrite'], ['payment-handler', 'paymentHandler'], ['persistent-storage', 'durableStorage'], ['idle-detection', 'idleDetection'],\n// chrome-specific permissions we have.\n['midi-sysex', 'midiSysex']]);\n/**\n * {@link Browser} represents a browser instance that is either:\n *\n * - connected to via {@link Puppeteer.connect} or\n * - launched by {@link PuppeteerNode.launch}.\n *\n * {@link Browser} {@link EventEmitter | emits} various events which are\n * documented in the {@link BrowserEvent} enum.\n *\n * @example Using a {@link Browser} to create a {@link Page}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * const page = await browser.newPage();\n * await page.goto('https://example.com');\n * await browser.close();\n * ```\n *\n * @example Disconnecting from and reconnecting to a {@link Browser}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * // Store the endpoint to be able to reconnect to the browser.\n * const browserWSEndpoint = browser.wsEndpoint();\n * // Disconnect puppeteer from the browser.\n * browser.disconnect();\n *\n * // Use the endpoint to reestablish a connection\n * const browser2 = await puppeteer.connect({browserWSEndpoint});\n * // Close the browser.\n * await browser2.close();\n * ```\n *\n * @public\n */\nexport class Browser extends EventEmitter {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n  /**\n   * @internal\n   */\n  _attach() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  _detach() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Gets the associated\n   * {@link https://nodejs.org/api/child_process.html#class-childprocess | ChildProcess}.\n   *\n   * @returns `null` if this instance was connected to via\n   * {@link Puppeteer.connect}.\n   */\n  process() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * @internal\n   */\n  _getIsPageTargetCallback() {\n    throw new Error('Not implemented');\n  }\n  _disposeContext() {\n    throw new Error('Not implemented');\n  }\n  _createPageInContext() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Waits until a {@link Target | target} matching the given `predicate`\n   * appears and returns it.\n   *\n   * This will look all open {@link BrowserContext | browser contexts}.\n   *\n   * @example Finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browser.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   */\n  async waitForTarget(predicate) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      timeout: ms = 30000\n    } = options;\n    return await firstValueFrom(merge(fromEvent(this, \"targetcreated\" /* BrowserEvent.TargetCreated */), fromEvent(this, \"targetchanged\" /* BrowserEvent.TargetChanged */), from(this.targets())).pipe(filterAsync(predicate), raceWith(timeout(ms))));\n  }\n  /**\n   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.\n   *\n   * If there ar multiple {@link BrowserContext | browser contexts}, this\n   * returns all {@link Page | pages} in all\n   * {@link BrowserContext | browser contexts}.\n   *\n   * @remarks Non-visible {@link Page | pages}, such as `\"background_page\"`,\n   * will not be listed here. You can find them using {@link Target.page}.\n   */\n  async pages() {\n    const contextPages = await Promise.all(this.browserContexts().map(context => {\n      return context.pages();\n    }));\n    // Flatten array.\n    return contextPages.reduce((acc, x) => {\n      return acc.concat(x);\n    }, []);\n  }\n  /**\n   * Gets this {@link Browser | browser's} original user agent.\n   *\n   * {@link Page | Pages} can override the user agent with\n   * {@link Page.setUserAgent}.\n   */\n  userAgent() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Disconnects Puppeteer from this {@link Browser | browser}, but leaves the\n   * process running.\n   */\n  disconnect() {\n    throw new Error('Not implemented');\n  }\n  /**\n   * Whether Puppeteer is connected to this {@link Browser | browser}.\n   *\n   * @deprecated Use {@link Browser.connected}.\n   */\n  isConnected() {\n    return this.connected;\n  }\n  /** @internal */\n  [disposeSymbol]() {\n    return void this.close().catch(debugError);\n  }\n  /** @internal */\n  [asyncDisposeSymbol]() {\n    return this.close();\n  }\n}","map":{"version":3,"mappings":"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","names":["firstValueFrom","from","merge","raceWith","filterAsync","fromEvent","EventEmitter","debugError","timeout","asyncDisposeSymbol","disposeSymbol","WEB_PERMISSION_TO_PROTOCOL_PERMISSION","Map","Browser","constructor","_attach","Error","_detach","process","_getIsPageTargetCallback","_disposeContext","_createPageInContext","waitForTarget","predicate","options","ms","targets","pipe","pages","contextPages","Promise","all","browserContexts","map","context","reduce","acc","x","concat","userAgent","disconnect","isConnected","connected","close","catch"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\api\\Browser.ts"],"sourcesContent":["/**\n * Copyright 2017 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {ChildProcess} from 'child_process';\n\nimport type {Protocol} from 'devtools-protocol';\n\nimport {\n  firstValueFrom,\n  from,\n  merge,\n  raceWith,\n  filterAsync,\n  fromEvent,\n  type Observable,\n} from '../../third_party/rxjs/rxjs.js';\nimport {EventEmitter, type EventType} from '../common/EventEmitter.js';\nimport {debugError} from '../common/util.js';\nimport {timeout} from '../common/util.js';\nimport {asyncDisposeSymbol, disposeSymbol} from '../util/disposable.js';\n\nimport type {BrowserContext} from './BrowserContext.js';\nimport type {Page} from './Page.js';\nimport type {Target} from './Target.js';\n/**\n * @public\n */\nexport interface BrowserContextOptions {\n  /**\n   * Proxy server with optional port to use for all requests.\n   * Username and password can be set in `Page.authenticate`.\n   */\n  proxyServer?: string;\n  /**\n   * Bypass the proxy for the given list of hosts.\n   */\n  proxyBypassList?: string[];\n}\n\n/**\n * @internal\n */\nexport type BrowserCloseCallback = () => Promise<void> | void;\n\n/**\n * @public\n */\nexport type TargetFilterCallback = (target: Target) => boolean;\n\n/**\n * @internal\n */\nexport type IsPageTargetCallback = (target: Target) => boolean;\n\n/**\n * @internal\n */\nexport const WEB_PERMISSION_TO_PROTOCOL_PERMISSION = new Map<\n  Permission,\n  Protocol.Browser.PermissionType\n>([\n  ['geolocation', 'geolocation'],\n  ['midi', 'midi'],\n  ['notifications', 'notifications'],\n  // TODO: push isn't a valid type?\n  // ['push', 'push'],\n  ['camera', 'videoCapture'],\n  ['microphone', 'audioCapture'],\n  ['background-sync', 'backgroundSync'],\n  ['ambient-light-sensor', 'sensors'],\n  ['accelerometer', 'sensors'],\n  ['gyroscope', 'sensors'],\n  ['magnetometer', 'sensors'],\n  ['accessibility-events', 'accessibilityEvents'],\n  ['clipboard-read', 'clipboardReadWrite'],\n  ['clipboard-write', 'clipboardReadWrite'],\n  ['clipboard-sanitized-write', 'clipboardSanitizedWrite'],\n  ['payment-handler', 'paymentHandler'],\n  ['persistent-storage', 'durableStorage'],\n  ['idle-detection', 'idleDetection'],\n  // chrome-specific permissions we have.\n  ['midi-sysex', 'midiSysex'],\n]);\n\n/**\n * @public\n */\nexport type Permission =\n  | 'geolocation'\n  | 'midi'\n  | 'notifications'\n  | 'camera'\n  | 'microphone'\n  | 'background-sync'\n  | 'ambient-light-sensor'\n  | 'accelerometer'\n  | 'gyroscope'\n  | 'magnetometer'\n  | 'accessibility-events'\n  | 'clipboard-read'\n  | 'clipboard-write'\n  | 'clipboard-sanitized-write'\n  | 'payment-handler'\n  | 'persistent-storage'\n  | 'idle-detection'\n  | 'midi-sysex';\n\n/**\n * @public\n */\nexport interface WaitForTargetOptions {\n  /**\n   * Maximum wait time in milliseconds. Pass `0` to disable the timeout.\n   *\n   * @defaultValue `30_000`\n   */\n  timeout?: number;\n}\n\n/**\n * All the events a {@link Browser | browser instance} may emit.\n *\n * @public\n */\nexport const enum BrowserEvent {\n  /**\n   * Emitted when Puppeteer gets disconnected from the browser instance. This\n   * might happen because either:\n   *\n   * - The browser closes/crashes or\n   * - {@link Browser.disconnect} was called.\n   */\n  Disconnected = 'disconnected',\n  /**\n   * Emitted when the URL of a target changes. Contains a {@link Target}\n   * instance.\n   *\n   * @remarks Note that this includes target changes in incognito browser\n   * contexts.\n   */\n  TargetChanged = 'targetchanged',\n  /**\n   * Emitted when a target is created, for example when a new page is opened by\n   * {@link https://developer.mozilla.org/en-US/docs/Web/API/Window/open | window.open}\n   * or by {@link Browser.newPage | browser.newPage}\n   *\n   * Contains a {@link Target} instance.\n   *\n   * @remarks Note that this includes target creations in incognito browser\n   * contexts.\n   */\n  TargetCreated = 'targetcreated',\n  /**\n   * Emitted when a target is destroyed, for example when a page is closed.\n   * Contains a {@link Target} instance.\n   *\n   * @remarks Note that this includes target destructions in incognito browser\n   * contexts.\n   */\n  TargetDestroyed = 'targetdestroyed',\n  /**\n   * @internal\n   */\n  TargetDiscovered = 'targetdiscovered',\n}\n\nexport {\n  /**\n   * @deprecated Use {@link BrowserEvent}.\n   */\n  BrowserEvent as BrowserEmittedEvents,\n};\n\n/**\n * @public\n */\nexport interface BrowserEvents extends Record<EventType, unknown> {\n  [BrowserEvent.Disconnected]: undefined;\n  [BrowserEvent.TargetCreated]: Target;\n  [BrowserEvent.TargetDestroyed]: Target;\n  [BrowserEvent.TargetChanged]: Target;\n  /**\n   * @internal\n   */\n  [BrowserEvent.TargetDiscovered]: Protocol.Target.TargetInfo;\n}\n\n/**\n * {@link Browser} represents a browser instance that is either:\n *\n * - connected to via {@link Puppeteer.connect} or\n * - launched by {@link PuppeteerNode.launch}.\n *\n * {@link Browser} {@link EventEmitter | emits} various events which are\n * documented in the {@link BrowserEvent} enum.\n *\n * @example Using a {@link Browser} to create a {@link Page}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * const page = await browser.newPage();\n * await page.goto('https://example.com');\n * await browser.close();\n * ```\n *\n * @example Disconnecting from and reconnecting to a {@link Browser}:\n *\n * ```ts\n * import puppeteer from 'puppeteer';\n *\n * const browser = await puppeteer.launch();\n * // Store the endpoint to be able to reconnect to the browser.\n * const browserWSEndpoint = browser.wsEndpoint();\n * // Disconnect puppeteer from the browser.\n * browser.disconnect();\n *\n * // Use the endpoint to reestablish a connection\n * const browser2 = await puppeteer.connect({browserWSEndpoint});\n * // Close the browser.\n * await browser2.close();\n * ```\n *\n * @public\n */\nexport abstract class Browser extends EventEmitter<BrowserEvents> {\n  /**\n   * @internal\n   */\n  constructor() {\n    super();\n  }\n\n  /**\n   * @internal\n   */\n  _attach(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  _detach(): void {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Gets the associated\n   * {@link https://nodejs.org/api/child_process.html#class-childprocess | ChildProcess}.\n   *\n   * @returns `null` if this instance was connected to via\n   * {@link Puppeteer.connect}.\n   */\n  process(): ChildProcess | null {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * @internal\n   */\n  _getIsPageTargetCallback(): IsPageTargetCallback | undefined {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Creates a new incognito {@link BrowserContext | browser context}.\n   *\n   * This won't share cookies/cache with other {@link BrowserContext | browser contexts}.\n   *\n   * @example\n   *\n   * ```ts\n   * import puppeteer from 'puppeteer';\n   *\n   * const browser = await puppeteer.launch();\n   * // Create a new incognito browser context.\n   * const context = await browser.createIncognitoBrowserContext();\n   * // Create a new page in a pristine context.\n   * const page = await context.newPage();\n   * // Do stuff\n   * await page.goto('https://example.com');\n   * ```\n   */\n  abstract createIncognitoBrowserContext(\n    options?: BrowserContextOptions\n  ): Promise<BrowserContext>;\n\n  /**\n   * Gets a list of open {@link BrowserContext | browser contexts}.\n   *\n   * In a newly-created {@link Browser | browser}, this will return a single\n   * instance of {@link BrowserContext}.\n   */\n  abstract browserContexts(): BrowserContext[];\n\n  /**\n   * Gets the default {@link BrowserContext | browser context}.\n   *\n   * @remarks The default {@link BrowserContext | browser context} cannot be\n   * closed.\n   */\n  abstract defaultBrowserContext(): BrowserContext;\n\n  /**\n   * @internal\n   */\n  _disposeContext(contextId?: string): Promise<void>;\n  _disposeContext(): Promise<void> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Gets the WebSocket URL to connect to this {@link Browser | browser}.\n   *\n   * This is usually used with {@link Puppeteer.connect}.\n   *\n   * You can find the debugger URL (`webSocketDebuggerUrl`) from\n   * `http://${host}:${port}/json/version`.\n   *\n   * See {@link\n   * https://chromedevtools.github.io/devtools-protocol/#how-do-i-access-the-browser-target\n   * | browser endpoint} for more information.\n   *\n   * @remarks The format is always `ws://${host}:${port}/devtools/browser/<id>`.\n   */\n  abstract wsEndpoint(): string;\n\n  /**\n   * Creates a new {@link Page | page} in the\n   * {@link Browser.defaultBrowserContext | default browser context}.\n   */\n  abstract newPage(): Promise<Page>;\n\n  /**\n   * @internal\n   */\n  _createPageInContext(contextId?: string): Promise<Page>;\n  _createPageInContext(): Promise<Page> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Gets all active {@link Target | targets}.\n   *\n   * In case of multiple {@link BrowserContext | browser contexts}, this returns\n   * all {@link Target | targets} in all\n   * {@link BrowserContext | browser contexts}.\n   */\n  abstract targets(): Target[];\n\n  /**\n   * Gets the {@link Target | target} associated with the\n   * {@link Browser.defaultBrowserContext | default browser context}).\n   */\n  abstract target(): Target;\n\n  /**\n   * Waits until a {@link Target | target} matching the given `predicate`\n   * appears and returns it.\n   *\n   * This will look all open {@link BrowserContext | browser contexts}.\n   *\n   * @example Finding a target for a page opened via `window.open`:\n   *\n   * ```ts\n   * await page.evaluate(() => window.open('https://www.example.com/'));\n   * const newWindowTarget = await browser.waitForTarget(\n   *   target => target.url() === 'https://www.example.com/'\n   * );\n   * ```\n   */\n  async waitForTarget(\n    predicate: (x: Target) => boolean | Promise<boolean>,\n    options: WaitForTargetOptions = {}\n  ): Promise<Target> {\n    const {timeout: ms = 30000} = options;\n    return await firstValueFrom(\n      merge(\n        fromEvent(this, BrowserEvent.TargetCreated) as Observable<Target>,\n        fromEvent(this, BrowserEvent.TargetChanged) as Observable<Target>,\n        from(this.targets())\n      ).pipe(filterAsync(predicate), raceWith(timeout(ms)))\n    );\n  }\n\n  /**\n   * Gets a list of all open {@link Page | pages} inside this {@link Browser}.\n   *\n   * If there ar multiple {@link BrowserContext | browser contexts}, this\n   * returns all {@link Page | pages} in all\n   * {@link BrowserContext | browser contexts}.\n   *\n   * @remarks Non-visible {@link Page | pages}, such as `\"background_page\"`,\n   * will not be listed here. You can find them using {@link Target.page}.\n   */\n  async pages(): Promise<Page[]> {\n    const contextPages = await Promise.all(\n      this.browserContexts().map(context => {\n        return context.pages();\n      })\n    );\n    // Flatten array.\n    return contextPages.reduce((acc, x) => {\n      return acc.concat(x);\n    }, []);\n  }\n\n  /**\n   * Gets a string representing this {@link Browser | browser's} name and\n   * version.\n   *\n   * For headless browser, this is similar to `\"HeadlessChrome/61.0.3153.0\"`. For\n   * non-headless or new-headless, this is similar to `\"Chrome/61.0.3153.0\"`. For\n   * Firefox, it is similar to `\"Firefox/116.0a1\"`.\n   *\n   * The format of {@link Browser.version} might change with future releases of\n   * browsers.\n   */\n  abstract version(): Promise<string>;\n\n  /**\n   * Gets this {@link Browser | browser's} original user agent.\n   *\n   * {@link Page | Pages} can override the user agent with\n   * {@link Page.setUserAgent}.\n   */\n  userAgent(): Promise<string> {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Closes this {@link Browser | browser} and all associated\n   * {@link Page | pages}.\n   */\n  abstract close(): Promise<void>;\n\n  /**\n   * Disconnects Puppeteer from this {@link Browser | browser}, but leaves the\n   * process running.\n   */\n  disconnect(): void {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Whether Puppeteer is connected to this {@link Browser | browser}.\n   *\n   * @deprecated Use {@link Browser.connected}.\n   */\n  isConnected(): boolean {\n    return this.connected;\n  }\n\n  /**\n   * Whether Puppeteer is connected to this {@link Browser | browser}.\n   */\n  abstract get connected(): boolean;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.close().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.close();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}