{"ast":null,"code":"function byteLength(string) {\n  let length = 0;\n  for (let i = 0, n = string.length; i < n; i++) {\n    const code = string.charCodeAt(i);\n    if (code >= 0xd800 && code <= 0xdbff && i + 1 < n) {\n      const code = string.charCodeAt(i + 1);\n      if (code >= 0xdc00 && code <= 0xdfff) {\n        length += 4;\n        i++;\n        continue;\n      }\n    }\n    if (code <= 0x7f) length += 1;else if (code <= 0x7ff) length += 2;else length += 3;\n  }\n  return length;\n}\nlet toString;\nif (typeof TextDecoder !== 'undefined') {\n  const decoder = new TextDecoder();\n  toString = function toString(buffer) {\n    return decoder.decode(buffer);\n  };\n} else {\n  toString = function toString(buffer) {\n    const len = buffer.byteLength;\n    let output = '';\n    let i = 0;\n    while (i < len) {\n      let byte = buffer[i];\n      if (byte <= 0x7f) {\n        output += String.fromCharCode(byte);\n        i++;\n        continue;\n      }\n      let bytesNeeded = 0;\n      let codePoint = 0;\n      if (byte <= 0xdf) {\n        bytesNeeded = 1;\n        codePoint = byte & 0x1f;\n      } else if (byte <= 0xef) {\n        bytesNeeded = 2;\n        codePoint = byte & 0x0f;\n      } else if (byte <= 0xf4) {\n        bytesNeeded = 3;\n        codePoint = byte & 0x07;\n      }\n      if (len - i - bytesNeeded > 0) {\n        let k = 0;\n        while (k < bytesNeeded) {\n          byte = buffer[i + k + 1];\n          codePoint = codePoint << 6 | byte & 0x3f;\n          k += 1;\n        }\n      } else {\n        codePoint = 0xfffd;\n        bytesNeeded = len - i;\n      }\n      output += String.fromCodePoint(codePoint);\n      i += bytesNeeded + 1;\n    }\n    return output;\n  };\n}\nlet write;\nif (typeof TextEncoder !== 'undefined') {\n  const encoder = new TextEncoder();\n  write = function write(buffer, string) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : byteLength(string);\n    const len = Math.min(length, buffer.byteLength - offset);\n    encoder.encodeInto(string, buffer.subarray(offset, offset + len));\n    return len;\n  };\n} else {\n  write = function write(buffer, string) {\n    let offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let length = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : byteLength(string);\n    const len = Math.min(length, buffer.byteLength - offset);\n    buffer = buffer.subarray(offset, offset + len);\n    let i = 0;\n    let j = 0;\n    while (i < string.length) {\n      const code = string.codePointAt(i);\n      if (code <= 0x7f) {\n        buffer[j++] = code;\n        i++;\n        continue;\n      }\n      let count = 0;\n      let bits = 0;\n      if (code <= 0x7ff) {\n        count = 6;\n        bits = 0xc0;\n      } else if (code <= 0xffff) {\n        count = 12;\n        bits = 0xe0;\n      } else if (code <= 0x1fffff) {\n        count = 18;\n        bits = 0xf0;\n      }\n      buffer[j++] = bits | code >> count;\n      count -= 6;\n      while (count >= 0) {\n        buffer[j++] = 0x80 | code >> count & 0x3f;\n        count -= 6;\n      }\n      i += code >= 0x10000 ? 2 : 1;\n    }\n    return len;\n  };\n}\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n};","map":{"version":3,"names":["byteLength","string","length","i","n","code","charCodeAt","toString","TextDecoder","decoder","buffer","decode","len","output","byte","String","fromCharCode","bytesNeeded","codePoint","k","fromCodePoint","write","TextEncoder","encoder","offset","Math","min","encodeInto","subarray","j","codePointAt","count","bits","module","exports"],"sources":["D:/Julieth-Campos/PSO/node_modules/b4a/lib/utf8.js"],"sourcesContent":["function byteLength (string) {\n  let length = 0\n\n  for (let i = 0, n = string.length; i < n; i++) {\n    const code = string.charCodeAt(i)\n\n    if (code >= 0xd800 && code <= 0xdbff && i + 1 < n) {\n      const code = string.charCodeAt(i + 1)\n\n      if (code >= 0xdc00 && code <= 0xdfff) {\n        length += 4\n        i++\n        continue\n      }\n    }\n\n    if (code <= 0x7f) length += 1\n    else if (code <= 0x7ff) length += 2\n    else length += 3\n  }\n\n  return length\n}\n\nlet toString\n\nif (typeof TextDecoder !== 'undefined') {\n  const decoder = new TextDecoder()\n\n  toString = function toString (buffer) {\n    return decoder.decode(buffer)\n  }\n} else {\n  toString = function toString (buffer) {\n    const len = buffer.byteLength\n\n    let output = ''\n    let i = 0\n\n    while (i < len) {\n      let byte = buffer[i]\n\n      if (byte <= 0x7f) {\n        output += String.fromCharCode(byte)\n        i++\n        continue\n      }\n\n      let bytesNeeded = 0\n      let codePoint = 0\n\n      if (byte <= 0xdf) {\n        bytesNeeded = 1\n        codePoint = byte & 0x1f\n      } else if (byte <= 0xef) {\n        bytesNeeded = 2\n        codePoint = byte & 0x0f\n      } else if (byte <= 0xf4) {\n        bytesNeeded = 3\n        codePoint = byte & 0x07\n      }\n\n      if (len - i - bytesNeeded > 0) {\n        let k = 0\n\n        while (k < bytesNeeded) {\n          byte = buffer[i + k + 1]\n          codePoint = (codePoint << 6) | (byte & 0x3f)\n          k += 1\n        }\n      } else {\n        codePoint = 0xfffd\n        bytesNeeded = len - i\n      }\n\n      output += String.fromCodePoint(codePoint)\n      i += bytesNeeded + 1\n    }\n\n    return output\n  }\n}\n\nlet write\n\nif (typeof TextEncoder !== 'undefined') {\n  const encoder = new TextEncoder()\n\n  write = function write (buffer, string, offset = 0, length = byteLength(string)) {\n    const len = Math.min(length, buffer.byteLength - offset)\n    encoder.encodeInto(string, buffer.subarray(offset, offset + len))\n    return len\n  }\n} else {\n  write = function write (buffer, string, offset = 0, length = byteLength(string)) {\n    const len = Math.min(length, buffer.byteLength - offset)\n\n    buffer = buffer.subarray(offset, offset + len)\n\n    let i = 0\n    let j = 0\n\n    while (i < string.length) {\n      const code = string.codePointAt(i)\n\n      if (code <= 0x7f) {\n        buffer[j++] = code\n        i++\n        continue\n      }\n\n      let count = 0\n      let bits = 0\n\n      if (code <= 0x7ff) {\n        count = 6\n        bits = 0xc0\n      } else if (code <= 0xffff) {\n        count = 12\n        bits = 0xe0\n      } else if (code <= 0x1fffff) {\n        count = 18\n        bits = 0xf0\n      }\n\n      buffer[j++] = bits | (code >> count)\n      count -= 6\n\n      while (count >= 0) {\n        buffer[j++] = 0x80 | ((code >> count) & 0x3f)\n        count -= 6\n      }\n\n      i += code >= 0x10000 ? 2 : 1\n    }\n\n    return len\n  }\n}\n\nmodule.exports = {\n  byteLength,\n  toString,\n  write\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}