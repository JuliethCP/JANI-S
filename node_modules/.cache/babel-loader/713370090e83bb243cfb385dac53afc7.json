{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Def = void 0;\nvar tslib_1 = require(\"tslib\");\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\nvar BaseType = /** @class */function () {\n  function BaseType() {}\n  BaseType.prototype.assert = function (value, deep) {\n    if (!this.check(value, deep)) {\n      var str = shallowStringify(value);\n      throw new Error(str + \" does not match type \" + this);\n    }\n    return true;\n  };\n  BaseType.prototype.arrayOf = function () {\n    var elemType = this;\n    return new ArrayType(elemType);\n  };\n  return BaseType;\n}();\nvar ArrayType = /** @class */function (_super) {\n  tslib_1.__extends(ArrayType, _super);\n  function ArrayType(elemType) {\n    var _this = _super.call(this) || this;\n    _this.elemType = elemType;\n    _this.kind = \"ArrayType\";\n    return _this;\n  }\n  ArrayType.prototype.toString = function () {\n    return \"[\" + this.elemType + \"]\";\n  };\n  ArrayType.prototype.check = function (value, deep) {\n    var _this = this;\n    return Array.isArray(value) && value.every(function (elem) {\n      return _this.elemType.check(elem, deep);\n    });\n  };\n  return ArrayType;\n}(BaseType);\nvar IdentityType = /** @class */function (_super) {\n  tslib_1.__extends(IdentityType, _super);\n  function IdentityType(value) {\n    var _this = _super.call(this) || this;\n    _this.value = value;\n    _this.kind = \"IdentityType\";\n    return _this;\n  }\n  IdentityType.prototype.toString = function () {\n    return String(this.value);\n  };\n  IdentityType.prototype.check = function (value, deep) {\n    var result = value === this.value;\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n    return result;\n  };\n  return IdentityType;\n}(BaseType);\nvar ObjectType = /** @class */function (_super) {\n  tslib_1.__extends(ObjectType, _super);\n  function ObjectType(fields) {\n    var _this = _super.call(this) || this;\n    _this.fields = fields;\n    _this.kind = \"ObjectType\";\n    return _this;\n  }\n  ObjectType.prototype.toString = function () {\n    return \"{ \" + this.fields.join(\", \") + \" }\";\n  };\n  ObjectType.prototype.check = function (value, deep) {\n    return objToStr.call(value) === objToStr.call({}) && this.fields.every(function (field) {\n      return field.type.check(value[field.name], deep);\n    });\n  };\n  return ObjectType;\n}(BaseType);\nvar OrType = /** @class */function (_super) {\n  tslib_1.__extends(OrType, _super);\n  function OrType(types) {\n    var _this = _super.call(this) || this;\n    _this.types = types;\n    _this.kind = \"OrType\";\n    return _this;\n  }\n  OrType.prototype.toString = function () {\n    return this.types.join(\" | \");\n  };\n  OrType.prototype.check = function (value, deep) {\n    return this.types.some(function (type) {\n      return type.check(value, deep);\n    });\n  };\n  return OrType;\n}(BaseType);\nvar PredicateType = /** @class */function (_super) {\n  tslib_1.__extends(PredicateType, _super);\n  function PredicateType(name, predicate) {\n    var _this = _super.call(this) || this;\n    _this.name = name;\n    _this.predicate = predicate;\n    _this.kind = \"PredicateType\";\n    return _this;\n  }\n  PredicateType.prototype.toString = function () {\n    return this.name;\n  };\n  PredicateType.prototype.check = function (value, deep) {\n    var result = this.predicate(value, deep);\n    if (!result && typeof deep === \"function\") {\n      deep(this, value);\n    }\n    return result;\n  };\n  return PredicateType;\n}(BaseType);\nvar Def = /** @class */function () {\n  function Def(type, typeName) {\n    this.type = type;\n    this.typeName = typeName;\n    this.baseNames = [];\n    this.ownFields = Object.create(null);\n    // Includes own typeName. Populated during finalization.\n    this.allSupertypes = Object.create(null);\n    // Linear inheritance hierarchy. Populated during finalization.\n    this.supertypeList = [];\n    // Includes inherited fields.\n    this.allFields = Object.create(null);\n    // Non-hidden keys of allFields.\n    this.fieldNames = [];\n    // This property will be overridden as true by individual Def instances\n    // when they are finalized.\n    this.finalized = false;\n    // False by default until .build(...) is called on an instance.\n    this.buildable = false;\n    this.buildParams = [];\n  }\n  Def.prototype.isSupertypeOf = function (that) {\n    if (that instanceof Def) {\n      if (this.finalized !== true || that.finalized !== true) {\n        throw new Error(\"\");\n      }\n      return hasOwn.call(that.allSupertypes, this.typeName);\n    } else {\n      throw new Error(that + \" is not a Def\");\n    }\n  };\n  Def.prototype.checkAllFields = function (value, deep) {\n    var allFields = this.allFields;\n    if (this.finalized !== true) {\n      throw new Error(\"\" + this.typeName);\n    }\n    function checkFieldByName(name) {\n      var field = allFields[name];\n      var type = field.type;\n      var child = field.getValue(value);\n      return type.check(child, deep);\n    }\n    return value !== null && typeof value === \"object\" && Object.keys(allFields).every(checkFieldByName);\n  };\n  Def.prototype.bases = function () {\n    var supertypeNames = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      supertypeNames[_i] = arguments[_i];\n    }\n    var bases = this.baseNames;\n    if (this.finalized) {\n      if (supertypeNames.length !== bases.length) {\n        throw new Error(\"\");\n      }\n      for (var i = 0; i < supertypeNames.length; i++) {\n        if (supertypeNames[i] !== bases[i]) {\n          throw new Error(\"\");\n        }\n      }\n      return this;\n    }\n    supertypeNames.forEach(function (baseName) {\n      // This indexOf lookup may be O(n), but the typical number of base\n      // names is very small, and indexOf is a native Array method.\n      if (bases.indexOf(baseName) < 0) {\n        bases.push(baseName);\n      }\n    });\n    return this; // For chaining.\n  };\n\n  return Def;\n}();\nexports.Def = Def;\nvar Field = /** @class */function () {\n  function Field(name, type, defaultFn, hidden) {\n    this.name = name;\n    this.type = type;\n    this.defaultFn = defaultFn;\n    this.hidden = !!hidden;\n  }\n  Field.prototype.toString = function () {\n    return JSON.stringify(this.name) + \": \" + this.type;\n  };\n  Field.prototype.getValue = function (obj) {\n    var value = obj[this.name];\n    if (typeof value !== \"undefined\") {\n      return value;\n    }\n    if (typeof this.defaultFn === \"function\") {\n      value = this.defaultFn.call(obj);\n    }\n    return value;\n  };\n  return Field;\n}();\nfunction shallowStringify(value) {\n  if (Array.isArray(value)) {\n    return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n  }\n  if (value && typeof value === \"object\") {\n    return \"{ \" + Object.keys(value).map(function (key) {\n      return key + \": \" + value[key];\n    }).join(\", \") + \" }\";\n  }\n  return JSON.stringify(value);\n}\nfunction typesPlugin(_fork) {\n  var Type = {\n    or: function () {\n      var types = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        types[_i] = arguments[_i];\n      }\n      return new OrType(types.map(function (type) {\n        return Type.from(type);\n      }));\n    },\n    from: function (value, name) {\n      if (value instanceof ArrayType || value instanceof IdentityType || value instanceof ObjectType || value instanceof OrType || value instanceof PredicateType) {\n        return value;\n      }\n      // The Def type is used as a helper for constructing compound\n      // interface types for AST nodes.\n      if (value instanceof Def) {\n        return value.type;\n      }\n      // Support [ElemType] syntax.\n      if (isArray.check(value)) {\n        if (value.length !== 1) {\n          throw new Error(\"only one element type is permitted for typed arrays\");\n        }\n        return new ArrayType(Type.from(value[0]));\n      }\n      // Support { someField: FieldType, ... } syntax.\n      if (isObject.check(value)) {\n        return new ObjectType(Object.keys(value).map(function (name) {\n          return new Field(name, Type.from(value[name], name));\n        }));\n      }\n      if (typeof value === \"function\") {\n        var bicfIndex = builtInCtorFns.indexOf(value);\n        if (bicfIndex >= 0) {\n          return builtInCtorTypes[bicfIndex];\n        }\n        if (typeof name !== \"string\") {\n          throw new Error(\"missing name\");\n        }\n        return new PredicateType(name, value);\n      }\n      // As a last resort, toType returns a type that matches any value that\n      // is === from. This is primarily useful for literal values like\n      // toType(null), but it has the additional advantage of allowing\n      // toType to be a total function.\n      return new IdentityType(value);\n    },\n    // Define a type whose name is registered in a namespace (the defCache) so\n    // that future definitions will return the same type given the same name.\n    // In particular, this system allows for circular and forward definitions.\n    // The Def object d returned from Type.def may be used to configure the\n    // type d.type by calling methods such as d.bases, d.build, and d.field.\n    def: function (typeName) {\n      return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);\n    },\n    hasDef: function (typeName) {\n      return hasOwn.call(defCache, typeName);\n    }\n  };\n  var builtInCtorFns = [];\n  var builtInCtorTypes = [];\n  function defBuiltInType(name, example) {\n    var objStr = objToStr.call(example);\n    var type = new PredicateType(name, function (value) {\n      return objToStr.call(value) === objStr;\n    });\n    if (example && typeof example.constructor === \"function\") {\n      builtInCtorFns.push(example.constructor);\n      builtInCtorTypes.push(type);\n    }\n    return type;\n  }\n  // These types check the underlying [[Class]] attribute of the given\n  // value, rather than using the problematic typeof operator. Note however\n  // that no subtyping is considered; so, for instance, isObject.check\n  // returns false for [], /./, new Date, and null.\n  var isString = defBuiltInType(\"string\", \"truthy\");\n  var isFunction = defBuiltInType(\"function\", function () {});\n  var isArray = defBuiltInType(\"array\", []);\n  var isObject = defBuiltInType(\"object\", {});\n  var isRegExp = defBuiltInType(\"RegExp\", /./);\n  var isDate = defBuiltInType(\"Date\", new Date());\n  var isNumber = defBuiltInType(\"number\", 3);\n  var isBoolean = defBuiltInType(\"boolean\", true);\n  var isNull = defBuiltInType(\"null\", null);\n  var isUndefined = defBuiltInType(\"undefined\", undefined);\n  var builtInTypes = {\n    string: isString,\n    function: isFunction,\n    array: isArray,\n    object: isObject,\n    RegExp: isRegExp,\n    Date: isDate,\n    number: isNumber,\n    boolean: isBoolean,\n    null: isNull,\n    undefined: isUndefined\n  };\n  // In order to return the same Def instance every time Type.def is called\n  // with a particular name, those instances need to be stored in a cache.\n  var defCache = Object.create(null);\n  function defFromValue(value) {\n    if (value && typeof value === \"object\") {\n      var type = value.type;\n      if (typeof type === \"string\" && hasOwn.call(defCache, type)) {\n        var d = defCache[type];\n        if (d.finalized) {\n          return d;\n        }\n      }\n    }\n    return null;\n  }\n  var DefImpl = /** @class */function (_super) {\n    tslib_1.__extends(DefImpl, _super);\n    function DefImpl(typeName) {\n      var _this = _super.call(this, new PredicateType(typeName, function (value, deep) {\n        return _this.check(value, deep);\n      }), typeName) || this;\n      return _this;\n    }\n    DefImpl.prototype.check = function (value, deep) {\n      if (this.finalized !== true) {\n        throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n      }\n      // A Def type can only match an object value.\n      if (value === null || typeof value !== \"object\") {\n        return false;\n      }\n      var vDef = defFromValue(value);\n      if (!vDef) {\n        // If we couldn't infer the Def associated with the given value,\n        // and we expected it to be a SourceLocation or a Position, it was\n        // probably just missing a \"type\" field (because Esprima does not\n        // assign a type property to such nodes). Be optimistic and let\n        // this.checkAllFields make the final decision.\n        if (this.typeName === \"SourceLocation\" || this.typeName === \"Position\") {\n          return this.checkAllFields(value, deep);\n        }\n        // Calling this.checkAllFields for any other type of node is both\n        // bad for performance and way too forgiving.\n        return false;\n      }\n      // If checking deeply and vDef === this, then we only need to call\n      // checkAllFields once. Calling checkAllFields is too strict when deep\n      // is false, because then we only care about this.isSupertypeOf(vDef).\n      if (deep && vDef === this) {\n        return this.checkAllFields(value, deep);\n      }\n      // In most cases we rely exclusively on isSupertypeOf to make O(1)\n      // subtyping determinations. This suffices in most situations outside\n      // of unit tests, since interface conformance is checked whenever new\n      // instances are created using builder functions.\n      if (!this.isSupertypeOf(vDef)) {\n        return false;\n      }\n      // The exception is when deep is true; then, we recursively check all\n      // fields.\n      if (!deep) {\n        return true;\n      }\n      // Use the more specific Def (vDef) to perform the deep check, but\n      // shallow-check fields defined by the less specific Def (this).\n      return vDef.checkAllFields(value, deep) && this.checkAllFields(value, false);\n    };\n    DefImpl.prototype.build = function () {\n      var _this = this;\n      var buildParams = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        buildParams[_i] = arguments[_i];\n      }\n      // Calling Def.prototype.build multiple times has the effect of merely\n      // redefining this property.\n      this.buildParams = buildParams;\n      if (this.buildable) {\n        // If this Def is already buildable, update self.buildParams and\n        // continue using the old builder function.\n        return this;\n      }\n      // Every buildable type will have its \"type\" field filled in\n      // automatically. This includes types that are not subtypes of Node,\n      // like SourceLocation, but that seems harmless (TODO?).\n      this.field(\"type\", String, function () {\n        return _this.typeName;\n      });\n      // Override Dp.buildable for this Def instance.\n      this.buildable = true;\n      var addParam = function (built, param, arg, isArgAvailable) {\n        if (hasOwn.call(built, param)) return;\n        var all = _this.allFields;\n        if (!hasOwn.call(all, param)) {\n          throw new Error(\"\" + param);\n        }\n        var field = all[param];\n        var type = field.type;\n        var value;\n        if (isArgAvailable) {\n          value = arg;\n        } else if (field.defaultFn) {\n          // Expose the partially-built object to the default\n          // function as its `this` object.\n          value = field.defaultFn.call(built);\n        } else {\n          var message = \"no value or default function given for field \" + JSON.stringify(param) + \" of \" + _this.typeName + \"(\" + _this.buildParams.map(function (name) {\n            return all[name];\n          }).join(\", \") + \")\";\n          throw new Error(message);\n        }\n        if (!type.check(value)) {\n          throw new Error(shallowStringify(value) + \" does not match field \" + field + \" of type \" + _this.typeName);\n        }\n        built[param] = value;\n      };\n      // Calling the builder function will construct an instance of the Def,\n      // with positional arguments mapped to the fields original passed to .build.\n      // If not enough arguments are provided, the default value for the remaining fields\n      // will be used.\n      var builder = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n          args[_i] = arguments[_i];\n        }\n        var argc = args.length;\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n        var built = Object.create(nodePrototype);\n        _this.buildParams.forEach(function (param, i) {\n          if (i < argc) {\n            addParam(built, param, args[i], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n        Object.keys(_this.allFields).forEach(function (param) {\n          // Use the default value.\n          addParam(built, param, null, false);\n        });\n        // Make sure that the \"type\" field was filled automatically.\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n        return built;\n      };\n      // Calling .from on the builder function will construct an instance of the Def,\n      // using field values from the passed object. For fields missing from the passed object,\n      // their default value will be used.\n      builder.from = function (obj) {\n        if (!_this.finalized) {\n          throw new Error(\"attempting to instantiate unfinalized type \" + _this.typeName);\n        }\n        var built = Object.create(nodePrototype);\n        Object.keys(_this.allFields).forEach(function (param) {\n          if (hasOwn.call(obj, param)) {\n            addParam(built, param, obj[param], true);\n          } else {\n            addParam(built, param, null, false);\n          }\n        });\n        // Make sure that the \"type\" field was filled automatically.\n        if (built.type !== _this.typeName) {\n          throw new Error(\"\");\n        }\n        return built;\n      };\n      Object.defineProperty(builders, getBuilderName(this.typeName), {\n        enumerable: true,\n        value: builder\n      });\n      return this;\n    };\n    // The reason fields are specified using .field(...) instead of an object\n    // literal syntax is somewhat subtle: the object literal syntax would\n    // support only one key and one value, but with .field(...) we can pass\n    // any number of arguments to specify the field.\n    DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n      if (this.finalized) {\n        console.error(\"Ignoring attempt to redefine field \" + JSON.stringify(name) + \" of finalized type \" + JSON.stringify(this.typeName));\n        return this;\n      }\n      this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n      return this; // For chaining.\n    };\n\n    DefImpl.prototype.finalize = function () {\n      var _this = this;\n      // It's not an error to finalize a type more than once, but only the\n      // first call to .finalize does anything.\n      if (!this.finalized) {\n        var allFields = this.allFields;\n        var allSupertypes = this.allSupertypes;\n        this.baseNames.forEach(function (name) {\n          var def = defCache[name];\n          if (def instanceof Def) {\n            def.finalize();\n            extend(allFields, def.allFields);\n            extend(allSupertypes, def.allSupertypes);\n          } else {\n            var message = \"unknown supertype name \" + JSON.stringify(name) + \" for subtype \" + JSON.stringify(_this.typeName);\n            throw new Error(message);\n          }\n        });\n        // TODO Warn if fields are overridden with incompatible types.\n        extend(allFields, this.ownFields);\n        allSupertypes[this.typeName] = this;\n        this.fieldNames.length = 0;\n        for (var fieldName in allFields) {\n          if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {\n            this.fieldNames.push(fieldName);\n          }\n        }\n        // Types are exported only once they have been finalized.\n        Object.defineProperty(namedTypes, this.typeName, {\n          enumerable: true,\n          value: this.type\n        });\n        this.finalized = true;\n        // A linearization of the inheritance hierarchy.\n        populateSupertypeList(this.typeName, this.supertypeList);\n        if (this.buildable && this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n          wrapExpressionBuilderWithStatement(this.typeName);\n        }\n      }\n    };\n    return DefImpl;\n  }(Def);\n  // Note that the list returned by this function is a copy of the internal\n  // supertypeList, *without* the typeName itself as the first element.\n  function getSupertypeNames(typeName) {\n    if (!hasOwn.call(defCache, typeName)) {\n      throw new Error(\"\");\n    }\n    var d = defCache[typeName];\n    if (d.finalized !== true) {\n      throw new Error(\"\");\n    }\n    return d.supertypeList.slice(1);\n  }\n  // Returns an object mapping from every known type in the defCache to the\n  // most specific supertype whose name is an own property of the candidates\n  // object.\n  function computeSupertypeLookupTable(candidates) {\n    var table = {};\n    var typeNames = Object.keys(defCache);\n    var typeNameCount = typeNames.length;\n    for (var i = 0; i < typeNameCount; ++i) {\n      var typeName = typeNames[i];\n      var d = defCache[typeName];\n      if (d.finalized !== true) {\n        throw new Error(\"\" + typeName);\n      }\n      for (var j = 0; j < d.supertypeList.length; ++j) {\n        var superTypeName = d.supertypeList[j];\n        if (hasOwn.call(candidates, superTypeName)) {\n          table[typeName] = superTypeName;\n          break;\n        }\n      }\n    }\n    return table;\n  }\n  var builders = Object.create(null);\n  // This object is used as prototype for any node created by a builder.\n  var nodePrototype = {};\n  // Call this function to define a new method to be shared by all AST\n  // nodes. The replaced method (if any) is returned for easy wrapping.\n  function defineMethod(name, func) {\n    var old = nodePrototype[name];\n    // Pass undefined as func to delete nodePrototype[name].\n    if (isUndefined.check(func)) {\n      delete nodePrototype[name];\n    } else {\n      isFunction.assert(func);\n      Object.defineProperty(nodePrototype, name, {\n        enumerable: true,\n        configurable: true,\n        value: func\n      });\n    }\n    return old;\n  }\n  function getBuilderName(typeName) {\n    return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n      var len = upperCasePrefix.length;\n      switch (len) {\n        case 0:\n          return \"\";\n        // If there's only one initial capital letter, just lower-case it.\n        case 1:\n          return upperCasePrefix.toLowerCase();\n        default:\n          // If there's more than one initial capital letter, lower-case\n          // all but the last one, so that XMLDefaultDeclaration (for\n          // example) becomes xmlDefaultDeclaration.\n          return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);\n      }\n    });\n  }\n  function getStatementBuilderName(typeName) {\n    typeName = getBuilderName(typeName);\n    return typeName.replace(/(Expression)?$/, \"Statement\");\n  }\n  var namedTypes = {};\n  // Like Object.keys, but aware of what fields each AST type should have.\n  function getFieldNames(object) {\n    var d = defFromValue(object);\n    if (d) {\n      return d.fieldNames.slice(0);\n    }\n    if (\"type\" in object) {\n      throw new Error(\"did not recognize object of type \" + JSON.stringify(object.type));\n    }\n    return Object.keys(object);\n  }\n  // Get the value of an object property, taking object.type and default\n  // functions into account.\n  function getFieldValue(object, fieldName) {\n    var d = defFromValue(object);\n    if (d) {\n      var field = d.allFields[fieldName];\n      if (field) {\n        return field.getValue(object);\n      }\n    }\n    return object && object[fieldName];\n  }\n  // Iterate over all defined fields of an object, including those missing\n  // or undefined, passing each field name and effective value (as returned\n  // by getFieldValue) to the callback. If the object has no corresponding\n  // Def, the callback will never be called.\n  function eachField(object, callback, context) {\n    getFieldNames(object).forEach(function (name) {\n      callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  }\n  // Similar to eachField, except that iteration stops as soon as the\n  // callback returns a truthy value. Like Array.prototype.some, the final\n  // result is either true or false to indicates whether the callback\n  // returned true for any element or not.\n  function someField(object, callback, context) {\n    return getFieldNames(object).some(function (name) {\n      return callback.call(this, name, getFieldValue(object, name));\n    }, context);\n  }\n  // Adds an additional builder for Expression subtypes\n  // that wraps the built Expression in an ExpressionStatements.\n  function wrapExpressionBuilderWithStatement(typeName) {\n    var wrapperName = getStatementBuilderName(typeName);\n    // skip if the builder already exists\n    if (builders[wrapperName]) return;\n    // the builder function to wrap with builders.ExpressionStatement\n    var wrapped = builders[getBuilderName(typeName)];\n    // skip if there is nothing to wrap\n    if (!wrapped) return;\n    var builder = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return builders.expressionStatement(wrapped.apply(builders, args));\n    };\n    builder.from = function () {\n      var args = [];\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n      return builders.expressionStatement(wrapped.from.apply(builders, args));\n    };\n    builders[wrapperName] = builder;\n  }\n  function populateSupertypeList(typeName, list) {\n    list.length = 0;\n    list.push(typeName);\n    var lastSeen = Object.create(null);\n    for (var pos = 0; pos < list.length; ++pos) {\n      typeName = list[pos];\n      var d = defCache[typeName];\n      if (d.finalized !== true) {\n        throw new Error(\"\");\n      }\n      // If we saw typeName earlier in the breadth-first traversal,\n      // delete the last-seen occurrence.\n      if (hasOwn.call(lastSeen, typeName)) {\n        delete list[lastSeen[typeName]];\n      }\n      // Record the new index of the last-seen occurrence of typeName.\n      lastSeen[typeName] = pos;\n      // Enqueue the base names of this type.\n      list.push.apply(list, d.baseNames);\n    }\n    // Compaction loop to remove array holes.\n    for (var to = 0, from = to, len = list.length; from < len; ++from) {\n      if (hasOwn.call(list, from)) {\n        list[to++] = list[from];\n      }\n    }\n    list.length = to;\n  }\n  function extend(into, from) {\n    Object.keys(from).forEach(function (name) {\n      into[name] = from[name];\n    });\n    return into;\n  }\n  function finalize() {\n    Object.keys(defCache).forEach(function (name) {\n      defCache[name].finalize();\n    });\n  }\n  return {\n    Type: Type,\n    builtInTypes: builtInTypes,\n    getSupertypeNames: getSupertypeNames,\n    computeSupertypeLookupTable: computeSupertypeLookupTable,\n    builders: builders,\n    defineMethod: defineMethod,\n    getBuilderName: getBuilderName,\n    getStatementBuilderName: getStatementBuilderName,\n    namedTypes: namedTypes,\n    getFieldNames: getFieldNames,\n    getFieldValue: getFieldValue,\n    eachField: eachField,\n    someField: someField,\n    finalize: finalize\n  };\n}\nexports.default = typesPlugin;\n;","map":{"version":3,"names":["Object","defineProperty","exports","value","Def","tslib_1","require","Op","prototype","objToStr","toString","hasOwn","hasOwnProperty","BaseType","assert","deep","check","str","shallowStringify","Error","arrayOf","elemType","ArrayType","_super","__extends","_this","call","kind","Array","isArray","every","elem","IdentityType","String","result","ObjectType","fields","join","field","type","name","OrType","types","some","PredicateType","predicate","typeName","baseNames","ownFields","create","allSupertypes","supertypeList","allFields","fieldNames","finalized","buildable","buildParams","isSupertypeOf","that","checkAllFields","checkFieldByName","child","getValue","keys","bases","supertypeNames","_i","arguments","length","i","forEach","baseName","indexOf","push","Field","defaultFn","hidden","JSON","stringify","obj","map","key","typesPlugin","_fork","Type","or","from","isObject","bicfIndex","builtInCtorFns","builtInCtorTypes","def","defCache","DefImpl","hasDef","defBuiltInType","example","objStr","constructor","isString","isFunction","isRegExp","isDate","Date","isNumber","isBoolean","isNull","isUndefined","undefined","builtInTypes","string","function","array","object","RegExp","number","boolean","null","defFromValue","d","vDef","build","addParam","built","param","arg","isArgAvailable","all","message","builder","args","argc","nodePrototype","builders","getBuilderName","enumerable","console","error","finalize","extend","fieldName","namedTypes","populateSupertypeList","lastIndexOf","wrapExpressionBuilderWithStatement","getSupertypeNames","slice","computeSupertypeLookupTable","candidates","table","typeNames","typeNameCount","j","superTypeName","defineMethod","func","old","configurable","replace","upperCasePrefix","len","toLowerCase","charAt","getStatementBuilderName","getFieldNames","getFieldValue","eachField","callback","context","someField","wrapperName","wrapped","expressionStatement","apply","list","lastSeen","pos","to","into","default"],"sources":["D:/Julieth-Campos/PSO/node_modules/ast-types/lib/types.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Def = void 0;\nvar tslib_1 = require(\"tslib\");\nvar Op = Object.prototype;\nvar objToStr = Op.toString;\nvar hasOwn = Op.hasOwnProperty;\nvar BaseType = /** @class */ (function () {\n    function BaseType() {\n    }\n    BaseType.prototype.assert = function (value, deep) {\n        if (!this.check(value, deep)) {\n            var str = shallowStringify(value);\n            throw new Error(str + \" does not match type \" + this);\n        }\n        return true;\n    };\n    BaseType.prototype.arrayOf = function () {\n        var elemType = this;\n        return new ArrayType(elemType);\n    };\n    return BaseType;\n}());\nvar ArrayType = /** @class */ (function (_super) {\n    tslib_1.__extends(ArrayType, _super);\n    function ArrayType(elemType) {\n        var _this = _super.call(this) || this;\n        _this.elemType = elemType;\n        _this.kind = \"ArrayType\";\n        return _this;\n    }\n    ArrayType.prototype.toString = function () {\n        return \"[\" + this.elemType + \"]\";\n    };\n    ArrayType.prototype.check = function (value, deep) {\n        var _this = this;\n        return Array.isArray(value) && value.every(function (elem) { return _this.elemType.check(elem, deep); });\n    };\n    return ArrayType;\n}(BaseType));\nvar IdentityType = /** @class */ (function (_super) {\n    tslib_1.__extends(IdentityType, _super);\n    function IdentityType(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.kind = \"IdentityType\";\n        return _this;\n    }\n    IdentityType.prototype.toString = function () {\n        return String(this.value);\n    };\n    IdentityType.prototype.check = function (value, deep) {\n        var result = value === this.value;\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return IdentityType;\n}(BaseType));\nvar ObjectType = /** @class */ (function (_super) {\n    tslib_1.__extends(ObjectType, _super);\n    function ObjectType(fields) {\n        var _this = _super.call(this) || this;\n        _this.fields = fields;\n        _this.kind = \"ObjectType\";\n        return _this;\n    }\n    ObjectType.prototype.toString = function () {\n        return \"{ \" + this.fields.join(\", \") + \" }\";\n    };\n    ObjectType.prototype.check = function (value, deep) {\n        return (objToStr.call(value) === objToStr.call({}) &&\n            this.fields.every(function (field) {\n                return field.type.check(value[field.name], deep);\n            }));\n    };\n    return ObjectType;\n}(BaseType));\nvar OrType = /** @class */ (function (_super) {\n    tslib_1.__extends(OrType, _super);\n    function OrType(types) {\n        var _this = _super.call(this) || this;\n        _this.types = types;\n        _this.kind = \"OrType\";\n        return _this;\n    }\n    OrType.prototype.toString = function () {\n        return this.types.join(\" | \");\n    };\n    OrType.prototype.check = function (value, deep) {\n        return this.types.some(function (type) {\n            return type.check(value, deep);\n        });\n    };\n    return OrType;\n}(BaseType));\nvar PredicateType = /** @class */ (function (_super) {\n    tslib_1.__extends(PredicateType, _super);\n    function PredicateType(name, predicate) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this.predicate = predicate;\n        _this.kind = \"PredicateType\";\n        return _this;\n    }\n    PredicateType.prototype.toString = function () {\n        return this.name;\n    };\n    PredicateType.prototype.check = function (value, deep) {\n        var result = this.predicate(value, deep);\n        if (!result && typeof deep === \"function\") {\n            deep(this, value);\n        }\n        return result;\n    };\n    return PredicateType;\n}(BaseType));\nvar Def = /** @class */ (function () {\n    function Def(type, typeName) {\n        this.type = type;\n        this.typeName = typeName;\n        this.baseNames = [];\n        this.ownFields = Object.create(null);\n        // Includes own typeName. Populated during finalization.\n        this.allSupertypes = Object.create(null);\n        // Linear inheritance hierarchy. Populated during finalization.\n        this.supertypeList = [];\n        // Includes inherited fields.\n        this.allFields = Object.create(null);\n        // Non-hidden keys of allFields.\n        this.fieldNames = [];\n        // This property will be overridden as true by individual Def instances\n        // when they are finalized.\n        this.finalized = false;\n        // False by default until .build(...) is called on an instance.\n        this.buildable = false;\n        this.buildParams = [];\n    }\n    Def.prototype.isSupertypeOf = function (that) {\n        if (that instanceof Def) {\n            if (this.finalized !== true ||\n                that.finalized !== true) {\n                throw new Error(\"\");\n            }\n            return hasOwn.call(that.allSupertypes, this.typeName);\n        }\n        else {\n            throw new Error(that + \" is not a Def\");\n        }\n    };\n    Def.prototype.checkAllFields = function (value, deep) {\n        var allFields = this.allFields;\n        if (this.finalized !== true) {\n            throw new Error(\"\" + this.typeName);\n        }\n        function checkFieldByName(name) {\n            var field = allFields[name];\n            var type = field.type;\n            var child = field.getValue(value);\n            return type.check(child, deep);\n        }\n        return value !== null &&\n            typeof value === \"object\" &&\n            Object.keys(allFields).every(checkFieldByName);\n    };\n    Def.prototype.bases = function () {\n        var supertypeNames = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            supertypeNames[_i] = arguments[_i];\n        }\n        var bases = this.baseNames;\n        if (this.finalized) {\n            if (supertypeNames.length !== bases.length) {\n                throw new Error(\"\");\n            }\n            for (var i = 0; i < supertypeNames.length; i++) {\n                if (supertypeNames[i] !== bases[i]) {\n                    throw new Error(\"\");\n                }\n            }\n            return this;\n        }\n        supertypeNames.forEach(function (baseName) {\n            // This indexOf lookup may be O(n), but the typical number of base\n            // names is very small, and indexOf is a native Array method.\n            if (bases.indexOf(baseName) < 0) {\n                bases.push(baseName);\n            }\n        });\n        return this; // For chaining.\n    };\n    return Def;\n}());\nexports.Def = Def;\nvar Field = /** @class */ (function () {\n    function Field(name, type, defaultFn, hidden) {\n        this.name = name;\n        this.type = type;\n        this.defaultFn = defaultFn;\n        this.hidden = !!hidden;\n    }\n    Field.prototype.toString = function () {\n        return JSON.stringify(this.name) + \": \" + this.type;\n    };\n    Field.prototype.getValue = function (obj) {\n        var value = obj[this.name];\n        if (typeof value !== \"undefined\") {\n            return value;\n        }\n        if (typeof this.defaultFn === \"function\") {\n            value = this.defaultFn.call(obj);\n        }\n        return value;\n    };\n    return Field;\n}());\nfunction shallowStringify(value) {\n    if (Array.isArray(value)) {\n        return \"[\" + value.map(shallowStringify).join(\", \") + \"]\";\n    }\n    if (value && typeof value === \"object\") {\n        return \"{ \" + Object.keys(value).map(function (key) {\n            return key + \": \" + value[key];\n        }).join(\", \") + \" }\";\n    }\n    return JSON.stringify(value);\n}\nfunction typesPlugin(_fork) {\n    var Type = {\n        or: function () {\n            var types = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                types[_i] = arguments[_i];\n            }\n            return new OrType(types.map(function (type) { return Type.from(type); }));\n        },\n        from: function (value, name) {\n            if (value instanceof ArrayType ||\n                value instanceof IdentityType ||\n                value instanceof ObjectType ||\n                value instanceof OrType ||\n                value instanceof PredicateType) {\n                return value;\n            }\n            // The Def type is used as a helper for constructing compound\n            // interface types for AST nodes.\n            if (value instanceof Def) {\n                return value.type;\n            }\n            // Support [ElemType] syntax.\n            if (isArray.check(value)) {\n                if (value.length !== 1) {\n                    throw new Error(\"only one element type is permitted for typed arrays\");\n                }\n                return new ArrayType(Type.from(value[0]));\n            }\n            // Support { someField: FieldType, ... } syntax.\n            if (isObject.check(value)) {\n                return new ObjectType(Object.keys(value).map(function (name) {\n                    return new Field(name, Type.from(value[name], name));\n                }));\n            }\n            if (typeof value === \"function\") {\n                var bicfIndex = builtInCtorFns.indexOf(value);\n                if (bicfIndex >= 0) {\n                    return builtInCtorTypes[bicfIndex];\n                }\n                if (typeof name !== \"string\") {\n                    throw new Error(\"missing name\");\n                }\n                return new PredicateType(name, value);\n            }\n            // As a last resort, toType returns a type that matches any value that\n            // is === from. This is primarily useful for literal values like\n            // toType(null), but it has the additional advantage of allowing\n            // toType to be a total function.\n            return new IdentityType(value);\n        },\n        // Define a type whose name is registered in a namespace (the defCache) so\n        // that future definitions will return the same type given the same name.\n        // In particular, this system allows for circular and forward definitions.\n        // The Def object d returned from Type.def may be used to configure the\n        // type d.type by calling methods such as d.bases, d.build, and d.field.\n        def: function (typeName) {\n            return hasOwn.call(defCache, typeName)\n                ? defCache[typeName]\n                : defCache[typeName] = new DefImpl(typeName);\n        },\n        hasDef: function (typeName) {\n            return hasOwn.call(defCache, typeName);\n        }\n    };\n    var builtInCtorFns = [];\n    var builtInCtorTypes = [];\n    function defBuiltInType(name, example) {\n        var objStr = objToStr.call(example);\n        var type = new PredicateType(name, function (value) { return objToStr.call(value) === objStr; });\n        if (example && typeof example.constructor === \"function\") {\n            builtInCtorFns.push(example.constructor);\n            builtInCtorTypes.push(type);\n        }\n        return type;\n    }\n    // These types check the underlying [[Class]] attribute of the given\n    // value, rather than using the problematic typeof operator. Note however\n    // that no subtyping is considered; so, for instance, isObject.check\n    // returns false for [], /./, new Date, and null.\n    var isString = defBuiltInType(\"string\", \"truthy\");\n    var isFunction = defBuiltInType(\"function\", function () { });\n    var isArray = defBuiltInType(\"array\", []);\n    var isObject = defBuiltInType(\"object\", {});\n    var isRegExp = defBuiltInType(\"RegExp\", /./);\n    var isDate = defBuiltInType(\"Date\", new Date());\n    var isNumber = defBuiltInType(\"number\", 3);\n    var isBoolean = defBuiltInType(\"boolean\", true);\n    var isNull = defBuiltInType(\"null\", null);\n    var isUndefined = defBuiltInType(\"undefined\", undefined);\n    var builtInTypes = {\n        string: isString,\n        function: isFunction,\n        array: isArray,\n        object: isObject,\n        RegExp: isRegExp,\n        Date: isDate,\n        number: isNumber,\n        boolean: isBoolean,\n        null: isNull,\n        undefined: isUndefined,\n    };\n    // In order to return the same Def instance every time Type.def is called\n    // with a particular name, those instances need to be stored in a cache.\n    var defCache = Object.create(null);\n    function defFromValue(value) {\n        if (value && typeof value === \"object\") {\n            var type = value.type;\n            if (typeof type === \"string\" &&\n                hasOwn.call(defCache, type)) {\n                var d = defCache[type];\n                if (d.finalized) {\n                    return d;\n                }\n            }\n        }\n        return null;\n    }\n    var DefImpl = /** @class */ (function (_super) {\n        tslib_1.__extends(DefImpl, _super);\n        function DefImpl(typeName) {\n            var _this = _super.call(this, new PredicateType(typeName, function (value, deep) { return _this.check(value, deep); }), typeName) || this;\n            return _this;\n        }\n        DefImpl.prototype.check = function (value, deep) {\n            if (this.finalized !== true) {\n                throw new Error(\"prematurely checking unfinalized type \" + this.typeName);\n            }\n            // A Def type can only match an object value.\n            if (value === null || typeof value !== \"object\") {\n                return false;\n            }\n            var vDef = defFromValue(value);\n            if (!vDef) {\n                // If we couldn't infer the Def associated with the given value,\n                // and we expected it to be a SourceLocation or a Position, it was\n                // probably just missing a \"type\" field (because Esprima does not\n                // assign a type property to such nodes). Be optimistic and let\n                // this.checkAllFields make the final decision.\n                if (this.typeName === \"SourceLocation\" ||\n                    this.typeName === \"Position\") {\n                    return this.checkAllFields(value, deep);\n                }\n                // Calling this.checkAllFields for any other type of node is both\n                // bad for performance and way too forgiving.\n                return false;\n            }\n            // If checking deeply and vDef === this, then we only need to call\n            // checkAllFields once. Calling checkAllFields is too strict when deep\n            // is false, because then we only care about this.isSupertypeOf(vDef).\n            if (deep && vDef === this) {\n                return this.checkAllFields(value, deep);\n            }\n            // In most cases we rely exclusively on isSupertypeOf to make O(1)\n            // subtyping determinations. This suffices in most situations outside\n            // of unit tests, since interface conformance is checked whenever new\n            // instances are created using builder functions.\n            if (!this.isSupertypeOf(vDef)) {\n                return false;\n            }\n            // The exception is when deep is true; then, we recursively check all\n            // fields.\n            if (!deep) {\n                return true;\n            }\n            // Use the more specific Def (vDef) to perform the deep check, but\n            // shallow-check fields defined by the less specific Def (this).\n            return vDef.checkAllFields(value, deep)\n                && this.checkAllFields(value, false);\n        };\n        DefImpl.prototype.build = function () {\n            var _this = this;\n            var buildParams = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                buildParams[_i] = arguments[_i];\n            }\n            // Calling Def.prototype.build multiple times has the effect of merely\n            // redefining this property.\n            this.buildParams = buildParams;\n            if (this.buildable) {\n                // If this Def is already buildable, update self.buildParams and\n                // continue using the old builder function.\n                return this;\n            }\n            // Every buildable type will have its \"type\" field filled in\n            // automatically. This includes types that are not subtypes of Node,\n            // like SourceLocation, but that seems harmless (TODO?).\n            this.field(\"type\", String, function () { return _this.typeName; });\n            // Override Dp.buildable for this Def instance.\n            this.buildable = true;\n            var addParam = function (built, param, arg, isArgAvailable) {\n                if (hasOwn.call(built, param))\n                    return;\n                var all = _this.allFields;\n                if (!hasOwn.call(all, param)) {\n                    throw new Error(\"\" + param);\n                }\n                var field = all[param];\n                var type = field.type;\n                var value;\n                if (isArgAvailable) {\n                    value = arg;\n                }\n                else if (field.defaultFn) {\n                    // Expose the partially-built object to the default\n                    // function as its `this` object.\n                    value = field.defaultFn.call(built);\n                }\n                else {\n                    var message = \"no value or default function given for field \" +\n                        JSON.stringify(param) + \" of \" + _this.typeName + \"(\" +\n                        _this.buildParams.map(function (name) {\n                            return all[name];\n                        }).join(\", \") + \")\";\n                    throw new Error(message);\n                }\n                if (!type.check(value)) {\n                    throw new Error(shallowStringify(value) +\n                        \" does not match field \" + field +\n                        \" of type \" + _this.typeName);\n                }\n                built[param] = value;\n            };\n            // Calling the builder function will construct an instance of the Def,\n            // with positional arguments mapped to the fields original passed to .build.\n            // If not enough arguments are provided, the default value for the remaining fields\n            // will be used.\n            var builder = function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                var argc = args.length;\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                _this.buildParams.forEach(function (param, i) {\n                    if (i < argc) {\n                        addParam(built, param, args[i], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                Object.keys(_this.allFields).forEach(function (param) {\n                    // Use the default value.\n                    addParam(built, param, null, false);\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            // Calling .from on the builder function will construct an instance of the Def,\n            // using field values from the passed object. For fields missing from the passed object,\n            // their default value will be used.\n            builder.from = function (obj) {\n                if (!_this.finalized) {\n                    throw new Error(\"attempting to instantiate unfinalized type \" +\n                        _this.typeName);\n                }\n                var built = Object.create(nodePrototype);\n                Object.keys(_this.allFields).forEach(function (param) {\n                    if (hasOwn.call(obj, param)) {\n                        addParam(built, param, obj[param], true);\n                    }\n                    else {\n                        addParam(built, param, null, false);\n                    }\n                });\n                // Make sure that the \"type\" field was filled automatically.\n                if (built.type !== _this.typeName) {\n                    throw new Error(\"\");\n                }\n                return built;\n            };\n            Object.defineProperty(builders, getBuilderName(this.typeName), {\n                enumerable: true,\n                value: builder\n            });\n            return this;\n        };\n        // The reason fields are specified using .field(...) instead of an object\n        // literal syntax is somewhat subtle: the object literal syntax would\n        // support only one key and one value, but with .field(...) we can pass\n        // any number of arguments to specify the field.\n        DefImpl.prototype.field = function (name, type, defaultFn, hidden) {\n            if (this.finalized) {\n                console.error(\"Ignoring attempt to redefine field \" +\n                    JSON.stringify(name) + \" of finalized type \" +\n                    JSON.stringify(this.typeName));\n                return this;\n            }\n            this.ownFields[name] = new Field(name, Type.from(type), defaultFn, hidden);\n            return this; // For chaining.\n        };\n        DefImpl.prototype.finalize = function () {\n            var _this = this;\n            // It's not an error to finalize a type more than once, but only the\n            // first call to .finalize does anything.\n            if (!this.finalized) {\n                var allFields = this.allFields;\n                var allSupertypes = this.allSupertypes;\n                this.baseNames.forEach(function (name) {\n                    var def = defCache[name];\n                    if (def instanceof Def) {\n                        def.finalize();\n                        extend(allFields, def.allFields);\n                        extend(allSupertypes, def.allSupertypes);\n                    }\n                    else {\n                        var message = \"unknown supertype name \" +\n                            JSON.stringify(name) +\n                            \" for subtype \" +\n                            JSON.stringify(_this.typeName);\n                        throw new Error(message);\n                    }\n                });\n                // TODO Warn if fields are overridden with incompatible types.\n                extend(allFields, this.ownFields);\n                allSupertypes[this.typeName] = this;\n                this.fieldNames.length = 0;\n                for (var fieldName in allFields) {\n                    if (hasOwn.call(allFields, fieldName) &&\n                        !allFields[fieldName].hidden) {\n                        this.fieldNames.push(fieldName);\n                    }\n                }\n                // Types are exported only once they have been finalized.\n                Object.defineProperty(namedTypes, this.typeName, {\n                    enumerable: true,\n                    value: this.type\n                });\n                this.finalized = true;\n                // A linearization of the inheritance hierarchy.\n                populateSupertypeList(this.typeName, this.supertypeList);\n                if (this.buildable &&\n                    this.supertypeList.lastIndexOf(\"Expression\") >= 0) {\n                    wrapExpressionBuilderWithStatement(this.typeName);\n                }\n            }\n        };\n        return DefImpl;\n    }(Def));\n    // Note that the list returned by this function is a copy of the internal\n    // supertypeList, *without* the typeName itself as the first element.\n    function getSupertypeNames(typeName) {\n        if (!hasOwn.call(defCache, typeName)) {\n            throw new Error(\"\");\n        }\n        var d = defCache[typeName];\n        if (d.finalized !== true) {\n            throw new Error(\"\");\n        }\n        return d.supertypeList.slice(1);\n    }\n    // Returns an object mapping from every known type in the defCache to the\n    // most specific supertype whose name is an own property of the candidates\n    // object.\n    function computeSupertypeLookupTable(candidates) {\n        var table = {};\n        var typeNames = Object.keys(defCache);\n        var typeNameCount = typeNames.length;\n        for (var i = 0; i < typeNameCount; ++i) {\n            var typeName = typeNames[i];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\" + typeName);\n            }\n            for (var j = 0; j < d.supertypeList.length; ++j) {\n                var superTypeName = d.supertypeList[j];\n                if (hasOwn.call(candidates, superTypeName)) {\n                    table[typeName] = superTypeName;\n                    break;\n                }\n            }\n        }\n        return table;\n    }\n    var builders = Object.create(null);\n    // This object is used as prototype for any node created by a builder.\n    var nodePrototype = {};\n    // Call this function to define a new method to be shared by all AST\n    // nodes. The replaced method (if any) is returned for easy wrapping.\n    function defineMethod(name, func) {\n        var old = nodePrototype[name];\n        // Pass undefined as func to delete nodePrototype[name].\n        if (isUndefined.check(func)) {\n            delete nodePrototype[name];\n        }\n        else {\n            isFunction.assert(func);\n            Object.defineProperty(nodePrototype, name, {\n                enumerable: true,\n                configurable: true,\n                value: func\n            });\n        }\n        return old;\n    }\n    function getBuilderName(typeName) {\n        return typeName.replace(/^[A-Z]+/, function (upperCasePrefix) {\n            var len = upperCasePrefix.length;\n            switch (len) {\n                case 0: return \"\";\n                // If there's only one initial capital letter, just lower-case it.\n                case 1: return upperCasePrefix.toLowerCase();\n                default:\n                    // If there's more than one initial capital letter, lower-case\n                    // all but the last one, so that XMLDefaultDeclaration (for\n                    // example) becomes xmlDefaultDeclaration.\n                    return upperCasePrefix.slice(0, len - 1).toLowerCase() +\n                        upperCasePrefix.charAt(len - 1);\n            }\n        });\n    }\n    function getStatementBuilderName(typeName) {\n        typeName = getBuilderName(typeName);\n        return typeName.replace(/(Expression)?$/, \"Statement\");\n    }\n    var namedTypes = {};\n    // Like Object.keys, but aware of what fields each AST type should have.\n    function getFieldNames(object) {\n        var d = defFromValue(object);\n        if (d) {\n            return d.fieldNames.slice(0);\n        }\n        if (\"type\" in object) {\n            throw new Error(\"did not recognize object of type \" +\n                JSON.stringify(object.type));\n        }\n        return Object.keys(object);\n    }\n    // Get the value of an object property, taking object.type and default\n    // functions into account.\n    function getFieldValue(object, fieldName) {\n        var d = defFromValue(object);\n        if (d) {\n            var field = d.allFields[fieldName];\n            if (field) {\n                return field.getValue(object);\n            }\n        }\n        return object && object[fieldName];\n    }\n    // Iterate over all defined fields of an object, including those missing\n    // or undefined, passing each field name and effective value (as returned\n    // by getFieldValue) to the callback. If the object has no corresponding\n    // Def, the callback will never be called.\n    function eachField(object, callback, context) {\n        getFieldNames(object).forEach(function (name) {\n            callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Similar to eachField, except that iteration stops as soon as the\n    // callback returns a truthy value. Like Array.prototype.some, the final\n    // result is either true or false to indicates whether the callback\n    // returned true for any element or not.\n    function someField(object, callback, context) {\n        return getFieldNames(object).some(function (name) {\n            return callback.call(this, name, getFieldValue(object, name));\n        }, context);\n    }\n    // Adds an additional builder for Expression subtypes\n    // that wraps the built Expression in an ExpressionStatements.\n    function wrapExpressionBuilderWithStatement(typeName) {\n        var wrapperName = getStatementBuilderName(typeName);\n        // skip if the builder already exists\n        if (builders[wrapperName])\n            return;\n        // the builder function to wrap with builders.ExpressionStatement\n        var wrapped = builders[getBuilderName(typeName)];\n        // skip if there is nothing to wrap\n        if (!wrapped)\n            return;\n        var builder = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.apply(builders, args));\n        };\n        builder.from = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return builders.expressionStatement(wrapped.from.apply(builders, args));\n        };\n        builders[wrapperName] = builder;\n    }\n    function populateSupertypeList(typeName, list) {\n        list.length = 0;\n        list.push(typeName);\n        var lastSeen = Object.create(null);\n        for (var pos = 0; pos < list.length; ++pos) {\n            typeName = list[pos];\n            var d = defCache[typeName];\n            if (d.finalized !== true) {\n                throw new Error(\"\");\n            }\n            // If we saw typeName earlier in the breadth-first traversal,\n            // delete the last-seen occurrence.\n            if (hasOwn.call(lastSeen, typeName)) {\n                delete list[lastSeen[typeName]];\n            }\n            // Record the new index of the last-seen occurrence of typeName.\n            lastSeen[typeName] = pos;\n            // Enqueue the base names of this type.\n            list.push.apply(list, d.baseNames);\n        }\n        // Compaction loop to remove array holes.\n        for (var to = 0, from = to, len = list.length; from < len; ++from) {\n            if (hasOwn.call(list, from)) {\n                list[to++] = list[from];\n            }\n        }\n        list.length = to;\n    }\n    function extend(into, from) {\n        Object.keys(from).forEach(function (name) {\n            into[name] = from[name];\n        });\n        return into;\n    }\n    function finalize() {\n        Object.keys(defCache).forEach(function (name) {\n            defCache[name].finalize();\n        });\n    }\n    return {\n        Type: Type,\n        builtInTypes: builtInTypes,\n        getSupertypeNames: getSupertypeNames,\n        computeSupertypeLookupTable: computeSupertypeLookupTable,\n        builders: builders,\n        defineMethod: defineMethod,\n        getBuilderName: getBuilderName,\n        getStatementBuilderName: getStatementBuilderName,\n        namedTypes: namedTypes,\n        getFieldNames: getFieldNames,\n        getFieldValue: getFieldValue,\n        eachField: eachField,\n        someField: someField,\n        finalize: finalize,\n    };\n}\nexports.default = typesPlugin;\n;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}