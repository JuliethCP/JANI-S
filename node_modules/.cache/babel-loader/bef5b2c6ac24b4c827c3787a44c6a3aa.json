{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.downloadTo = exports.uploadFrom = exports.connectForPassiveTransfer = exports.parsePasvResponse = exports.enterPassiveModeIPv4 = exports.parseEpsvResponse = exports.enterPassiveModeIPv6 = void 0;\nconst netUtils_1 = require(\"./netUtils\");\nconst stream_1 = require(\"stream\");\nconst tls_1 = require(\"tls\");\nconst parseControlResponse_1 = require(\"./parseControlResponse\");\n/**\n * Prepare a data socket using passive mode over IPv6.\n */\nasync function enterPassiveModeIPv6(ftp) {\n  const res = await ftp.request(\"EPSV\");\n  const port = parseEpsvResponse(res.message);\n  if (!port) {\n    throw new Error(\"Can't parse EPSV response: \" + res.message);\n  }\n  const controlHost = ftp.socket.remoteAddress;\n  if (controlHost === undefined) {\n    throw new Error(\"Control socket is disconnected, can't get remote address.\");\n  }\n  await connectForPassiveTransfer(controlHost, port, ftp);\n  return res;\n}\nexports.enterPassiveModeIPv6 = enterPassiveModeIPv6;\n/**\n * Parse an EPSV response. Returns only the port as in EPSV the host of the control connection is used.\n */\nfunction parseEpsvResponse(message) {\n  // Get port from EPSV response, e.g. \"229 Entering Extended Passive Mode (|||6446|)\"\n  // Some FTP Servers such as the one on IBM i (OS/400) use ! instead of | in their EPSV response.\n  const groups = message.match(/[|!]{3}(.+)[|!]/);\n  if (groups === null || groups[1] === undefined) {\n    throw new Error(`Can't parse response to 'EPSV': ${message}`);\n  }\n  const port = parseInt(groups[1], 10);\n  if (Number.isNaN(port)) {\n    throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);\n  }\n  return port;\n}\nexports.parseEpsvResponse = parseEpsvResponse;\n/**\n * Prepare a data socket using passive mode over IPv4.\n */\nasync function enterPassiveModeIPv4(ftp) {\n  const res = await ftp.request(\"PASV\");\n  const target = parsePasvResponse(res.message);\n  if (!target) {\n    throw new Error(\"Can't parse PASV response: \" + res.message);\n  }\n  // If the host in the PASV response has a local address while the control connection hasn't,\n  // we assume a NAT issue and use the IP of the control connection as the target for the data connection.\n  // We can't always perform this replacement because it's possible (although unlikely) that the FTP server\n  // indeed uses a different host for data connections.\n  const controlHost = ftp.socket.remoteAddress;\n  if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {\n    target.host = controlHost;\n  }\n  await connectForPassiveTransfer(target.host, target.port, ftp);\n  return res;\n}\nexports.enterPassiveModeIPv4 = enterPassiveModeIPv4;\n/**\n * Parse a PASV response.\n */\nfunction parsePasvResponse(message) {\n  // Get host and port from PASV response, e.g. \"227 Entering Passive Mode (192,168,1,100,10,229)\"\n  const groups = message.match(/([-\\d]+,[-\\d]+,[-\\d]+,[-\\d]+),([-\\d]+),([-\\d]+)/);\n  if (groups === null || groups.length !== 4) {\n    throw new Error(`Can't parse response to 'PASV': ${message}`);\n  }\n  return {\n    host: groups[1].replace(/,/g, \".\"),\n    port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)\n  };\n}\nexports.parsePasvResponse = parsePasvResponse;\nfunction connectForPassiveTransfer(host, port, ftp) {\n  return new Promise((resolve, reject) => {\n    let socket = ftp._newSocket();\n    const handleConnErr = function (err) {\n      err.message = \"Can't open data connection in passive mode: \" + err.message;\n      reject(err);\n    };\n    const handleTimeout = function () {\n      socket.destroy();\n      reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));\n    };\n    socket.setTimeout(ftp.timeout);\n    socket.on(\"error\", handleConnErr);\n    socket.on(\"timeout\", handleTimeout);\n    socket.connect({\n      port,\n      host,\n      family: ftp.ipFamily\n    }, () => {\n      if (ftp.socket instanceof tls_1.TLSSocket) {\n        socket = (0, tls_1.connect)(Object.assign({}, ftp.tlsOptions, {\n          socket,\n          // Reuse the TLS session negotiated earlier when the control connection\n          // was upgraded. Servers expect this because it provides additional\n          // security: If a completely new session would be negotiated, a hacker\n          // could guess the port and connect to the new data connection before we do\n          // by just starting his/her own TLS session.\n          session: ftp.socket.getSession()\n        }));\n        // It's the responsibility of the transfer task to wait until the\n        // TLS socket issued the event 'secureConnect'. We can't do this\n        // here because some servers will start upgrading after the\n        // specific transfer request has been made. List and download don't\n        // have to wait for this event because the server sends whenever it\n        // is ready. But for upload this has to be taken into account,\n        // see the details in the upload() function below.\n      }\n      // Let the FTPContext listen to errors from now on, remove local handler.\n      socket.removeListener(\"error\", handleConnErr);\n      socket.removeListener(\"timeout\", handleTimeout);\n      ftp.dataSocket = socket;\n      resolve();\n    });\n  });\n}\nexports.connectForPassiveTransfer = connectForPassiveTransfer;\n/**\n * Helps resolving/rejecting transfers.\n *\n * This is used internally for all FTP transfers. For example when downloading, the server might confirm\n * with \"226 Transfer complete\" when in fact the download on the data connection has not finished\n * yet. With all transfers we make sure that a) the result arrived and b) has been confirmed by\n * e.g. the control connection. We just don't know in which order this will happen.\n */\nclass TransferResolver {\n  /**\n   * Instantiate a TransferResolver\n   */\n  constructor(ftp, progress) {\n    this.ftp = ftp;\n    this.progress = progress;\n    this.response = undefined;\n    this.dataTransferDone = false;\n  }\n  /**\n   * Mark the beginning of a transfer.\n   *\n   * @param name - Name of the transfer, usually the filename.\n   * @param type - Type of transfer, usually \"upload\" or \"download\".\n   */\n  onDataStart(name, type) {\n    // Let the data socket be in charge of tracking timeouts during transfer.\n    // The control socket sits idle during this time anyway and might provoke\n    // a timeout unnecessarily. The control connection will take care\n    // of timeouts again once data transfer is complete or failed.\n    if (this.ftp.dataSocket === undefined) {\n      throw new Error(\"Data transfer should start but there is no data connection.\");\n    }\n    this.ftp.socket.setTimeout(0);\n    this.ftp.dataSocket.setTimeout(this.ftp.timeout);\n    this.progress.start(this.ftp.dataSocket, name, type);\n  }\n  /**\n   * The data connection has finished the transfer.\n   */\n  onDataDone(task) {\n    this.progress.updateAndStop();\n    // Hand-over timeout tracking back to the control connection. It's possible that\n    // we don't receive the response over the control connection that the transfer is\n    // done. In this case, we want to correctly associate the resulting timeout with\n    // the control connection.\n    this.ftp.socket.setTimeout(this.ftp.timeout);\n    if (this.ftp.dataSocket) {\n      this.ftp.dataSocket.setTimeout(0);\n    }\n    this.dataTransferDone = true;\n    this.tryResolve(task);\n  }\n  /**\n   * The control connection reports the transfer as finished.\n   */\n  onControlDone(task, response) {\n    this.response = response;\n    this.tryResolve(task);\n  }\n  /**\n   * An error has been reported and the task should be rejected.\n   */\n  onError(task, err) {\n    this.progress.updateAndStop();\n    this.ftp.socket.setTimeout(this.ftp.timeout);\n    this.ftp.dataSocket = undefined;\n    task.reject(err);\n  }\n  /**\n   * Control connection sent an unexpected request requiring a response from our part. We\n   * can't provide that (because unknown) and have to close the contrext with an error because\n   * the FTP server is now caught up in a state we can't resolve.\n   */\n  onUnexpectedRequest(response) {\n    const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);\n    this.ftp.closeWithError(err);\n  }\n  tryResolve(task) {\n    // To resolve, we need both control and data connection to report that the transfer is done.\n    const canResolve = this.dataTransferDone && this.response !== undefined;\n    if (canResolve) {\n      this.ftp.dataSocket = undefined;\n      task.resolve(this.response);\n    }\n  }\n}\nfunction uploadFrom(source, config) {\n  const resolver = new TransferResolver(config.ftp, config.tracker);\n  const fullCommand = `${config.command} ${config.remotePath}`;\n  return config.ftp.handle(fullCommand, (res, task) => {\n    if (res instanceof Error) {\n      resolver.onError(task, res);\n    } else if (res.code === 150 || res.code === 125) {\n      // Ready to upload\n      const dataSocket = config.ftp.dataSocket;\n      if (!dataSocket) {\n        resolver.onError(task, new Error(\"Upload should begin but no data connection is available.\"));\n        return;\n      }\n      // If we are using TLS, we have to wait until the dataSocket issued\n      // 'secureConnect'. If this hasn't happened yet, getCipher() returns undefined.\n      const canUpload = \"getCipher\" in dataSocket ? dataSocket.getCipher() !== undefined : true;\n      onConditionOrEvent(canUpload, dataSocket, \"secureConnect\", () => {\n        config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n        resolver.onDataStart(config.remotePath, config.type);\n        (0, stream_1.pipeline)(source, dataSocket, err => {\n          if (err) {\n            resolver.onError(task, err);\n          } else {\n            resolver.onDataDone(task);\n          }\n        });\n      });\n    } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n      // Transfer complete\n      resolver.onControlDone(task, res);\n    } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n      resolver.onUnexpectedRequest(res);\n    }\n    // Ignore all other positive preliminary response codes (< 200)\n  });\n}\n\nexports.uploadFrom = uploadFrom;\nfunction downloadTo(destination, config) {\n  if (!config.ftp.dataSocket) {\n    throw new Error(\"Download will be initiated but no data connection is available.\");\n  }\n  const resolver = new TransferResolver(config.ftp, config.tracker);\n  return config.ftp.handle(config.command, (res, task) => {\n    if (res instanceof Error) {\n      resolver.onError(task, res);\n    } else if (res.code === 150 || res.code === 125) {\n      // Ready to download\n      const dataSocket = config.ftp.dataSocket;\n      if (!dataSocket) {\n        resolver.onError(task, new Error(\"Download should begin but no data connection is available.\"));\n        return;\n      }\n      config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n      resolver.onDataStart(config.remotePath, config.type);\n      (0, stream_1.pipeline)(dataSocket, destination, err => {\n        if (err) {\n          resolver.onError(task, err);\n        } else {\n          resolver.onDataDone(task);\n        }\n      });\n    } else if (res.code === 350) {\n      // Restarting at startAt.\n      config.ftp.send(\"RETR \" + config.remotePath);\n    } else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n      // Transfer complete\n      resolver.onControlDone(task, res);\n    } else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n      resolver.onUnexpectedRequest(res);\n    }\n    // Ignore all other positive preliminary response codes (< 200)\n  });\n}\n\nexports.downloadTo = downloadTo;\n/**\n * Calls a function immediately if a condition is met or subscribes to an event and calls\n * it once the event is emitted.\n *\n * @param condition  The condition to test.\n * @param emitter  The emitter to use if the condition is not met.\n * @param eventName  The event to subscribe to if the condition is not met.\n * @param action  The function to call.\n */\nfunction onConditionOrEvent(condition, emitter, eventName, action) {\n  if (condition === true) {\n    action();\n  } else {\n    emitter.once(eventName, () => action());\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","downloadTo","uploadFrom","connectForPassiveTransfer","parsePasvResponse","enterPassiveModeIPv4","parseEpsvResponse","enterPassiveModeIPv6","netUtils_1","require","stream_1","tls_1","parseControlResponse_1","ftp","res","request","port","message","Error","controlHost","socket","remoteAddress","undefined","groups","match","parseInt","Number","isNaN","target","ipIsPrivateV4Address","host","length","replace","Promise","resolve","reject","_newSocket","handleConnErr","err","handleTimeout","destroy","setTimeout","timeout","on","connect","family","ipFamily","TLSSocket","assign","tlsOptions","session","getSession","removeListener","dataSocket","TransferResolver","constructor","progress","response","dataTransferDone","onDataStart","name","type","start","onDataDone","task","updateAndStop","tryResolve","onControlDone","onError","onUnexpectedRequest","closeWithError","canResolve","source","config","resolver","tracker","fullCommand","command","remotePath","handle","code","canUpload","getCipher","onConditionOrEvent","log","describeAddress","describeTLS","pipeline","positiveCompletion","positiveIntermediate","destination","send","condition","emitter","eventName","action","once"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/transfer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.downloadTo = exports.uploadFrom = exports.connectForPassiveTransfer = exports.parsePasvResponse = exports.enterPassiveModeIPv4 = exports.parseEpsvResponse = exports.enterPassiveModeIPv6 = void 0;\nconst netUtils_1 = require(\"./netUtils\");\nconst stream_1 = require(\"stream\");\nconst tls_1 = require(\"tls\");\nconst parseControlResponse_1 = require(\"./parseControlResponse\");\n/**\n * Prepare a data socket using passive mode over IPv6.\n */\nasync function enterPassiveModeIPv6(ftp) {\n    const res = await ftp.request(\"EPSV\");\n    const port = parseEpsvResponse(res.message);\n    if (!port) {\n        throw new Error(\"Can't parse EPSV response: \" + res.message);\n    }\n    const controlHost = ftp.socket.remoteAddress;\n    if (controlHost === undefined) {\n        throw new Error(\"Control socket is disconnected, can't get remote address.\");\n    }\n    await connectForPassiveTransfer(controlHost, port, ftp);\n    return res;\n}\nexports.enterPassiveModeIPv6 = enterPassiveModeIPv6;\n/**\n * Parse an EPSV response. Returns only the port as in EPSV the host of the control connection is used.\n */\nfunction parseEpsvResponse(message) {\n    // Get port from EPSV response, e.g. \"229 Entering Extended Passive Mode (|||6446|)\"\n    // Some FTP Servers such as the one on IBM i (OS/400) use ! instead of | in their EPSV response.\n    const groups = message.match(/[|!]{3}(.+)[|!]/);\n    if (groups === null || groups[1] === undefined) {\n        throw new Error(`Can't parse response to 'EPSV': ${message}`);\n    }\n    const port = parseInt(groups[1], 10);\n    if (Number.isNaN(port)) {\n        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);\n    }\n    return port;\n}\nexports.parseEpsvResponse = parseEpsvResponse;\n/**\n * Prepare a data socket using passive mode over IPv4.\n */\nasync function enterPassiveModeIPv4(ftp) {\n    const res = await ftp.request(\"PASV\");\n    const target = parsePasvResponse(res.message);\n    if (!target) {\n        throw new Error(\"Can't parse PASV response: \" + res.message);\n    }\n    // If the host in the PASV response has a local address while the control connection hasn't,\n    // we assume a NAT issue and use the IP of the control connection as the target for the data connection.\n    // We can't always perform this replacement because it's possible (although unlikely) that the FTP server\n    // indeed uses a different host for data connections.\n    const controlHost = ftp.socket.remoteAddress;\n    if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {\n        target.host = controlHost;\n    }\n    await connectForPassiveTransfer(target.host, target.port, ftp);\n    return res;\n}\nexports.enterPassiveModeIPv4 = enterPassiveModeIPv4;\n/**\n * Parse a PASV response.\n */\nfunction parsePasvResponse(message) {\n    // Get host and port from PASV response, e.g. \"227 Entering Passive Mode (192,168,1,100,10,229)\"\n    const groups = message.match(/([-\\d]+,[-\\d]+,[-\\d]+,[-\\d]+),([-\\d]+),([-\\d]+)/);\n    if (groups === null || groups.length !== 4) {\n        throw new Error(`Can't parse response to 'PASV': ${message}`);\n    }\n    return {\n        host: groups[1].replace(/,/g, \".\"),\n        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)\n    };\n}\nexports.parsePasvResponse = parsePasvResponse;\nfunction connectForPassiveTransfer(host, port, ftp) {\n    return new Promise((resolve, reject) => {\n        let socket = ftp._newSocket();\n        const handleConnErr = function (err) {\n            err.message = \"Can't open data connection in passive mode: \" + err.message;\n            reject(err);\n        };\n        const handleTimeout = function () {\n            socket.destroy();\n            reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));\n        };\n        socket.setTimeout(ftp.timeout);\n        socket.on(\"error\", handleConnErr);\n        socket.on(\"timeout\", handleTimeout);\n        socket.connect({ port, host, family: ftp.ipFamily }, () => {\n            if (ftp.socket instanceof tls_1.TLSSocket) {\n                socket = (0, tls_1.connect)(Object.assign({}, ftp.tlsOptions, {\n                    socket,\n                    // Reuse the TLS session negotiated earlier when the control connection\n                    // was upgraded. Servers expect this because it provides additional\n                    // security: If a completely new session would be negotiated, a hacker\n                    // could guess the port and connect to the new data connection before we do\n                    // by just starting his/her own TLS session.\n                    session: ftp.socket.getSession()\n                }));\n                // It's the responsibility of the transfer task to wait until the\n                // TLS socket issued the event 'secureConnect'. We can't do this\n                // here because some servers will start upgrading after the\n                // specific transfer request has been made. List and download don't\n                // have to wait for this event because the server sends whenever it\n                // is ready. But for upload this has to be taken into account,\n                // see the details in the upload() function below.\n            }\n            // Let the FTPContext listen to errors from now on, remove local handler.\n            socket.removeListener(\"error\", handleConnErr);\n            socket.removeListener(\"timeout\", handleTimeout);\n            ftp.dataSocket = socket;\n            resolve();\n        });\n    });\n}\nexports.connectForPassiveTransfer = connectForPassiveTransfer;\n/**\n * Helps resolving/rejecting transfers.\n *\n * This is used internally for all FTP transfers. For example when downloading, the server might confirm\n * with \"226 Transfer complete\" when in fact the download on the data connection has not finished\n * yet. With all transfers we make sure that a) the result arrived and b) has been confirmed by\n * e.g. the control connection. We just don't know in which order this will happen.\n */\nclass TransferResolver {\n    /**\n     * Instantiate a TransferResolver\n     */\n    constructor(ftp, progress) {\n        this.ftp = ftp;\n        this.progress = progress;\n        this.response = undefined;\n        this.dataTransferDone = false;\n    }\n    /**\n     * Mark the beginning of a transfer.\n     *\n     * @param name - Name of the transfer, usually the filename.\n     * @param type - Type of transfer, usually \"upload\" or \"download\".\n     */\n    onDataStart(name, type) {\n        // Let the data socket be in charge of tracking timeouts during transfer.\n        // The control socket sits idle during this time anyway and might provoke\n        // a timeout unnecessarily. The control connection will take care\n        // of timeouts again once data transfer is complete or failed.\n        if (this.ftp.dataSocket === undefined) {\n            throw new Error(\"Data transfer should start but there is no data connection.\");\n        }\n        this.ftp.socket.setTimeout(0);\n        this.ftp.dataSocket.setTimeout(this.ftp.timeout);\n        this.progress.start(this.ftp.dataSocket, name, type);\n    }\n    /**\n     * The data connection has finished the transfer.\n     */\n    onDataDone(task) {\n        this.progress.updateAndStop();\n        // Hand-over timeout tracking back to the control connection. It's possible that\n        // we don't receive the response over the control connection that the transfer is\n        // done. In this case, we want to correctly associate the resulting timeout with\n        // the control connection.\n        this.ftp.socket.setTimeout(this.ftp.timeout);\n        if (this.ftp.dataSocket) {\n            this.ftp.dataSocket.setTimeout(0);\n        }\n        this.dataTransferDone = true;\n        this.tryResolve(task);\n    }\n    /**\n     * The control connection reports the transfer as finished.\n     */\n    onControlDone(task, response) {\n        this.response = response;\n        this.tryResolve(task);\n    }\n    /**\n     * An error has been reported and the task should be rejected.\n     */\n    onError(task, err) {\n        this.progress.updateAndStop();\n        this.ftp.socket.setTimeout(this.ftp.timeout);\n        this.ftp.dataSocket = undefined;\n        task.reject(err);\n    }\n    /**\n     * Control connection sent an unexpected request requiring a response from our part. We\n     * can't provide that (because unknown) and have to close the contrext with an error because\n     * the FTP server is now caught up in a state we can't resolve.\n     */\n    onUnexpectedRequest(response) {\n        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);\n        this.ftp.closeWithError(err);\n    }\n    tryResolve(task) {\n        // To resolve, we need both control and data connection to report that the transfer is done.\n        const canResolve = this.dataTransferDone && this.response !== undefined;\n        if (canResolve) {\n            this.ftp.dataSocket = undefined;\n            task.resolve(this.response);\n        }\n    }\n}\nfunction uploadFrom(source, config) {\n    const resolver = new TransferResolver(config.ftp, config.tracker);\n    const fullCommand = `${config.command} ${config.remotePath}`;\n    return config.ftp.handle(fullCommand, (res, task) => {\n        if (res instanceof Error) {\n            resolver.onError(task, res);\n        }\n        else if (res.code === 150 || res.code === 125) { // Ready to upload\n            const dataSocket = config.ftp.dataSocket;\n            if (!dataSocket) {\n                resolver.onError(task, new Error(\"Upload should begin but no data connection is available.\"));\n                return;\n            }\n            // If we are using TLS, we have to wait until the dataSocket issued\n            // 'secureConnect'. If this hasn't happened yet, getCipher() returns undefined.\n            const canUpload = \"getCipher\" in dataSocket ? dataSocket.getCipher() !== undefined : true;\n            onConditionOrEvent(canUpload, dataSocket, \"secureConnect\", () => {\n                config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n                resolver.onDataStart(config.remotePath, config.type);\n                (0, stream_1.pipeline)(source, dataSocket, err => {\n                    if (err) {\n                        resolver.onError(task, err);\n                    }\n                    else {\n                        resolver.onDataDone(task);\n                    }\n                });\n            });\n        }\n        else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) { // Transfer complete\n            resolver.onControlDone(task, res);\n        }\n        else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n            resolver.onUnexpectedRequest(res);\n        }\n        // Ignore all other positive preliminary response codes (< 200)\n    });\n}\nexports.uploadFrom = uploadFrom;\nfunction downloadTo(destination, config) {\n    if (!config.ftp.dataSocket) {\n        throw new Error(\"Download will be initiated but no data connection is available.\");\n    }\n    const resolver = new TransferResolver(config.ftp, config.tracker);\n    return config.ftp.handle(config.command, (res, task) => {\n        if (res instanceof Error) {\n            resolver.onError(task, res);\n        }\n        else if (res.code === 150 || res.code === 125) { // Ready to download\n            const dataSocket = config.ftp.dataSocket;\n            if (!dataSocket) {\n                resolver.onError(task, new Error(\"Download should begin but no data connection is available.\"));\n                return;\n            }\n            config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n            resolver.onDataStart(config.remotePath, config.type);\n            (0, stream_1.pipeline)(dataSocket, destination, err => {\n                if (err) {\n                    resolver.onError(task, err);\n                }\n                else {\n                    resolver.onDataDone(task);\n                }\n            });\n        }\n        else if (res.code === 350) { // Restarting at startAt.\n            config.ftp.send(\"RETR \" + config.remotePath);\n        }\n        else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) { // Transfer complete\n            resolver.onControlDone(task, res);\n        }\n        else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n            resolver.onUnexpectedRequest(res);\n        }\n        // Ignore all other positive preliminary response codes (< 200)\n    });\n}\nexports.downloadTo = downloadTo;\n/**\n * Calls a function immediately if a condition is met or subscribes to an event and calls\n * it once the event is emitted.\n *\n * @param condition  The condition to test.\n * @param emitter  The emitter to use if the condition is not met.\n * @param eventName  The event to subscribe to if the condition is not met.\n * @param action  The function to call.\n */\nfunction onConditionOrEvent(condition, emitter, eventName, action) {\n    if (condition === true) {\n        action();\n    }\n    else {\n        emitter.once(eventName, () => action());\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}