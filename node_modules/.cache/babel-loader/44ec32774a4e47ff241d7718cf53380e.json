{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { DisposableStack, disposeSymbol } from '../util/disposable.js';\nconst DEFAULT_BATCH_SIZE = 20;\n/**\n * This will transpose an iterator JSHandle into a fast, Puppeteer-side iterator\n * of JSHandles.\n *\n * @param size - The number of elements to transpose. This should be something\n * reasonable.\n */\nasync function* fastTransposeIteratorHandle(iterator, size) {\n  const env_1 = {\n    stack: [],\n    error: void 0,\n    hasError: false\n  };\n  try {\n    const array = __addDisposableResource(env_1, await iterator.evaluateHandle(async (iterator, size) => {\n      const results = [];\n      while (results.length < size) {\n        const result = await iterator.next();\n        if (result.done) {\n          break;\n        }\n        results.push(result.value);\n      }\n      return results;\n    }, size), false);\n    const properties = await array.getProperties();\n    const handles = properties.values();\n    const stack = __addDisposableResource(env_1, new DisposableStack(), false);\n    stack.defer(() => {\n      for (const handle_1 of handles) {\n        const env_2 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_2, handle_1, false);\n          handle[disposeSymbol]();\n        } catch (e_2) {\n          env_2.error = e_2;\n          env_2.hasError = true;\n        } finally {\n          __disposeResources(env_2);\n        }\n      }\n    });\n    yield* handles;\n    return properties.size === 0;\n  } catch (e_1) {\n    env_1.error = e_1;\n    env_1.hasError = true;\n  } finally {\n    __disposeResources(env_1);\n  }\n}\n/**\n * This will transpose an iterator JSHandle in batches based on the default size\n * of {@link fastTransposeIteratorHandle}.\n */\nasync function* transposeIteratorHandle(iterator) {\n  let size = DEFAULT_BATCH_SIZE;\n  while (!(yield* fastTransposeIteratorHandle(iterator, size))) {\n    size <<= 1;\n  }\n}\n/**\n * @internal\n */\nexport async function* transposeIterableHandle(handle) {\n  const env_3 = {\n    stack: [],\n    error: void 0,\n    hasError: false\n  };\n  try {\n    const generatorHandle = __addDisposableResource(env_3, await handle.evaluateHandle(iterable => {\n      return async function* () {\n        yield* iterable;\n      }();\n    }), false);\n    yield* transposeIteratorHandle(generatorHandle);\n  } catch (e_3) {\n    env_3.error = e_3;\n    env_3.hasError = true;\n  } finally {\n    __disposeResources(env_3);\n  }\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiBA,SAAQA,eAAe,EAAEC,aAAa,QAAO,uBAAuB;AAIpE,MAAMC,kBAAkB,GAAG,EAAE;AAE7B;;;;;;;AAOA,gBAAgBC,2BAA2B,CACzCC,QAAwC,EACxCC,IAAY;;;;;;;IAEZ,MAAMC,KAAK,kCAAG,MAAMF,QAAQ,CAACG,cAAc,CAAC,OAAOH,QAAQ,EAAEC,IAAI,KAAI;MACnE,MAAMG,OAAO,GAAG,EAAE;MAClB,OAAOA,OAAO,CAACC,MAAM,GAAGJ,IAAI,EAAE;QAC5B,MAAMK,MAAM,GAAG,MAAMN,QAAQ,CAACO,IAAI,EAAE;QACpC,IAAID,MAAM,CAACE,IAAI,EAAE;UACf;;QAEFJ,OAAO,CAACK,IAAI,CAACH,MAAM,CAACI,KAAK,CAAC;;MAE5B,OAAON,OAAO;IAChB,CAAC,EAAEH,IAAI,CAAC;IACR,MAAMU,UAAU,GAAI,MAAMT,KAAK,CAACU,aAAa,EAAgC;IAC7E,MAAMC,OAAO,GAAGF,UAAU,CAACG,MAAM,EAAE;IACnC,MAAMC,KAAK,kCAAG,IAAInB,eAAe,EAAE;IACnCmB,KAAK,CAACC,KAAK,CAAC,MAAK;MACf,uBAAqBH,OAAO,EAAE;;;;;;;gBAAnBI,MAAM;UACfA,MAAM,CAACpB,aAAa,CAAC,EAAE;;;;;;;;IAE3B,CAAC,CAAC;IACF,OAAOgB,OAAO;IACd,OAAOF,UAAU,CAACV,IAAI,KAAK,CAAC;;;;;;;;AAG9B;;;;AAKA,gBAAgBiB,uBAAuB,CACrClB,QAAwC;EAExC,IAAIC,IAAI,GAAGH,kBAAkB;EAC7B,OAAO,EAAE,OAAOC,2BAA2B,CAACC,QAAQ,EAAEC,IAAI,CAAC,CAAC,EAAE;IAC5DA,IAAI,KAAK,CAAC;;AAEd;AAIA;;;AAGA,OAAO,gBAAgBkB,uBAAuB,CAC5CF,MAAsC;;;;;;;IAEtC,MAAMG,eAAe,kCAAG,MAAMH,MAAM,CAACd,cAAc,CAACkB,QAAQ,IAAG;MAC7D,OAAQ,mBAAe;QACrB,OAAOA,QAAQ;MACjB,CAAC,EAAG;IACN,CAAC,CAAC;IACF,OAAOH,uBAAuB,CAACE,eAAe,CAAC","names":["DisposableStack","disposeSymbol","DEFAULT_BATCH_SIZE","fastTransposeIteratorHandle","iterator","size","array","evaluateHandle","results","length","result","next","done","push","value","properties","getProperties","handles","values","stack","defer","handle","transposeIteratorHandle","transposeIterableHandle","generatorHandle","iterable"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\common\\HandleIterator.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type {JSHandle} from '../api/JSHandle.js';\nimport {DisposableStack, disposeSymbol} from '../util/disposable.js';\n\nimport type {AwaitableIterable, HandleFor} from './types.js';\n\nconst DEFAULT_BATCH_SIZE = 20;\n\n/**\n * This will transpose an iterator JSHandle into a fast, Puppeteer-side iterator\n * of JSHandles.\n *\n * @param size - The number of elements to transpose. This should be something\n * reasonable.\n */\nasync function* fastTransposeIteratorHandle<T>(\n  iterator: JSHandle<AwaitableIterator<T>>,\n  size: number\n) {\n  using array = await iterator.evaluateHandle(async (iterator, size) => {\n    const results = [];\n    while (results.length < size) {\n      const result = await iterator.next();\n      if (result.done) {\n        break;\n      }\n      results.push(result.value);\n    }\n    return results;\n  }, size);\n  const properties = (await array.getProperties()) as Map<string, HandleFor<T>>;\n  const handles = properties.values();\n  using stack = new DisposableStack();\n  stack.defer(() => {\n    for (using handle of handles) {\n      handle[disposeSymbol]();\n    }\n  });\n  yield* handles;\n  return properties.size === 0;\n}\n\n/**\n * This will transpose an iterator JSHandle in batches based on the default size\n * of {@link fastTransposeIteratorHandle}.\n */\n\nasync function* transposeIteratorHandle<T>(\n  iterator: JSHandle<AwaitableIterator<T>>\n) {\n  let size = DEFAULT_BATCH_SIZE;\n  while (!(yield* fastTransposeIteratorHandle(iterator, size))) {\n    size <<= 1;\n  }\n}\n\ntype AwaitableIterator<T> = Iterator<T> | AsyncIterator<T>;\n\n/**\n * @internal\n */\nexport async function* transposeIterableHandle<T>(\n  handle: JSHandle<AwaitableIterable<T>>\n): AsyncIterableIterator<HandleFor<T>> {\n  using generatorHandle = await handle.evaluateHandle(iterable => {\n    return (async function* () {\n      yield* iterable;\n    })();\n  });\n  yield* transposeIteratorHandle(generatorHandle);\n}\n"]},"metadata":{},"sourceType":"module"}