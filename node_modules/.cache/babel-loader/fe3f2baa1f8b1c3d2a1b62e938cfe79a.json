{"ast":null,"code":"const ascii = require('./lib/ascii');\nconst base64 = require('./lib/base64');\nconst hex = require('./lib/hex');\nconst utf8 = require('./lib/utf8');\nconst utf16le = require('./lib/utf16le');\nconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff;\nfunction codecFor(encoding) {\n  switch (encoding) {\n    case 'ascii':\n      return ascii;\n    case 'base64':\n      return base64;\n    case 'hex':\n      return hex;\n    case 'utf8':\n    case 'utf-8':\n    case undefined:\n      return utf8;\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return utf16le;\n    default:\n      throw new Error(`Unknown encoding: ${encoding}`);\n  }\n}\nfunction isBuffer(value) {\n  return value instanceof Uint8Array;\n}\nfunction isEncoding(encoding) {\n  try {\n    codecFor(encoding);\n    return true;\n  } catch {\n    return false;\n  }\n}\nfunction alloc(size, fill, encoding) {\n  const buffer = new Uint8Array(size);\n  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding);\n  return buffer;\n}\nfunction allocUnsafe(size) {\n  return new Uint8Array(size);\n}\nfunction allocUnsafeSlow(size) {\n  return new Uint8Array(size);\n}\nfunction byteLength(string, encoding) {\n  return codecFor(encoding).byteLength(string);\n}\nfunction compare(a, b) {\n  if (a === b) return 0;\n  const len = Math.min(a.byteLength, b.byteLength);\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength);\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength);\n  let i = 0;\n  for (let n = len - len % 4; i < n; i += 4) {\n    const x = a.getUint32(i, LE);\n    const y = b.getUint32(i, LE);\n    if (x !== y) break;\n  }\n  for (; i < len; i++) {\n    const x = a.getUint8(i);\n    const y = b.getUint8(i);\n    if (x < y) return -1;\n    if (x > y) return 1;\n  }\n  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0;\n}\nfunction concat(buffers, totalLength) {\n  if (totalLength === undefined) {\n    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0);\n  }\n  const result = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const buffer of buffers) {\n    if (offset + buffer.byteLength > result.byteLength) {\n      const sub = buffer.subarray(0, result.byteLength - offset);\n      result.set(sub, offset);\n      return result;\n    }\n    result.set(buffer, offset);\n    offset += buffer.byteLength;\n  }\n  return result;\n}\nfunction copy(source, target) {\n  let targetStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let start = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  let end = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : source.byteLength;\n  if (end > 0 && end < start) return 0;\n  if (end === start) return 0;\n  if (source.byteLength === 0 || target.byteLength === 0) return 0;\n  if (targetStart < 0) throw new RangeError('targetStart is out of range');\n  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range');\n  if (end < 0) throw new RangeError('sourceEnd is out of range');\n  if (targetStart >= target.byteLength) targetStart = target.byteLength;\n  if (end > source.byteLength) end = source.byteLength;\n  if (target.byteLength - targetStart < end - start) {\n    end = target.length - targetStart + start;\n  }\n  const len = end - start;\n  if (source === target) {\n    target.copyWithin(targetStart, start, end);\n  } else {\n    target.set(source.subarray(start, end), targetStart);\n  }\n  return len;\n}\nfunction equals(a, b) {\n  if (a === b) return true;\n  if (a.byteLength !== b.byteLength) return false;\n  const len = a.byteLength;\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength);\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength);\n  let i = 0;\n  for (let n = len - len % 4; i < n; i += 4) {\n    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false;\n  }\n  for (; i < len; i++) {\n    if (a.getUint8(i) !== b.getUint8(i)) return false;\n  }\n  return true;\n}\nfunction fill(buffer, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    // fill(buffer, string, encoding)\n    if (typeof offset === 'string') {\n      encoding = offset;\n      offset = 0;\n      end = buffer.byteLength;\n\n      // fill(buffer, string, offset, encoding)\n    } else if (typeof end === 'string') {\n      encoding = end;\n      end = buffer.byteLength;\n    }\n  } else if (typeof value === 'number') {\n    value = value & 0xff;\n  } else if (typeof value === 'boolean') {\n    value = +value;\n  }\n  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n    throw new RangeError('Out of range index');\n  }\n  if (offset === undefined) offset = 0;\n  if (end === undefined) end = buffer.byteLength;\n  if (end <= offset) return buffer;\n  if (!value) value = 0;\n  if (typeof value === 'number') {\n    for (let i = offset; i < end; ++i) {\n      buffer[i] = value;\n    }\n  } else {\n    value = isBuffer(value) ? value : from(value, encoding);\n    const len = value.byteLength;\n    for (let i = 0; i < end - offset; ++i) {\n      buffer[i + offset] = value[i % len];\n    }\n  }\n  return buffer;\n}\nfunction from(value, encodingOrOffset, length) {\n  // from(string, encoding)\n  if (typeof value === 'string') return fromString(value, encodingOrOffset);\n\n  // from(array)\n  if (Array.isArray(value)) return fromArray(value);\n\n  // from(buffer)\n  if (ArrayBuffer.isView(value)) return fromBuffer(value);\n\n  // from(arrayBuffer[, byteOffset[, length]])\n  return fromArrayBuffer(value, encodingOrOffset, length);\n}\nfunction fromString(string, encoding) {\n  const codec = codecFor(encoding);\n  const buffer = new Uint8Array(codec.byteLength(string));\n  codec.write(buffer, string, 0, buffer.byteLength);\n  return buffer;\n}\nfunction fromArray(array) {\n  const buffer = new Uint8Array(array.length);\n  buffer.set(array);\n  return buffer;\n}\nfunction fromBuffer(buffer) {\n  const copy = new Uint8Array(buffer.byteLength);\n  copy.set(buffer);\n  return copy;\n}\nfunction fromArrayBuffer(arrayBuffer, byteOffset, length) {\n  return new Uint8Array(arrayBuffer, byteOffset, length);\n}\nfunction includes(buffer, value, byteOffset, encoding) {\n  return indexOf(buffer, value, byteOffset, encoding) !== -1;\n}\nfunction bidirectionalIndexOf(buffer, value, byteOffset, encoding, first) {\n  if (buffer.byteLength === 0) return -1;\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset;\n    byteOffset = 0;\n  } else if (byteOffset === undefined) {\n    byteOffset = first ? 0 : buffer.length - 1;\n  } else if (byteOffset < 0) {\n    byteOffset += buffer.byteLength;\n  }\n  if (byteOffset >= buffer.byteLength) {\n    if (first) return -1;else byteOffset = buffer.byteLength - 1;\n  } else if (byteOffset < 0) {\n    if (first) byteOffset = 0;else return -1;\n  }\n  if (typeof value === 'string') {\n    value = from(value, encoding);\n  } else if (typeof value === 'number') {\n    value = value & 0xff;\n    if (first) {\n      return buffer.indexOf(value, byteOffset);\n    } else {\n      return buffer.lastIndexOf(value, byteOffset);\n    }\n  }\n  if (value.byteLength === 0) return -1;\n  if (first) {\n    let foundIndex = -1;\n    for (let i = byteOffset; i < buffer.byteLength; i++) {\n      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i;\n        if (i - foundIndex + 1 === value.byteLength) return foundIndex;\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex;\n        foundIndex = -1;\n      }\n    }\n  } else {\n    if (byteOffset + value.byteLength > buffer.byteLength) {\n      byteOffset = buffer.byteLength - value.byteLength;\n    }\n    for (let i = byteOffset; i >= 0; i--) {\n      let found = true;\n      for (let j = 0; j < value.byteLength; j++) {\n        if (buffer[i + j] !== value[j]) {\n          found = false;\n          break;\n        }\n      }\n      if (found) return i;\n    }\n  }\n  return -1;\n}\nfunction indexOf(buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */);\n}\n\nfunction lastIndexOf(buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */);\n}\n\nfunction swap(buffer, n, m) {\n  const i = buffer[n];\n  buffer[n] = buffer[m];\n  buffer[m] = i;\n}\nfunction swap16(buffer) {\n  const len = buffer.byteLength;\n  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits');\n  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1);\n  return buffer;\n}\nfunction swap32(buffer) {\n  const len = buffer.byteLength;\n  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits');\n  for (let i = 0; i < len; i += 4) {\n    swap(buffer, i, i + 3);\n    swap(buffer, i + 1, i + 2);\n  }\n  return buffer;\n}\nfunction swap64(buffer) {\n  const len = buffer.byteLength;\n  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits');\n  for (let i = 0; i < len; i += 8) {\n    swap(buffer, i, i + 7);\n    swap(buffer, i + 1, i + 6);\n    swap(buffer, i + 2, i + 5);\n    swap(buffer, i + 3, i + 4);\n  }\n  return buffer;\n}\nfunction toBuffer(buffer) {\n  return buffer;\n}\nfunction toString(buffer, encoding) {\n  let start = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  let end = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : buffer.byteLength;\n  const len = buffer.byteLength;\n  if (start >= len) return '';\n  if (end <= start) return '';\n  if (start < 0) start = 0;\n  if (end > len) end = len;\n  if (start !== 0 || end < len) buffer = buffer.subarray(start, end);\n  return codecFor(encoding).toString(buffer);\n}\nfunction write(buffer, string, offset, length, encoding) {\n  // write(buffer, string)\n  if (offset === undefined) {\n    encoding = 'utf8';\n\n    // write(buffer, string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset;\n    offset = undefined;\n\n    // write(buffer, string, offset, encoding)\n  } else if (encoding === undefined && typeof length === 'string') {\n    encoding = length;\n    length = undefined;\n  }\n  return codecFor(encoding).write(buffer, string, offset, length);\n}\nfunction writeDoubleLE(buffer, value, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setFloat64(offset, value, true);\n  return offset + 8;\n}\nfunction writeFloatLE(buffer, value, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setFloat32(offset, value, true);\n  return offset + 4;\n}\nfunction writeUInt32LE(buffer, value, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setUint32(offset, value, true);\n  return offset + 4;\n}\nfunction writeInt32LE(buffer, value, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  view.setInt32(offset, value, true);\n  return offset + 4;\n}\nfunction readDoubleLE(buffer, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getFloat64(offset, true);\n}\nfunction readFloatLE(buffer, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getFloat32(offset, true);\n}\nfunction readUInt32LE(buffer, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getUint32(offset, true);\n}\nfunction readInt32LE(buffer, offset) {\n  if (offset === undefined) offset = 0;\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  return view.getInt32(offset, true);\n}\nmodule.exports = exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE\n};","map":{"version":3,"names":["ascii","require","base64","hex","utf8","utf16le","LE","Uint8Array","Uint16Array","of","buffer","codecFor","encoding","undefined","Error","isBuffer","value","isEncoding","alloc","size","fill","exports","byteLength","allocUnsafe","allocUnsafeSlow","string","compare","a","b","len","Math","min","DataView","byteOffset","i","n","x","getUint32","y","getUint8","concat","buffers","totalLength","reduce","result","offset","sub","subarray","set","copy","source","target","targetStart","start","end","RangeError","length","copyWithin","equals","from","encodingOrOffset","fromString","Array","isArray","fromArray","ArrayBuffer","isView","fromBuffer","fromArrayBuffer","codec","write","array","arrayBuffer","includes","indexOf","bidirectionalIndexOf","first","lastIndexOf","foundIndex","found","j","swap","m","swap16","swap32","swap64","toBuffer","toString","writeDoubleLE","view","setFloat64","writeFloatLE","setFloat32","writeUInt32LE","setUint32","writeInt32LE","setInt32","readDoubleLE","getFloat64","readFloatLE","getFloat32","readUInt32LE","readInt32LE","getInt32","module"],"sources":["D:/Julieth-Campos/PSO/node_modules/b4a/browser.js"],"sourcesContent":["const ascii = require('./lib/ascii')\nconst base64 = require('./lib/base64')\nconst hex = require('./lib/hex')\nconst utf8 = require('./lib/utf8')\nconst utf16le = require('./lib/utf16le')\n\nconst LE = new Uint8Array(Uint16Array.of(0xff).buffer)[0] === 0xff\n\nfunction codecFor (encoding) {\n  switch (encoding) {\n    case 'ascii':\n      return ascii\n    case 'base64':\n      return base64\n    case 'hex':\n      return hex\n    case 'utf8':\n    case 'utf-8':\n    case undefined:\n      return utf8\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return utf16le\n    default:\n      throw new Error(`Unknown encoding: ${encoding}`)\n  }\n}\n\nfunction isBuffer (value) {\n  return value instanceof Uint8Array\n}\n\nfunction isEncoding (encoding) {\n  try {\n    codecFor(encoding)\n    return true\n  } catch {\n    return false\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  const buffer = new Uint8Array(size)\n  if (fill !== undefined) exports.fill(buffer, fill, 0, buffer.byteLength, encoding)\n  return buffer\n}\n\nfunction allocUnsafe (size) {\n  return new Uint8Array(size)\n}\n\nfunction allocUnsafeSlow (size) {\n  return new Uint8Array(size)\n}\n\nfunction byteLength (string, encoding) {\n  return codecFor(encoding).byteLength(string)\n}\n\nfunction compare (a, b) {\n  if (a === b) return 0\n\n  const len = Math.min(a.byteLength, b.byteLength)\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    const x = a.getUint32(i, LE)\n    const y = b.getUint32(i, LE)\n    if (x !== y) break\n  }\n\n  for (; i < len; i++) {\n    const x = a.getUint8(i)\n    const y = b.getUint8(i)\n    if (x < y) return -1\n    if (x > y) return 1\n  }\n\n  return a.byteLength > b.byteLength ? 1 : a.byteLength < b.byteLength ? -1 : 0\n}\n\nfunction concat (buffers, totalLength) {\n  if (totalLength === undefined) {\n    totalLength = buffers.reduce((len, buffer) => len + buffer.byteLength, 0)\n  }\n\n  const result = new Uint8Array(totalLength)\n\n  let offset = 0\n  for (const buffer of buffers) {\n    if (offset + buffer.byteLength > result.byteLength) {\n      const sub = buffer.subarray(0, result.byteLength - offset)\n      result.set(sub, offset)\n      return result\n    }\n    result.set(buffer, offset)\n    offset += buffer.byteLength\n  }\n\n  return result\n}\n\nfunction copy (source, target, targetStart = 0, start = 0, end = source.byteLength) {\n  if (end > 0 && end < start) return 0\n  if (end === start) return 0\n  if (source.byteLength === 0 || target.byteLength === 0) return 0\n\n  if (targetStart < 0) throw new RangeError('targetStart is out of range')\n  if (start < 0 || start >= source.byteLength) throw new RangeError('sourceStart is out of range')\n  if (end < 0) throw new RangeError('sourceEnd is out of range')\n\n  if (targetStart >= target.byteLength) targetStart = target.byteLength\n  if (end > source.byteLength) end = source.byteLength\n  if (target.byteLength - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (source === target) {\n    target.copyWithin(targetStart, start, end)\n  } else {\n    target.set(source.subarray(start, end), targetStart)\n  }\n\n  return len\n}\n\nfunction equals (a, b) {\n  if (a === b) return true\n  if (a.byteLength !== b.byteLength) return false\n\n  const len = a.byteLength\n\n  a = new DataView(a.buffer, a.byteOffset, a.byteLength)\n  b = new DataView(b.buffer, b.byteOffset, b.byteLength)\n\n  let i = 0\n\n  for (let n = len - (len % 4); i < n; i += 4) {\n    if (a.getUint32(i, LE) !== b.getUint32(i, LE)) return false\n  }\n\n  for (; i < len; i++) {\n    if (a.getUint8(i) !== b.getUint8(i)) return false\n  }\n\n  return true\n}\n\nfunction fill (buffer, value, offset, end, encoding) {\n  if (typeof value === 'string') {\n    // fill(buffer, string, encoding)\n    if (typeof offset === 'string') {\n      encoding = offset\n      offset = 0\n      end = buffer.byteLength\n\n    // fill(buffer, string, offset, encoding)\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = buffer.byteLength\n    }\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n  } else if (typeof value === 'boolean') {\n    value = +value\n  }\n\n  if (offset < 0 || buffer.byteLength < offset || buffer.byteLength < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (offset === undefined) offset = 0\n  if (end === undefined) end = buffer.byteLength\n\n  if (end <= offset) return buffer\n\n  if (!value) value = 0\n\n  if (typeof value === 'number') {\n    for (let i = offset; i < end; ++i) {\n      buffer[i] = value\n    }\n  } else {\n    value = isBuffer(value) ? value : from(value, encoding)\n\n    const len = value.byteLength\n\n    for (let i = 0; i < end - offset; ++i) {\n      buffer[i + offset] = value[i % len]\n    }\n  }\n\n  return buffer\n}\n\nfunction from (value, encodingOrOffset, length) {\n  // from(string, encoding)\n  if (typeof value === 'string') return fromString(value, encodingOrOffset)\n\n  // from(array)\n  if (Array.isArray(value)) return fromArray(value)\n\n  // from(buffer)\n  if (ArrayBuffer.isView(value)) return fromBuffer(value)\n\n  // from(arrayBuffer[, byteOffset[, length]])\n  return fromArrayBuffer(value, encodingOrOffset, length)\n}\n\nfunction fromString (string, encoding) {\n  const codec = codecFor(encoding)\n  const buffer = new Uint8Array(codec.byteLength(string))\n  codec.write(buffer, string, 0, buffer.byteLength)\n  return buffer\n}\n\nfunction fromArray (array) {\n  const buffer = new Uint8Array(array.length)\n  buffer.set(array)\n  return buffer\n}\n\nfunction fromBuffer (buffer) {\n  const copy = new Uint8Array(buffer.byteLength)\n  copy.set(buffer)\n  return copy\n}\n\nfunction fromArrayBuffer (arrayBuffer, byteOffset, length) {\n  return new Uint8Array(arrayBuffer, byteOffset, length)\n}\n\nfunction includes (buffer, value, byteOffset, encoding) {\n  return indexOf(buffer, value, byteOffset, encoding) !== -1\n}\n\nfunction bidirectionalIndexOf (buffer, value, byteOffset, encoding, first) {\n  if (buffer.byteLength === 0) return -1\n\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset === undefined) {\n    byteOffset = first ? 0 : (buffer.length - 1)\n  } else if (byteOffset < 0) {\n    byteOffset += buffer.byteLength\n  }\n\n  if (byteOffset >= buffer.byteLength) {\n    if (first) return -1\n    else byteOffset = buffer.byteLength - 1\n  } else if (byteOffset < 0) {\n    if (first) byteOffset = 0\n    else return -1\n  }\n\n  if (typeof value === 'string') {\n    value = from(value, encoding)\n  } else if (typeof value === 'number') {\n    value = value & 0xff\n\n    if (first) {\n      return buffer.indexOf(value, byteOffset)\n    } else {\n      return buffer.lastIndexOf(value, byteOffset)\n    }\n  }\n\n  if (value.byteLength === 0) return -1\n\n  if (first) {\n    let foundIndex = -1\n\n    for (let i = byteOffset; i < buffer.byteLength; i++) {\n      if (buffer[i] === value[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === value.byteLength) return foundIndex\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + value.byteLength > buffer.byteLength) {\n      byteOffset = buffer.byteLength - value.byteLength\n    }\n\n    for (let i = byteOffset; i >= 0; i--) {\n      let found = true\n\n      for (let j = 0; j < value.byteLength; j++) {\n        if (buffer[i + j] !== value[j]) {\n          found = false\n          break\n        }\n      }\n\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nfunction indexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, true /* first */)\n}\n\nfunction lastIndexOf (buffer, value, byteOffset, encoding) {\n  return bidirectionalIndexOf(buffer, value, byteOffset, encoding, false /* last */)\n}\n\nfunction swap (buffer, n, m) {\n  const i = buffer[n]\n  buffer[n] = buffer[m]\n  buffer[m] = i\n}\n\nfunction swap16 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 2 !== 0) throw new RangeError('Buffer size must be a multiple of 16-bits')\n\n  for (let i = 0; i < len; i += 2) swap(buffer, i, i + 1)\n\n  return buffer\n}\n\nfunction swap32 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 4 !== 0) throw new RangeError('Buffer size must be a multiple of 32-bits')\n\n  for (let i = 0; i < len; i += 4) {\n    swap(buffer, i, i + 3)\n    swap(buffer, i + 1, i + 2)\n  }\n\n  return buffer\n}\n\nfunction swap64 (buffer) {\n  const len = buffer.byteLength\n\n  if (len % 8 !== 0) throw new RangeError('Buffer size must be a multiple of 64-bits')\n\n  for (let i = 0; i < len; i += 8) {\n    swap(buffer, i, i + 7)\n    swap(buffer, i + 1, i + 6)\n    swap(buffer, i + 2, i + 5)\n    swap(buffer, i + 3, i + 4)\n  }\n\n  return buffer\n}\n\nfunction toBuffer (buffer) {\n  return buffer\n}\n\nfunction toString (buffer, encoding, start = 0, end = buffer.byteLength) {\n  const len = buffer.byteLength\n\n  if (start >= len) return ''\n  if (end <= start) return ''\n  if (start < 0) start = 0\n  if (end > len) end = len\n\n  if (start !== 0 || end < len) buffer = buffer.subarray(start, end)\n\n  return codecFor(encoding).toString(buffer)\n}\n\nfunction write (buffer, string, offset, length, encoding) {\n  // write(buffer, string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n\n  // write(buffer, string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    offset = undefined\n\n  // write(buffer, string, offset, encoding)\n  } else if (encoding === undefined && typeof length === 'string') {\n    encoding = length\n    length = undefined\n  }\n\n  return codecFor(encoding).write(buffer, string, offset, length)\n}\n\nfunction writeDoubleLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat64(offset, value, true)\n\n  return offset + 8\n}\n\nfunction writeFloatLE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setFloat32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeUInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setUint32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction writeInt32LE (buffer, value, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n  view.setInt32(offset, value, true)\n\n  return offset + 4\n}\n\nfunction readDoubleLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat64(offset, true)\n}\n\nfunction readFloatLE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getFloat32(offset, true)\n}\n\nfunction readUInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getUint32(offset, true)\n}\n\nfunction readInt32LE (buffer, offset) {\n  if (offset === undefined) offset = 0\n\n  const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength)\n\n  return view.getInt32(offset, true)\n}\n\nmodule.exports = exports = {\n  isBuffer,\n  isEncoding,\n  alloc,\n  allocUnsafe,\n  allocUnsafeSlow,\n  byteLength,\n  compare,\n  concat,\n  copy,\n  equals,\n  fill,\n  from,\n  includes,\n  indexOf,\n  lastIndexOf,\n  swap16,\n  swap32,\n  swap64,\n  toBuffer,\n  toString,\n  write,\n  writeDoubleLE,\n  writeFloatLE,\n  writeUInt32LE,\n  writeInt32LE,\n  readDoubleLE,\n  readFloatLE,\n  readUInt32LE,\n  readInt32LE\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}