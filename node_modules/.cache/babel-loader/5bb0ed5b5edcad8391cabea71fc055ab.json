{"ast":null,"code":"/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar __runInitializers = this && this.__runInitializers || function (thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\nvar __esDecorate = this && this.__esDecorate || function (ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) {\n    if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\");\n    return f;\n  }\n  var kind = contextIn.kind,\n    key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _,\n    done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n    var context = {};\n    for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n    for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n    context.addInitializer = function (f) {\n      if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\");\n      extraInitializers.push(accept(f || null));\n    };\n    var result = (0, decorators[i])(kind === \"accessor\" ? {\n      get: descriptor.get,\n      set: descriptor.set\n    } : descriptor[key], context);\n    if (kind === \"accessor\") {\n      if (result === void 0) continue;\n      if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n      if (_ = accept(result.get)) descriptor.get = _;\n      if (_ = accept(result.set)) descriptor.set = _;\n      if (_ = accept(result.init)) initializers.unshift(_);\n    } else if (_ = accept(result)) {\n      if (kind === \"field\") initializers.unshift(_);else descriptor[key] = _;\n    }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\nvar __addDisposableResource = this && this.__addDisposableResource || function (env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    env.stack.push({\n      value: value,\n      dispose: dispose,\n      async: async\n    });\n  } else if (async) {\n    env.stack.push({\n      async: true\n    });\n  }\n  return value;\n};\nvar __disposeResources = this && this.__disposeResources || function (SuppressedError) {\n  return function (env) {\n    function fail(e) {\n      env.error = env.hasError ? new SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n      env.hasError = true;\n    }\n    function next() {\n      while (env.stack.length) {\n        var rec = env.stack.pop();\n        try {\n          var result = rec.dispose && rec.dispose.call(rec.value);\n          if (rec.async) return Promise.resolve(result).then(next, function (e) {\n            fail(e);\n            return next();\n          });\n        } catch (e) {\n          fail(e);\n        }\n      }\n      if (env.hasError) throw env.error;\n    }\n    return next();\n  };\n}(typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n});\nimport { debugError, withSourcePuppeteerURLIfNone } from '../common/util.js';\nimport { moveable, throwIfDisposed } from '../util/decorators.js';\nimport { disposeSymbol, asyncDisposeSymbol } from '../util/disposable.js';\n/**\n * Represents a reference to a JavaScript object. Instances can be created using\n * {@link Page.evaluateHandle}.\n *\n * Handles prevent the referenced JavaScript object from being garbage-collected\n * unless the handle is purposely {@link JSHandle.dispose | disposed}. JSHandles\n * are auto-disposed when their associated frame is navigated away or the parent\n * context gets destroyed.\n *\n * Handles can be used as arguments for any evaluation function such as\n * {@link Page.$eval}, {@link Page.evaluate}, and {@link Page.evaluateHandle}.\n * They are resolved to their referenced object.\n *\n * @example\n *\n * ```ts\n * const windowHandle = await page.evaluateHandle(() => window);\n * ```\n *\n * @public\n */\nlet JSHandle = (() => {\n  let _classDecorators = [moveable];\n  let _classDescriptor;\n  let _classExtraInitializers = [];\n  let _classThis;\n  let _instanceExtraInitializers = [];\n  let _getProperty_decorators;\n  let _getProperties_decorators;\n  var JSHandle = class {\n    static #_ = _classThis = this;\n    static #_2 = (() => {\n      const _metadata = typeof Symbol === \"function\" && Symbol.metadata ? Object.create(null) : void 0;\n      __esDecorate(this, null, _getProperty_decorators, {\n        kind: \"method\",\n        name: \"getProperty\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperty\" in obj,\n          get: obj => obj.getProperty\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(this, null, _getProperties_decorators, {\n        kind: \"method\",\n        name: \"getProperties\",\n        static: false,\n        private: false,\n        access: {\n          has: obj => \"getProperties\" in obj,\n          get: obj => obj.getProperties\n        },\n        metadata: _metadata\n      }, null, _instanceExtraInitializers);\n      __esDecorate(null, _classDescriptor = {\n        value: _classThis\n      }, _classDecorators, {\n        kind: \"class\",\n        name: _classThis.name,\n        metadata: _metadata\n      }, null, _classExtraInitializers);\n      JSHandle = _classThis = _classDescriptor.value;\n      if (_metadata) Object.defineProperty(_classThis, Symbol.metadata, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: _metadata\n      });\n      __runInitializers(_classThis, _classExtraInitializers);\n    })();\n    /**\n     * @internal\n     */\n    constructor() {\n      __runInitializers(this, _instanceExtraInitializers);\n    }\n    /**\n     * @internal\n     */\n    get disposed() {\n      throw new Error('Not implemented');\n    }\n    /**\n     * Evaluates the given function with the current handle as its first argument.\n     */\n    async evaluate(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluate.name, pageFunction);\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return await this.realm.evaluate(pageFunction, this, ...args);\n    }\n    /**\n     * Evaluates the given function with the current handle as its first argument.\n     *\n     */\n    async evaluateHandle(pageFunction) {\n      pageFunction = withSourcePuppeteerURLIfNone(this.evaluateHandle.name, pageFunction);\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n      return await this.realm.evaluateHandle(pageFunction, this, ...args);\n    }\n    /**\n     * @internal\n     */\n    async getProperty(propertyName) {\n      return await this.evaluateHandle((object, propertyName) => {\n        return object[propertyName];\n      }, propertyName);\n    }\n    /**\n     * Gets a map of handles representing the properties of the current handle.\n     *\n     * @example\n     *\n     * ```ts\n     * const listHandle = await page.evaluateHandle(() => document.body.children);\n     * const properties = await listHandle.getProperties();\n     * const children = [];\n     * for (const property of properties.values()) {\n     *   const element = property.asElement();\n     *   if (element) {\n     *     children.push(element);\n     *   }\n     * }\n     * children; // holds elementHandles to all children of document.body\n     * ```\n     */\n    async getProperties() {\n      const propertyNames = await this.evaluate(object => {\n        const enumerableProperties = [];\n        const descriptors = Object.getOwnPropertyDescriptors(object);\n        for (const propertyName in descriptors) {\n          if (descriptors[propertyName]?.enumerable) {\n            enumerableProperties.push(propertyName);\n          }\n        }\n        return enumerableProperties;\n      });\n      const map = new Map();\n      const results = await Promise.all(propertyNames.map(key => {\n        return this.getProperty(key);\n      }));\n      for (const [key, value] of Object.entries(propertyNames)) {\n        const env_1 = {\n          stack: [],\n          error: void 0,\n          hasError: false\n        };\n        try {\n          const handle = __addDisposableResource(env_1, results[key], false);\n          if (handle) {\n            map.set(value, handle.move());\n          }\n        } catch (e_1) {\n          env_1.error = e_1;\n          env_1.hasError = true;\n        } finally {\n          __disposeResources(env_1);\n        }\n      }\n      return map;\n    }\n    /** @internal */\n    [(_getProperty_decorators = [throwIfDisposed()], _getProperties_decorators = [throwIfDisposed()], disposeSymbol)]() {\n      return void this.dispose().catch(debugError);\n    }\n    /** @internal */\n    [asyncDisposeSymbol]() {\n      return this.dispose();\n    }\n  };\n  return JSHandle = _classThis;\n})();\nexport { JSHandle };","map":{"version":3,"mappings":"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","names":["debugError","withSourcePuppeteerURLIfNone","moveable","throwIfDisposed","disposeSymbol","asyncDisposeSymbol","JSHandle","__esDecorate","kind","name","static","private","access","has","get","getProperty","metadata","getProperties","value","__runInitializers","constructor","disposed","Error","evaluate","pageFunction","args","realm","evaluateHandle","propertyName","object","propertyNames","enumerableProperties","descriptors","Object","getOwnPropertyDescriptors","enumerable","push","map","Map","results","Promise","all","key","entries","handle","set","move","dispose","catch"],"sources":["D:\\Julieth-Campos\\PSO\\node_modules\\puppeteer-core\\src\\api\\JSHandle.ts"],"sourcesContent":["/**\n * Copyright 2023 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type Protocol from 'devtools-protocol';\n\nimport type {EvaluateFuncWith, HandleFor, HandleOr} from '../common/types.js';\nimport {debugError, withSourcePuppeteerURLIfNone} from '../common/util.js';\nimport {moveable, throwIfDisposed} from '../util/decorators.js';\nimport {disposeSymbol, asyncDisposeSymbol} from '../util/disposable.js';\n\nimport type {ElementHandle} from './ElementHandle.js';\nimport type {Realm} from './Realm.js';\n\n/**\n * Represents a reference to a JavaScript object. Instances can be created using\n * {@link Page.evaluateHandle}.\n *\n * Handles prevent the referenced JavaScript object from being garbage-collected\n * unless the handle is purposely {@link JSHandle.dispose | disposed}. JSHandles\n * are auto-disposed when their associated frame is navigated away or the parent\n * context gets destroyed.\n *\n * Handles can be used as arguments for any evaluation function such as\n * {@link Page.$eval}, {@link Page.evaluate}, and {@link Page.evaluateHandle}.\n * They are resolved to their referenced object.\n *\n * @example\n *\n * ```ts\n * const windowHandle = await page.evaluateHandle(() => window);\n * ```\n *\n * @public\n */\n@moveable\nexport abstract class JSHandle<T = unknown> {\n  declare move: () => this;\n\n  /**\n   * Used for nominally typing {@link JSHandle}.\n   */\n  declare _?: T;\n\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * @internal\n   */\n  abstract get realm(): Realm;\n\n  /**\n   * @internal\n   */\n  get disposed(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  /**\n   * Evaluates the given function with the current handle as its first argument.\n   */\n  async evaluate<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<T, Params> = EvaluateFuncWith<T, Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<Awaited<ReturnType<Func>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluate.name,\n      pageFunction\n    );\n    return await this.realm.evaluate(pageFunction, this, ...args);\n  }\n\n  /**\n   * Evaluates the given function with the current handle as its first argument.\n   *\n   */\n  async evaluateHandle<\n    Params extends unknown[],\n    Func extends EvaluateFuncWith<T, Params> = EvaluateFuncWith<T, Params>,\n  >(\n    pageFunction: Func | string,\n    ...args: Params\n  ): Promise<HandleFor<Awaited<ReturnType<Func>>>> {\n    pageFunction = withSourcePuppeteerURLIfNone(\n      this.evaluateHandle.name,\n      pageFunction\n    );\n    return await this.realm.evaluateHandle(pageFunction, this, ...args);\n  }\n\n  /**\n   * Fetches a single property from the referenced object.\n   */\n  getProperty<K extends keyof T>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<T[K]>>;\n  getProperty(propertyName: string): Promise<JSHandle<unknown>>;\n\n  /**\n   * @internal\n   */\n  @throwIfDisposed()\n  async getProperty<K extends keyof T>(\n    propertyName: HandleOr<K>\n  ): Promise<HandleFor<T[K]>> {\n    return await this.evaluateHandle((object, propertyName) => {\n      return object[propertyName as K];\n    }, propertyName);\n  }\n\n  /**\n   * Gets a map of handles representing the properties of the current handle.\n   *\n   * @example\n   *\n   * ```ts\n   * const listHandle = await page.evaluateHandle(() => document.body.children);\n   * const properties = await listHandle.getProperties();\n   * const children = [];\n   * for (const property of properties.values()) {\n   *   const element = property.asElement();\n   *   if (element) {\n   *     children.push(element);\n   *   }\n   * }\n   * children; // holds elementHandles to all children of document.body\n   * ```\n   */\n  @throwIfDisposed()\n  async getProperties(): Promise<Map<string, JSHandle>> {\n    const propertyNames = await this.evaluate(object => {\n      const enumerableProperties = [];\n      const descriptors = Object.getOwnPropertyDescriptors(object);\n      for (const propertyName in descriptors) {\n        if (descriptors[propertyName]?.enumerable) {\n          enumerableProperties.push(propertyName);\n        }\n      }\n      return enumerableProperties;\n    });\n    const map = new Map<string, JSHandle>();\n    const results = await Promise.all(\n      propertyNames.map(key => {\n        return this.getProperty(key);\n      })\n    );\n    for (const [key, value] of Object.entries(propertyNames)) {\n      using handle = results[key as any];\n      if (handle) {\n        map.set(value, handle.move());\n      }\n    }\n    return map;\n  }\n\n  /**\n   * A vanilla object representing the serializable portions of the\n   * referenced object.\n   * @throws Throws if the object cannot be serialized due to circularity.\n   *\n   * @remarks\n   * If the object has a `toJSON` function, it **will not** be called.\n   */\n  abstract jsonValue(): Promise<T>;\n\n  /**\n   * Either `null` or the handle itself if the handle is an\n   * instance of {@link ElementHandle}.\n   */\n  abstract asElement(): ElementHandle<Node> | null;\n\n  /**\n   * Releases the object referenced by the handle for garbage collection.\n   */\n  abstract dispose(): Promise<void>;\n\n  /**\n   * Returns a string representation of the JSHandle.\n   *\n   * @remarks\n   * Useful during debugging.\n   */\n  abstract toString(): string;\n\n  /**\n   * @internal\n   */\n  abstract get id(): string | undefined;\n\n  /**\n   * Provides access to the\n   * {@link https://chromedevtools.github.io/devtools-protocol/tot/Runtime/#type-RemoteObject | Protocol.Runtime.RemoteObject}\n   * backing this handle.\n   */\n  abstract remoteObject(): Protocol.Runtime.RemoteObject;\n\n  /** @internal */\n  [disposeSymbol](): void {\n    return void this.dispose().catch(debugError);\n  }\n\n  /** @internal */\n  [asyncDisposeSymbol](): Promise<void> {\n    return this.dispose();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}