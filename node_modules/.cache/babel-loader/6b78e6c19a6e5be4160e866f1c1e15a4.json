{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.degenerator = void 0;\nconst util_1 = require(\"util\");\nconst escodegen_1 = require(\"escodegen\");\nconst esprima_1 = require(\"esprima\");\nconst ast_types_1 = require(\"ast-types\");\n/**\n * Compiles sync JavaScript code into JavaScript with async Functions.\n *\n * @param {String} code JavaScript string to convert\n * @param {Array} names Array of function names to add `await` operators to\n * @return {String} Converted JavaScript string with async/await injected\n * @api public\n */\nfunction degenerator(code, _names) {\n  if (!Array.isArray(_names)) {\n    throw new TypeError('an array of async function \"names\" is required');\n  }\n  // Duplicate the `names` array since it's rude to augment the user args\n  const names = _names.slice(0);\n  const ast = (0, esprima_1.parseScript)(code);\n  // First pass is to find the `function` nodes and turn them into async or\n  // generator functions only if their body includes `CallExpressions` to\n  // function in `names`. We also add the names of the functions to the `names`\n  // array. We'll iterate several time, as every iteration might add new items\n  // to the `names` array, until no new names were added in the iteration.\n  let lastNamesLength = 0;\n  do {\n    lastNamesLength = names.length;\n    (0, ast_types_1.visit)(ast, {\n      visitVariableDeclaration(path) {\n        if (path.node.declarations) {\n          for (let i = 0; i < path.node.declarations.length; i++) {\n            const declaration = path.node.declarations[i];\n            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {\n              names.push(declaration.id.name);\n            }\n          }\n        }\n        return false;\n      },\n      visitAssignmentExpression(path) {\n        if (ast_types_1.namedTypes.Identifier.check(path.node.left) && ast_types_1.namedTypes.Identifier.check(path.node.right) && checkName(path.node.right.name, names) && !checkName(path.node.left.name, names)) {\n          names.push(path.node.left.name);\n        }\n        return false;\n      },\n      visitFunction(path) {\n        if (path.node.id) {\n          let shouldDegenerate = false;\n          (0, ast_types_1.visit)(path.node, {\n            visitCallExpression(path) {\n              if (checkNames(path.node, names)) {\n                shouldDegenerate = true;\n              }\n              return false;\n            }\n          });\n          if (!shouldDegenerate) {\n            return false;\n          }\n          // Got a \"function\" expression/statement,\n          // convert it into an async function\n          path.node.async = true;\n          // Add function name to `names` array\n          if (!checkName(path.node.id.name, names)) {\n            names.push(path.node.id.name);\n          }\n        }\n        this.traverse(path);\n      }\n    });\n  } while (lastNamesLength !== names.length);\n  // Second pass is for adding `await` statements to any function\n  // invocations that match the given `names` array.\n  (0, ast_types_1.visit)(ast, {\n    visitCallExpression(path) {\n      if (checkNames(path.node, names)) {\n        // A \"function invocation\" expression,\n        // we need to inject an `AwaitExpression`\n        const delegate = false;\n        const {\n          name,\n          parent: {\n            node: pNode\n          }\n        } = path;\n        const expr = ast_types_1.builders.awaitExpression(path.node, delegate);\n        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {\n          pNode.arguments[name] = expr;\n        } else {\n          pNode[name] = expr;\n        }\n      }\n      this.traverse(path);\n    }\n  });\n  return (0, escodegen_1.generate)(ast);\n}\nexports.degenerator = degenerator;\n/**\n * Returns `true` if `node` has a matching name to one of the entries in the\n * `names` array.\n *\n * @param {types.Node} node\n * @param {Array} names Array of function names to return true for\n * @return {Boolean}\n * @api private\n */\nfunction checkNames(_ref, names) {\n  let {\n    callee\n  } = _ref;\n  let name;\n  if (ast_types_1.namedTypes.Identifier.check(callee)) {\n    name = callee.name;\n  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {\n    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {\n      name = `${callee.object.name}.${callee.property.name}`;\n    } else {\n      return false;\n    }\n  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {\n    if (callee.id) {\n      name = callee.id.name;\n    } else {\n      return false;\n    }\n  } else {\n    throw new Error(`Don't know how to get name for: ${callee.type}`);\n  }\n  return checkName(name, names);\n}\nfunction checkName(name, names) {\n  // now that we have the `name`, check if any entries match in the `names` array\n  for (let i = 0; i < names.length; i++) {\n    const n = names[i];\n    if (util_1.types.isRegExp(n)) {\n      if (n.test(name)) {\n        return true;\n      }\n    } else if (name === n) {\n      return true;\n    }\n  }\n  return false;\n}","map":{"version":3,"mappings":"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","names":["degenerator","code","_names","Array","isArray","TypeError","names","slice","ast","lastNamesLength","length","visitVariableDeclaration","path","node","declarations","i","declaration","ast_types_1","VariableDeclarator","check","Identifier","init","id","checkName","name","push","visitAssignmentExpression","left","right","visitFunction","shouldDegenerate","visitCallExpression","checkNames","async","traverse","delegate","parent","pNode","expr","awaitExpression","CallExpression","arguments","exports","callee","MemberExpression","object","property","FunctionExpression","Error","type","n","util_1","isRegExp","test"],"sources":["../src/degenerator.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}