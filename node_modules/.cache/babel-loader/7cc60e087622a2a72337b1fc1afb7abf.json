{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.positiveIntermediate = exports.positiveCompletion = exports.isMultiline = exports.isSingleLine = exports.parseControlResponse = void 0;\nconst LF = \"\\n\";\n/**\n * Parse an FTP control response as a collection of messages. A message is a complete\n * single- or multiline response. A response can also contain multiple multiline responses\n * that will each be represented by a message. A response can also be incomplete\n * and be completed on the next incoming data chunk for which case this function also\n * describes a `rest`. This function converts all CRLF to LF.\n */\nfunction parseControlResponse(text) {\n  const lines = text.split(/\\r?\\n/).filter(isNotBlank);\n  const messages = [];\n  let startAt = 0;\n  let tokenRegex;\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n    // No group has been opened.\n    if (!tokenRegex) {\n      if (isMultiline(line)) {\n        // Open a group by setting an expected token.\n        const token = line.substr(0, 3);\n        tokenRegex = new RegExp(`^${token}(?:$| )`);\n        startAt = i;\n      } else if (isSingleLine(line)) {\n        // Single lines can be grouped immediately.\n        messages.push(line);\n      }\n    }\n    // Group has been opened, expect closing token.\n    else if (tokenRegex.test(line)) {\n      tokenRegex = undefined;\n      messages.push(lines.slice(startAt, i + 1).join(LF));\n    }\n  }\n  // The last group might not have been closed, report it as a rest.\n  const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : \"\";\n  return {\n    messages,\n    rest\n  };\n}\nexports.parseControlResponse = parseControlResponse;\nfunction isSingleLine(line) {\n  return /^\\d\\d\\d(?:$| )/.test(line);\n}\nexports.isSingleLine = isSingleLine;\nfunction isMultiline(line) {\n  return /^\\d\\d\\d-/.test(line);\n}\nexports.isMultiline = isMultiline;\n/**\n * Return true if an FTP return code describes a positive completion.\n */\nfunction positiveCompletion(code) {\n  return code >= 200 && code < 300;\n}\nexports.positiveCompletion = positiveCompletion;\n/**\n * Return true if an FTP return code describes a positive intermediate response.\n */\nfunction positiveIntermediate(code) {\n  return code >= 300 && code < 400;\n}\nexports.positiveIntermediate = positiveIntermediate;\nfunction isNotBlank(str) {\n  return str.trim() !== \"\";\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","positiveIntermediate","positiveCompletion","isMultiline","isSingleLine","parseControlResponse","LF","text","lines","split","filter","isNotBlank","messages","startAt","tokenRegex","i","length","line","token","substr","RegExp","push","test","undefined","slice","join","rest","code","str","trim"],"sources":["D:/Julieth-Campos/PSO/node_modules/basic-ftp/dist/parseControlResponse.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.positiveIntermediate = exports.positiveCompletion = exports.isMultiline = exports.isSingleLine = exports.parseControlResponse = void 0;\nconst LF = \"\\n\";\n/**\n * Parse an FTP control response as a collection of messages. A message is a complete\n * single- or multiline response. A response can also contain multiple multiline responses\n * that will each be represented by a message. A response can also be incomplete\n * and be completed on the next incoming data chunk for which case this function also\n * describes a `rest`. This function converts all CRLF to LF.\n */\nfunction parseControlResponse(text) {\n    const lines = text.split(/\\r?\\n/).filter(isNotBlank);\n    const messages = [];\n    let startAt = 0;\n    let tokenRegex;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        // No group has been opened.\n        if (!tokenRegex) {\n            if (isMultiline(line)) {\n                // Open a group by setting an expected token.\n                const token = line.substr(0, 3);\n                tokenRegex = new RegExp(`^${token}(?:$| )`);\n                startAt = i;\n            }\n            else if (isSingleLine(line)) {\n                // Single lines can be grouped immediately.\n                messages.push(line);\n            }\n        }\n        // Group has been opened, expect closing token.\n        else if (tokenRegex.test(line)) {\n            tokenRegex = undefined;\n            messages.push(lines.slice(startAt, i + 1).join(LF));\n        }\n    }\n    // The last group might not have been closed, report it as a rest.\n    const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : \"\";\n    return { messages, rest };\n}\nexports.parseControlResponse = parseControlResponse;\nfunction isSingleLine(line) {\n    return /^\\d\\d\\d(?:$| )/.test(line);\n}\nexports.isSingleLine = isSingleLine;\nfunction isMultiline(line) {\n    return /^\\d\\d\\d-/.test(line);\n}\nexports.isMultiline = isMultiline;\n/**\n * Return true if an FTP return code describes a positive completion.\n */\nfunction positiveCompletion(code) {\n    return code >= 200 && code < 300;\n}\nexports.positiveCompletion = positiveCompletion;\n/**\n * Return true if an FTP return code describes a positive intermediate response.\n */\nfunction positiveIntermediate(code) {\n    return code >= 300 && code < 400;\n}\nexports.positiveIntermediate = positiveIntermediate;\nfunction isNotBlank(str) {\n    return str.trim() !== \"\";\n}\n"],"mappings":"AAAA,YAAY;;AACZA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7DD,OAAO,CAACE,oBAAoB,GAAGF,OAAO,CAACG,kBAAkB,GAAGH,OAAO,CAACI,WAAW,GAAGJ,OAAO,CAACK,YAAY,GAAGL,OAAO,CAACM,oBAAoB,GAAG,KAAK,CAAC;AAC9I,MAAMC,EAAE,GAAG,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASD,oBAAoB,CAACE,IAAI,EAAE;EAChC,MAAMC,KAAK,GAAGD,IAAI,CAACE,KAAK,CAAC,OAAO,CAAC,CAACC,MAAM,CAACC,UAAU,CAAC;EACpD,MAAMC,QAAQ,GAAG,EAAE;EACnB,IAAIC,OAAO,GAAG,CAAC;EACf,IAAIC,UAAU;EACd,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGP,KAAK,CAACQ,MAAM,EAAED,CAAC,EAAE,EAAE;IACnC,MAAME,IAAI,GAAGT,KAAK,CAACO,CAAC,CAAC;IACrB;IACA,IAAI,CAACD,UAAU,EAAE;MACb,IAAIX,WAAW,CAACc,IAAI,CAAC,EAAE;QACnB;QACA,MAAMC,KAAK,GAAGD,IAAI,CAACE,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC;QAC/BL,UAAU,GAAG,IAAIM,MAAM,CAAE,IAAGF,KAAM,SAAQ,CAAC;QAC3CL,OAAO,GAAGE,CAAC;MACf,CAAC,MACI,IAAIX,YAAY,CAACa,IAAI,CAAC,EAAE;QACzB;QACAL,QAAQ,CAACS,IAAI,CAACJ,IAAI,CAAC;MACvB;IACJ;IACA;IAAA,KACK,IAAIH,UAAU,CAACQ,IAAI,CAACL,IAAI,CAAC,EAAE;MAC5BH,UAAU,GAAGS,SAAS;MACtBX,QAAQ,CAACS,IAAI,CAACb,KAAK,CAACgB,KAAK,CAACX,OAAO,EAAEE,CAAC,GAAG,CAAC,CAAC,CAACU,IAAI,CAACnB,EAAE,CAAC,CAAC;IACvD;EACJ;EACA;EACA,MAAMoB,IAAI,GAAGZ,UAAU,GAAGN,KAAK,CAACgB,KAAK,CAACX,OAAO,CAAC,CAACY,IAAI,CAACnB,EAAE,CAAC,GAAGA,EAAE,GAAG,EAAE;EACjE,OAAO;IAAEM,QAAQ;IAAEc;EAAK,CAAC;AAC7B;AACA3B,OAAO,CAACM,oBAAoB,GAAGA,oBAAoB;AACnD,SAASD,YAAY,CAACa,IAAI,EAAE;EACxB,OAAO,gBAAgB,CAACK,IAAI,CAACL,IAAI,CAAC;AACtC;AACAlB,OAAO,CAACK,YAAY,GAAGA,YAAY;AACnC,SAASD,WAAW,CAACc,IAAI,EAAE;EACvB,OAAO,UAAU,CAACK,IAAI,CAACL,IAAI,CAAC;AAChC;AACAlB,OAAO,CAACI,WAAW,GAAGA,WAAW;AACjC;AACA;AACA;AACA,SAASD,kBAAkB,CAACyB,IAAI,EAAE;EAC9B,OAAOA,IAAI,IAAI,GAAG,IAAIA,IAAI,GAAG,GAAG;AACpC;AACA5B,OAAO,CAACG,kBAAkB,GAAGA,kBAAkB;AAC/C;AACA;AACA;AACA,SAASD,oBAAoB,CAAC0B,IAAI,EAAE;EAChC,OAAOA,IAAI,IAAI,GAAG,IAAIA,IAAI,GAAG,GAAG;AACpC;AACA5B,OAAO,CAACE,oBAAoB,GAAGA,oBAAoB;AACnD,SAASU,UAAU,CAACiB,GAAG,EAAE;EACrB,OAAOA,GAAG,CAACC,IAAI,EAAE,KAAK,EAAE;AAC5B"},"metadata":{},"sourceType":"script"}